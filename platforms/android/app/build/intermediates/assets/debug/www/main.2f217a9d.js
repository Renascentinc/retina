// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({"T1lj":[function(require,module,exports) {

},{}],"4673":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*!
 * Vue.js v2.5.17
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // these helpers produces better vm code in JS engines due to their
// explicitness and function inlining

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value e.g. [object Object]
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString(val) {
  return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if a attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether the object has the property.
 */


var hasOwnProperty = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */


function noop(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/**
 * Return same value
 */


var identity = function (_) {
  return _;
};
/**
 * Generate a static keys string from compiler modules.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject(a);
  var isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = /[^\w.$]/;

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge; // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check

var formatComponentName = noop;

if ("production" !== 'production') {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */


var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.


Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }

  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;

  if (!getter && arguments.length === 2) {
    val = obj[key];
  }

  var setter = property && property.set;
  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if ("production" !== 'production' && customSetter) {
        customSetter();
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if ("production" !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    "production" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if ("production" !== 'production' && (isUndef(target) || isPrimitive(target))) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    "production" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

if ("production" !== 'production') {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */


function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    "production" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  if ("production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else if ("production" !== 'production') {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : {
        type: val
      };
    }
  } else if ("production" !== 'production') {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else if ("production" !== 'production') {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];

      if (typeof def === 'function') {
        dirs[key] = {
          bind: def,
          update: def
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  if ("production" !== 'production') {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;

  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }

  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if ("production" !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  if ("production" !== 'production' && // skip validation for weex recycle-list child component props
  !(false && isObject(value) && '@binding' in value)) {
    assertProp(prop, key, value, vm, absent);
  }

  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if ("production" !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  if ("production" !== 'production') {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */


  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */

/* globals MessageChannel */


var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In < 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).


var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false; // Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.

/* istanbul ignore if */

if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || // PhantomJS
MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;

  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
} // Determine microtask defer implementation.

/* istanbul ignore next, $flow-disable-line */


if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  microTimerFunc = function () {
    p.then(flushCallbacks); // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop);
    }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}
/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */


function withMacroTask(fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res;
  });
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;

    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */

/* not type checking this file because flow doesn't play well with Proxy */


var initProxy;

if ("production" !== 'production') {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';

      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */


var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if ("production" !== 'production') {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, def, cur, old, event;

  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */

    if (isUndef(cur)) {
      "production" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }

      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);

      if ("production" !== 'production') {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }

      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender();
      }
    });
    var reject = once(function (reason) {
      "production" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });
    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("production" !== 'production' ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    }

    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;

      while (i$1--) {
        cb = cbs[i$1];

        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;

    if ("production" !== 'production') {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }

    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);

      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }

    return vm;
  };
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  var slots = {};

  if (!children) {
    return slots;
  }

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};

  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }

  return res;
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;

    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }

    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm); // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)

      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    activeInstance = prevActiveInstance; // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;

    if ("production" !== 'production') {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if ("production" !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop, null, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if ("production" !== 'production') {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren


  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if ("production" !== 'production') {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};

  if ("production" !== 'production') {
    circular = {};
  }

  waiting = flushing = false;
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if ("production" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$1; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = "production" !== 'production' ? expOrFn.toString() : ''; // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = function () {};

      "production" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;
  var i = this.deps.length;

  while (i--) {
    var dep = this$1.deps[i];

    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var this$1 = this;
  var i = this.deps.length;

  while (i--) {
    this$1.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    if ("production" !== 'production') {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive(props, key, value);
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.


    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];

    if ("production" !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if ("production" !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if ("production" !== 'production') {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }

  if ("production" !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    if ("production" !== 'production') {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }

    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  if ("production" !== 'production') {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }

  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      cb.call(vm, watcher.value);
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if ("production" !== 'production') {
        defineReactive(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if ("production" !== 'production') {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);

    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }

  if (isDef(ret)) {
    ret._isVList = true;
  }

  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if ("production" !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name]; // warn duplicate slot usage

    if (slotNodes) {
      if ("production" !== 'production' && slotNodes._rendered) {
        warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      }

      slotNodes._rendered = true;
    }

    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    return resolveSlots(children, parent);
  }; // support for compiled functional template


  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */
// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.
// Updates the state of the component to weex native render engine.

/*  */
// https://github.com/Hanks10100/weex-native-directive/tree/master/component
// listening on native callback

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    if ("production" !== 'production') {
      warn("Invalid Component definition: " + String(Ctor), context);
    }

    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory); // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component

  /* istanbul ignore if */

  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    hooks[key] = componentVNodeHooks[key];
  }
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});

  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "production" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if ("production" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }

  if (isObject(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  if ("production" !== 'production') {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode; // reset _rendered flag on slots for duplicate slot check

    if ("production" !== 'production') {
      for (var key in vm.$slots) {
        // $flow-disable-line
        vm.$slots[key]._rendered = false;
      }
    }

    if (_parentVnode) {
      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if ("production" !== 'production') {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if ("production" !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if ("production" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    if ("production" !== 'production') {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    } // expose real self


    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if ("production" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }

  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];

    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }

    return res;
  } else {
    return latest;
  }
}

function Vue(options) {
  if ("production" !== 'production' && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if ("production" !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if ("production" !== 'production' && type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
  /*  */

};

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  if ("production" !== 'production') {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }

  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;
  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.5.17';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      "production" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      if ("production" !== 'production') {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }

      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if ("production" !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        , parentElm, refElm);
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if ("production" !== 'production') {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;

    if ("production" !== 'production') {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    if ("production" !== 'production') {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("production" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("production" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if ("production" !== 'production') {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
  /*  */

};

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
  /*  */

  /*  */
  // add a raw attr (use this in preTransforms)
  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */

  /*  */
  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.

};
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.

function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler(handler, event, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

function add$1(event, handler, once$$1, capture, passive) {
  handler = withMacroTask(handler);

  if (once$$1) {
    handler = createOnceHandler(handler, event, capture);
  }

  target$1.addEventListener(event, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
  /*  */

};

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false;
    }

    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
  /*  */

};
var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
  /*  */

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */

};

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def === 'object') {
    var res = {};

    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }

    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ("production" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ("production" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    "production" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
  /*  */
  // Provides transition support for a single element/component.
  // supports transition mode (out-in / in-out)

};
var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if ("production" !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if ("production" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
  /*  */
  // Provides transition support for list items.
  // supports move transitions using the FLIP technique.
  // Because the vdom's children update algorithm is "unstable" - i.e.
  // it doesn't guarantee the relative positioning of removed elements,
  // we force transition-group to update its children into two passes:
  // in the first pass, we remove all nodes that need to be removed,
  // triggering their leaving transition; in the second pass, we insert/move
  // into the final desired state. This way in the second pass removed
  // nodes will remain where they should be.

};
var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else if ("production" !== 'production') {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );

    this._vnode = this.kept;
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
  /*  */
  // install platform specific utils

};
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if ("production" !== 'production' && "production" !== 'test' && isChrome) {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if ("production" !== 'production' && "production" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var _default = Vue;
exports.default = _default;
},{}],"SvHR":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.install = install;
exports.ApolloMutation = exports.ApolloSubscribeToMore = exports.ApolloQuery = exports.ApolloProvider = exports.default = void 0;

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}
/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */


function throttle(delay, noTrailing, callback, debounceMode) {
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */
  var timeoutID; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // `noTrailing` defaults to falsy.

  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    var self = this;
    var elapsed = Number(new Date()) - lastExec;
    var args = arguments; // Execute `callback` and update the `lastExec` timestamp.

    function exec() {
      lastExec = Number(new Date());
      callback.apply(self, args);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`.
       */
      exec();
    } // Clear any existing timeout.


    if (timeoutID) {
      clearTimeout(timeoutID);
    }

    if (debounceMode === undefined && elapsed > delay) {
      /*
       * In throttle mode, if `delay` time has been exceeded, execute
       * `callback`.
       */
      exec();
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  } // Return the wrapper function.


  return wrapper;
}
/* eslint-disable no-undefined */

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {Number}   delay         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}  [atBegin]     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @return {Function} A new, debounced function.
 */


function debounce(delay, atBegin, callback) {
  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
}

var index_esm = Object.freeze({
  throttle: throttle,
  debounce: debounce
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var utils = createCommonjsModule(function (module, exports) {
  var Globals = exports.Globals = {};

  function factory(action) {
    return function (cb, time) {
      return action(time, cb);
    };
  }

  exports.throttle = factory(index_esm.throttle);
  exports.debounce = factory(index_esm.debounce);

  exports.getMergedDefinition = function (def) {
    return Globals.Vue.util.mergeOptions({}, def);
  };

  exports.reapply = function (options, context) {
    while (typeof options === 'function') {
      options = options.call(context);
    }

    return options;
  };

  exports.omit = function (obj, properties) {
    return Object.entries(obj).filter(function (_ref) {
      var _ref2 = slicedToArray(_ref, 1),
          key = _ref2[0];

      return !properties.includes(key);
    }).reduce(function (c, _ref3) {
      var _ref4 = slicedToArray(_ref3, 2),
          key = _ref4[0],
          val = _ref4[1];

      c[key] = val;
      return c;
    }, {});
  };

  exports.addGqlError = function (error) {
    if (error.graphQLErrors && error.graphQLErrors.length) {
      error.gqlError = error.graphQLErrors[0];
    }
  };

  exports.noop = function () {};
});
var utils_1 = utils.Globals;
var utils_2 = utils.throttle;
var utils_3 = utils.debounce;
var utils_4 = utils.getMergedDefinition;
var utils_5 = utils.reapply;
var utils_6 = utils.omit;
var utils_7 = utils.addGqlError;
var utils_8 = utils.noop;

var SmartApollo = function () {
  function SmartApollo(vm, key, options) {
    var autostart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    classCallCheck(this, SmartApollo);
    this.type = null;
    this.vueApolloSpecialKeys = [];
    this.vm = vm;
    this.key = key;
    this.initialOptions = options;
    this.options = Object.assign({}, options);
    this._skip = false;
    this._watchers = [];
    this._destroyed = false;

    if (this.vm.$isServer) {
      this.options.fetchPolicy = 'cache-first';
    }

    if (autostart) {
      this.autostart();
    }
  }

  createClass(SmartApollo, [{
    key: 'autostart',
    value: function autostart() {
      if (typeof this.options.skip === 'function') {
        this._skipWatcher = this.vm.$watch(this.options.skip.bind(this.vm), this.skipChanged.bind(this), {
          immediate: true,
          deep: this.options.deep
        });
      } else if (!this.options.skip) {
        this.start();
      } else {
        this._skip = true;
      }
    }
  }, {
    key: 'skipChanged',
    value: function skipChanged(value, oldValue) {
      if (value !== oldValue) {
        this.skip = value;
      }
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      if (!this._skip) {
        this.stop();
        this.start();
      }
    }
  }, {
    key: 'start',
    value: function start() {
      var _this = this;

      this.starting = true; // Query callback

      if (typeof this.initialOptions.query === 'function') {
        var queryCb = this.initialOptions.query.bind(this.vm);
        this.options.query = queryCb();

        this._watchers.push(this.vm.$watch(queryCb, function (query) {
          _this.options.query = query;

          _this.refresh();
        }, {
          deep: this.options.deep
        }));
      } // Query callback


      if (typeof this.initialOptions.document === 'function') {
        var _queryCb = this.initialOptions.document.bind(this.vm);

        this.options.document = _queryCb();

        this._watchers.push(this.vm.$watch(_queryCb, function (document) {
          _this.options.document = document;

          _this.refresh();
        }, {
          deep: this.options.deep
        }));
      } // Apollo context


      if (typeof this.initialOptions.context === 'function') {
        var cb = this.initialOptions.context.bind(this.vm);
        this.options.context = cb();

        this._watchers.push(this.vm.$watch(cb, function (context) {
          _this.options.context = context;

          _this.refresh();
        }, {
          deep: this.options.deep
        }));
      } // GraphQL Variables


      if (typeof this.options.variables === 'function') {
        var _cb = this.executeApollo.bind(this);

        _cb = this.options.throttle ? utils_2(_cb, this.options.throttle) : _cb;
        _cb = this.options.debounce ? utils_3(_cb, this.options.debounce) : _cb;

        this._watchers.push(this.vm.$watch(function () {
          return _this.options.variables.call(_this.vm);
        }, _cb, {
          immediate: true,
          deep: this.options.deep
        }));
      } else {
        this.executeApollo(this.options.variables);
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._watchers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var unwatch = _step.value;
          unwatch();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (this.sub) {
        this.sub.unsubscribe();
        this.sub = null;
      }
    }
  }, {
    key: 'generateApolloOptions',
    value: function generateApolloOptions(variables) {
      var apolloOptions = utils_6(this.options, this.vueApolloSpecialKeys);
      apolloOptions.variables = variables;
      return apolloOptions;
    }
  }, {
    key: 'executeApollo',
    value: function executeApollo(variables) {
      this.starting = false;
    }
  }, {
    key: 'nextResult',
    value: function nextResult(result) {
      var error = result.error;
      if (error) utils_7(error);
    }
  }, {
    key: 'callHandlers',
    value: function callHandlers(handlers) {
      var catched = false;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var handler = _step2.value;

          if (handler) {
            catched = true;
            var result = handler.apply(this.vm, args);

            if (typeof result !== 'undefined' && !result) {
              break;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return catched;
    }
  }, {
    key: 'errorHandler',
    value: function errorHandler() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.callHandlers.apply(this, [[this.options.error, this.vm.$apollo.error, this.vm.$apollo.provider.errorHandler]].concat(args));
    }
  }, {
    key: 'catchError',
    value: function catchError(error) {
      utils_7(error);
      var catched = this.errorHandler(error);
      if (catched) return;

      if (error.graphQLErrors && error.graphQLErrors.length !== 0) {
        console.error('GraphQL execution errors for ' + this.type + ' \'' + this.key + '\'');
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = error.graphQLErrors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var e = _step3.value;
            console.error(e);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } else if (error.networkError) {
        console.error('Error sending the ' + this.type + ' \'' + this.key + '\'', error.networkError);
      } else {
        console.error('[vue-apollo] An error has occured for ' + this.type + ' \'' + this.key + '\'');

        if (Array.isArray(error)) {
          var _console;

          (_console = console).error.apply(_console, toConsumableArray(error));
        } else {
          console.error(error);
        }
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._destroyed) return;
      this._destroyed = true;
      this.stop();

      if (this._skipWatcher) {
        this._skipWatcher();
      }
    }
  }, {
    key: 'skip',
    get: function get$$1() {
      return this._skip;
    },
    set: function set$$1(value) {
      if (value) {
        this.stop();
      } else {
        this.start();
      }

      this._skip = value;
    }
  }]);
  return SmartApollo;
}();

var VUE_APOLLO_QUERY_KEYWORDS = ['variables', 'watch', 'update', 'result', 'error', 'loadingKey', 'watchLoading', 'skip', 'throttle', 'debounce', 'subscribeToMore', 'prefetch', 'manual'];

var SmartQuery = function (_SmartApollo) {
  inherits(SmartQuery, _SmartApollo);

  function SmartQuery(vm, key, options) {
    var autostart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    classCallCheck(this, SmartQuery); // Simple query

    if (!options.query) {
      var query = options;
      options = {
        query: query
      };
    } // Add reactive data related to the query


    if (vm.$data.$apolloData && !vm.$data.$apolloData.queries[key]) {
      vm.$set(vm.$data.$apolloData.queries, key, {
        loading: false
      });
    }

    var _this = possibleConstructorReturn(this, (SmartQuery.__proto__ || Object.getPrototypeOf(SmartQuery)).call(this, vm, key, options, autostart));

    _this.type = 'query';
    _this.vueApolloSpecialKeys = VUE_APOLLO_QUERY_KEYWORDS;
    _this._loading = false;

    if (!options.manual) {
      _this.hasDataField = _this.vm.$data.hasOwnProperty(key);

      if (_this.hasDataField) {
        Object.defineProperty(_this.vm.$data.$apolloData.data, key, {
          get: function get$$1() {
            return _this.vm.$data[key];
          },
          enumerable: true,
          configurable: true
        });
      } else {
        Object.defineProperty(_this.vm.$data, key, {
          get: function get$$1() {
            return _this.vm.$data.$apolloData.data[key];
          },
          enumerable: true,
          configurable: true
        });
      }
    }

    return _this;
  }

  createClass(SmartQuery, [{
    key: 'stop',
    value: function stop() {
      get(SmartQuery.prototype.__proto__ || Object.getPrototypeOf(SmartQuery.prototype), 'stop', this).call(this);

      if (this.observer) {
        this.observer.stopPolling();
        this.observer = null;
      }
    }
  }, {
    key: 'executeApollo',
    value: function executeApollo(variables) {
      if (this.observer) {
        // Update variables
        // Don't use setVariables directly or it will ignore cache
        this.observer.setOptions(this.generateApolloOptions(variables));
      } else {
        if (this.sub) {
          this.sub.unsubscribe();
        } // Create observer


        this.observer = this.vm.$apollo.watchQuery(this.generateApolloOptions(variables));
      }

      this.startQuerySubscription();

      if (this.options.fetchPolicy !== 'no-cache') {
        var currentResult = this.maySetLoading();

        if (!currentResult.loading) {
          this.nextResult(currentResult);
        }
      }

      get(SmartQuery.prototype.__proto__ || Object.getPrototypeOf(SmartQuery.prototype), 'executeApollo', this).call(this, variables);
    }
  }, {
    key: 'startQuerySubscription',
    value: function startQuerySubscription() {
      if (this.sub && !this.sub.closed) return; // Create subscription

      this.sub = this.observer.subscribe({
        next: this.nextResult.bind(this),
        error: this.catchError.bind(this)
      });
    }
  }, {
    key: 'maySetLoading',
    value: function maySetLoading() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var currentResult = this.observer.currentResult();

      if (force || currentResult.loading) {
        if (!this.loading) {
          this.applyLoadingModifier(1);
        }

        this.loading = true;
      }

      return currentResult;
    }
  }, {
    key: 'nextResult',
    value: function nextResult(result) {
      get(SmartQuery.prototype.__proto__ || Object.getPrototypeOf(SmartQuery.prototype), 'nextResult', this).call(this, result);
      var data = result.data,
          loading = result.loading;

      if (!loading) {
        this.loadingDone();
      }

      var hasResultCallback = typeof this.options.result === 'function';

      if (typeof data === 'undefined') {// No result
      } else if (!this.options.manual) {
        if (typeof this.options.update === 'function') {
          this.setData(this.options.update.call(this.vm, data));
        } else if (typeof data[this.key] === 'undefined' && Object.keys(data).length) {
          console.error('Missing ' + this.key + ' attribute on result', data);
        } else {
          this.setData(data[this.key]);
        }
      } else if (!hasResultCallback) {
        console.error(this.key + ' query must have a \'result\' hook in manual mode');
      }

      if (hasResultCallback) {
        this.options.result.call(this.vm, result);
      }
    }
  }, {
    key: 'setData',
    value: function setData(value) {
      this.vm.$set(this.hasDataField ? this.vm.$data : this.vm.$data.$apolloData.data, this.key, value);
    }
  }, {
    key: 'catchError',
    value: function catchError(error) {
      get(SmartQuery.prototype.__proto__ || Object.getPrototypeOf(SmartQuery.prototype), 'catchError', this).call(this, error);
      this.loadingDone();
      this.nextResult(this.observer.currentResult()); // The observable closes the sub if an error occurs

      this.resubscribeToQuery();
    }
  }, {
    key: 'resubscribeToQuery',
    value: function resubscribeToQuery() {
      var lastError = this.observer.getLastError();
      var lastResult = this.observer.getLastResult();
      this.observer.resetLastResults();
      this.startQuerySubscription();
      Object.assign(this.observer, {
        lastError: lastError,
        lastResult: lastResult
      });
    }
  }, {
    key: 'watchLoading',
    value: function watchLoading() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.callHandlers.apply(this, [[this.options.watchLoading, this.vm.$apollo.watchLoading, this.vm.$apollo.provider.watchLoading]].concat(args, [this]));
    }
  }, {
    key: 'applyLoadingModifier',
    value: function applyLoadingModifier(value) {
      var loadingKey = this.loadingKey;

      if (loadingKey && typeof this.vm[loadingKey] === 'number') {
        this.vm[loadingKey] += value;
      }

      this.watchLoading(value === 1, value);
    }
  }, {
    key: 'loadingDone',
    value: function loadingDone() {
      if (this.loading) {
        this.applyLoadingModifier(-1);
      }

      this.loading = false;
    }
  }, {
    key: 'fetchMore',
    value: function fetchMore() {
      var _this2 = this;

      if (this.observer) {
        var _observer;

        this.maySetLoading(true);
        return (_observer = this.observer).fetchMore.apply(_observer, arguments).then(function (result) {
          if (!result.loading) {
            _this2.loadingDone();
          }

          return result;
        });
      }
    }
  }, {
    key: 'subscribeToMore',
    value: function subscribeToMore() {
      if (this.observer) {
        var _observer2;

        return {
          unsubscribe: (_observer2 = this.observer).subscribeToMore.apply(_observer2, arguments)
        };
      }
    }
  }, {
    key: 'refetch',
    value: function refetch(variables) {
      var _this3 = this;

      variables && (this.options.variables = variables);

      if (this.observer) {
        var result = this.observer.refetch(variables).then(function (result) {
          if (!result.loading) {
            _this3.loadingDone();
          }

          return result;
        });
        this.maySetLoading();
        return result;
      }
    }
  }, {
    key: 'setVariables',
    value: function setVariables(variables, tryFetch) {
      this.options.variables = variables;

      if (this.observer) {
        var result = this.observer.setVariables(variables, tryFetch);
        this.maySetLoading();
        return result;
      }
    }
  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      Object.assign(this.options, options);

      if (this.observer) {
        var result = this.observer.setOptions(options);
        this.maySetLoading();
        return result;
      }
    }
  }, {
    key: 'startPolling',
    value: function startPolling() {
      if (this.observer) {
        var _observer3;

        return (_observer3 = this.observer).startPolling.apply(_observer3, arguments);
      }
    }
  }, {
    key: 'stopPolling',
    value: function stopPolling() {
      if (this.observer) {
        var _observer4;

        return (_observer4 = this.observer).stopPolling.apply(_observer4, arguments);
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      get(SmartQuery.prototype.__proto__ || Object.getPrototypeOf(SmartQuery.prototype), 'destroy', this).call(this);

      if (this.loading) {
        this.watchLoading(false, -1);
      }

      this.loading = false;
    }
  }, {
    key: 'client',
    get: function get$$1() {
      return this.vm.$apollo.getClient(this.options);
    }
  }, {
    key: 'loading',
    get: function get$$1() {
      return this.vm.$data.$apolloData && this.vm.$data.$apolloData.queries[this.key] ? this.vm.$data.$apolloData.queries[this.key].loading : this._loading;
    },
    set: function set$$1(value) {
      if (this._loading !== value) {
        this._loading = value;

        if (this.vm.$data.$apolloData && this.vm.$data.$apolloData.queries[this.key]) {
          this.vm.$data.$apolloData.queries[this.key].loading = value;
          this.vm.$data.$apolloData.loading += value ? 1 : -1;
        }
      }
    }
  }, {
    key: 'loadingKey',
    get: function get$$1() {
      return this.options.loadingKey || this.vm.$apollo.loadingKey;
    }
  }]);
  return SmartQuery;
}(SmartApollo);

var SmartSubscription = function (_SmartApollo) {
  inherits(SmartSubscription, _SmartApollo);

  function SmartSubscription() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, SmartSubscription);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SmartSubscription.__proto__ || Object.getPrototypeOf(SmartSubscription)).call.apply(_ref, [this].concat(args))), _this), _this.type = 'subscription', _this.vueApolloSpecialKeys = ['variables', 'result', 'error', 'throttle', 'debounce', 'linkedQuery'], _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(SmartSubscription, [{
    key: 'executeApollo',
    value: function executeApollo(variables) {
      var variablesJson = JSON.stringify(variables);

      if (this.sub) {
        // do nothing if subscription is already running using exactly the same variables
        if (variablesJson === this.previousVariablesJson) {
          return;
        }

        this.sub.unsubscribe();
      }

      this.previousVariablesJson = variablesJson;
      var apolloOptions = this.generateApolloOptions(variables);

      if (typeof apolloOptions.updateQuery === 'function') {
        apolloOptions.updateQuery = apolloOptions.updateQuery.bind(this.vm);
      }

      if (this.options.linkedQuery) {
        if (typeof this.options.result === 'function') {
          var rcb = this.options.result.bind(this.vm);
          var ucb = apolloOptions.updateQuery && apolloOptions.updateQuery.bind(this.vm);

          apolloOptions.updateQuery = function () {
            rcb.apply(undefined, arguments);
            ucb && ucb.apply(undefined, arguments);
          };
        }

        this.sub = this.options.linkedQuery.subscribeToMore(apolloOptions);
      } else {
        // Create observer
        this.observer = this.vm.$apollo.subscribe(apolloOptions); // Create subscription

        this.sub = this.observer.subscribe({
          next: this.nextResult.bind(this),
          error: this.catchError.bind(this)
        });
      }

      get(SmartSubscription.prototype.__proto__ || Object.getPrototypeOf(SmartSubscription.prototype), 'executeApollo', this).call(this, variables);
    }
  }, {
    key: 'nextResult',
    value: function nextResult(data) {
      get(SmartSubscription.prototype.__proto__ || Object.getPrototypeOf(SmartSubscription.prototype), 'nextResult', this).call(this, data);

      if (typeof this.options.result === 'function') {
        this.options.result.call(this.vm, data);
      }
    }
  }]);
  return SmartSubscription;
}(SmartApollo);

var DollarApollo = function () {
  function DollarApollo(vm) {
    classCallCheck(this, DollarApollo);
    this._apolloSubscriptions = [];
    this._watchers = [];
    this.vm = vm;
    this.queries = {};
    this.subscriptions = {};
    this.client = undefined;
    this.loadingKey = undefined;
    this.error = undefined;
  }

  createClass(DollarApollo, [{
    key: 'query',
    value: function query(options) {
      return this.getClient(options).query(options);
    }
  }, {
    key: 'getClient',
    value: function getClient() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (!options || !options.client) {
        if (_typeof(this.client) === 'object') {
          return this.client;
        }

        if (this.client) {
          if (!this.provider.clients) {
            throw new Error('[vue-apollo] Missing \'clients\' options in \'apolloProvider\'');
          } else {
            var _client = this.provider.clients[this.client];

            if (!_client) {
              throw new Error('[vue-apollo] Missing client \'' + this.client + '\' in \'apolloProvider\'');
            }

            return _client;
          }
        }

        return this.provider.defaultClient;
      }

      var client = this.provider.clients[options.client];

      if (!client) {
        throw new Error('[vue-apollo] Missing client \'' + options.client + '\' in \'apolloProvider\'');
      }

      return client;
    }
  }, {
    key: 'watchQuery',
    value: function watchQuery(options) {
      var _this = this;

      var observable = this.getClient(options).watchQuery(options);

      var _subscribe = observable.subscribe.bind(observable);

      observable.subscribe = function (options) {
        var sub = _subscribe(options);

        _this._apolloSubscriptions.push(sub);

        return sub;
      };

      return observable;
    }
  }, {
    key: 'mutate',
    value: function mutate(options) {
      return this.getClient(options).mutate(options);
    }
  }, {
    key: 'subscribe',
    value: function subscribe(options) {
      var _this2 = this;

      if (!this.vm.$isServer) {
        var observable = this.getClient(options).subscribe(options);

        var _subscribe = observable.subscribe.bind(observable);

        observable.subscribe = function (options) {
          var sub = _subscribe(options);

          _this2._apolloSubscriptions.push(sub);

          return sub;
        };

        return observable;
      }
    }
  }, {
    key: 'addSmartQuery',
    value: function addSmartQuery(key, options) {
      var _this3 = this;

      var finalOptions = utils_5(options, this.vm);
      var apollo = this.vm.$options.apollo;
      var defaultOptions = this.provider.defaultOptions;
      var $query = void 0;

      if (apollo && apollo.$query) {
        $query = apollo.$query;
      }

      if ((!apollo || !apollo.$query) && defaultOptions && defaultOptions.$query) {
        $query = defaultOptions.$query;
      }

      if ($query) {
        // Also replaces 'undefined' values
        for (var _key in $query) {
          if (typeof finalOptions[_key] === 'undefined') {
            finalOptions[_key] = $query[_key];
          }
        }
      }

      var smart = this.queries[key] = new SmartQuery(this.vm, key, finalOptions, false);

      if (!this.vm.$isServer || finalOptions.prefetch !== false) {
        smart.autostart();
      }

      if (!this.vm.$isServer) {
        var subs = finalOptions.subscribeToMore;

        if (subs) {
          if (Array.isArray(subs)) {
            subs.forEach(function (sub, index) {
              _this3.addSmartSubscription('' + key + index, _extends({}, sub, {
                linkedQuery: smart
              }));
            });
          } else {
            this.addSmartSubscription(key, _extends({}, subs, {
              linkedQuery: smart
            }));
          }
        }
      }

      return smart;
    }
  }, {
    key: 'addSmartSubscription',
    value: function addSmartSubscription(key, options) {
      if (!this.vm.$isServer) {
        options = utils_5(options, this.vm);
        var smart = this.subscriptions[key] = new SmartSubscription(this.vm, key, options, false);
        smart.autostart();
        return smart;
      }
    }
  }, {
    key: 'defineReactiveSetter',
    value: function defineReactiveSetter(key, func, deep) {
      var _this4 = this;

      this._watchers.push(this.vm.$watch(func, function (value) {
        _this4[key] = value;
      }, {
        immediate: true,
        deep: deep
      }));
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._watchers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var unwatch = _step.value;
          unwatch();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      for (var key in this.queries) {
        this.queries[key].destroy();
      }

      for (var _key2 in this.subscriptions) {
        this.subscriptions[_key2].destroy();
      }

      this._apolloSubscriptions.forEach(function (sub) {
        sub.unsubscribe();
      });

      this._apolloSubscriptions = null;
      this.vm = null;
    }
  }, {
    key: 'provider',
    get: function get$$1() {
      return this.vm.$apolloProvider;
    }
  }, {
    key: 'loading',
    get: function get$$1() {
      return this.vm.$data.$apolloData.loading !== 0;
    }
  }, {
    key: 'data',
    get: function get$$1() {
      return this.vm.$data.$apolloData.data;
    }
  }, {
    key: 'skipAllQueries',
    set: function set$$1(value) {
      for (var key in this.queries) {
        this.queries[key].skip = value;
      }
    }
  }, {
    key: 'skipAllSubscriptions',
    set: function set$$1(value) {
      for (var key in this.subscriptions) {
        this.subscriptions[key].skip = value;
      }
    }
  }, {
    key: 'skipAll',
    set: function set$$1(value) {
      this.skipAllQueries = value;
      this.skipAllSubscriptions = value;
    }
  }]);
  return DollarApollo;
}();

var ApolloProvider = function () {
  function ApolloProvider(options) {
    classCallCheck(this, ApolloProvider);

    if (!options) {
      throw new Error('Options argument required');
    }

    this.clients = options.clients || {};
    this.clients.defaultClient = this.defaultClient = options.defaultClient;
    this.defaultOptions = options.defaultOptions;
    this.watchLoading = options.watchLoading;
    this.errorHandler = options.errorHandler;
    this.prefetchQueries = [];
  }

  createClass(ApolloProvider, [{
    key: 'provide',
    value: function provide() {
      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$apolloProvider';
      console.warn('<ApolloProvider>.provide() is deprecated. Use the \'apolloProvider\' option instead with the provider object directly.');
      return defineProperty({}, key, this);
    }
  }]);
  return ApolloProvider;
}();

function isDataFilled(data) {
  return Object.keys(data).length > 0;
}

var CApolloQuery = {
  name: 'ApolloQuery',
  provide: function provide() {
    return {
      getDollarApollo: this.getDollarApollo,
      getApolloQuery: this.getApolloQuery
    };
  },
  props: {
    query: {
      type: Object,
      required: true
    },
    variables: {
      type: Object,
      default: undefined
    },
    fetchPolicy: {
      type: String,
      default: undefined
    },
    pollInterval: {
      type: Number,
      default: undefined
    },
    notifyOnNetworkStatusChange: {
      type: Boolean,
      default: undefined
    },
    context: {
      type: Object,
      default: undefined
    },
    skip: {
      type: Boolean,
      default: false
    },
    debounce: {
      type: Number,
      default: 0
    },
    throttle: {
      type: Number,
      default: 0
    },
    clientId: {
      type: String,
      default: undefined
    },
    deep: {
      type: Boolean,
      default: undefined
    },
    tag: {
      type: String,
      default: 'div'
    }
  },
  data: function data() {
    return {
      result: {
        data: null,
        loading: false,
        networkStatus: 7,
        error: null
      },
      times: 0
    };
  },
  watch: {
    fetchPolicy: function fetchPolicy(value) {
      this.$apollo.queries.query.setOptions({
        fetchPolicy: value
      });
    },
    pollInterval: function pollInterval(value) {
      this.$apollo.queries.query.setOptions({
        pollInterval: value
      });
    },
    notifyOnNetworkStatusChange: function notifyOnNetworkStatusChange(value) {
      this.$apollo.queries.query.setOptions({
        notifyOnNetworkStatusChange: value
      });
    }
  },
  apollo: {
    $client: function $client() {
      return this.clientId;
    },
    query: function query() {
      return {
        query: function query() {
          return this.query;
        },
        variables: function variables() {
          return this.variables;
        },
        fetchPolicy: this.fetchPolicy,
        pollInterval: this.pollInterval,
        debounce: this.debounce,
        throttle: this.throttle,
        notifyOnNetworkStatusChange: this.notifyOnNetworkStatusChange,
        context: function context() {
          return this.context;
        },
        skip: function skip() {
          return this.skip;
        },
        deep: this.deep,
        manual: true,
        result: function result(_result) {
          var _result2 = _result,
              errors = _result2.errors,
              loading = _result2.loading,
              networkStatus = _result2.networkStatus;
          var _result3 = _result,
              error = _result3.error;
          _result = Object.assign({}, _result);

          if (errors && errors.length) {
            error = new Error('Apollo errors occured (' + errors.length + ')');
            error.graphQLErrors = errors;
          }

          var data = {};

          if (loading) {
            Object.assign(data, this.$_previousData, _result.data);
          } else if (error) {
            Object.assign(data, this.$apollo.queries.query.observer.getLastResult() || {}, _result.data);
          } else {
            data = _result.data;
            this.$_previousData = _result.data;
          }

          this.result = {
            data: isDataFilled(data) ? data : undefined,
            loading: loading,
            error: error,
            networkStatus: networkStatus
          };
          this.times = ++this.$_times;
          this.$emit('result', this.result);
        },
        error: function error(_error) {
          this.result.loading = false;
          this.result.error = _error;
          this.$emit('error', _error);
        }
      };
    }
  },
  created: function created() {
    this.$_times = 0;
  },
  methods: {
    getDollarApollo: function getDollarApollo() {
      return this.$apollo;
    },
    getApolloQuery: function getApolloQuery() {
      return this.$apollo.queries.query;
    }
  },
  render: function render(h) {
    var result = this.$scopedSlots.default({
      result: this.result,
      times: this.times,
      query: this.$apollo.queries.query,
      isLoading: this.$apolloData.loading,
      gqlError: this.result && this.result.error && this.result.error.gqlError
    });

    if (Array.isArray(result)) {
      result = result.concat(this.$slots.default);
    } else {
      result = [result].concat(this.$slots.default);
    }

    return this.tag ? h(this.tag, result) : result[0];
  }
};
var uid = 0;
var CApolloSubscribeToMore = {
  name: 'ApolloSubscribeToMore',
  inject: ['getDollarApollo', 'getApolloQuery'],
  props: {
    document: {
      type: Object,
      required: true
    },
    variables: {
      type: Object,
      default: undefined
    },
    updateQuery: {
      type: Function,
      default: undefined
    }
  },
  watch: {
    document: 'refresh',
    variables: 'refresh'
  },
  created: function created() {
    this.$_key = 'sub_component_' + uid++;
  },
  mounted: function mounted() {
    this.refresh();
  },
  beforeDestroy: function beforeDestroy() {
    this.destroy();
  },
  methods: {
    destroy: function destroy() {
      if (this.$_sub) {
        this.$_sub.destroy();
      }
    },
    refresh: function refresh() {
      this.destroy();
      this.$_sub = this.getDollarApollo().addSmartSubscription(this.$_key, {
        document: this.document,
        variables: this.variables,
        updateQuery: this.updateQuery,
        linkedQuery: this.getApolloQuery()
      });
    }
  },
  render: function render(h) {
    return null;
  }
};
var CApolloMutation = {
  props: {
    mutation: {
      type: Object,
      required: true
    },
    variables: {
      type: Object,
      default: undefined
    },
    optimisticResponse: {
      type: Object,
      default: undefined
    },
    update: {
      type: Function,
      default: undefined
    },
    refetchQueries: {
      type: Function,
      default: undefined
    },
    clientId: {
      type: String,
      default: undefined
    },
    tag: {
      type: String,
      default: 'div'
    }
  },
  data: function data() {
    return {
      loading: false,
      error: null
    };
  },
  methods: {
    mutate: function mutate(options) {
      var _this = this;

      this.loading = true;
      this.error = null;
      this.$apollo.mutate(_extends({
        mutation: this.mutation,
        client: this.clientId,
        variables: this.variables,
        optimisticResponse: this.optimisticResponse,
        update: this.update,
        refetchQueries: this.refetchQueries
      }, options)).then(function (result) {
        _this.$emit('done', result);

        _this.loading = false;
      }).catch(function (e) {
        utils_7(e);
        _this.error = e;

        _this.$emit('error', e);

        _this.loading = false;
      });
    }
  },
  render: function render(h) {
    var result = this.$scopedSlots.default({
      mutate: this.mutate,
      loading: this.loading,
      error: this.error,
      gqlError: this.error && this.error.gqlError
    });

    if (Array.isArray(result)) {
      result = result.concat(this.$slots.default);
    } else {
      result = [result].concat(this.$slots.default);
    }

    return this.tag ? h(this.tag, result) : result[0];
  }
};

function hasProperty(holder, key) {
  return typeof holder !== 'undefined' && Object.prototype.hasOwnProperty.call(holder, key);
}

function initDollarApollo() {
  var options = this.$options; // ApolloProvider injection

  var optionValue = options.apolloProvider;

  if (optionValue) {
    this.$apolloProvider = typeof optionValue === 'function' ? optionValue() : optionValue;
  } else if (options.parent && options.parent.$apolloProvider) {
    this.$apolloProvider = options.parent.$apolloProvider;
  } else if (options.provide) {
    // TODO remove
    // Temporary retro-compatibility
    var provided = typeof options.provide === 'function' ? options.provide.call(this) : options.provide;

    if (provided.$apolloProvider) {
      this.$apolloProvider = provided.$apolloProvider;
    }
  }
}

function proxyData() {
  var _this = this;

  this.$_apolloInitData = {};
  var apollo = this.$options.apollo;

  if (apollo) {
    var _loop = function _loop(key) {
      if (key.charAt(0) !== '$') {
        var options = apollo[key]; // Property proxy

        if (!options.manual && !hasProperty(_this.$options.props, key) && !hasProperty(_this.$options.computed, key) && !hasProperty(_this.$options.methods, key)) {
          Object.defineProperty(_this, key, {
            get: function get$$1() {
              return _this.$data.$apolloData.data[key];
            },
            // For component class constructor
            set: function set$$1(value) {
              return _this.$_apolloInitData[key] = value;
            },
            enumerable: true,
            configurable: true
          });
        }
      }
    }; // watchQuery


    for (var key in apollo) {
      _loop(key);
    }
  }
}

function launch() {
  var _this2 = this;

  var apolloProvider = this.$apolloProvider;
  if (this._apolloLaunched || !apolloProvider) return;
  this._apolloLaunched = true; // Prepare properties

  var apollo = this.$options.apollo;

  if (apollo) {
    if (!apollo.$init) {
      apollo.$init = true; // Default options applied to `apollo` options

      if (apolloProvider.defaultOptions) {
        apollo = this.$options.apollo = Object.assign({}, apolloProvider.defaultOptions, apollo);
      }
    }

    defineReactiveSetter(this.$apollo, 'skipAll', apollo.$skipAll, apollo.$deep);
    defineReactiveSetter(this.$apollo, 'skipAllQueries', apollo.$skipAllQueries, apollo.$deep);
    defineReactiveSetter(this.$apollo, 'skipAllSubscriptions', apollo.$skipAllSubscriptions, apollo.$deep);
    defineReactiveSetter(this.$apollo, 'client', apollo.$client, apollo.$deep);
    defineReactiveSetter(this.$apollo, 'loadingKey', apollo.$loadingKey, apollo.$deep);
    defineReactiveSetter(this.$apollo, 'error', apollo.$error, apollo.$deep);
    defineReactiveSetter(this.$apollo, 'watchLoading', apollo.$watchLoading, apollo.$deep); // Apollo Data

    Object.defineProperty(this, '$apolloData', {
      get: function get$$1() {
        return _this2.$data.$apolloData;
      },
      enumerable: true,
      configurable: true
    }); // watchQuery

    for (var key in apollo) {
      if (key.charAt(0) !== '$') {
        var options = apollo[key];
        this.$apollo.addSmartQuery(key, options);
      }
    }

    if (apollo.subscribe) {
      utils_1.Vue.util.warn('vue-apollo -> `subscribe` option is deprecated. Use the `$subscribe` option instead.');
    }

    if (apollo.$subscribe) {
      for (var _key in apollo.$subscribe) {
        this.$apollo.addSmartSubscription(_key, apollo.$subscribe[_key]);
      }
    }
  }
}

function defineReactiveSetter($apollo, key, value, deep) {
  if (typeof value !== 'undefined') {
    if (typeof value === 'function') {
      $apollo.defineReactiveSetter(key, value, deep);
    } else {
      $apollo[key] = value;
    }
  }
}

function installMixin(Vue, vueVersion) {
  Vue.mixin(_extends({}, vueVersion === '1' ? {
    init: initDollarApollo
  } : {}, vueVersion === '2' ? {
    data: function data() {
      return {
        '$apolloData': {
          queries: {},
          loading: 0,
          data: this.$_apolloInitData
        }
      };
    },
    beforeCreate: function beforeCreate() {
      initDollarApollo.call(this);
      proxyData.call(this);
    }
  } : {}, {
    created: launch,
    destroyed: function destroyed() {
      if (this.$_apollo) {
        this.$_apollo.destroy();
        this.$_apollo = null;
      }
    }
  }));
}

var keywords = ['$subscribe'];

function install(Vue, options) {
  if (install.installed) return;
  install.installed = true;
  utils_1.Vue = Vue;
  var vueVersion = Vue.version.substr(0, Vue.version.indexOf('.')); // Options merging

  var merge = Vue.config.optionMergeStrategies.methods;

  Vue.config.optionMergeStrategies.apollo = function (toVal, fromVal, vm) {
    if (!toVal) return fromVal;
    if (!fromVal) return toVal;
    var toData = Object.assign({}, utils_6(toVal, keywords), toVal.data);
    var fromData = Object.assign({}, utils_6(fromVal, keywords), fromVal.data);
    var map = {};

    for (var i = 0; i < keywords.length; i++) {
      var key = keywords[i];
      map[key] = merge(toVal[key], fromVal[key]);
    }

    return Object.assign(map, merge(toData, fromData));
  }; // Lazy creation


  Object.defineProperty(Vue.prototype, '$apollo', {
    get: function get() {
      if (!this.$_apollo) {
        this.$_apollo = new DollarApollo(this);
      }

      return this.$_apollo;
    }
  });
  installMixin(Vue, vueVersion);

  if (vueVersion === '2') {
    Vue.component('apollo-query', CApolloQuery);
    Vue.component('ApolloQuery', CApolloQuery);
    Vue.component('apollo-subscribe-to-more', CApolloSubscribeToMore);
    Vue.component('ApolloSubscribeToMore', CApolloSubscribeToMore);
    Vue.component('apollo-mutation', CApolloMutation);
    Vue.component('ApolloMutation', CApolloMutation);
  }
}

ApolloProvider.install = install; // eslint-disable-next-line no-undef

ApolloProvider.version = "3.0.0-beta.25"; // Apollo provider

var ApolloProvider$1 = ApolloProvider; // Components

exports.ApolloProvider = ApolloProvider$1;
var ApolloQuery = CApolloQuery;
exports.ApolloQuery = ApolloQuery;
var ApolloSubscribeToMore = CApolloSubscribeToMore;
exports.ApolloSubscribeToMore = ApolloSubscribeToMore;
var ApolloMutation = CApolloMutation; // Auto-install

exports.ApolloMutation = ApolloMutation;
var GlobalVue = null;

if (typeof window !== 'undefined') {
  GlobalVue = window.Vue;
} else if (typeof global !== 'undefined') {
  GlobalVue = global.Vue;
}

if (GlobalVue) {
  GlobalVue.use(ApolloProvider);
}

var _default = ApolloProvider;
exports.default = _default;
},{}],"gQ3o":[function(require,module,exports) {
var define;
/*!
 * Vue-Lazyload.js v1.2.6
 * (c) 2018 Awe <hilongjw@gmail.com>
 * Released under the MIT License.
 */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.VueLazyload = e();
}(this, function () {
  "use strict";

  function t(t) {
    return t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t);
  }

  function e(t) {
    t = t || {};
    var e = arguments.length,
        i = 0;
    if (1 === e) return t;

    for (; ++i < e;) {
      var o = arguments[i];
      g(t) && (t = o), r(o) && n(t, o);
    }

    return t;
  }

  function n(t, n) {
    m(t, n);

    for (var o in n) if ("__proto__" !== o && i(n, o)) {
      var a = n[o];
      r(a) ? ("undefined" === L(t[o]) && "function" === L(a) && (t[o] = a), t[o] = e(t[o] || {}, a)) : t[o] = a;
    }

    return t;
  }

  function r(t) {
    return "object" === L(t) || "function" === L(t);
  }

  function i(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }

  function o(t, e) {
    if (t.length) {
      var n = t.indexOf(e);
      return n > -1 ? t.splice(n, 1) : void 0;
    }
  }

  function a(t, e) {
    for (var n = !1, r = 0, i = t.length; r < i; r++) if (e(t[r])) {
      n = !0;
      break;
    }

    return n;
  }

  function s(t, e) {
    if ("IMG" === t.tagName && t.getAttribute("data-srcset")) {
      var n = t.getAttribute("data-srcset"),
          r = [],
          i = t.parentNode,
          o = i.offsetWidth * e,
          a = void 0,
          s = void 0,
          u = void 0;
      n = n.trim().split(","), n.map(function (t) {
        t = t.trim(), a = t.lastIndexOf(" "), -1 === a ? (s = t, u = 999998) : (s = t.substr(0, a), u = parseInt(t.substr(a + 1, t.length - a - 2), 10)), r.push([u, s]);
      }), r.sort(function (t, e) {
        if (t[0] < e[0]) return -1;
        if (t[0] > e[0]) return 1;

        if (t[0] === e[0]) {
          if (-1 !== e[1].indexOf(".webp", e[1].length - 5)) return 1;
          if (-1 !== t[1].indexOf(".webp", t[1].length - 5)) return -1;
        }

        return 0;
      });

      for (var l = "", d = void 0, c = r.length, h = 0; h < c; h++) if (d = r[h], d[0] >= o) {
        l = d[1];
        break;
      }

      return l;
    }
  }

  function u(t, e) {
    for (var n = void 0, r = 0, i = t.length; r < i; r++) if (e(t[r])) {
      n = t[r];
      break;
    }

    return n;
  }

  function l() {
    if (!E) return !1;
    var t = !0,
        e = document;

    try {
      var n = e.createElement("object");
      n.type = "image/webp", n.style.visibility = "hidden", n.innerHTML = "!", e.body.appendChild(n), t = !n.offsetWidth, e.body.removeChild(n);
    } catch (e) {
      t = !1;
    }

    return t;
  }

  function d(t, e) {
    var n = null,
        r = 0;
    return function () {
      if (!n) {
        var i = Date.now() - r,
            o = this,
            a = arguments,
            s = function () {
          r = Date.now(), n = !1, t.apply(o, a);
        };

        i >= e ? s() : n = setTimeout(s, e);
      }
    };
  }

  function c(t) {
    return null !== t && "object" === (void 0 === t ? "undefined" : p(t));
  }

  function h(t) {
    if (!(t instanceof Object)) return [];
    if (Object.keys) return Object.keys(t);
    var e = [];

    for (var n in t) t.hasOwnProperty(n) && e.push(n);

    return e;
  }

  function f(t) {
    for (var e = t.length, n = [], r = 0; r < e; r++) n.push(t[r]);

    return n;
  }

  function v() {}

  var p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
    return typeof t;
  } : function (t) {
    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  },
      b = function (t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  },
      y = function () {
    function t(t, e) {
      for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);
      }
    }

    return function (e, n, r) {
      return n && t(e.prototype, n), r && t(e, r), e;
    };
  }(),
      g = function (t) {
    return null == t || "function" != typeof t && "object" !== (void 0 === t ? "undefined" : p(t));
  },
      m = function (t, e) {
    if (null === t || void 0 === t) throw new TypeError("expected first argument to be an object.");
    if (void 0 === e || "undefined" == typeof Symbol) return t;
    if ("function" != typeof Object.getOwnPropertySymbols) return t;

    for (var n = Object.prototype.propertyIsEnumerable, r = Object(t), i = arguments.length, o = 0; ++o < i;) for (var a = Object(arguments[o]), s = Object.getOwnPropertySymbols(a), u = 0; u < s.length; u++) {
      var l = s[u];
      n.call(a, l) && (r[l] = a[l]);
    }

    return r;
  },
      w = Object.prototype.toString,
      L = function (e) {
    var n = void 0 === e ? "undefined" : p(e);
    return "undefined" === n ? "undefined" : null === e ? "null" : !0 === e || !1 === e || e instanceof Boolean ? "boolean" : "string" === n || e instanceof String ? "string" : "number" === n || e instanceof Number ? "number" : "function" === n || e instanceof Function ? void 0 !== e.constructor.name && "Generator" === e.constructor.name.slice(0, 9) ? "generatorfunction" : "function" : void 0 !== Array.isArray && Array.isArray(e) ? "array" : e instanceof RegExp ? "regexp" : e instanceof Date ? "date" : (n = w.call(e), "[object RegExp]" === n ? "regexp" : "[object Date]" === n ? "date" : "[object Arguments]" === n ? "arguments" : "[object Error]" === n ? "error" : "[object Promise]" === n ? "promise" : t(e) ? "buffer" : "[object Set]" === n ? "set" : "[object WeakSet]" === n ? "weakset" : "[object Map]" === n ? "map" : "[object WeakMap]" === n ? "weakmap" : "[object Symbol]" === n ? "symbol" : "[object Map Iterator]" === n ? "mapiterator" : "[object Set Iterator]" === n ? "setiterator" : "[object String Iterator]" === n ? "stringiterator" : "[object Array Iterator]" === n ? "arrayiterator" : "[object Int8Array]" === n ? "int8array" : "[object Uint8Array]" === n ? "uint8array" : "[object Uint8ClampedArray]" === n ? "uint8clampedarray" : "[object Int16Array]" === n ? "int16array" : "[object Uint16Array]" === n ? "uint16array" : "[object Int32Array]" === n ? "int32array" : "[object Uint32Array]" === n ? "uint32array" : "[object Float32Array]" === n ? "float32array" : "[object Float64Array]" === n ? "float64array" : "object");
  },
      _ = e,
      E = "undefined" != typeof window,
      A = E && "IntersectionObserver" in window,
      k = {
    event: "event",
    observer: "observer"
  },
      z = function () {
    function t(t, e) {
      e = e || {
        bubbles: !1,
        cancelable: !1,
        detail: void 0
      };
      var n = document.createEvent("CustomEvent");
      return n.initCustomEvent(t, e.bubbles, e.cancelable, e.detail), n;
    }

    if (E) return "function" == typeof window.CustomEvent ? window.CustomEvent : (t.prototype = window.Event.prototype, t);
  }(),
      j = function () {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
    return E ? window.devicePixelRatio || t : t;
  },
      T = function () {
    if (E) {
      var t = !1;

      try {
        var e = Object.defineProperty({}, "passive", {
          get: function () {
            t = !0;
          }
        });
        window.addEventListener("test", null, e);
      } catch (t) {}

      return t;
    }
  }(),
      S = {
    on: function (t, e, n) {
      var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      T ? t.addEventListener(e, n, {
        capture: r,
        passive: !0
      }) : t.addEventListener(e, n, r);
    },
    off: function (t, e, n) {
      var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      t.removeEventListener(e, n, r);
    }
  },
      I = function (t, e, n) {
    var r = new Image();
    r.src = t.src, r.onload = function () {
      e({
        naturalHeight: r.naturalHeight,
        naturalWidth: r.naturalWidth,
        src: r.src
      });
    }, r.onerror = function (t) {
      n(t);
    };
  },
      O = function (t, e) {
    return "undefined" != typeof getComputedStyle ? getComputedStyle(t, null).getPropertyValue(e) : t.style[e];
  },
      $ = function (t) {
    return O(t, "overflow") + O(t, "overflow-y") + O(t, "overflow-x");
  },
      x = function (t) {
    if (E) {
      if (!(t instanceof HTMLElement)) return window;

      for (var e = t; e && e !== document.body && e !== document.documentElement && e.parentNode;) {
        if (/(scroll|auto)/.test($(e))) return e;
        e = e.parentNode;
      }

      return window;
    }
  },
      H = {},
      Q = function () {
    function t(e) {
      var n = e.el,
          r = e.src,
          i = e.error,
          o = e.loading,
          a = e.bindType,
          s = e.$parent,
          u = e.options,
          l = e.elRenderer;
      b(this, t), this.el = n, this.src = r, this.error = i, this.loading = o, this.bindType = a, this.attempt = 0, this.naturalHeight = 0, this.naturalWidth = 0, this.options = u, this.rect = null, this.$parent = s, this.elRenderer = l, this.performanceData = {
        init: Date.now(),
        loadStart: 0,
        loadEnd: 0
      }, this.filter(), this.initState(), this.render("loading", !1);
    }

    return y(t, [{
      key: "initState",
      value: function () {
        "dataset" in this.el ? this.el.dataset.src = this.src : this.el.setAttribute("data-src", this.src), this.state = {
          error: !1,
          loaded: !1,
          rendered: !1
        };
      }
    }, {
      key: "record",
      value: function (t) {
        this.performanceData[t] = Date.now();
      }
    }, {
      key: "update",
      value: function (t) {
        var e = t.src,
            n = t.loading,
            r = t.error,
            i = this.src;
        this.src = e, this.loading = n, this.error = r, this.filter(), i !== this.src && (this.attempt = 0, this.initState());
      }
    }, {
      key: "getRect",
      value: function () {
        this.rect = this.el.getBoundingClientRect();
      }
    }, {
      key: "checkInView",
      value: function () {
        return this.getRect(), this.rect.top < window.innerHeight * this.options.preLoad && this.rect.bottom > this.options.preLoadTop && this.rect.left < window.innerWidth * this.options.preLoad && this.rect.right > 0;
      }
    }, {
      key: "filter",
      value: function () {
        var t = this;
        h(this.options.filter).map(function (e) {
          t.options.filter[e](t, t.options);
        });
      }
    }, {
      key: "renderLoading",
      value: function (t) {
        var e = this;
        I({
          src: this.loading
        }, function (n) {
          e.render("loading", !1), t();
        }, function () {
          t(), e.options.silent || console.warn("VueLazyload log: load failed with loading image(" + e.loading + ")");
        });
      }
    }, {
      key: "load",
      value: function () {
        var t = this,
            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v;
        return this.attempt > this.options.attempt - 1 && this.state.error ? (this.options.silent || console.log("VueLazyload log: " + this.src + " tried too more than " + this.options.attempt + " times"), void e()) : this.state.loaded || H[this.src] ? (this.state.loaded = !0, e(), this.render("loaded", !0)) : void this.renderLoading(function () {
          t.attempt++, t.record("loadStart"), I({
            src: t.src
          }, function (n) {
            t.naturalHeight = n.naturalHeight, t.naturalWidth = n.naturalWidth, t.state.loaded = !0, t.state.error = !1, t.record("loadEnd"), t.render("loaded", !1), H[t.src] = 1, e();
          }, function (e) {
            !t.options.silent && console.error(e), t.state.error = !0, t.state.loaded = !1, t.render("error", !1);
          });
        });
      }
    }, {
      key: "render",
      value: function (t, e) {
        this.elRenderer(this, t, e);
      }
    }, {
      key: "performance",
      value: function () {
        var t = "loading",
            e = 0;
        return this.state.loaded && (t = "loaded", e = (this.performanceData.loadEnd - this.performanceData.loadStart) / 1e3), this.state.error && (t = "error"), {
          src: this.src,
          state: t,
          time: e
        };
      }
    }, {
      key: "destroy",
      value: function () {
        this.el = null, this.src = null, this.error = null, this.loading = null, this.bindType = null, this.attempt = 0;
      }
    }]), t;
  }(),
      C = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      R = ["scroll", "wheel", "mousewheel", "resize", "animationend", "transitionend", "touchmove"],
      W = {
    rootMargin: "0px",
    threshold: 0
  },
      B = function (t) {
    return function () {
      function e(t) {
        var n = t.preLoad,
            r = t.error,
            i = t.throttleWait,
            o = t.preLoadTop,
            a = t.dispatchEvent,
            s = t.loading,
            u = t.attempt,
            c = t.silent,
            h = void 0 === c || c,
            f = t.scale,
            v = t.listenEvents,
            p = (t.hasbind, t.filter),
            y = t.adapter,
            g = t.observer,
            m = t.observerOptions;
        b(this, e), this.version = "1.2.6", this.mode = k.event, this.ListenerQueue = [], this.TargetIndex = 0, this.TargetQueue = [], this.options = {
          silent: h,
          dispatchEvent: !!a,
          throttleWait: i || 200,
          preLoad: n || 1.3,
          preLoadTop: o || 0,
          error: r || C,
          loading: s || C,
          attempt: u || 3,
          scale: f || j(f),
          ListenEvents: v || R,
          hasbind: !1,
          supportWebp: l(),
          filter: p || {},
          adapter: y || {},
          observer: !!g,
          observerOptions: m || W
        }, this._initEvent(), this.lazyLoadHandler = d(this._lazyLoadHandler.bind(this), this.options.throttleWait), this.setMode(this.options.observer ? k.observer : k.event);
      }

      return y(e, [{
        key: "config",
        value: function () {
          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};

          _(this.options, t);
        }
      }, {
        key: "performance",
        value: function () {
          var t = [];
          return this.ListenerQueue.map(function (e) {
            t.push(e.performance());
          }), t;
        }
      }, {
        key: "addLazyBox",
        value: function (t) {
          this.ListenerQueue.push(t), E && (this._addListenerTarget(window), this._observer && this._observer.observe(t.el), t.$el && t.$el.parentNode && this._addListenerTarget(t.$el.parentNode));
        }
      }, {
        key: "add",
        value: function (e, n, r) {
          var i = this;
          if (a(this.ListenerQueue, function (t) {
            return t.el === e;
          })) return this.update(e, n), t.nextTick(this.lazyLoadHandler);

          var o = this._valueFormatter(n.value),
              u = o.src,
              l = o.loading,
              d = o.error;

          t.nextTick(function () {
            u = s(e, i.options.scale) || u, i._observer && i._observer.observe(e);
            var o = Object.keys(n.modifiers)[0],
                a = void 0;
            o && (a = r.context.$refs[o], a = a ? a.$el || a : document.getElementById(o)), a || (a = x(e));
            var c = new Q({
              bindType: n.arg,
              $parent: a,
              el: e,
              loading: l,
              error: d,
              src: u,
              elRenderer: i._elRenderer.bind(i),
              options: i.options
            });
            i.ListenerQueue.push(c), E && (i._addListenerTarget(window), i._addListenerTarget(a)), i.lazyLoadHandler(), t.nextTick(function () {
              return i.lazyLoadHandler();
            });
          });
        }
      }, {
        key: "update",
        value: function (e, n) {
          var r = this,
              i = this._valueFormatter(n.value),
              o = i.src,
              a = i.loading,
              l = i.error;

          o = s(e, this.options.scale) || o;
          var d = u(this.ListenerQueue, function (t) {
            return t.el === e;
          });
          d && d.update({
            src: o,
            loading: a,
            error: l
          }), this._observer && (this._observer.unobserve(e), this._observer.observe(e)), this.lazyLoadHandler(), t.nextTick(function () {
            return r.lazyLoadHandler();
          });
        }
      }, {
        key: "remove",
        value: function (t) {
          if (t) {
            this._observer && this._observer.unobserve(t);
            var e = u(this.ListenerQueue, function (e) {
              return e.el === t;
            });
            e && (this._removeListenerTarget(e.$parent), this._removeListenerTarget(window), o(this.ListenerQueue, e) && e.destroy());
          }
        }
      }, {
        key: "removeComponent",
        value: function (t) {
          t && (o(this.ListenerQueue, t), this._observer && this._observer.unobserve(t.el), t.$parent && t.$el.parentNode && this._removeListenerTarget(t.$el.parentNode), this._removeListenerTarget(window));
        }
      }, {
        key: "setMode",
        value: function (t) {
          var e = this;
          A || t !== k.observer || (t = k.event), this.mode = t, t === k.event ? (this._observer && (this.ListenerQueue.forEach(function (t) {
            e._observer.unobserve(t.el);
          }), this._observer = null), this.TargetQueue.forEach(function (t) {
            e._initListen(t.el, !0);
          })) : (this.TargetQueue.forEach(function (t) {
            e._initListen(t.el, !1);
          }), this._initIntersectionObserver());
        }
      }, {
        key: "_addListenerTarget",
        value: function (t) {
          if (t) {
            var e = u(this.TargetQueue, function (e) {
              return e.el === t;
            });
            return e ? e.childrenCount++ : (e = {
              el: t,
              id: ++this.TargetIndex,
              childrenCount: 1,
              listened: !0
            }, this.mode === k.event && this._initListen(e.el, !0), this.TargetQueue.push(e)), this.TargetIndex;
          }
        }
      }, {
        key: "_removeListenerTarget",
        value: function (t) {
          var e = this;
          this.TargetQueue.forEach(function (n, r) {
            n.el === t && (--n.childrenCount || (e._initListen(n.el, !1), e.TargetQueue.splice(r, 1), n = null));
          });
        }
      }, {
        key: "_initListen",
        value: function (t, e) {
          var n = this;
          this.options.ListenEvents.forEach(function (r) {
            return S[e ? "on" : "off"](t, r, n.lazyLoadHandler);
          });
        }
      }, {
        key: "_initEvent",
        value: function () {
          var t = this;
          this.Event = {
            listeners: {
              loading: [],
              loaded: [],
              error: []
            }
          }, this.$on = function (e, n) {
            t.Event.listeners[e] || (t.Event.listeners[e] = []), t.Event.listeners[e].push(n);
          }, this.$once = function (e, n) {
            function r() {
              i.$off(e, r), n.apply(i, arguments);
            }

            var i = t;
            t.$on(e, r);
          }, this.$off = function (e, n) {
            if (!n) {
              if (!t.Event.listeners[e]) return;
              return void (t.Event.listeners[e].length = 0);
            }

            o(t.Event.listeners[e], n);
          }, this.$emit = function (e, n, r) {
            t.Event.listeners[e] && t.Event.listeners[e].forEach(function (t) {
              return t(n, r);
            });
          };
        }
      }, {
        key: "_lazyLoadHandler",
        value: function () {
          var t = this,
              e = [];
          this.ListenerQueue.forEach(function (t, n) {
            if (!t.state.error && t.state.loaded) return e.push(t);
            t.checkInView() && t.load();
          }), e.forEach(function (e) {
            return o(t.ListenerQueue, e);
          });
        }
      }, {
        key: "_initIntersectionObserver",
        value: function () {
          var t = this;
          A && (this._observer = new IntersectionObserver(this._observerHandler.bind(this), this.options.observerOptions), this.ListenerQueue.length && this.ListenerQueue.forEach(function (e) {
            t._observer.observe(e.el);
          }));
        }
      }, {
        key: "_observerHandler",
        value: function (t, e) {
          var n = this;
          t.forEach(function (t) {
            t.isIntersecting && n.ListenerQueue.forEach(function (e) {
              if (e.el === t.target) {
                if (e.state.loaded) return n._observer.unobserve(e.el);
                e.load();
              }
            });
          });
        }
      }, {
        key: "_elRenderer",
        value: function (t, e, n) {
          if (t.el) {
            var r = t.el,
                i = t.bindType,
                o = void 0;

            switch (e) {
              case "loading":
                o = t.loading;
                break;

              case "error":
                o = t.error;
                break;

              default:
                o = t.src;
            }

            if (i ? r.style[i] = 'url("' + o + '")' : r.getAttribute("src") !== o && r.setAttribute("src", o), r.setAttribute("lazy", e), this.$emit(e, t, n), this.options.adapter[e] && this.options.adapter[e](t, this.options), this.options.dispatchEvent) {
              var a = new z(e, {
                detail: t
              });
              r.dispatchEvent(a);
            }
          }
        }
      }, {
        key: "_valueFormatter",
        value: function (t) {
          var e = t,
              n = this.options.loading,
              r = this.options.error;
          return c(t) && (t.src || this.options.silent || console.error("Vue Lazyload warning: miss src with " + t), e = t.src, n = t.loading || this.options.loading, r = t.error || this.options.error), {
            src: e,
            loading: n,
            error: r
          };
        }
      }]), e;
    }();
  },
      D = function (t) {
    return {
      props: {
        tag: {
          type: String,
          default: "div"
        }
      },
      render: function (t) {
        return !1 === this.show ? t(this.tag) : t(this.tag, null, this.$slots.default);
      },
      data: function () {
        return {
          el: null,
          state: {
            loaded: !1
          },
          rect: {},
          show: !1
        };
      },
      mounted: function () {
        this.el = this.$el, t.addLazyBox(this), t.lazyLoadHandler();
      },
      beforeDestroy: function () {
        t.removeComponent(this);
      },
      methods: {
        getRect: function () {
          this.rect = this.$el.getBoundingClientRect();
        },
        checkInView: function () {
          return this.getRect(), E && this.rect.top < window.innerHeight * t.options.preLoad && this.rect.bottom > 0 && this.rect.left < window.innerWidth * t.options.preLoad && this.rect.right > 0;
        },
        load: function () {
          this.show = !0, this.state.loaded = !0, this.$emit("show", this);
        }
      }
    };
  },
      V = function () {
    function t(e) {
      var n = e.lazy;
      b(this, t), this.lazy = n, n.lazyContainerMananger = this, this._queue = [];
    }

    return y(t, [{
      key: "bind",
      value: function (t, e, n) {
        var r = new N({
          el: t,
          binding: e,
          vnode: n,
          lazy: this.lazy
        });

        this._queue.push(r);
      }
    }, {
      key: "update",
      value: function (t, e, n) {
        var r = u(this._queue, function (e) {
          return e.el === t;
        });
        r && r.update({
          el: t,
          binding: e,
          vnode: n
        });
      }
    }, {
      key: "unbind",
      value: function (t, e, n) {
        var r = u(this._queue, function (e) {
          return e.el === t;
        });
        r && (r.clear(), o(this._queue, r));
      }
    }]), t;
  }(),
      M = {
    selector: "img"
  },
      N = function () {
    function t(e) {
      var n = e.el,
          r = e.binding,
          i = e.vnode,
          o = e.lazy;
      b(this, t), this.el = null, this.vnode = i, this.binding = r, this.options = {}, this.lazy = o, this._queue = [], this.update({
        el: n,
        binding: r
      });
    }

    return y(t, [{
      key: "update",
      value: function (t) {
        var e = this,
            n = t.el,
            r = t.binding;
        this.el = n, this.options = _({}, M, r.value), this.getImgs().forEach(function (t) {
          e.lazy.add(t, _({}, e.binding, {
            value: {
              src: "dataset" in t ? t.dataset.src : t.getAttribute("data-src"),
              error: "dataset" in t ? t.dataset.error : t.getAttribute("data-error"),
              loading: "dataset" in t ? t.dataset.loading : t.getAttribute("data-loading")
            }
          }), e.vnode);
        });
      }
    }, {
      key: "getImgs",
      value: function () {
        return f(this.el.querySelectorAll(this.options.selector));
      }
    }, {
      key: "clear",
      value: function () {
        var t = this;
        this.getImgs().forEach(function (e) {
          return t.lazy.remove(e);
        }), this.vnode = null, this.binding = null, this.lazy = null;
      }
    }]), t;
  }(),
      P = function (t) {
    return {
      props: {
        src: [String, Object],
        tag: {
          type: String,
          default: "img"
        }
      },
      render: function (t) {
        return t(this.tag, {
          attrs: {
            src: this.renderSrc
          }
        }, this.$slots.default);
      },
      data: function () {
        return {
          el: null,
          options: {
            src: "",
            error: "",
            loading: "",
            attempt: t.options.attempt
          },
          state: {
            loaded: !1,
            error: !1,
            attempt: 0
          },
          rect: {},
          renderSrc: ""
        };
      },
      watch: {
        src: function () {
          this.init(), t.addLazyBox(this), t.lazyLoadHandler();
        }
      },
      created: function () {
        this.init(), this.renderSrc = this.options.loading;
      },
      mounted: function () {
        this.el = this.$el, t.addLazyBox(this), t.lazyLoadHandler();
      },
      beforeDestroy: function () {
        t.removeComponent(this);
      },
      methods: {
        init: function () {
          var e = t._valueFormatter(this.src),
              n = e.src,
              r = e.loading,
              i = e.error;

          this.state.loaded = !1, this.options.src = n, this.options.error = i, this.options.loading = r, this.renderSrc = this.options.loading;
        },
        getRect: function () {
          this.rect = this.$el.getBoundingClientRect();
        },
        checkInView: function () {
          return this.getRect(), E && this.rect.top < window.innerHeight * t.options.preLoad && this.rect.bottom > 0 && this.rect.left < window.innerWidth * t.options.preLoad && this.rect.right > 0;
        },
        load: function () {
          var e = this,
              n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v;
          if (this.state.attempt > this.options.attempt - 1 && this.state.error) return t.options.silent || console.log("VueLazyload log: " + this.options.src + " tried too more than " + this.options.attempt + " times"), void n();
          var r = this.options.src;
          I({
            src: r
          }, function (t) {
            var n = t.src;
            e.renderSrc = n, e.state.loaded = !0;
          }, function (t) {
            e.state.attempt++, e.renderSrc = e.options.error, e.state.error = !0;
          });
        }
      }
    };
  };

  return {
    install: function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          n = B(t),
          r = new n(e),
          i = new V({
        lazy: r
      }),
          o = "2" === t.version.split(".")[0];
      t.prototype.$Lazyload = r, e.lazyComponent && t.component("lazy-component", D(r)), e.lazyImage && t.component("lazy-image", P(r)), o ? (t.directive("lazy", {
        bind: r.add.bind(r),
        update: r.update.bind(r),
        componentUpdated: r.lazyLoadHandler.bind(r),
        unbind: r.remove.bind(r)
      }), t.directive("lazy-container", {
        bind: i.bind.bind(i),
        update: i.update.bind(i),
        unbind: i.unbind.bind(i)
      })) : (t.directive("lazy", {
        bind: r.lazyLoadHandler.bind(r),
        update: function (t, e) {
          _(this.vm.$refs, this.vm.$els), r.add(this.el, {
            modifiers: this.modifiers || {},
            arg: this.arg,
            value: t,
            oldValue: e
          }, {
            context: this.vm
          });
        },
        unbind: function () {
          r.remove(this.el);
        }
      }), t.directive("lazy-container", {
        update: function (t, e) {
          i.update(this.el, {
            modifiers: this.modifiers || {},
            arg: this.arg,
            value: t,
            oldValue: e
          }, {
            context: this.vm
          });
        },
        unbind: function () {
          i.unbind(this.el);
        }
      }));
    }
  };
});
},{}],"6plK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
var _default = {
  name: 'App'
};
exports.default = _default;
        var $8d1ce4 = exports.default || module.exports;
      
      if (typeof $8d1ce4 === 'function') {
        $8d1ce4 = $8d1ce4.options;
      }
    
        /* template */
        Object.assign($8d1ce4, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"app"}},[_c('transition',{attrs:{"name":"page-change"}},[_c('router-view')],1)],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"1iTB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
  * vue-router v3.0.1
  * (c) 2017 Evan You
  * @license MIT
  */

/*  */
function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if ("production" !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;
    data.routerView = true; // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots

    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.

    var depth = 0;
    var inactive = false;

    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }

      if (parent._inactive) {
        inactive = true;
      }

      parent = parent.$parent;
    }

    data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive

    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth]; // render empty node if no matched route

    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name]; // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks

    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];

      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    } // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;

    (data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    }; // resolve props


    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);

    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs

      var attrs = data.attrs = data.attrs || {};

      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config) {
    case 'undefined':
      return;

    case 'object':
      return config;

    case 'function':
      return config(route);

    case 'boolean':
      return config ? route.params : undefined;

    default:
      if ("production" !== 'production') {
        warn(false, "props in \"" + route.path + "\" is a " + typeof config + ", " + "expecting an object, function or boolean.");
      }

  }
}

function extend(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }

  return to;
}
/*  */


var encodeReserveRE = /[!'()*]/g;

var encodeReserveReplacer = function (c) {
  return '%' + c.charCodeAt(0).toString(16);
};

var commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas

var encode = function (str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};
  var parse = _parseQuery || parseQuery;
  var parsedQuery;

  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "production" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }

  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }

  return parsedQuery;
}

function parseQuery(query) {
  var res = {};
  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });
  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }

        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}
/*  */


var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var query = location.query || {};

  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };

  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }

  return Object.freeze(route);
}

function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  } else if (value && typeof value === 'object') {
    var res = {};

    for (var key in value) {
      res[key] = clone(value[key]);
    }

    return res;
  } else {
    return value;
  }
} // the starting route that represents the initial state


var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];

  while (record) {
    res.unshift(record);
    record = record.parent;
  }

  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;
  if (query === void 0) query = {};
  var hash = ref.hash;
  if (hash === void 0) hash = '';
  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {}; // handle null value #1566

  if (!a || !b) {
    return a === b;
  }

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);

  if (aKeys.length !== bKeys.length) {
    return false;
  }

  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key]; // check nested equality

    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal);
    }

    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }

  return true;
}
/*  */
// work around weird flow bug


var toTypes = [String, Object];
var eventTypes = [String, Array];
var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;
    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;
    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class

    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;
    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = {
      click: guardEvent
    };

    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = {
        href: href
      };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);

      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  } // don't redirect when preventDefault called


  if (e.defaultPrevented) {
    return;
  } // don't redirect on right click


  if (e.button !== undefined && e.button !== 0) {
    return;
  } // don't redirect if `target="_blank"`


  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');

    if (/\b_blank\b/i.test(target)) {
      return;
    }
  } // this may be a Weex event which doesn't have this method


  if (e.preventDefault) {
    e.preventDefault();
  }

  return true;
}

function findAnchor(children) {
  if (children) {
    var child;

    for (var i = 0; i < children.length; i++) {
      child = children[i];

      if (child.tag === 'a') {
        return child;
      }

      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed && _Vue === Vue) {
    return;
  }

  install.installed = true;
  _Vue = Vue;

  var isDef = function (v) {
    return v !== undefined;
  };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;

    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;

        this._router.init(this);

        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }

      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });
  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });
  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });
  Vue.component('router-view', View);
  Vue.component('router-link', Link);
  var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks

  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}
/*  */


var inBrowser = typeof window !== 'undefined';
/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);

  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/'); // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)

  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  } // resolve relative path


  var segments = relative.replace(/^\//, '').split('/');

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];

    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  } // ensure leading slash


  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';
  var hashIndex = path.indexOf('#');

  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');

  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};
/**
 * Expose `pathToRegexp`.
 */


var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;
/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */

var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)', // Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');
/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length; // Ignore already escaped sequences.

    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7]; // Push the current path onto the tokens.

    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;
    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  } // Match any characters still remaining.


  if (index < str.length) {
    path += str.substr(index);
  } // If the path exists, push it onto the end.


  if (path) {
    tokens.push(path);
  }

  return tokens;
}
/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */


function compile(str, options) {
  return tokensToFunction(parse(str, options));
}
/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */


function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */


function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
/**
 * Expose a method for transforming tokens into the path function.
 */


function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length); // Compile all the patterns before compilation.

  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}
/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */


function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}
/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */


function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}
/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */


function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}
/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */


function flags(options) {
  return options.sensitive ? '' : 'i';
}
/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */


function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}
/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}
/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */


function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */


function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = ''; // Iterate over the tokens and create our regexp string.

  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';
      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".

  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */


function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options =
    /** @type {!Object} */
    keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path,
    /** @type {!Array} */
    keys);
  }

  if (isarray(path)) {
    return arrayToRegexp(
    /** @type {!Array} */
    path,
    /** @type {!Array} */
    keys, options);
  }

  return stringToRegexp(
  /** @type {string} */
  path,
  /** @type {!Array} */
  keys, options);
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;
/*  */
// $flow-disable-line

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, {
      pretty: true
    });
  } catch (e) {
    if ("production" !== 'production') {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }

    return '';
  }
}
/*  */


function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || []; // $flow-disable-line

  var pathMap = oldPathMap || Object.create(null); // $flow-disable-line

  var nameMap = oldNameMap || Object.create(null);
  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  }); // ensure wildcard routes are always at the end

  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;

  if ("production" !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || {
      default: route.component
    },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : {
      default: route.props
    }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if ("production" !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return /^\/?$/.test(child.path);
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }

    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];
    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ("production" !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);

  if ("production" !== 'production') {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }

  return regex;
}

function normalizePath(path, parent, strict) {
  if (!strict) {
    path = path.replace(/\/$/, '');
  }

  if (path[0] === '/') {
    return path;
  }

  if (parent == null) {
    return path;
  }

  return cleanPath(parent.path + "/" + path);
}
/*  */


function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? {
    path: raw
  } : raw; // named target

  if (next.name || next._normalized) {
    return next;
  } // relative params


  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);

    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if ("production" !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }

    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;
  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);
  var hash = next.hash || parsedPath.hash;

  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }

  return a;
}
/*  */


function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];

      if ("production" !== 'production') {
        warn(record, "Route with name '" + name + "' does not exist");
      }

      if (!record) {
        return _createRoute(null, location);
      }

      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};

      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];

        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    } // no match


    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = {
        path: redirect
      };
    }

    if (!redirect || typeof redirect !== 'object') {
      if ("production" !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];

      if ("production" !== 'production') {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }

      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record); // 2. resolve params

      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\""); // 3. rematch with existing query and hash

      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if ("production" !== 'production') {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }

      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });

    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }

    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }

    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }

    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];

    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}
/*  */


var positionStore = Object.create(null);

function setupScroll() {
  // Fix for #1585 for Firefox
  window.history.replaceState({
    key: getStateKey()
  }, '');
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();

    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;

  if (!behavior) {
    return;
  }

  if ("production" !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  } // wait until re-render finishes before scrolling


  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);

    if (!shouldScroll) {
      return;
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition(shouldScroll, position);
      }).catch(function (err) {
        if ("production" !== 'production') {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();

  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();

  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

function scrollToPosition(shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';

  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);

    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}
/*  */


var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}(); // use User Timing api (if present) for more accurate key precision


var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition(); // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls

  var history = window.history;

  try {
    if (replace) {
      history.replaceState({
        key: _key
      }, '', url);
    } else {
      _key = genKey();
      history.pushState({
        key: _key
      }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}
/*  */


function runQueue(queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };

  step(0);
}
/*  */


function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;
    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;
        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          } // save resolved on async factory in case it's used elsewhere


          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;

          if (pending <= 0) {
            next();
          }
        });
        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "production" !== 'production' && warn(false, msg);

          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });
        var res;

        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }

        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;

            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

var hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';
} // in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.


function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    if (called) {
      return;
    }

    called = true;
    return fn.apply(this, args);
  };
}
/*  */


var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base); // start with a route object that stands for "nowhere"

  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);

    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;
  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL(); // fire ready cbs once

    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }

    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;
  var current = this.current;

  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }

    onAbort && onAbort(err);
  };

  if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;
  var queue = [].concat( // in-component leave guards
  extractLeaveGuards(deactivated), // global before hooks
  this.router.beforeHooks, // in-component update hooks
  extractUpdateHooks(updated), // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }), // async components
  resolveAsyncComponents(activated));
  this.pending = route;

  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }

    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();

          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];

    var isValid = function () {
      return this$1.current === route;
    }; // wait until async components are resolved before
    // extracting in-component enter guards


    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }

      this$1.pending = null;
      onComplete(route);

      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin

      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  } // make sure there's the starting slash


  if (base.charAt(0) !== '/') {
    base = '/' + base;
  } // remove trailing slash


  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);

  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }

  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);

    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }

  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);

      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}
/*  */


var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;
    History$$1.call(this, router, base);
    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.

      var location = getLocation(this$1.base);

      if (this$1.current === START && location === initLocation) {
        return;
      }

      this$1.transitionTo(location, function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;

  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }

  return (path || '/') + window.location.search + window.location.hash;
}
/*  */


var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base); // check history fallback deeplinking

    if (fallback && checkFallback(this.base)) {
      return;
    }

    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early

  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;
    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;

      if (!ensureSlash()) {
        return;
      }

      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }

        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;

    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);

  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();

  if (path.charAt(0) === '/') {
    return true;
  }

  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function getUrl(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return base + "#" + path;
}

function pushHash(path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash(path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}
/*  */


var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;
    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;
    var targetIndex = this.index + n;

    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }

    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {// noop
  };

  return AbstractHistory;
}(History);
/*  */


var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};
  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);
  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;

  if (this.fallback) {
    mode = 'hash';
  }

  if (!inBrowser) {
    mode = 'abstract';
  }

  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;

    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;

    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;

    default:
      if ("production" !== 'production') {
        assert(false, "invalid mode: " + mode);
      }

  }
};

var prototypeAccessors = {
  currentRoute: {
    configurable: true
  }
};

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app
/* Vue component instance */
) {
  var this$1 = this;
  "production" !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");
  this.apps.push(app); // main app already initialized.

  if (this.app) {
    return;
  }

  this.app = app;
  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };

    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;

  if (!route) {
    return [];
  }

  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);

  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);

    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '3.0.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

var _default = VueRouter;
exports.default = _default;
},{}],"Choh":[function(require,module,exports) {
"use strict";

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function (obj) { return typeof obj; }; } else { _typeof2 = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inspect;

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Used to print values in error messages.
 */


function inspect(value) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value) {
        if (typeof value.inspect === 'function') {
          return value.inspect();
        } else if (Array.isArray(value)) {
          return '[' + value.map(inspect).join(', ') + ']';
        }

        var properties = Object.keys(value).map(function (k) {
          return "".concat(k, ": ").concat(inspect(value[k]));
        }).join(', ');
        return properties ? '{ ' + properties + ' }' : '{}';
      }

      return String(value);

    default:
      return String(value);
  }
}
},{}],"jrPS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = invariant;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

function invariant(condition, message) {
  /* istanbul ignore else */
  if (!condition) {
    throw new Error(message);
  }
}
},{}],"dh80":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyToStringTag;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * The `applyToStringTag()` function checks first to see if the runtime
 * supports the `Symbol` class and then if the `Symbol.toStringTag` constant
 * is defined as a `Symbol` instance. If both conditions are met, the
 * Symbol.toStringTag property is defined as a getter that returns the
 * supplied class constructor's name.
 *
 * @method applyToStringTag
 *
 * @param {Class<any>} classObject a class such as Object, String, Number but
 * typically one of your own creation through the class keyword; `class A {}`,
 * for example.
 */

function applyToStringTag(classObject) {
  if (typeof Symbol === 'function' && Symbol.toStringTag) {
    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
      get: function get() {
        return this.constructor.name;
      }
    });
  }
}
},{}],"kA/6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Source = void 0;

var _invariant = _interopRequireDefault(require("../jsutils/invariant"));

var _defineToStringTag = _interopRequireDefault(require("../jsutils/defineToStringTag"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * A representation of source input to GraphQL.
 * `name` and `locationOffset` are optional. They are useful for clients who
 * store GraphQL documents in source files; for example, if the GraphQL input
 * starts at line 40 in a file named Foo.graphql, it might be useful for name to
 * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
 * line and column in locationOffset are 1-indexed
 */


var Source = function Source(body, name, locationOffset) {
  _defineProperty(this, "body", void 0);

  _defineProperty(this, "name", void 0);

  _defineProperty(this, "locationOffset", void 0);

  this.body = body;
  this.name = name || 'GraphQL request';
  this.locationOffset = locationOffset || {
    line: 1,
    column: 1
  };
  !(this.locationOffset.line > 0) ? (0, _invariant.default)(0, 'line in locationOffset is 1-indexed and must be positive') : void 0;
  !(this.locationOffset.column > 0) ? (0, _invariant.default)(0, 'column in locationOffset is 1-indexed and must be positive') : void 0;
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported


exports.Source = Source;
(0, _defineToStringTag.default)(Source);
},{"../jsutils/invariant":"jrPS","../jsutils/defineToStringTag":"dh80"}],"ZX84":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLocation = getLocation;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Represents a location in a Source.
 */

/**
 * Takes a Source and a UTF-8 character offset, and returns the corresponding
 * line and column as a SourceLocation.
 */

function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}
},{}],"eUa2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printError = printError;

var _location = require("../language/location");
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Prints a GraphQLError to a string, representing useful location information
 * about the error's position in the source.
 */


function printError(error) {
  var printedLocations = [];

  if (error.nodes) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = error.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;

        if (node.loc) {
          printedLocations.push(highlightSourceAtLocation(node.loc.source, (0, _location.getLocation)(node.loc.source, node.loc.start)));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (error.source && error.locations) {
    var source = error.source;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = error.locations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var location = _step2.value;
        printedLocations.push(highlightSourceAtLocation(source, location));
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  return printedLocations.length === 0 ? error.message : [error.message].concat(printedLocations).join('\n\n') + '\n';
}
/**
 * Render a helpful description of the location of the error in the GraphQL
 * Source document.
 */


function highlightSourceAtLocation(source, location) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = location.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = location.line + lineOffset;
  var columnOffset = location.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = location.column + columnOffset;
  var lines = body.split(/\r\n|[\n\r]/g);
  return "".concat(source.name, " (").concat(lineNum, ":").concat(columnNum, ")\n") + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1, ": "), lines[lineIndex - 1]], ["".concat(lineNum, ": "), lines[lineIndex]], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1, ": "), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = 0;
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = existingLines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _ref4 = _step3.value;
      var prefix = _ref4[0];
      padLen = Math.max(padLen, prefix.length);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return existingLines.map(function (_ref3) {
    var prefix = _ref3[0],
        line = _ref3[1];
    return lpad(padLen, prefix) + line;
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function lpad(len, str) {
  return whitespace(len - str.length) + str;
}
},{"../language/location":"ZX84"}],"zFQB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphQLError = GraphQLError;

var _printError = require("./printError");

var _location = require("../language/location");
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */


function GraphQLError( // eslint-disable-line no-redeclare
message, nodes, source, positions, path, originalError, extensions) {
  // Compute list of blame nodes.
  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


  var _source = source;

  if (!_source && _nodes) {
    var node = _nodes[0];
    _source = node && node.loc && node.loc.source;
  }

  var _positions = positions;

  if (!_positions && _nodes) {
    _positions = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push(node.loc.start);
      }

      return list;
    }, []);
  }

  if (_positions && _positions.length === 0) {
    _positions = undefined;
  }

  var _locations;

  if (positions && source) {
    _locations = positions.map(function (pos) {
      return (0, _location.getLocation)(source, pos);
    });
  } else if (_nodes) {
    _locations = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push((0, _location.getLocation)(node.loc.source, node.loc.start));
      }

      return list;
    }, []);
  }

  var _extensions = extensions || originalError && originalError.extensions;

  Object.defineProperties(this, {
    message: {
      value: message,
      // By being enumerable, JSON.stringify will include `message` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: true,
      writable: true
    },
    locations: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _locations || undefined,
      // By being enumerable, JSON.stringify will include `locations` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_locations)
    },
    path: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: path || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(path)
    },
    nodes: {
      value: _nodes || undefined
    },
    source: {
      value: _source || undefined
    },
    positions: {
      value: _positions || undefined
    },
    originalError: {
      value: originalError
    },
    extensions: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _extensions || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_extensions)
    }
  }); // Include (non-enumerable) stack trace.

  if (originalError && originalError.stack) {
    Object.defineProperty(this, 'stack', {
      value: originalError.stack,
      writable: true,
      configurable: true
    });
  } else if (Error.captureStackTrace) {
    Error.captureStackTrace(this, GraphQLError);
  } else {
    Object.defineProperty(this, 'stack', {
      value: Error().stack,
      writable: true,
      configurable: true
    });
  }
}

GraphQLError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: GraphQLError
  },
  name: {
    value: 'GraphQLError'
  },
  toString: {
    value: function toString() {
      return (0, _printError.printError)(this);
    }
  }
});
},{"./printError":"eUa2","../language/location":"ZX84"}],"I8r9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.syntaxError = syntaxError;

var _GraphQLError = require("./GraphQLError");
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Produces a GraphQLError representing a syntax error, containing useful
 * descriptive information about the syntax error's position in the source.
 */


function syntaxError(source, position, description) {
  return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), undefined, source, [position]);
}
},{"./GraphQLError":"zFQB"}],"I8IO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.locatedError = locatedError;

var _GraphQLError = require("./GraphQLError");
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Given an arbitrary Error, presumably thrown while attempting to execute a
 * GraphQL operation, produce a new GraphQLError aware of the location in the
 * document responsible for the original Error.
 */


function locatedError(originalError, nodes, path) {
  // Note: this uses a brand-check to support GraphQL errors originating from
  // other contexts.
  if (originalError && Array.isArray(originalError.path)) {
    return originalError;
  }

  return new _GraphQLError.GraphQLError(originalError && originalError.message, originalError && originalError.nodes || nodes, originalError && originalError.source, originalError && originalError.positions, path, originalError);
}
},{"./GraphQLError":"zFQB"}],"Zorn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatError = formatError;

var _invariant = _interopRequireDefault(require("../jsutils/invariant"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Given a GraphQLError, format it according to the rules described by the
 * Response Format, Errors section of the GraphQL Specification.
 */


function formatError(error) {
  !error ? (0, _invariant.default)(0, 'Received null or undefined error.') : void 0;
  var message = error.message || 'An unknown error occurred.';
  var locations = error.locations;
  var path = error.path;
  var extensions = error.extensions;
  return extensions ? {
    message: message,
    locations: locations,
    path: path,
    extensions: extensions
  } : {
    message: message,
    locations: locations,
    path: path
  };
}
},{"../jsutils/invariant":"jrPS"}],"OZfr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "GraphQLError", {
  enumerable: true,
  get: function get() {
    return _GraphQLError.GraphQLError;
  }
});
Object.defineProperty(exports, "syntaxError", {
  enumerable: true,
  get: function get() {
    return _syntaxError.syntaxError;
  }
});
Object.defineProperty(exports, "locatedError", {
  enumerable: true,
  get: function get() {
    return _locatedError.locatedError;
  }
});
Object.defineProperty(exports, "printError", {
  enumerable: true,
  get: function get() {
    return _printError.printError;
  }
});
Object.defineProperty(exports, "formatError", {
  enumerable: true,
  get: function get() {
    return _formatError.formatError;
  }
});

var _GraphQLError = require("./GraphQLError");

var _syntaxError = require("./syntaxError");

var _locatedError = require("./locatedError");

var _printError = require("./printError");

var _formatError = require("./formatError");
},{"./GraphQLError":"zFQB","./syntaxError":"I8r9","./locatedError":"I8IO","./printError":"eUa2","./formatError":"Zorn"}],"8V3Z":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = blockStringValue;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 */

function blockStringValue(rawString) {
  // Expand a block string's raw value into independent lines.
  var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

  var commonIndent = null;

  for (var i = 1; i < lines.length; i++) {
    var line = lines[i];
    var indent = leadingWhitespace(line);

    if (indent < line.length && (commonIndent === null || indent < commonIndent)) {
      commonIndent = indent;

      if (commonIndent === 0) {
        break;
      }
    }
  }

  if (commonIndent) {
    for (var _i = 1; _i < lines.length; _i++) {
      lines[_i] = lines[_i].slice(commonIndent);
    }
  } // Remove leading and trailing blank lines.


  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }

  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  } // Return a string of the lines joined with U+000A.


  return lines.join('\n');
}

function leadingWhitespace(str) {
  var i = 0;

  while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
    i++;
  }

  return i;
}

function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
},{}],"JJWu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLexer = createLexer;
exports.getTokenDesc = getTokenDesc;
exports.TokenKind = void 0;

var _error = require("../error");

var _blockStringValue = _interopRequireDefault(require("./blockStringValue"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Given a Source object, this returns a Lexer for that source.
 * A Lexer is a stateful stream generator in that every time
 * it is advanced, it returns the next token in the Source. Assuming the
 * source lexes, the final Token emitted by the lexer will be of kind
 * EOF, after which the lexer will repeatedly return the same EOF token
 * whenever called.
 */


function createLexer(source, options) {
  var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);
  var lexer = {
    source: source,
    options: options,
    lastToken: startOfFileToken,
    token: startOfFileToken,
    line: 1,
    lineStart: 0,
    advance: advanceLexer,
    lookahead: lookahead
  };
  return lexer;
}

function advanceLexer() {
  this.lastToken = this.token;
  var token = this.token = this.lookahead();
  return token;
}

function lookahead() {
  var token = this.token;

  if (token.kind !== TokenKind.EOF) {
    do {
      // Note: next is only mutable during parsing, so we cast to allow this.
      token = token.next || (token.next = readToken(this, token));
    } while (token.kind === TokenKind.COMMENT);
  }

  return token;
}
/**
 * The return type of createLexer.
 */

/**
 * An exported enum describing the different kinds of tokens that the
 * lexer emits.
 */


var TokenKind = Object.freeze({
  SOF: '<SOF>',
  EOF: '<EOF>',
  BANG: '!',
  DOLLAR: '$',
  AMP: '&',
  PAREN_L: '(',
  PAREN_R: ')',
  SPREAD: '...',
  COLON: ':',
  EQUALS: '=',
  AT: '@',
  BRACKET_L: '[',
  BRACKET_R: ']',
  BRACE_L: '{',
  PIPE: '|',
  BRACE_R: '}',
  NAME: 'Name',
  INT: 'Int',
  FLOAT: 'Float',
  STRING: 'String',
  BLOCK_STRING: 'BlockString',
  COMMENT: 'Comment'
});
/**
 * The enum type representing the token kinds values.
 */

exports.TokenKind = TokenKind;
/**
 * A helper function to describe a token as a string for debugging
 */

function getTokenDesc(token) {
  var value = token.value;
  return value ? "".concat(token.kind, " \"").concat(value, "\"") : token.kind;
}

var charCodeAt = String.prototype.charCodeAt;
var slice = String.prototype.slice;
/**
 * Helper function for constructing the Token object.
 */

function Tok(kind, start, end, line, column, prev, value) {
  this.kind = kind;
  this.start = start;
  this.end = end;
  this.line = line;
  this.column = column;
  this.value = value;
  this.prev = prev;
  this.next = null;
} // Print a simplified form when appearing in JSON/util.inspect.


Tok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {
  return {
    kind: this.kind,
    value: this.value,
    line: this.line,
    column: this.column
  };
};

function printCharCode(code) {
  return (// NaN/undefined represents access beyond the end of the file.
    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.
    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.
    "\"\\u".concat(('00' + code.toString(16).toUpperCase()).slice(-4), "\"")
  );
}
/**
 * Gets the next token from the source starting at the given position.
 *
 * This skips over whitespace and comments until it finds the next lexable
 * token, then lexes punctuators immediately or calls the appropriate helper
 * function for more complicated tokens.
 */


function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = positionAfterWhitespace(body, prev.end, lexer);
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;

  if (pos >= bodyLength) {
    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
  }

  var code = charCodeAt.call(body, pos); // SourceCharacter

  switch (code) {
    // !
    case 33:
      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);
    // #

    case 35:
      return readComment(source, pos, line, col, prev);
    // $

    case 36:
      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);
    // &

    case 38:
      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);
    // (

    case 40:
      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);
    // )

    case 41:
      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);
    // .

    case 46:
      if (charCodeAt.call(body, pos + 1) === 46 && charCodeAt.call(body, pos + 2) === 46) {
        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);
      }

      break;
    // :

    case 58:
      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);
    // =

    case 61:
      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);
    // @

    case 64:
      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);
    // [

    case 91:
      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);
    // ]

    case 93:
      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);
    // {

    case 123:
      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);
    // |

    case 124:
      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);
    // }

    case 125:
      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);
    // A-Z _ a-z

    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 95:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
      return readName(source, pos, line, col, prev);
    // - 0-9

    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return readNumber(source, pos, code, line, col, prev);
    // "

    case 34:
      if (charCodeAt.call(body, pos + 1) === 34 && charCodeAt.call(body, pos + 2) === 34) {
        return readBlockString(source, pos, line, col, prev);
      }

      return readString(source, pos, line, col, prev);
  }

  throw (0, _error.syntaxError)(source, pos, unexpectedCharacterMessage(code));
}
/**
 * Report a message that an unexpected character was encountered.
 */


function unexpectedCharacterMessage(code) {
  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }

  if (code === 39) {
    // '
    return "Unexpected single quote character ('), did you mean to use " + 'a double quote (")?';
  }

  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
/**
 * Reads from body starting at startPosition until it finds a non-whitespace
 * or commented character, then returns the position of that character for
 * lexing.
 */


function positionAfterWhitespace(body, startPosition, lexer) {
  var bodyLength = body.length;
  var position = startPosition;

  while (position < bodyLength) {
    var code = charCodeAt.call(body, position); // tab | space | comma | BOM

    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
      ++position;
    } else if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (charCodeAt.call(body, position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else {
      break;
    }
  }

  return position;
}
/**
 * Reads a comment token from the source file.
 *
 * #[\u0009\u0020-\uFFFF]*
 */


function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;

  do {
    code = charCodeAt.call(body, ++position);
  } while (code !== null && ( // SourceCharacter but not LineTerminator
  code > 0x001f || code === 0x0009));

  return new Tok(TokenKind.COMMENT, start, position, line, col, prev, slice.call(body, start + 1, position));
}
/**
 * Reads a number token from the source file, either a float
 * or an int depending on whether a decimal point appears.
 *
 * Int:   -?(0|[1-9][0-9]*)
 * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
 */


function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;

  if (code === 45) {
    // -
    code = charCodeAt.call(body, ++position);
  }

  if (code === 48) {
    // 0
    code = charCodeAt.call(body, ++position);

    if (code >= 48 && code <= 57) {
      throw (0, _error.syntaxError)(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = charCodeAt.call(body, position);
  }

  if (code === 46) {
    // .
    isFloat = true;
    code = charCodeAt.call(body, ++position);
    position = readDigits(source, position, code);
    code = charCodeAt.call(body, position);
  }

  if (code === 69 || code === 101) {
    // E e
    isFloat = true;
    code = charCodeAt.call(body, ++position);

    if (code === 43 || code === 45) {
      // + -
      code = charCodeAt.call(body, ++position);
    }

    position = readDigits(source, position, code);
  }

  return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, slice.call(body, start, position));
}
/**
 * Returns the new position in the source after reading digits.
 */


function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;

  if (code >= 48 && code <= 57) {
    // 0 - 9
    do {
      code = charCodeAt.call(body, ++position);
    } while (code >= 48 && code <= 57); // 0 - 9


    return position;
  }

  throw (0, _error.syntaxError)(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
/**
 * Reads a string token from the source file.
 *
 * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
 */


function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = '';

  while (position < body.length && (code = charCodeAt.call(body, position)) !== null && // not LineTerminator
  code !== 0x000a && code !== 0x000d) {
    // Closing Quote (")
    if (code === 34) {
      value += slice.call(body, chunkStart, position);
      return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009) {
      throw (0, _error.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    ++position;

    if (code === 92) {
      // \
      value += slice.call(body, chunkStart, position - 1);
      code = charCodeAt.call(body, position);

      switch (code) {
        case 34:
          value += '"';
          break;

        case 47:
          value += '/';
          break;

        case 92:
          value += '\\';
          break;

        case 98:
          value += '\b';
          break;

        case 102:
          value += '\f';
          break;

        case 110:
          value += '\n';
          break;

        case 114:
          value += '\r';
          break;

        case 116:
          value += '\t';
          break;

        case 117:
          // u
          var charCode = uniCharCode(charCodeAt.call(body, position + 1), charCodeAt.call(body, position + 2), charCodeAt.call(body, position + 3), charCodeAt.call(body, position + 4));

          if (charCode < 0) {
            throw (0, _error.syntaxError)(source, position, 'Invalid character escape sequence: ' + "\\u".concat(body.slice(position + 1, position + 5), "."));
          }

          value += String.fromCharCode(charCode);
          position += 4;
          break;

        default:
          throw (0, _error.syntaxError)(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }

      ++position;
      chunkStart = position;
    }
  }

  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');
}
/**
 * Reads a block string token from the source file.
 *
 * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
 */


function readBlockString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = '';

  while (position < body.length && (code = charCodeAt.call(body, position)) !== null) {
    // Closing Triple-Quote (""")
    if (code === 34 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34) {
      rawValue += slice.call(body, chunkStart, position);
      return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, (0, _blockStringValue.default)(rawValue));
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
      throw (0, _error.syntaxError)(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    } // Escape Triple-Quote (\""")


    if (code === 92 && charCodeAt.call(body, position + 1) === 34 && charCodeAt.call(body, position + 2) === 34 && charCodeAt.call(body, position + 3) === 34) {
      rawValue += slice.call(body, chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }

  throw (0, _error.syntaxError)(source, position, 'Unterminated string.');
}
/**
 * Converts four hexadecimal chars to the integer that the
 * string represents. For example, uniCharCode('0','0','0','f')
 * will return 15, and uniCharCode('0','0','f','f') returns 255.
 *
 * Returns a negative number on error, if a char was invalid.
 *
 * This is implemented by noting that char2hex() returns -1 on error,
 * which means the result of ORing the char2hex() will also be negative.
 */


function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
/**
 * Converts a hex character to its integer value.
 * '0' becomes 0, '9' becomes 9
 * 'A' becomes 10, 'F' becomes 15
 * 'a' becomes 10, 'f' becomes 15
 *
 * Returns -1 on error.
 */


function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 // 0-9
  : a >= 65 && a <= 70 ? a - 55 // A-F
  : a >= 97 && a <= 102 ? a - 87 // a-f
  : -1;
}
/**
 * Reads an alphanumeric + underscore name from the source.
 *
 * [_A-Za-z][_0-9A-Za-z]*
 */


function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;

  while (position !== bodyLength && (code = charCodeAt.call(body, position)) !== null && (code === 95 || // _
  code >= 48 && code <= 57 || // 0-9
  code >= 65 && code <= 90 || // A-Z
  code >= 97 && code <= 122) // a-z
  ) {
    ++position;
  }

  return new Tok(TokenKind.NAME, start, position, line, col, prev, slice.call(body, start, position));
}
},{"../error":"OZfr","./blockStringValue":"8V3Z"}],"XgLo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Kind = void 0;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * The set of allowed kind values for AST nodes.
 */

var Kind = Object.freeze({
  // Name
  NAME: 'Name',
  // Document
  DOCUMENT: 'Document',
  OPERATION_DEFINITION: 'OperationDefinition',
  VARIABLE_DEFINITION: 'VariableDefinition',
  SELECTION_SET: 'SelectionSet',
  FIELD: 'Field',
  ARGUMENT: 'Argument',
  // Fragments
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_FRAGMENT: 'InlineFragment',
  FRAGMENT_DEFINITION: 'FragmentDefinition',
  // Values
  VARIABLE: 'Variable',
  INT: 'IntValue',
  FLOAT: 'FloatValue',
  STRING: 'StringValue',
  BOOLEAN: 'BooleanValue',
  NULL: 'NullValue',
  ENUM: 'EnumValue',
  LIST: 'ListValue',
  OBJECT: 'ObjectValue',
  OBJECT_FIELD: 'ObjectField',
  // Directives
  DIRECTIVE: 'Directive',
  // Types
  NAMED_TYPE: 'NamedType',
  LIST_TYPE: 'ListType',
  NON_NULL_TYPE: 'NonNullType',
  // Type System Definitions
  SCHEMA_DEFINITION: 'SchemaDefinition',
  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
  // Type Definitions
  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
  FIELD_DEFINITION: 'FieldDefinition',
  INPUT_VALUE_DEFINITION: 'InputValueDefinition',
  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
  // Directive Definitions
  DIRECTIVE_DEFINITION: 'DirectiveDefinition',
  // Type System Extensions
  SCHEMA_EXTENSION: 'SchemaExtension',
  // Type Extensions
  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
  UNION_TYPE_EXTENSION: 'UnionTypeExtension',
  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
});
/**
 * The enum type representing the possible kind values of AST nodes.
 */

exports.Kind = Kind;
},{}],"FpMx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectiveLocation = void 0;
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * The set of allowed directive location values.
 */

var DirectiveLocation = Object.freeze({
  // Request Definitions
  QUERY: 'QUERY',
  MUTATION: 'MUTATION',
  SUBSCRIPTION: 'SUBSCRIPTION',
  FIELD: 'FIELD',
  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
  // Type System Definitions
  SCHEMA: 'SCHEMA',
  SCALAR: 'SCALAR',
  OBJECT: 'OBJECT',
  FIELD_DEFINITION: 'FIELD_DEFINITION',
  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
  INTERFACE: 'INTERFACE',
  UNION: 'UNION',
  ENUM: 'ENUM',
  ENUM_VALUE: 'ENUM_VALUE',
  INPUT_OBJECT: 'INPUT_OBJECT',
  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
});
/**
 * The enum type representing the directive location values.
 */

exports.DirectiveLocation = DirectiveLocation;
},{}],"n355":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.parseValue = parseValue;
exports.parseType = parseType;
exports.parseConstValue = parseConstValue;
exports.parseTypeReference = parseTypeReference;
exports.parseNamedType = parseNamedType;

var _inspect = _interopRequireDefault(require("../jsutils/inspect"));

var _source = require("./source");

var _error = require("../error");

var _lexer = require("./lexer");

var _kinds = require("./kinds");

var _directiveLocation = require("./directiveLocation");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */

/**
 * Given a GraphQL source, parses it into a Document.
 * Throws GraphQLError if a syntax error is encountered.
 */


function parse(source, options) {
  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;

  if (!(sourceObj instanceof _source.Source)) {
    throw new TypeError("Must provide Source. Received: ".concat((0, _inspect.default)(sourceObj)));
  }

  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
  return parseDocument(lexer);
}
/**
 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
 * that value.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: valueFromAST().
 */


function parseValue(source, options) {
  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
  expect(lexer, _lexer.TokenKind.SOF);
  var value = parseValueLiteral(lexer, false);
  expect(lexer, _lexer.TokenKind.EOF);
  return value;
}
/**
 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
 * that type.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Types directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: typeFromAST().
 */


function parseType(source, options) {
  var sourceObj = typeof source === 'string' ? new _source.Source(source) : source;
  var lexer = (0, _lexer.createLexer)(sourceObj, options || {});
  expect(lexer, _lexer.TokenKind.SOF);
  var type = parseTypeReference(lexer);
  expect(lexer, _lexer.TokenKind.EOF);
  return type;
}
/**
 * Converts a name lex token into a name parse node.
 */


function parseName(lexer) {
  var token = expect(lexer, _lexer.TokenKind.NAME);
  return {
    kind: _kinds.Kind.NAME,
    value: token.value,
    loc: loc(lexer, token)
  };
} // Implements the parsing rules in the Document section.

/**
 * Document : Definition+
 */


function parseDocument(lexer) {
  var start = lexer.token;
  return {
    kind: _kinds.Kind.DOCUMENT,
    definitions: many(lexer, _lexer.TokenKind.SOF, parseDefinition, _lexer.TokenKind.EOF),
    loc: loc(lexer, start)
  };
}
/**
 * Definition :
 *   - ExecutableDefinition
 *   - TypeSystemDefinition
 *   - TypeSystemExtension
 */


function parseDefinition(lexer) {
  if (peek(lexer, _lexer.TokenKind.NAME)) {
    switch (lexer.token.value) {
      case 'query':
      case 'mutation':
      case 'subscription':
      case 'fragment':
        return parseExecutableDefinition(lexer);

      case 'schema':
      case 'scalar':
      case 'type':
      case 'interface':
      case 'union':
      case 'enum':
      case 'input':
      case 'directive':
        return parseTypeSystemDefinition(lexer);

      case 'extend':
        return parseTypeSystemExtension(lexer);
    }
  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
    return parseExecutableDefinition(lexer);
  } else if (peekDescription(lexer)) {
    return parseTypeSystemDefinition(lexer);
  }

  throw unexpected(lexer);
}
/**
 * ExecutableDefinition :
 *   - OperationDefinition
 *   - FragmentDefinition
 */


function parseExecutableDefinition(lexer) {
  if (peek(lexer, _lexer.TokenKind.NAME)) {
    switch (lexer.token.value) {
      case 'query':
      case 'mutation':
      case 'subscription':
        return parseOperationDefinition(lexer);

      case 'fragment':
        return parseFragmentDefinition(lexer);
    }
  } else if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
    return parseOperationDefinition(lexer);
  }

  throw unexpected(lexer);
} // Implements the parsing rules in the Operations section.

/**
 * OperationDefinition :
 *  - SelectionSet
 *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
 */


function parseOperationDefinition(lexer) {
  var start = lexer.token;

  if (peek(lexer, _lexer.TokenKind.BRACE_L)) {
    return {
      kind: _kinds.Kind.OPERATION_DEFINITION,
      operation: 'query',
      name: undefined,
      variableDefinitions: [],
      directives: [],
      selectionSet: parseSelectionSet(lexer),
      loc: loc(lexer, start)
    };
  }

  var operation = parseOperationType(lexer);
  var name;

  if (peek(lexer, _lexer.TokenKind.NAME)) {
    name = parseName(lexer);
  }

  return {
    kind: _kinds.Kind.OPERATION_DEFINITION,
    operation: operation,
    name: name,
    variableDefinitions: parseVariableDefinitions(lexer),
    directives: parseDirectives(lexer, false),
    selectionSet: parseSelectionSet(lexer),
    loc: loc(lexer, start)
  };
}
/**
 * OperationType : one of query mutation subscription
 */


function parseOperationType(lexer) {
  var operationToken = expect(lexer, _lexer.TokenKind.NAME);

  switch (operationToken.value) {
    case 'query':
      return 'query';

    case 'mutation':
      return 'mutation';

    case 'subscription':
      return 'subscription';
  }

  throw unexpected(lexer, operationToken);
}
/**
 * VariableDefinitions : ( VariableDefinition+ )
 */


function parseVariableDefinitions(lexer) {
  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, parseVariableDefinition, _lexer.TokenKind.PAREN_R) : [];
}
/**
 * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
 */


function parseVariableDefinition(lexer) {
  var start = lexer.token;

  if (lexer.options.experimentalVariableDefinitionDirectives) {
    return {
      kind: _kinds.Kind.VARIABLE_DEFINITION,
      variable: parseVariable(lexer),
      type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),
      defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,
      directives: parseDirectives(lexer, true),
      loc: loc(lexer, start)
    };
  }

  return {
    kind: _kinds.Kind.VARIABLE_DEFINITION,
    variable: parseVariable(lexer),
    type: (expect(lexer, _lexer.TokenKind.COLON), parseTypeReference(lexer)),
    defaultValue: skip(lexer, _lexer.TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : undefined,
    loc: loc(lexer, start)
  };
}
/**
 * Variable : $ Name
 */


function parseVariable(lexer) {
  var start = lexer.token;
  expect(lexer, _lexer.TokenKind.DOLLAR);
  return {
    kind: _kinds.Kind.VARIABLE,
    name: parseName(lexer),
    loc: loc(lexer, start)
  };
}
/**
 * SelectionSet : { Selection+ }
 */


function parseSelectionSet(lexer) {
  var start = lexer.token;
  return {
    kind: _kinds.Kind.SELECTION_SET,
    selections: many(lexer, _lexer.TokenKind.BRACE_L, parseSelection, _lexer.TokenKind.BRACE_R),
    loc: loc(lexer, start)
  };
}
/**
 * Selection :
 *   - Field
 *   - FragmentSpread
 *   - InlineFragment
 */


function parseSelection(lexer) {
  return peek(lexer, _lexer.TokenKind.SPREAD) ? parseFragment(lexer) : parseField(lexer);
}
/**
 * Field : Alias? Name Arguments? Directives? SelectionSet?
 *
 * Alias : Name :
 */


function parseField(lexer) {
  var start = lexer.token;
  var nameOrAlias = parseName(lexer);
  var alias;
  var name;

  if (skip(lexer, _lexer.TokenKind.COLON)) {
    alias = nameOrAlias;
    name = parseName(lexer);
  } else {
    name = nameOrAlias;
  }

  return {
    kind: _kinds.Kind.FIELD,
    alias: alias,
    name: name,
    arguments: parseArguments(lexer, false),
    directives: parseDirectives(lexer, false),
    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L) ? parseSelectionSet(lexer) : undefined,
    loc: loc(lexer, start)
  };
}
/**
 * Arguments[Const] : ( Argument[?Const]+ )
 */


function parseArguments(lexer, isConst) {
  var item = isConst ? parseConstArgument : parseArgument;
  return peek(lexer, _lexer.TokenKind.PAREN_L) ? many(lexer, _lexer.TokenKind.PAREN_L, item, _lexer.TokenKind.PAREN_R) : [];
}
/**
 * Argument[Const] : Name : Value[?Const]
 */


function parseArgument(lexer) {
  var start = lexer.token;
  return {
    kind: _kinds.Kind.ARGUMENT,
    name: parseName(lexer),
    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, false)),
    loc: loc(lexer, start)
  };
}

function parseConstArgument(lexer) {
  var start = lexer.token;
  return {
    kind: _kinds.Kind.ARGUMENT,
    name: parseName(lexer),
    value: (expect(lexer, _lexer.TokenKind.COLON), parseConstValue(lexer)),
    loc: loc(lexer, start)
  };
} // Implements the parsing rules in the Fragments section.

/**
 * Corresponds to both FragmentSpread and InlineFragment in the spec.
 *
 * FragmentSpread : ... FragmentName Directives?
 *
 * InlineFragment : ... TypeCondition? Directives? SelectionSet
 */


function parseFragment(lexer) {
  var start = lexer.token;
  expect(lexer, _lexer.TokenKind.SPREAD);

  if (peek(lexer, _lexer.TokenKind.NAME) && lexer.token.value !== 'on') {
    return {
      kind: _kinds.Kind.FRAGMENT_SPREAD,
      name: parseFragmentName(lexer),
      directives: parseDirectives(lexer, false),
      loc: loc(lexer, start)
    };
  }

  var typeCondition;

  if (lexer.token.value === 'on') {
    lexer.advance();
    typeCondition = parseNamedType(lexer);
  }

  return {
    kind: _kinds.Kind.INLINE_FRAGMENT,
    typeCondition: typeCondition,
    directives: parseDirectives(lexer, false),
    selectionSet: parseSelectionSet(lexer),
    loc: loc(lexer, start)
  };
}
/**
 * FragmentDefinition :
 *   - fragment FragmentName on TypeCondition Directives? SelectionSet
 *
 * TypeCondition : NamedType
 */


function parseFragmentDefinition(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'fragment'); // Experimental support for defining variables within fragments changes
  // the grammar of FragmentDefinition:
  //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

  if (lexer.options.experimentalFragmentVariables) {
    return {
      kind: _kinds.Kind.FRAGMENT_DEFINITION,
      name: parseFragmentName(lexer),
      variableDefinitions: parseVariableDefinitions(lexer),
      typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),
      directives: parseDirectives(lexer, false),
      selectionSet: parseSelectionSet(lexer),
      loc: loc(lexer, start)
    };
  }

  return {
    kind: _kinds.Kind.FRAGMENT_DEFINITION,
    name: parseFragmentName(lexer),
    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),
    directives: parseDirectives(lexer, false),
    selectionSet: parseSelectionSet(lexer),
    loc: loc(lexer, start)
  };
}
/**
 * FragmentName : Name but not `on`
 */


function parseFragmentName(lexer) {
  if (lexer.token.value === 'on') {
    throw unexpected(lexer);
  }

  return parseName(lexer);
} // Implements the parsing rules in the Values section.

/**
 * Value[Const] :
 *   - [~Const] Variable
 *   - IntValue
 *   - FloatValue
 *   - StringValue
 *   - BooleanValue
 *   - NullValue
 *   - EnumValue
 *   - ListValue[?Const]
 *   - ObjectValue[?Const]
 *
 * BooleanValue : one of `true` `false`
 *
 * NullValue : `null`
 *
 * EnumValue : Name but not `true`, `false` or `null`
 */


function parseValueLiteral(lexer, isConst) {
  var token = lexer.token;

  switch (token.kind) {
    case _lexer.TokenKind.BRACKET_L:
      return parseList(lexer, isConst);

    case _lexer.TokenKind.BRACE_L:
      return parseObject(lexer, isConst);

    case _lexer.TokenKind.INT:
      lexer.advance();
      return {
        kind: _kinds.Kind.INT,
        value: token.value,
        loc: loc(lexer, token)
      };

    case _lexer.TokenKind.FLOAT:
      lexer.advance();
      return {
        kind: _kinds.Kind.FLOAT,
        value: token.value,
        loc: loc(lexer, token)
      };

    case _lexer.TokenKind.STRING:
    case _lexer.TokenKind.BLOCK_STRING:
      return parseStringLiteral(lexer);

    case _lexer.TokenKind.NAME:
      if (token.value === 'true' || token.value === 'false') {
        lexer.advance();
        return {
          kind: _kinds.Kind.BOOLEAN,
          value: token.value === 'true',
          loc: loc(lexer, token)
        };
      } else if (token.value === 'null') {
        lexer.advance();
        return {
          kind: _kinds.Kind.NULL,
          loc: loc(lexer, token)
        };
      }

      lexer.advance();
      return {
        kind: _kinds.Kind.ENUM,
        value: token.value,
        loc: loc(lexer, token)
      };

    case _lexer.TokenKind.DOLLAR:
      if (!isConst) {
        return parseVariable(lexer);
      }

      break;
  }

  throw unexpected(lexer);
}

function parseStringLiteral(lexer) {
  var token = lexer.token;
  lexer.advance();
  return {
    kind: _kinds.Kind.STRING,
    value: token.value,
    block: token.kind === _lexer.TokenKind.BLOCK_STRING,
    loc: loc(lexer, token)
  };
}

function parseConstValue(lexer) {
  return parseValueLiteral(lexer, true);
}

function parseValueValue(lexer) {
  return parseValueLiteral(lexer, false);
}
/**
 * ListValue[Const] :
 *   - [ ]
 *   - [ Value[?Const]+ ]
 */


function parseList(lexer, isConst) {
  var start = lexer.token;
  var item = isConst ? parseConstValue : parseValueValue;
  return {
    kind: _kinds.Kind.LIST,
    values: any(lexer, _lexer.TokenKind.BRACKET_L, item, _lexer.TokenKind.BRACKET_R),
    loc: loc(lexer, start)
  };
}
/**
 * ObjectValue[Const] :
 *   - { }
 *   - { ObjectField[?Const]+ }
 */


function parseObject(lexer, isConst) {
  var start = lexer.token;
  expect(lexer, _lexer.TokenKind.BRACE_L);
  var fields = [];

  while (!skip(lexer, _lexer.TokenKind.BRACE_R)) {
    fields.push(parseObjectField(lexer, isConst));
  }

  return {
    kind: _kinds.Kind.OBJECT,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * ObjectField[Const] : Name : Value[?Const]
 */


function parseObjectField(lexer, isConst) {
  var start = lexer.token;
  return {
    kind: _kinds.Kind.OBJECT_FIELD,
    name: parseName(lexer),
    value: (expect(lexer, _lexer.TokenKind.COLON), parseValueLiteral(lexer, isConst)),
    loc: loc(lexer, start)
  };
} // Implements the parsing rules in the Directives section.

/**
 * Directives[Const] : Directive[?Const]+
 */


function parseDirectives(lexer, isConst) {
  var directives = [];

  while (peek(lexer, _lexer.TokenKind.AT)) {
    directives.push(parseDirective(lexer, isConst));
  }

  return directives;
}
/**
 * Directive[Const] : @ Name Arguments[?Const]?
 */


function parseDirective(lexer, isConst) {
  var start = lexer.token;
  expect(lexer, _lexer.TokenKind.AT);
  return {
    kind: _kinds.Kind.DIRECTIVE,
    name: parseName(lexer),
    arguments: parseArguments(lexer, isConst),
    loc: loc(lexer, start)
  };
} // Implements the parsing rules in the Types section.

/**
 * Type :
 *   - NamedType
 *   - ListType
 *   - NonNullType
 */


function parseTypeReference(lexer) {
  var start = lexer.token;
  var type;

  if (skip(lexer, _lexer.TokenKind.BRACKET_L)) {
    type = parseTypeReference(lexer);
    expect(lexer, _lexer.TokenKind.BRACKET_R);
    type = {
      kind: _kinds.Kind.LIST_TYPE,
      type: type,
      loc: loc(lexer, start)
    };
  } else {
    type = parseNamedType(lexer);
  }

  if (skip(lexer, _lexer.TokenKind.BANG)) {
    return {
      kind: _kinds.Kind.NON_NULL_TYPE,
      type: type,
      loc: loc(lexer, start)
    };
  }

  return type;
}
/**
 * NamedType : Name
 */


function parseNamedType(lexer) {
  var start = lexer.token;
  return {
    kind: _kinds.Kind.NAMED_TYPE,
    name: parseName(lexer),
    loc: loc(lexer, start)
  };
} // Implements the parsing rules in the Type Definition section.

/**
 * TypeSystemDefinition :
 *   - SchemaDefinition
 *   - TypeDefinition
 *   - DirectiveDefinition
 *
 * TypeDefinition :
 *   - ScalarTypeDefinition
 *   - ObjectTypeDefinition
 *   - InterfaceTypeDefinition
 *   - UnionTypeDefinition
 *   - EnumTypeDefinition
 *   - InputObjectTypeDefinition
 */


function parseTypeSystemDefinition(lexer) {
  // Many definitions begin with a description and require a lookahead.
  var keywordToken = peekDescription(lexer) ? lexer.lookahead() : lexer.token;

  if (keywordToken.kind === _lexer.TokenKind.NAME) {
    switch (keywordToken.value) {
      case 'schema':
        return parseSchemaDefinition(lexer);

      case 'scalar':
        return parseScalarTypeDefinition(lexer);

      case 'type':
        return parseObjectTypeDefinition(lexer);

      case 'interface':
        return parseInterfaceTypeDefinition(lexer);

      case 'union':
        return parseUnionTypeDefinition(lexer);

      case 'enum':
        return parseEnumTypeDefinition(lexer);

      case 'input':
        return parseInputObjectTypeDefinition(lexer);

      case 'directive':
        return parseDirectiveDefinition(lexer);
    }
  }

  throw unexpected(lexer, keywordToken);
}

function peekDescription(lexer) {
  return peek(lexer, _lexer.TokenKind.STRING) || peek(lexer, _lexer.TokenKind.BLOCK_STRING);
}
/**
 * Description : StringValue
 */


function parseDescription(lexer) {
  if (peekDescription(lexer)) {
    return parseStringLiteral(lexer);
  }
}
/**
 * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }
 */


function parseSchemaDefinition(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'schema');
  var directives = parseDirectives(lexer, true);
  var operationTypes = many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R);
  return {
    kind: _kinds.Kind.SCHEMA_DEFINITION,
    directives: directives,
    operationTypes: operationTypes,
    loc: loc(lexer, start)
  };
}
/**
 * OperationTypeDefinition : OperationType : NamedType
 */


function parseOperationTypeDefinition(lexer) {
  var start = lexer.token;
  var operation = parseOperationType(lexer);
  expect(lexer, _lexer.TokenKind.COLON);
  var type = parseNamedType(lexer);
  return {
    kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
    operation: operation,
    type: type,
    loc: loc(lexer, start)
  };
}
/**
 * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
 */


function parseScalarTypeDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'scalar');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  return {
    kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
    description: description,
    name: name,
    directives: directives,
    loc: loc(lexer, start)
  };
}
/**
 * ObjectTypeDefinition :
 *   Description?
 *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
 */


function parseObjectTypeDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'type');
  var name = parseName(lexer);
  var interfaces = parseImplementsInterfaces(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);
  return {
    kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
    description: description,
    name: name,
    interfaces: interfaces,
    directives: directives,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * ImplementsInterfaces :
 *   - implements `&`? NamedType
 *   - ImplementsInterfaces & NamedType
 */


function parseImplementsInterfaces(lexer) {
  var types = [];

  if (lexer.token.value === 'implements') {
    lexer.advance(); // Optional leading ampersand

    skip(lexer, _lexer.TokenKind.AMP);

    do {
      types.push(parseNamedType(lexer));
    } while (skip(lexer, _lexer.TokenKind.AMP) || // Legacy support for the SDL?
    lexer.options.allowLegacySDLImplementsInterfaces && peek(lexer, _lexer.TokenKind.NAME));
  }

  return types;
}
/**
 * FieldsDefinition : { FieldDefinition+ }
 */


function parseFieldsDefinition(lexer) {
  // Legacy support for the SDL?
  if (lexer.options.allowLegacySDLEmptyFields && peek(lexer, _lexer.TokenKind.BRACE_L) && lexer.lookahead().kind === _lexer.TokenKind.BRACE_R) {
    lexer.advance();
    lexer.advance();
    return [];
  }

  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseFieldDefinition, _lexer.TokenKind.BRACE_R) : [];
}
/**
 * FieldDefinition :
 *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
 */


function parseFieldDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  var name = parseName(lexer);
  var args = parseArgumentDefs(lexer);
  expect(lexer, _lexer.TokenKind.COLON);
  var type = parseTypeReference(lexer);
  var directives = parseDirectives(lexer, true);
  return {
    kind: _kinds.Kind.FIELD_DEFINITION,
    description: description,
    name: name,
    arguments: args,
    type: type,
    directives: directives,
    loc: loc(lexer, start)
  };
}
/**
 * ArgumentsDefinition : ( InputValueDefinition+ )
 */


function parseArgumentDefs(lexer) {
  if (!peek(lexer, _lexer.TokenKind.PAREN_L)) {
    return [];
  }

  return many(lexer, _lexer.TokenKind.PAREN_L, parseInputValueDef, _lexer.TokenKind.PAREN_R);
}
/**
 * InputValueDefinition :
 *   - Description? Name : Type DefaultValue? Directives[Const]?
 */


function parseInputValueDef(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  var name = parseName(lexer);
  expect(lexer, _lexer.TokenKind.COLON);
  var type = parseTypeReference(lexer);
  var defaultValue;

  if (skip(lexer, _lexer.TokenKind.EQUALS)) {
    defaultValue = parseConstValue(lexer);
  }

  var directives = parseDirectives(lexer, true);
  return {
    kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
    description: description,
    name: name,
    type: type,
    defaultValue: defaultValue,
    directives: directives,
    loc: loc(lexer, start)
  };
}
/**
 * InterfaceTypeDefinition :
 *   - Description? interface Name Directives[Const]? FieldsDefinition?
 */


function parseInterfaceTypeDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'interface');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);
  return {
    kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
    description: description,
    name: name,
    directives: directives,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * UnionTypeDefinition :
 *   - Description? union Name Directives[Const]? UnionMemberTypes?
 */


function parseUnionTypeDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'union');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var types = parseUnionMemberTypes(lexer);
  return {
    kind: _kinds.Kind.UNION_TYPE_DEFINITION,
    description: description,
    name: name,
    directives: directives,
    types: types,
    loc: loc(lexer, start)
  };
}
/**
 * UnionMemberTypes :
 *   - = `|`? NamedType
 *   - UnionMemberTypes | NamedType
 */


function parseUnionMemberTypes(lexer) {
  var types = [];

  if (skip(lexer, _lexer.TokenKind.EQUALS)) {
    // Optional leading pipe
    skip(lexer, _lexer.TokenKind.PIPE);

    do {
      types.push(parseNamedType(lexer));
    } while (skip(lexer, _lexer.TokenKind.PIPE));
  }

  return types;
}
/**
 * EnumTypeDefinition :
 *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
 */


function parseEnumTypeDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'enum');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var values = parseEnumValuesDefinition(lexer);
  return {
    kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
    description: description,
    name: name,
    directives: directives,
    values: values,
    loc: loc(lexer, start)
  };
}
/**
 * EnumValuesDefinition : { EnumValueDefinition+ }
 */


function parseEnumValuesDefinition(lexer) {
  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseEnumValueDefinition, _lexer.TokenKind.BRACE_R) : [];
}
/**
 * EnumValueDefinition : Description? EnumValue Directives[Const]?
 *
 * EnumValue : Name
 */


function parseEnumValueDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  return {
    kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
    description: description,
    name: name,
    directives: directives,
    loc: loc(lexer, start)
  };
}
/**
 * InputObjectTypeDefinition :
 *   - Description? input Name Directives[Const]? InputFieldsDefinition?
 */


function parseInputObjectTypeDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'input');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseInputFieldsDefinition(lexer);
  return {
    kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: description,
    name: name,
    directives: directives,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * InputFieldsDefinition : { InputValueDefinition+ }
 */


function parseInputFieldsDefinition(lexer) {
  return peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseInputValueDef, _lexer.TokenKind.BRACE_R) : [];
}
/**
 * TypeSystemExtension :
 *   - SchemaExtension
 *   - TypeExtension
 *
 * TypeExtension :
 *   - ScalarTypeExtension
 *   - ObjectTypeExtension
 *   - InterfaceTypeExtension
 *   - UnionTypeExtension
 *   - EnumTypeExtension
 *   - InputObjectTypeDefinition
 */


function parseTypeSystemExtension(lexer) {
  var keywordToken = lexer.lookahead();

  if (keywordToken.kind === _lexer.TokenKind.NAME) {
    switch (keywordToken.value) {
      case 'schema':
        return parseSchemaExtension(lexer);

      case 'scalar':
        return parseScalarTypeExtension(lexer);

      case 'type':
        return parseObjectTypeExtension(lexer);

      case 'interface':
        return parseInterfaceTypeExtension(lexer);

      case 'union':
        return parseUnionTypeExtension(lexer);

      case 'enum':
        return parseEnumTypeExtension(lexer);

      case 'input':
        return parseInputObjectTypeExtension(lexer);
    }
  }

  throw unexpected(lexer, keywordToken);
}
/**
 * SchemaExtension :
 *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
 *  - extend schema Directives[Const]
 */


function parseSchemaExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'schema');
  var directives = parseDirectives(lexer, true);
  var operationTypes = peek(lexer, _lexer.TokenKind.BRACE_L) ? many(lexer, _lexer.TokenKind.BRACE_L, parseOperationTypeDefinition, _lexer.TokenKind.BRACE_R) : [];

  if (directives.length === 0 && operationTypes.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.SCHEMA_EXTENSION,
    directives: directives,
    operationTypes: operationTypes,
    loc: loc(lexer, start)
  };
}
/**
 * ScalarTypeExtension :
 *   - extend scalar Name Directives[Const]
 */


function parseScalarTypeExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'scalar');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);

  if (directives.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
    name: name,
    directives: directives,
    loc: loc(lexer, start)
  };
}
/**
 * ObjectTypeExtension :
 *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
 *  - extend type Name ImplementsInterfaces? Directives[Const]
 *  - extend type Name ImplementsInterfaces
 */


function parseObjectTypeExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'type');
  var name = parseName(lexer);
  var interfaces = parseImplementsInterfaces(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);

  if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
    name: name,
    interfaces: interfaces,
    directives: directives,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * InterfaceTypeExtension :
 *   - extend interface Name Directives[Const]? FieldsDefinition
 *   - extend interface Name Directives[Const]
 */


function parseInterfaceTypeExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'interface');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseFieldsDefinition(lexer);

  if (directives.length === 0 && fields.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
    name: name,
    directives: directives,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * UnionTypeExtension :
 *   - extend union Name Directives[Const]? UnionMemberTypes
 *   - extend union Name Directives[Const]
 */


function parseUnionTypeExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'union');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var types = parseUnionMemberTypes(lexer);

  if (directives.length === 0 && types.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.UNION_TYPE_EXTENSION,
    name: name,
    directives: directives,
    types: types,
    loc: loc(lexer, start)
  };
}
/**
 * EnumTypeExtension :
 *   - extend enum Name Directives[Const]? EnumValuesDefinition
 *   - extend enum Name Directives[Const]
 */


function parseEnumTypeExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'enum');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var values = parseEnumValuesDefinition(lexer);

  if (directives.length === 0 && values.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
    name: name,
    directives: directives,
    values: values,
    loc: loc(lexer, start)
  };
}
/**
 * InputObjectTypeExtension :
 *   - extend input Name Directives[Const]? InputFieldsDefinition
 *   - extend input Name Directives[Const]
 */


function parseInputObjectTypeExtension(lexer) {
  var start = lexer.token;
  expectKeyword(lexer, 'extend');
  expectKeyword(lexer, 'input');
  var name = parseName(lexer);
  var directives = parseDirectives(lexer, true);
  var fields = parseInputFieldsDefinition(lexer);

  if (directives.length === 0 && fields.length === 0) {
    throw unexpected(lexer);
  }

  return {
    kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
    name: name,
    directives: directives,
    fields: fields,
    loc: loc(lexer, start)
  };
}
/**
 * DirectiveDefinition :
 *   - Description? directive @ Name ArgumentsDefinition? on DirectiveLocations
 */


function parseDirectiveDefinition(lexer) {
  var start = lexer.token;
  var description = parseDescription(lexer);
  expectKeyword(lexer, 'directive');
  expect(lexer, _lexer.TokenKind.AT);
  var name = parseName(lexer);
  var args = parseArgumentDefs(lexer);
  expectKeyword(lexer, 'on');
  var locations = parseDirectiveLocations(lexer);
  return {
    kind: _kinds.Kind.DIRECTIVE_DEFINITION,
    description: description,
    name: name,
    arguments: args,
    locations: locations,
    loc: loc(lexer, start)
  };
}
/**
 * DirectiveLocations :
 *   - `|`? DirectiveLocation
 *   - DirectiveLocations | DirectiveLocation
 */


function parseDirectiveLocations(lexer) {
  // Optional leading pipe
  skip(lexer, _lexer.TokenKind.PIPE);
  var locations = [];

  do {
    locations.push(parseDirectiveLocation(lexer));
  } while (skip(lexer, _lexer.TokenKind.PIPE));

  return locations;
}
/*
 * DirectiveLocation :
 *   - ExecutableDirectiveLocation
 *   - TypeSystemDirectiveLocation
 *
 * ExecutableDirectiveLocation : one of
 *   `QUERY`
 *   `MUTATION`
 *   `SUBSCRIPTION`
 *   `FIELD`
 *   `FRAGMENT_DEFINITION`
 *   `FRAGMENT_SPREAD`
 *   `INLINE_FRAGMENT`
 *
 * TypeSystemDirectiveLocation : one of
 *   `SCHEMA`
 *   `SCALAR`
 *   `OBJECT`
 *   `FIELD_DEFINITION`
 *   `ARGUMENT_DEFINITION`
 *   `INTERFACE`
 *   `UNION`
 *   `ENUM`
 *   `ENUM_VALUE`
 *   `INPUT_OBJECT`
 *   `INPUT_FIELD_DEFINITION`
 */


function parseDirectiveLocation(lexer) {
  var start = lexer.token;
  var name = parseName(lexer);

  if (_directiveLocation.DirectiveLocation.hasOwnProperty(name.value)) {
    return name;
  }

  throw unexpected(lexer, start);
} // Core parsing utility functions

/**
 * Returns a location object, used to identify the place in
 * the source that created a given parsed object.
 */


function loc(lexer, startToken) {
  if (!lexer.options.noLocation) {
    return new Loc(startToken, lexer.lastToken, lexer.source);
  }
}

function Loc(startToken, endToken, source) {
  this.start = startToken.start;
  this.end = endToken.end;
  this.startToken = startToken;
  this.endToken = endToken;
  this.source = source;
} // Print a simplified form when appearing in JSON/util.inspect.


Loc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {
  return {
    start: this.start,
    end: this.end
  };
};
/**
 * Determines if the next token is of a given kind
 */


function peek(lexer, kind) {
  return lexer.token.kind === kind;
}
/**
 * If the next token is of the given kind, return true after advancing
 * the lexer. Otherwise, do not change the parser state and return false.
 */


function skip(lexer, kind) {
  var match = lexer.token.kind === kind;

  if (match) {
    lexer.advance();
  }

  return match;
}
/**
 * If the next token is of the given kind, return that token after advancing
 * the lexer. Otherwise, do not change the parser state and throw an error.
 */


function expect(lexer, kind) {
  var token = lexer.token;

  if (token.kind === kind) {
    lexer.advance();
    return token;
  }

  throw (0, _error.syntaxError)(lexer.source, token.start, "Expected ".concat(kind, ", found ").concat((0, _lexer.getTokenDesc)(token)));
}
/**
 * If the next token is a keyword with the given value, return that token after
 * advancing the lexer. Otherwise, do not change the parser state and return
 * false.
 */


function expectKeyword(lexer, value) {
  var token = lexer.token;

  if (token.kind === _lexer.TokenKind.NAME && token.value === value) {
    lexer.advance();
    return token;
  }

  throw (0, _error.syntaxError)(lexer.source, token.start, "Expected \"".concat(value, "\", found ").concat((0, _lexer.getTokenDesc)(token)));
}
/**
 * Helper function for creating an error when an unexpected lexed token
 * is encountered.
 */


function unexpected(lexer, atToken) {
  var token = atToken || lexer.token;
  return (0, _error.syntaxError)(lexer.source, token.start, "Unexpected ".concat((0, _lexer.getTokenDesc)(token)));
}
/**
 * Returns a possibly empty list of parse nodes, determined by
 * the parseFn. This list begins with a lex token of openKind
 * and ends with a lex token of closeKind. Advances the parser
 * to the next lex token after the closing token.
 */


function any(lexer, openKind, parseFn, closeKind) {
  expect(lexer, openKind);
  var nodes = [];

  while (!skip(lexer, closeKind)) {
    nodes.push(parseFn(lexer));
  }

  return nodes;
}
/**
 * Returns a non-empty list of parse nodes, determined by
 * the parseFn. This list begins with a lex token of openKind
 * and ends with a lex token of closeKind. Advances the parser
 * to the next lex token after the closing token.
 */


function many(lexer, openKind, parseFn, closeKind) {
  expect(lexer, openKind);
  var nodes = [parseFn(lexer)];

  while (!skip(lexer, closeKind)) {
    nodes.push(parseFn(lexer));
  }

  return nodes;
}
},{"../jsutils/inspect":"Choh","./source":"kA/6","../error":"OZfr","./lexer":"JJWu","./kinds":"XgLo","./directiveLocation":"FpMx"}],"MbWf":[function(require,module,exports) {
var parser = require('graphql/language/parser');

var parse = parser.parse;

// Strip insignificant whitespace
// Note that this could do a lot more, such as reorder fields etc.
function normalize(string) {
  return string.replace(/[\s,]+/g, ' ').trim();
}

// A map docString -> graphql document
var docCache = {};

// A map fragmentName -> [normalized source]
var fragmentSourceMap = {};

function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}

// For testing.
function resetCaches() {
  docCache = {};
  fragmentSourceMap = {};
}

// Take a unstripped parsed document (query/mutation or even fragment), and
// check all fragment definitions, checking for name->source uniqueness.
// We also want to make sure only unique fragments exist in the document.
var printFragmentWarnings = true;
function processFragments(ast) {
  var astFragmentMap = {};
  var definitions = [];

  for (var i = 0; i < ast.definitions.length; i++) {
    var fragmentDefinition = ast.definitions[i];

    if (fragmentDefinition.kind === 'FragmentDefinition') {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);

      // We know something about this fragment
      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {

        // this is a problem because the app developer is trying to register another fragment with
        // the same name as one previously registered. So, we tell them about it.
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\n"
            + "graphql-tag enforces all fragment names across your application to be unique; read more about\n"
            + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }

        fragmentSourceMap[fragmentName][sourceKey] = true;

      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
        fragmentSourceMap[fragmentName] = {};
        fragmentSourceMap[fragmentName][sourceKey] = true;
      }

      if (!astFragmentMap[sourceKey]) {
        astFragmentMap[sourceKey] = true;
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  }

  ast.definitions = definitions;
  return ast;
}

function disableFragmentWarnings() {
  printFragmentWarnings = false;
}

function stripLoc(doc, removeLocAtThisLevel) {
  var docType = Object.prototype.toString.call(doc);

  if (docType === '[object Array]') {
    return doc.map(function (d) {
      return stripLoc(d, removeLocAtThisLevel);
    });
  }

  if (docType !== '[object Object]') {
    throw new Error('Unexpected input.');
  }

  // We don't want to remove the root loc field so we can use it
  // for fragment substitution (see below)
  if (removeLocAtThisLevel && doc.loc) {
    delete doc.loc;
  }

  // https://github.com/apollographql/graphql-tag/issues/40
  if (doc.loc) {
    delete doc.loc.startToken;
    delete doc.loc.endToken;
  }

  var keys = Object.keys(doc);
  var key;
  var value;
  var valueType;

  for (key in keys) {
    if (keys.hasOwnProperty(key)) {
      value = doc[keys[key]];
      valueType = Object.prototype.toString.call(value);

      if (valueType === '[object Object]' || valueType === '[object Array]') {
        doc[keys[key]] = stripLoc(value, true);
      }
    }
  }

  return doc;
}

var experimentalFragmentVariables = false;
function parseDocument(doc) {
  var cacheKey = normalize(doc);

  if (docCache[cacheKey]) {
    return docCache[cacheKey];
  }

  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });
  if (!parsed || parsed.kind !== 'Document') {
    throw new Error('Not a valid GraphQL document.');
  }

  // check that all "new" fragments inside the documents are consistent with
  // existing fragments of the same name
  parsed = processFragments(parsed);
  parsed = stripLoc(parsed, false);
  docCache[cacheKey] = parsed;

  return parsed;
}

function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}

function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}

// XXX This should eventually disallow arbitrary string interpolation, like Relay does
function gql(/* arguments */) {
  var args = Array.prototype.slice.call(arguments);

  var literals = args[0];

  // We always get literals[0] and then matching post literals for each arg given
  var result = (typeof(literals) === "string") ? literals : literals[0];

  for (var i = 1; i < args.length; i++) {
    if (args[i] && args[i].kind && args[i].kind === 'Document') {
      result += args[i].loc.source.body;
    } else {
      result += args[i];
    }

    result += literals[i];
  }

  return parseDocument(result);
}

// Support typescript, which isn't as nice as Babel about default exports
gql.default = gql;
gql.resetCaches = resetCaches;
gql.disableFragmentWarnings = disableFragmentWarnings;
gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;

module.exports = gql;

},{"graphql/language/parser":"n355"}],"8A9v":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  UNAUTHENTICATED: 'UNAUTHENTICATED',
  INSUFFICIENT_INFORMATION: 'INSUFFICIENT_INFORMATION'
};
exports.default = _default;
},{}],"f46C":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'InputWithIcon',
  props: {
    iconClass: {
      type: String,
      required: true
    }
  }
};
exports.default = _default;
        var $ee1720 = exports.default || module.exports;
      
      if (typeof $ee1720 === 'function') {
        $ee1720 = $ee1720.options;
      }
    
        /* template */
        Object.assign($ee1720, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"input-with-icon"},[_c('div',{staticClass:"icon-container"},[_c('i',{staticClass:"fas",class:_vm.iconClass})]),_vm._v(" "),_vm._t("default")],2)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"9Y+B":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'ExtendedFab',
  props: {
    iconClass: {
      type: String,
      required: true
    },
    buttonText: {
      type: String,
      required: true
    },
    onClick: {
      type: Function,
      required: true
    },
    outlineDisplay: {
      type: Boolean,
      required: false,
      default: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    }
  }
};
exports.default = _default;
        var $cbabc5 = exports.default || module.exports;
      
      if (typeof $cbabc5 === 'function') {
        $cbabc5 = $cbabc5.options;
      }
    
        /* template */
        Object.assign($cbabc5, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"extended-fab",class:{ outlined: _vm.outlineDisplay, inactive: _vm.disabled },attrs:{"disabled":_vm.disabled},on:{"click":_vm.onClick}},[_c('div',{staticClass:"fab-icon-container"},[_c('i',{staticClass:"fas",class:_vm.iconClass})]),_vm._v(" "),_c('span',{staticClass:"efab-text"},[_vm._v("\n    "+_vm._s(_vm.buttonText)+"\n  ")])])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"Y8u2":[function(require,module,exports) {
var define;
var global = arguments[3];
/*!
* sweetalert2 v7.29.2
* Released under the MIT License.
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Sweetalert2 = factory();
})(this, function () {
  'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var consolePrefix = 'SweetAlert2:';
  /**
   * Filter the unique values into a new array
   * @param arr
   */

  var uniqueArray = function uniqueArray(arr) {
    var result = [];

    for (var i = 0; i < arr.length; i++) {
      if (result.indexOf(arr[i]) === -1) {
        result.push(arr[i]);
      }
    }

    return result;
  };
  /**
   * Convert NodeList to Array
   * @param nodeList
   */


  var toArray = function toArray(nodeList) {
    return Array.prototype.slice.call(nodeList);
  };
  /**
   * Converts `inputOptions` into an array of `[value, label]`s
   * @param inputOptions
   */


  var formatInputOptions = function formatInputOptions(inputOptions) {
    var result = [];

    if (typeof Map !== 'undefined' && inputOptions instanceof Map) {
      inputOptions.forEach(function (value, key) {
        result.push([key, value]);
      });
    } else {
      Object.keys(inputOptions).forEach(function (key) {
        result.push([key, inputOptions[key]]);
      });
    }

    return result;
  };
  /**
   * Standardise console warnings
   * @param message
   */


  var warn = function warn(message) {
    console.warn("".concat(consolePrefix, " ").concat(message));
  };
  /**
   * Standardise console errors
   * @param message
   */


  var error = function error(message) {
    console.error("".concat(consolePrefix, " ").concat(message));
  };
  /**
   * Private global state for `warnOnce`
   * @type {Array}
   * @private
   */


  var previousWarnOnceMessages = [];
  /**
   * Show a console warning, but only if it hasn't already been shown
   * @param message
   */

  var warnOnce = function warnOnce(message) {
    if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
      previousWarnOnceMessages.push(message);
      warn(message);
    }
  };
  /**
   * If `arg` is a function, call it (with no arguments or context) and return the result.
   * Otherwise, just pass the value through
   * @param arg
   */


  var callIfFunction = function callIfFunction(arg) {
    return typeof arg === 'function' ? arg() : arg;
  };

  var isThenable = function isThenable(arg) {
    return arg && _typeof(arg) === 'object' && typeof arg.then === 'function';
  };

  var DismissReason = Object.freeze({
    cancel: 'cancel',
    backdrop: 'overlay',
    close: 'close',
    esc: 'esc',
    timer: 'timer'
  });

  var argsToParams = function argsToParams(args) {
    var params = {};

    switch (_typeof(args[0])) {
      case 'object':
        _extends(params, args[0]);

        break;

      default:
        ['title', 'html', 'type'].forEach(function (name, index) {
          switch (_typeof(args[index])) {
            case 'string':
              params[name] = args[index];
              break;

            case 'undefined':
              break;

            default:
              error("Unexpected type of ".concat(name, "! Expected \"string\", got ").concat(_typeof(args[index])));
          }
        });
    }

    return params;
  };
  /**
   * Adapt a legacy inputValidator for use with expectRejections=false
   */


  var adaptInputValidator = function adaptInputValidator(legacyValidator) {
    return function adaptedInputValidator(inputValue, extraParams) {
      return legacyValidator.call(this, inputValue, extraParams).then(function () {
        return undefined;
      }, function (validationMessage) {
        return validationMessage;
      });
    };
  };

  var swalPrefix = 'swal2-';

  var prefix = function prefix(items) {
    var result = {};

    for (var i in items) {
      result[items[i]] = swalPrefix + items[i];
    }

    return result;
  };

  var swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'toast', 'toast-shown', 'toast-column', 'fade', 'show', 'hide', 'noanimation', 'close', 'title', 'header', 'content', 'actions', 'confirm', 'cancel', 'footer', 'icon', 'icon-text', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'validation-message', 'progresssteps', 'activeprogressstep', 'progresscircle', 'progressline', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl']);
  var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);
  var states = {
    previousBodyPadding: null
  };

  var hasClass = function hasClass(elem, className) {
    return elem.classList.contains(className);
  };

  var focusInput = function focusInput(input) {
    input.focus(); // place cursor at end of text in text input

    if (input.type !== 'file') {
      // http://stackoverflow.com/a/2345915
      var val = input.value;
      input.value = '';
      input.value = val;
    }
  };

  var addOrRemoveClass = function addOrRemoveClass(target, classList, add) {
    if (!target || !classList) {
      return;
    }

    if (typeof classList === 'string') {
      classList = classList.split(/\s+/).filter(Boolean);
    }

    classList.forEach(function (className) {
      if (target.forEach) {
        target.forEach(function (elem) {
          add ? elem.classList.add(className) : elem.classList.remove(className);
        });
      } else {
        add ? target.classList.add(className) : target.classList.remove(className);
      }
    });
  };

  var addClass = function addClass(target, classList) {
    addOrRemoveClass(target, classList, true);
  };

  var removeClass = function removeClass(target, classList) {
    addOrRemoveClass(target, classList, false);
  };

  var getChildByClass = function getChildByClass(elem, className) {
    for (var i = 0; i < elem.childNodes.length; i++) {
      if (hasClass(elem.childNodes[i], className)) {
        return elem.childNodes[i];
      }
    }
  };

  var show = function show(elem) {
    elem.style.opacity = '';
    elem.style.display = elem.id === swalClasses.content ? 'block' : 'flex';
  };

  var hide = function hide(elem) {
    elem.style.opacity = '';
    elem.style.display = 'none';
  }; // borrowed from jquery $(elem).is(':visible') implementation


  var isVisible = function isVisible(elem) {
    return elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  var getContainer = function getContainer() {
    return document.body.querySelector('.' + swalClasses.container);
  };

  var elementByClass = function elementByClass(className) {
    var container = getContainer();
    return container ? container.querySelector('.' + className) : null;
  };

  var getPopup = function getPopup() {
    return elementByClass(swalClasses.popup);
  };

  var getIcons = function getIcons() {
    var popup = getPopup();
    return toArray(popup.querySelectorAll('.' + swalClasses.icon));
  };

  var getTitle = function getTitle() {
    return elementByClass(swalClasses.title);
  };

  var getContent = function getContent() {
    return elementByClass(swalClasses.content);
  };

  var getImage = function getImage() {
    return elementByClass(swalClasses.image);
  };

  var getProgressSteps = function getProgressSteps() {
    return elementByClass(swalClasses.progresssteps);
  };

  var getValidationMessage = function getValidationMessage() {
    return elementByClass(swalClasses['validation-message']);
  };

  var getConfirmButton = function getConfirmButton() {
    return elementByClass(swalClasses.confirm);
  };

  var getCancelButton = function getCancelButton() {
    return elementByClass(swalClasses.cancel);
  };
  /* @deprecated */

  /* istanbul ignore next */


  var getButtonsWrapper = function getButtonsWrapper() {
    warnOnce("swal.getButtonsWrapper() is deprecated and will be removed in the next major release, use swal.getActions() instead");
    return elementByClass(swalClasses.actions);
  };

  var getActions = function getActions() {
    return elementByClass(swalClasses.actions);
  };

  var getFooter = function getFooter() {
    return elementByClass(swalClasses.footer);
  };

  var getCloseButton = function getCloseButton() {
    return elementByClass(swalClasses.close);
  };

  var getFocusableElements = function getFocusableElements() {
    var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')) // sort according to tabindex
    .sort(function (a, b) {
      a = parseInt(a.getAttribute('tabindex'));
      b = parseInt(b.getAttribute('tabindex'));

      if (a > b) {
        return 1;
      } else if (a < b) {
        return -1;
      }

      return 0;
    }); // https://github.com/jkup/focusable/blob/master/index.js

    var otherFocusableElements = toArray(getPopup().querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex="0"], [contenteditable], audio[controls], video[controls]')).filter(function (el) {
      return el.getAttribute('tabindex') !== '-1';
    });
    return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {
      return isVisible(el);
    });
  };

  var isModal = function isModal() {
    return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);
  };

  var isToast = function isToast() {
    return document.body.classList.contains(swalClasses['toast-shown']);
  };

  var isLoading = function isLoading() {
    return getPopup().hasAttribute('data-loading');
  }; // Detect Node env


  var isNodeEnv = function isNodeEnv() {
    return typeof window === 'undefined' || typeof document === 'undefined';
  };

  var sweetHTML = "\n <div aria-labelledby=\"".concat(swalClasses.title, "\" aria-describedby=\"").concat(swalClasses.content, "\" class=\"").concat(swalClasses.popup, "\" tabindex=\"-1\">\n   <div class=\"").concat(swalClasses.header, "\">\n     <ul class=\"").concat(swalClasses.progresssteps, "\"></ul>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.error, "\">\n       <span class=\"swal2-x-mark\"><span class=\"swal2-x-mark-line-left\"></span><span class=\"swal2-x-mark-line-right\"></span></span>\n     </div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.question, "\">\n       <span class=\"").concat(swalClasses['icon-text'], "\">?</span>\n      </div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.warning, "\">\n       <span class=\"").concat(swalClasses['icon-text'], "\">!</span>\n      </div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.info, "\">\n       <span class=\"").concat(swalClasses['icon-text'], "\">i</span>\n      </div>\n     <div class=\"").concat(swalClasses.icon, " ").concat(iconTypes.success, "\">\n       <div class=\"swal2-success-circular-line-left\"></div>\n       <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n       <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n       <div class=\"swal2-success-circular-line-right\"></div>\n     </div>\n     <img class=\"").concat(swalClasses.image, "\" />\n     <h2 class=\"").concat(swalClasses.title, "\" id=\"").concat(swalClasses.title, "\"></h2>\n     <button type=\"button\" class=\"").concat(swalClasses.close, "\">\xD7</button>\n   </div>\n   <div class=\"").concat(swalClasses.content, "\">\n     <div id=\"").concat(swalClasses.content, "\"></div>\n     <input class=\"").concat(swalClasses.input, "\" />\n     <input type=\"file\" class=\"").concat(swalClasses.file, "\" />\n     <div class=\"").concat(swalClasses.range, "\">\n       <input type=\"range\" />\n       <output></output>\n     </div>\n     <select class=\"").concat(swalClasses.select, "\"></select>\n     <div class=\"").concat(swalClasses.radio, "\"></div>\n     <label for=\"").concat(swalClasses.checkbox, "\" class=\"").concat(swalClasses.checkbox, "\">\n       <input type=\"checkbox\" />\n       <span class=\"").concat(swalClasses.label, "\"></span>\n     </label>\n     <textarea class=\"").concat(swalClasses.textarea, "\"></textarea>\n     <div class=\"").concat(swalClasses['validation-message'], "\" id=\"").concat(swalClasses['validation-message'], "\"></div>\n   </div>\n   <div class=\"").concat(swalClasses.actions, "\">\n     <button type=\"button\" class=\"").concat(swalClasses.confirm, "\">OK</button>\n     <button type=\"button\" class=\"").concat(swalClasses.cancel, "\">Cancel</button>\n   </div>\n   <div class=\"").concat(swalClasses.footer, "\">\n   </div>\n </div>\n").replace(/(^|\n)\s*/g, '');
  /*
   * Add modal + backdrop to DOM
   */

  var init = function init(params) {
    // Clean up the old popup if it exists
    var c = getContainer();

    if (c) {
      c.parentNode.removeChild(c);
      removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);
    }
    /* istanbul ignore if */


    if (isNodeEnv()) {
      error('SweetAlert2 requires document to initialize');
      return;
    }

    var container = document.createElement('div');
    container.className = swalClasses.container;
    container.innerHTML = sweetHTML;
    var targetElement = typeof params.target === 'string' ? document.querySelector(params.target) : params.target;
    targetElement.appendChild(container);
    var popup = getPopup();
    var content = getContent();
    var input = getChildByClass(content, swalClasses.input);
    var file = getChildByClass(content, swalClasses.file);
    var range = content.querySelector(".".concat(swalClasses.range, " input"));
    var rangeOutput = content.querySelector(".".concat(swalClasses.range, " output"));
    var select = getChildByClass(content, swalClasses.select);
    var checkbox = content.querySelector(".".concat(swalClasses.checkbox, " input"));
    var textarea = getChildByClass(content, swalClasses.textarea); // a11y

    popup.setAttribute('role', params.toast ? 'alert' : 'dialog');
    popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');

    if (!params.toast) {
      popup.setAttribute('aria-modal', 'true');
    } // RTL


    if (window.getComputedStyle(targetElement).direction === 'rtl') {
      addClass(getContainer(), swalClasses.rtl);
    }

    var oldInputVal; // IE11 workaround, see #1109 for details

    var resetValidationMessage = function resetValidationMessage(e) {
      if (Swal.isVisible() && oldInputVal !== e.target.value) {
        Swal.resetValidationMessage();
      }

      oldInputVal = e.target.value;
    };

    input.oninput = resetValidationMessage;
    file.onchange = resetValidationMessage;
    select.onchange = resetValidationMessage;
    checkbox.onchange = resetValidationMessage;
    textarea.oninput = resetValidationMessage;

    range.oninput = function (e) {
      resetValidationMessage(e);
      rangeOutput.value = range.value;
    };

    range.onchange = function (e) {
      resetValidationMessage(e);
      range.nextSibling.value = range.value;
    };

    return popup;
  };

  var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
    if (!param) {
      return hide(target);
    }

    if (_typeof(param) === 'object') {
      target.innerHTML = '';

      if (0 in param) {
        for (var i = 0; i in param; i++) {
          target.appendChild(param[i].cloneNode(true));
        }
      } else {
        target.appendChild(param.cloneNode(true));
      }
    } else if (param) {
      target.innerHTML = param;
    }

    show(target);
  };

  var animationEndEvent = function () {
    // Prevent run in Node env

    /* istanbul ignore if */
    if (isNodeEnv()) {
      return false;
    }

    var testEl = document.createElement('div');
    var transEndEventNames = {
      'WebkitAnimation': 'webkitAnimationEnd',
      'OAnimation': 'oAnimationEnd oanimationend',
      'animation': 'animationend'
    };

    for (var i in transEndEventNames) {
      if (transEndEventNames.hasOwnProperty(i) && typeof testEl.style[i] !== 'undefined') {
        return transEndEventNames[i];
      }
    }

    return false;
  }(); // Measure width of scrollbar
  // https://github.com/twbs/bootstrap/blob/master/js/modal.js#L279-L286


  var measureScrollbar = function measureScrollbar() {
    var supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;

    if (supportsTouch) {
      return 0;
    }

    var scrollDiv = document.createElement('div');
    scrollDiv.style.width = '50px';
    scrollDiv.style.height = '50px';
    scrollDiv.style.overflow = 'scroll';
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
  };

  var renderActions = function renderActions(params) {
    var actions = getActions();
    var confirmButton = getConfirmButton();
    var cancelButton = getCancelButton(); // Actions (buttons) wrapper

    if (!params.showConfirmButton && !params.showCancelButton) {
      hide(actions);
    } else {
      show(actions);
    } // Cancel button


    if (params.showCancelButton) {
      cancelButton.style.display = 'inline-block';
    } else {
      hide(cancelButton);
    } // Confirm button


    if (params.showConfirmButton) {
      confirmButton.style.removeProperty('display');
    } else {
      hide(confirmButton);
    } // Edit text on confirm and cancel buttons


    confirmButton.innerHTML = params.confirmButtonText;
    cancelButton.innerHTML = params.cancelButtonText; // ARIA labels for confirm and cancel buttons

    confirmButton.setAttribute('aria-label', params.confirmButtonAriaLabel);
    cancelButton.setAttribute('aria-label', params.cancelButtonAriaLabel); // Add buttons custom classes

    confirmButton.className = swalClasses.confirm;
    addClass(confirmButton, params.confirmButtonClass);
    cancelButton.className = swalClasses.cancel;
    addClass(cancelButton, params.cancelButtonClass); // Buttons styling

    if (params.buttonsStyling) {
      addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors

      if (params.confirmButtonColor) {
        confirmButton.style.backgroundColor = params.confirmButtonColor;
      }

      if (params.cancelButtonColor) {
        cancelButton.style.backgroundColor = params.cancelButtonColor;
      } // Loading state


      var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue('background-color');
      confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;
      confirmButton.style.borderRightColor = confirmButtonBackgroundColor;
    } else {
      removeClass([confirmButton, cancelButton], swalClasses.styled);
      confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';
      cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';
    }
  };

  var renderContent = function renderContent(params) {
    var content = getContent().querySelector('#' + swalClasses.content); // Content as HTML

    if (params.html) {
      parseHtmlToContainer(params.html, content); // Content as plain text
    } else if (params.text) {
      content.textContent = params.text;
      show(content);
    } else {
      hide(content);
    }
  };

  var renderIcon = function renderIcon(params) {
    var icons = getIcons();

    for (var i = 0; i < icons.length; i++) {
      hide(icons[i]);
    }

    if (params.type) {
      if (Object.keys(iconTypes).indexOf(params.type) !== -1) {
        var icon = Swal.getPopup().querySelector(".".concat(swalClasses.icon, ".").concat(iconTypes[params.type]));
        show(icon); // Animate icon

        if (params.animation) {
          addClass(icon, "swal2-animate-".concat(params.type, "-icon"));
        }
      } else {
        error("Unknown type! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"".concat(params.type, "\""));
      }
    }
  };

  var renderImage = function renderImage(params) {
    var image = getImage();

    if (params.imageUrl) {
      image.setAttribute('src', params.imageUrl);
      image.setAttribute('alt', params.imageAlt);
      show(image);

      if (params.imageWidth) {
        image.setAttribute('width', params.imageWidth);
      } else {
        image.removeAttribute('width');
      }

      if (params.imageHeight) {
        image.setAttribute('height', params.imageHeight);
      } else {
        image.removeAttribute('height');
      }

      image.className = swalClasses.image;

      if (params.imageClass) {
        addClass(image, params.imageClass);
      }
    } else {
      hide(image);
    }
  };

  var renderProgressSteps = function renderProgressSteps(params) {
    var progressStepsContainer = getProgressSteps();
    var currentProgressStep = parseInt(params.currentProgressStep === null ? Swal.getQueueStep() : params.currentProgressStep, 10);

    if (params.progressSteps && params.progressSteps.length) {
      show(progressStepsContainer);
      progressStepsContainer.innerHTML = '';

      if (currentProgressStep >= params.progressSteps.length) {
        warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');
      }

      params.progressSteps.forEach(function (step, index) {
        var circle = document.createElement('li');
        addClass(circle, swalClasses.progresscircle);
        circle.innerHTML = step;

        if (index === currentProgressStep) {
          addClass(circle, swalClasses.activeprogressstep);
        }

        progressStepsContainer.appendChild(circle);

        if (index !== params.progressSteps.length - 1) {
          var line = document.createElement('li');
          addClass(line, swalClasses.progressline);

          if (params.progressStepsDistance) {
            line.style.width = params.progressStepsDistance;
          }

          progressStepsContainer.appendChild(line);
        }
      });
    } else {
      hide(progressStepsContainer);
    }
  };

  var renderTitle = function renderTitle(params) {
    var title = getTitle();

    if (params.titleText) {
      title.innerText = params.titleText;
    } else if (params.title) {
      if (typeof params.title === 'string') {
        params.title = params.title.split('\n').join('<br />');
      }

      parseHtmlToContainer(params.title, title);
    }
  };

  var fixScrollbar = function fixScrollbar() {
    // for queues, do not do this more than once
    if (states.previousBodyPadding !== null) {
      return;
    } // if the body has overflow


    if (document.body.scrollHeight > window.innerHeight) {
      // add padding so the content doesn't shift after removal of scrollbar
      states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));
      document.body.style.paddingRight = states.previousBodyPadding + measureScrollbar() + 'px';
    }
  };

  var undoScrollbar = function undoScrollbar() {
    if (states.previousBodyPadding !== null) {
      document.body.style.paddingRight = states.previousBodyPadding;
      states.previousBodyPadding = null;
    }
  };
  /* istanbul ignore next */


  var iOSfix = function iOSfix() {
    var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

    if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
      var offset = document.body.scrollTop;
      document.body.style.top = offset * -1 + 'px';
      addClass(document.body, swalClasses.iosfix);
    }
  };
  /* istanbul ignore next */


  var undoIOSfix = function undoIOSfix() {
    if (hasClass(document.body, swalClasses.iosfix)) {
      var offset = parseInt(document.body.style.top, 10);
      removeClass(document.body, swalClasses.iosfix);
      document.body.style.top = '';
      document.body.scrollTop = offset * -1;
    }
  };

  var isIE11 = function isIE11() {
    return !!window.MSInputMethodContext && !!document.documentMode;
  }; // Fix IE11 centering sweetalert2/issues/933

  /* istanbul ignore next */


  var fixVerticalPositionIE = function fixVerticalPositionIE() {
    var container = getContainer();
    var popup = getPopup();
    container.style.removeProperty('align-items');

    if (popup.offsetTop < 0) {
      container.style.alignItems = 'flex-start';
    }
  };
  /* istanbul ignore next */


  var IEfix = function IEfix() {
    if (typeof window !== 'undefined' && isIE11()) {
      fixVerticalPositionIE();
      window.addEventListener('resize', fixVerticalPositionIE);
    }
  };
  /* istanbul ignore next */


  var undoIEfix = function undoIEfix() {
    if (typeof window !== 'undefined' && isIE11()) {
      window.removeEventListener('resize', fixVerticalPositionIE);
    }
  }; // Adding aria-hidden="true" to elements outside of the active modal dialog ensures that
  // elements not within the active modal dialog will not be surfaced if a user opens a screen
  // readers list of elements (headings, form controls, landmarks, etc.) in the document.


  var setAriaHidden = function setAriaHidden() {
    var bodyChildren = toArray(document.body.children);
    bodyChildren.forEach(function (el) {
      if (el === getContainer() || el.contains(getContainer())) {
        return;
      }

      if (el.hasAttribute('aria-hidden')) {
        el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));
      }

      el.setAttribute('aria-hidden', 'true');
    });
  };

  var unsetAriaHidden = function unsetAriaHidden() {
    var bodyChildren = toArray(document.body.children);
    bodyChildren.forEach(function (el) {
      if (el.hasAttribute('data-previous-aria-hidden')) {
        el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));
        el.removeAttribute('data-previous-aria-hidden');
      } else {
        el.removeAttribute('aria-hidden');
      }
    });
  };

  var RESTORE_FOCUS_TIMEOUT = 100;
  var globalState = {};

  var restoreActiveElement = function restoreActiveElement() {
    return new Promise(function (resolve) {
      var x = window.scrollX;
      var y = window.scrollY;
      globalState.restoreFocusTimeout = setTimeout(function () {
        if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
          globalState.previousActiveElement.focus();
          globalState.previousActiveElement = null;
        } else if (document.body) {
          document.body.focus();
        }

        resolve();
      }, RESTORE_FOCUS_TIMEOUT); // issues/900

      if (typeof x !== 'undefined' && typeof y !== 'undefined') {
        // IE doesn't have scrollX/scrollY support
        window.scrollTo(x, y);
      }
    });
  };
  /*
   * Global function to close sweetAlert
   */


  var close = function close(onClose, onAfterClose) {
    var container = getContainer();
    var popup = getPopup();

    if (!popup) {
      return;
    }

    if (onClose !== null && typeof onClose === 'function') {
      onClose(popup);
    }

    removeClass(popup, swalClasses.show);
    addClass(popup, swalClasses.hide);

    var removePopupAndResetState = function removePopupAndResetState() {
      if (!isToast()) {
        restoreActiveElement().then(function () {
          return triggerOnAfterClose(onAfterClose);
        });
        globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
          capture: globalState.keydownListenerCapture
        });
        globalState.keydownHandlerAdded = false;
      } else {
        triggerOnAfterClose(onAfterClose);
      }

      if (container.parentNode) {
        container.parentNode.removeChild(container);
      }

      removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);

      if (isModal()) {
        undoScrollbar();
        undoIOSfix();
        undoIEfix();
        unsetAriaHidden();
      }
    }; // If animation is supported, animate


    if (animationEndEvent && !hasClass(popup, swalClasses.noanimation)) {
      popup.addEventListener(animationEndEvent, function swalCloseEventFinished() {
        popup.removeEventListener(animationEndEvent, swalCloseEventFinished);

        if (hasClass(popup, swalClasses.hide)) {
          removePopupAndResetState();
        }
      });
    } else {
      // Otherwise, remove immediately
      removePopupAndResetState();
    }
  };

  var triggerOnAfterClose = function triggerOnAfterClose(onAfterClose) {
    if (onAfterClose !== null && typeof onAfterClose === 'function') {
      setTimeout(function () {
        onAfterClose();
      });
    }
  };
  /*
   * Global function to determine if swal2 popup is shown
   */


  var isVisible$1 = function isVisible() {
    return !!getPopup();
  };
  /*
   * Global function to click 'Confirm' button
   */


  var clickConfirm = function clickConfirm() {
    return getConfirmButton().click();
  };
  /*
   * Global function to click 'Cancel' button
   */


  var clickCancel = function clickCancel() {
    return getCancelButton().click();
  };

  function fire() {
    var Swal = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _construct(Swal, args);
  }
  /**
   * Extends a Swal class making it able to be instantiated without the `new` keyword (and thus without `Swal.fire`)
   * @param ParentSwal
   * @returns {NoNewKeywordSwal}
   */


  function withNoNewKeyword(ParentSwal) {
    var NoNewKeywordSwal = function NoNewKeywordSwal() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (!(this instanceof NoNewKeywordSwal)) {
        return _construct(NoNewKeywordSwal, args);
      }

      Object.getPrototypeOf(NoNewKeywordSwal).apply(this, args);
    };

    NoNewKeywordSwal.prototype = _extends(Object.create(ParentSwal.prototype), {
      constructor: NoNewKeywordSwal
    });

    if (typeof Object.setPrototypeOf === 'function') {
      Object.setPrototypeOf(NoNewKeywordSwal, ParentSwal);
    } else {
      // Android 4.4

      /* istanbul ignore next */
      // eslint-disable-next-line
      NoNewKeywordSwal.__proto__ = ParentSwal;
    }

    return NoNewKeywordSwal;
  }

  var defaultParams = {
    title: '',
    titleText: '',
    text: '',
    html: '',
    footer: '',
    type: null,
    toast: false,
    customClass: '',
    target: 'body',
    backdrop: true,
    animation: true,
    heightAuto: true,
    allowOutsideClick: true,
    allowEscapeKey: true,
    allowEnterKey: true,
    stopKeydownPropagation: true,
    keydownListenerCapture: false,
    showConfirmButton: true,
    showCancelButton: false,
    preConfirm: null,
    confirmButtonText: 'OK',
    confirmButtonAriaLabel: '',
    confirmButtonColor: null,
    confirmButtonClass: null,
    cancelButtonText: 'Cancel',
    cancelButtonAriaLabel: '',
    cancelButtonColor: null,
    cancelButtonClass: null,
    buttonsStyling: true,
    reverseButtons: false,
    focusConfirm: true,
    focusCancel: false,
    showCloseButton: false,
    closeButtonAriaLabel: 'Close this dialog',
    showLoaderOnConfirm: false,
    imageUrl: null,
    imageWidth: null,
    imageHeight: null,
    imageAlt: '',
    imageClass: null,
    timer: null,
    width: null,
    padding: null,
    background: null,
    input: null,
    inputPlaceholder: '',
    inputValue: '',
    inputOptions: {},
    inputAutoTrim: true,
    inputClass: null,
    inputAttributes: {},
    inputValidator: null,
    validationMessage: null,
    grow: false,
    position: 'center',
    progressSteps: [],
    currentProgressStep: null,
    progressStepsDistance: null,
    onBeforeOpen: null,
    onAfterClose: null,
    onOpen: null,
    onClose: null,
    useRejections: false,
    expectRejections: false
  };
  var deprecatedParams = ['useRejections', 'expectRejections', 'extraParams'];
  var toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];
  /**
   * Is valid parameter
   * @param {String} paramName
   */

  var isValidParameter = function isValidParameter(paramName) {
    return defaultParams.hasOwnProperty(paramName) || paramName === 'extraParams';
  };
  /**
   * Is deprecated parameter
   * @param {String} paramName
   */


  var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
    return deprecatedParams.indexOf(paramName) !== -1;
  };
  /**
   * Show relevant warnings for given params
   *
   * @param params
   */


  var showWarningsForParams = function showWarningsForParams(params) {
    for (var param in params) {
      if (!isValidParameter(param)) {
        warn("Unknown parameter \"".concat(param, "\""));
      }

      if (params.toast && toastIncompatibleParams.indexOf(param) !== -1) {
        warn("The parameter \"".concat(param, "\" is incompatible with toasts"));
      }

      if (isDeprecatedParameter(param)) {
        warnOnce("The parameter \"".concat(param, "\" is deprecated and will be removed in the next major release."));
      }
    }
  };

  var deprecationWarning = "\"setDefaults\" & \"resetDefaults\" methods are deprecated in favor of \"mixin\" method and will be removed in the next major release. For new projects, use \"mixin\". For past projects already using \"setDefaults\", support will be provided through an additional package.";
  var defaults = {};

  function withGlobalDefaults(ParentSwal) {
    var SwalWithGlobalDefaults =
    /*#__PURE__*/
    function (_ParentSwal) {
      _inherits(SwalWithGlobalDefaults, _ParentSwal);

      function SwalWithGlobalDefaults() {
        _classCallCheck(this, SwalWithGlobalDefaults);

        return _possibleConstructorReturn(this, _getPrototypeOf(SwalWithGlobalDefaults).apply(this, arguments));
      }

      _createClass(SwalWithGlobalDefaults, [{
        key: "_main",
        value: function _main(params) {
          return _get(_getPrototypeOf(SwalWithGlobalDefaults.prototype), "_main", this).call(this, _extends({}, defaults, params));
        }
      }], [{
        key: "setDefaults",
        value: function setDefaults(params) {
          warnOnce(deprecationWarning);

          if (!params || _typeof(params) !== 'object') {
            throw new TypeError('SweetAlert2: The argument for setDefaults() is required and has to be a object');
          }

          showWarningsForParams(params); // assign valid params from `params` to `defaults`

          Object.keys(params).forEach(function (param) {
            if (ParentSwal.isValidParameter(param)) {
              defaults[param] = params[param];
            }
          });
        }
      }, {
        key: "resetDefaults",
        value: function resetDefaults() {
          warnOnce(deprecationWarning);
          defaults = {};
        }
      }]);

      return SwalWithGlobalDefaults;
    }(ParentSwal); // Set default params if `window._swalDefaults` is an object


    if (typeof window !== 'undefined' && _typeof(window._swalDefaults) === 'object') {
      SwalWithGlobalDefaults.setDefaults(window._swalDefaults);
    }

    return SwalWithGlobalDefaults;
  }
  /**
   * Returns an extended version of `Swal` containing `params` as defaults.
   * Useful for reusing Swal configuration.
   *
   * For example:
   *
   * Before:
   * const textPromptOptions = { input: 'text', showCancelButton: true }
   * const {value: firstName} = await Swal({ ...textPromptOptions, title: 'What is your first name?' })
   * const {value: lastName} = await Swal({ ...textPromptOptions, title: 'What is your last name?' })
   *
   * After:
   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })
   * const {value: firstName} = await TextPrompt('What is your first name?')
   * const {value: lastName} = await TextPrompt('What is your last name?')
   *
   * @param mixinParams
   */


  function mixin(mixinParams) {
    return withNoNewKeyword(
    /*#__PURE__*/
    function (_this) {
      _inherits(MixinSwal, _this);

      function MixinSwal() {
        _classCallCheck(this, MixinSwal);

        return _possibleConstructorReturn(this, _getPrototypeOf(MixinSwal).apply(this, arguments));
      }

      _createClass(MixinSwal, [{
        key: "_main",
        value: function _main(params) {
          return _get(_getPrototypeOf(MixinSwal.prototype), "_main", this).call(this, _extends({}, mixinParams, params));
        }
      }]);

      return MixinSwal;
    }(this));
  } // private global state for the queue feature


  var currentSteps = [];
  /*
   * Global function for chaining sweetAlert popups
   */

  var queue = function queue(steps) {
    var swal = this;
    currentSteps = steps;

    var resetQueue = function resetQueue() {
      currentSteps = [];
      document.body.removeAttribute('data-swal2-queue-step');
    };

    var queueResult = [];
    return new Promise(function (resolve) {
      (function step(i, callback) {
        if (i < currentSteps.length) {
          document.body.setAttribute('data-swal2-queue-step', i);
          swal(currentSteps[i]).then(function (result) {
            if (typeof result.value !== 'undefined') {
              queueResult.push(result.value);
              step(i + 1, callback);
            } else {
              resetQueue();
              resolve({
                dismiss: result.dismiss
              });
            }
          });
        } else {
          resetQueue();
          resolve({
            value: queueResult
          });
        }
      })(0);
    });
  };
  /*
   * Global function for getting the index of current popup in queue
   */


  var getQueueStep = function getQueueStep() {
    return document.body.getAttribute('data-swal2-queue-step');
  };
  /*
   * Global function for inserting a popup to the queue
   */


  var insertQueueStep = function insertQueueStep(step, index) {
    if (index && index < currentSteps.length) {
      return currentSteps.splice(index, 0, step);
    }

    return currentSteps.push(step);
  };
  /*
   * Global function for deleting a popup from the queue
   */


  var deleteQueueStep = function deleteQueueStep(index) {
    if (typeof currentSteps[index] !== 'undefined') {
      currentSteps.splice(index, 1);
    }
  };
  /**
   * Show spinner instead of Confirm button and disable Cancel button
   */


  var showLoading = function showLoading() {
    var popup = getPopup();

    if (!popup) {
      Swal('');
    }

    popup = getPopup();
    var actions = getActions();
    var confirmButton = getConfirmButton();
    var cancelButton = getCancelButton();
    show(actions);
    show(confirmButton);
    addClass([popup, actions], swalClasses.loading);
    confirmButton.disabled = true;
    cancelButton.disabled = true;
    popup.setAttribute('data-loading', true);
    popup.setAttribute('aria-busy', true);
    popup.focus();
  };
  /**
   * If `timer` parameter is set, returns number os milliseconds of timer remained.
   * Otherwise, returns null.
   */


  var getTimerLeft = function getTimerLeft() {
    return globalState.timeout && globalState.timeout.getTimerLeft();
  };

  var staticMethods = Object.freeze({
    isValidParameter: isValidParameter,
    isDeprecatedParameter: isDeprecatedParameter,
    argsToParams: argsToParams,
    adaptInputValidator: adaptInputValidator,
    close: close,
    closePopup: close,
    closeModal: close,
    closeToast: close,
    isVisible: isVisible$1,
    clickConfirm: clickConfirm,
    clickCancel: clickCancel,
    getContainer: getContainer,
    getPopup: getPopup,
    getTitle: getTitle,
    getContent: getContent,
    getImage: getImage,
    getIcons: getIcons,
    getCloseButton: getCloseButton,
    getButtonsWrapper: getButtonsWrapper,
    getActions: getActions,
    getConfirmButton: getConfirmButton,
    getCancelButton: getCancelButton,
    getFooter: getFooter,
    getFocusableElements: getFocusableElements,
    getValidationMessage: getValidationMessage,
    isLoading: isLoading,
    fire: fire,
    mixin: mixin,
    queue: queue,
    getQueueStep: getQueueStep,
    insertQueueStep: insertQueueStep,
    deleteQueueStep: deleteQueueStep,
    showLoading: showLoading,
    enableLoading: showLoading,
    getTimerLeft: getTimerLeft
  }); // https://github.com/Riim/symbol-polyfill/blob/master/index.js

  /* istanbul ignore next */

  var _Symbol = typeof Symbol === 'function' ? Symbol : function () {
    var idCounter = 0;

    function _Symbol(key) {
      return '__' + key + '_' + Math.floor(Math.random() * 1e9) + '_' + ++idCounter + '__';
    }

    _Symbol.iterator = _Symbol('Symbol.iterator');
    return _Symbol;
  }(); // WeakMap polyfill, needed for Android 4.4
  // Related issue: https://github.com/sweetalert2/sweetalert2/issues/1071
  // http://webreflection.blogspot.fi/2015/04/a-weakmap-polyfill-in-20-lines-of-code.html

  /* istanbul ignore next */


  var WeakMap$1 = typeof WeakMap === 'function' ? WeakMap : function (s, dP, hOP) {
    function WeakMap() {
      dP(this, s, {
        value: _Symbol('WeakMap')
      });
    }

    WeakMap.prototype = {
      'delete': function del(o) {
        delete o[this[s]];
      },
      get: function get(o) {
        return o[this[s]];
      },
      has: function has(o) {
        return hOP.call(o, this[s]);
      },
      set: function set(o, v) {
        dP(o, this[s], {
          configurable: true,
          value: v
        });
      }
    };
    return WeakMap;
  }(_Symbol('WeakMap'), Object.defineProperty, {}.hasOwnProperty);
  /**
   * This module containts `WeakMap`s for each effectively-"private  property" that a `swal` has.
   * For example, to set the private property "foo" of `this` to "bar", you can `privateProps.foo.set(this, 'bar')`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */

  var privateProps = {
    promise: new WeakMap$1(),
    innerParams: new WeakMap$1(),
    domCache: new WeakMap$1()
  };
  /**
   * Enables buttons and hide loader.
   */

  function hideLoading() {
    var innerParams = privateProps.innerParams.get(this);
    var domCache = privateProps.domCache.get(this);

    if (!innerParams.showConfirmButton) {
      hide(domCache.confirmButton);

      if (!innerParams.showCancelButton) {
        hide(domCache.actions);
      }
    }

    removeClass([domCache.popup, domCache.actions], swalClasses.loading);
    domCache.popup.removeAttribute('aria-busy');
    domCache.popup.removeAttribute('data-loading');
    domCache.confirmButton.disabled = false;
    domCache.cancelButton.disabled = false;
  }

  function getInput(inputType) {
    var innerParams = privateProps.innerParams.get(this);
    var domCache = privateProps.domCache.get(this);
    inputType = inputType || innerParams.input;

    if (!inputType) {
      return null;
    }

    switch (inputType) {
      case 'select':
      case 'textarea':
      case 'file':
        return getChildByClass(domCache.content, swalClasses[inputType]);

      case 'checkbox':
        return domCache.popup.querySelector(".".concat(swalClasses.checkbox, " input"));

      case 'radio':
        return domCache.popup.querySelector(".".concat(swalClasses.radio, " input:checked")) || domCache.popup.querySelector(".".concat(swalClasses.radio, " input:first-child"));

      case 'range':
        return domCache.popup.querySelector(".".concat(swalClasses.range, " input"));

      default:
        return getChildByClass(domCache.content, swalClasses.input);
    }
  }

  function enableButtons() {
    var domCache = privateProps.domCache.get(this);
    domCache.confirmButton.disabled = false;
    domCache.cancelButton.disabled = false;
  }

  function disableButtons() {
    var domCache = privateProps.domCache.get(this);
    domCache.confirmButton.disabled = true;
    domCache.cancelButton.disabled = true;
  }

  function enableConfirmButton() {
    var domCache = privateProps.domCache.get(this);
    domCache.confirmButton.disabled = false;
  }

  function disableConfirmButton() {
    var domCache = privateProps.domCache.get(this);
    domCache.confirmButton.disabled = true;
  }

  function enableInput() {
    var input = this.getInput();

    if (!input) {
      return false;
    }

    if (input.type === 'radio') {
      var radiosContainer = input.parentNode.parentNode;
      var radios = radiosContainer.querySelectorAll('input');

      for (var i = 0; i < radios.length; i++) {
        radios[i].disabled = false;
      }
    } else {
      input.disabled = false;
    }
  }

  function disableInput() {
    var input = this.getInput();

    if (!input) {
      return false;
    }

    if (input && input.type === 'radio') {
      var radiosContainer = input.parentNode.parentNode;
      var radios = radiosContainer.querySelectorAll('input');

      for (var i = 0; i < radios.length; i++) {
        radios[i].disabled = true;
      }
    } else {
      input.disabled = true;
    }
  }

  function showValidationMessage(error$$1) {
    var domCache = privateProps.domCache.get(this);
    domCache.validationMessage.innerHTML = error$$1;
    var popupComputedStyle = window.getComputedStyle(domCache.popup);
    domCache.validationMessage.style.marginLeft = "-".concat(popupComputedStyle.getPropertyValue('padding-left'));
    domCache.validationMessage.style.marginRight = "-".concat(popupComputedStyle.getPropertyValue('padding-right'));
    show(domCache.validationMessage);
    var input = this.getInput();

    if (input) {
      input.setAttribute('aria-invalid', true);
      input.setAttribute('aria-describedBy', swalClasses['validation-message']);
      focusInput(input);
      addClass(input, swalClasses.inputerror);
    }
  } // Hide block with validation message


  function resetValidationMessage() {
    var domCache = privateProps.domCache.get(this);

    if (domCache.validationMessage) {
      hide(domCache.validationMessage);
    }

    var input = this.getInput();

    if (input) {
      input.removeAttribute('aria-invalid');
      input.removeAttribute('aria-describedBy');
      removeClass(input, swalClasses.inputerror);
    }
  } // @deprecated

  /* istanbul ignore next */


  function resetValidationError() {
    warnOnce("Swal.resetValidationError() is deprecated and will be removed in the next major release, use Swal.resetValidationMessage() instead");
    resetValidationMessage.bind(this)();
  } // @deprecated

  /* istanbul ignore next */


  function showValidationError(error$$1) {
    warnOnce("Swal.showValidationError() is deprecated and will be removed in the next major release, use Swal.showValidationMessage() instead");
    showValidationMessage.bind(this)(error$$1);
  }

  function getProgressSteps$1() {
    var innerParams = privateProps.innerParams.get(this);
    return innerParams.progressSteps;
  }

  function setProgressSteps(progressSteps) {
    var innerParams = privateProps.innerParams.get(this);

    var updatedParams = _extends({}, innerParams, {
      progressSteps: progressSteps
    });

    privateProps.innerParams.set(this, updatedParams);
    renderProgressSteps(updatedParams);
  }

  function showProgressSteps() {
    var domCache = privateProps.domCache.get(this);
    show(domCache.progressSteps);
  }

  function hideProgressSteps() {
    var domCache = privateProps.domCache.get(this);
    hide(domCache.progressSteps);
  }

  var Timer = function Timer(callback, delay) {
    _classCallCheck(this, Timer);

    var id, started, running;
    var remaining = delay;

    this.start = function () {
      running = true;
      started = new Date();
      id = setTimeout(callback, remaining);
    };

    this.stop = function () {
      running = false;
      clearTimeout(id);
      remaining -= new Date() - started;
    };

    this.getTimerLeft = function () {
      if (running) {
        this.stop();
        this.start();
      }

      return remaining;
    };

    this.start();
  };

  var defaultInputValidators = {
    email: function email(string, extraParams) {
      return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.reject(extraParams && extraParams.validationMessage ? extraParams.validationMessage : 'Invalid email address');
    },
    url: function url(string, extraParams) {
      // taken from https://stackoverflow.com/a/3809435 with a small change from #1306
      return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/.test(string) ? Promise.resolve() : Promise.reject(extraParams && extraParams.validationMessage ? extraParams.validationMessage : 'Invalid URL');
    }
  };
  /**
   * Set type, text and actions on popup
   *
   * @param params
   * @returns {boolean}
   */

  function setParameters(params) {
    // Use default `inputValidator` for supported input types if not provided
    if (!params.inputValidator) {
      Object.keys(defaultInputValidators).forEach(function (key) {
        if (params.input === key) {
          params.inputValidator = params.expectRejections ? defaultInputValidators[key] : Swal.adaptInputValidator(defaultInputValidators[key]);
        }
      });
    } // params.extraParams is @deprecated


    if (params.validationMessage) {
      if (_typeof(params.extraParams) !== 'object') {
        params.extraParams = {};
      }

      params.extraParams.validationMessage = params.validationMessage;
    } // Determine if the custom target element is valid


    if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {
      warn('Target parameter is not valid, defaulting to "body"');
      params.target = 'body';
    } // Animation


    if (typeof params.animation === 'function') {
      params.animation = params.animation.call();
    }

    var popup;
    var oldPopup = getPopup();
    var targetElement = typeof params.target === 'string' ? document.querySelector(params.target) : params.target; // If the model target has changed, refresh the popup

    if (oldPopup && targetElement && oldPopup.parentNode !== targetElement.parentNode) {
      popup = init(params);
    } else {
      popup = oldPopup || init(params);
    } // Set popup width


    if (params.width) {
      popup.style.width = typeof params.width === 'number' ? params.width + 'px' : params.width;
    } // Set popup padding


    if (params.padding) {
      popup.style.padding = typeof params.padding === 'number' ? params.padding + 'px' : params.padding;
    } // Set popup background


    if (params.background) {
      popup.style.background = params.background;
    }

    var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');
    var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');

    for (var i = 0; i < successIconParts.length; i++) {
      successIconParts[i].style.backgroundColor = popupBackgroundColor;
    }

    var container = getContainer();
    var closeButton = getCloseButton();
    var footer = getFooter(); // Title

    renderTitle(params); // Content

    renderContent(params); // Backdrop

    if (typeof params.backdrop === 'string') {
      getContainer().style.background = params.backdrop;
    } else if (!params.backdrop) {
      addClass([document.documentElement, document.body], swalClasses['no-backdrop']);
    }

    if (!params.backdrop && params.allowOutsideClick) {
      warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
    } // Position


    if (params.position in swalClasses) {
      addClass(container, swalClasses[params.position]);
    } else {
      warn('The "position" parameter is not valid, defaulting to "center"');
      addClass(container, swalClasses.center);
    } // Grow


    if (params.grow && typeof params.grow === 'string') {
      var growClass = 'grow-' + params.grow;

      if (growClass in swalClasses) {
        addClass(container, swalClasses[growClass]);
      }
    } // Close button


    if (params.showCloseButton) {
      closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);
      show(closeButton);
    } else {
      hide(closeButton);
    } // Default Class


    popup.className = swalClasses.popup;

    if (params.toast) {
      addClass([document.documentElement, document.body], swalClasses['toast-shown']);
      addClass(popup, swalClasses.toast);
    } else {
      addClass(popup, swalClasses.modal);
    } // Custom Class


    if (params.customClass) {
      addClass(popup, params.customClass);
    } // Progress steps


    renderProgressSteps(params); // Icon

    renderIcon(params); // Image

    renderImage(params); // Actions (buttons)

    renderActions(params); // Footer

    parseHtmlToContainer(params.footer, footer); // CSS animation

    if (params.animation === true) {
      removeClass(popup, swalClasses.noanimation);
    } else {
      addClass(popup, swalClasses.noanimation);
    } // showLoaderOnConfirm && preConfirm


    if (params.showLoaderOnConfirm && !params.preConfirm) {
      warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\n' + 'https://sweetalert2.github.io/#ajax-request');
    }
  }
  /**
   * Open popup, add necessary classes and styles, fix scrollbar
   *
   * @param {Array} params
   */


  var openPopup = function openPopup(params) {
    var container = getContainer();
    var popup = getPopup();

    if (params.onBeforeOpen !== null && typeof params.onBeforeOpen === 'function') {
      params.onBeforeOpen(popup);
    }

    if (params.animation) {
      addClass(popup, swalClasses.show);
      addClass(container, swalClasses.fade);
      removeClass(popup, swalClasses.hide);
    } else {
      removeClass(popup, swalClasses.fade);
    }

    show(popup); // scrolling is 'hidden' until animation is done, after that 'auto'

    container.style.overflowY = 'hidden';

    if (animationEndEvent && !hasClass(popup, swalClasses.noanimation)) {
      popup.addEventListener(animationEndEvent, function swalCloseEventFinished() {
        popup.removeEventListener(animationEndEvent, swalCloseEventFinished);
        container.style.overflowY = 'auto';
      });
    } else {
      container.style.overflowY = 'auto';
    }

    addClass([document.documentElement, document.body, container], swalClasses.shown);

    if (params.heightAuto && params.backdrop && !params.toast) {
      addClass([document.documentElement, document.body], swalClasses['height-auto']);
    }

    if (isModal()) {
      fixScrollbar();
      iOSfix();
      IEfix();
      setAriaHidden(); // sweetalert2/issues/1247

      setTimeout(function () {
        container.scrollTop = 0;
      });
    }

    if (!isToast() && !globalState.previousActiveElement) {
      globalState.previousActiveElement = document.activeElement;
    }

    if (params.onOpen !== null && typeof params.onOpen === 'function') {
      setTimeout(function () {
        params.onOpen(popup);
      });
    }
  };

  function _main(userParams) {
    var _this = this;

    showWarningsForParams(userParams);

    var innerParams = _extends({}, defaultParams, userParams);

    setParameters(innerParams);
    Object.freeze(innerParams);
    privateProps.innerParams.set(this, innerParams); // clear the previous timer

    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    } // clear the restore focus timeout


    clearTimeout(globalState.restoreFocusTimeout);
    var domCache = {
      popup: getPopup(),
      container: getContainer(),
      content: getContent(),
      actions: getActions(),
      confirmButton: getConfirmButton(),
      cancelButton: getCancelButton(),
      closeButton: getCloseButton(),
      validationMessage: getValidationMessage(),
      progressSteps: getProgressSteps()
    };
    privateProps.domCache.set(this, domCache);
    var constructor = this.constructor;
    return new Promise(function (resolve, reject) {
      // functions to handle all resolving/rejecting/settling
      var succeedWith = function succeedWith(value) {
        constructor.closePopup(innerParams.onClose, innerParams.onAfterClose); // TODO: make closePopup an *instance* method

        if (innerParams.useRejections) {
          resolve(value);
        } else {
          resolve({
            value: value
          });
        }
      };

      var dismissWith = function dismissWith(dismiss) {
        constructor.closePopup(innerParams.onClose, innerParams.onAfterClose);

        if (innerParams.useRejections) {
          reject(dismiss);
        } else {
          resolve({
            dismiss: dismiss
          });
        }
      };

      var errorWith = function errorWith(error$$1) {
        constructor.closePopup(innerParams.onClose, innerParams.onAfterClose);
        reject(error$$1);
      }; // Close on timer


      if (innerParams.timer) {
        globalState.timeout = new Timer(function () {
          dismissWith('timer');
          delete globalState.timeout;
        }, innerParams.timer);
      } // Get the value of the popup input


      var getInputValue = function getInputValue() {
        var input = _this.getInput();

        if (!input) {
          return null;
        }

        switch (innerParams.input) {
          case 'checkbox':
            return input.checked ? 1 : 0;

          case 'radio':
            return input.checked ? input.value : null;

          case 'file':
            return input.files.length ? input.files[0] : null;

          default:
            return innerParams.inputAutoTrim ? input.value.trim() : input.value;
        }
      }; // input autofocus


      if (innerParams.input) {
        setTimeout(function () {
          var input = _this.getInput();

          if (input) {
            focusInput(input);
          }
        }, 0);
      }

      var confirm = function confirm(value) {
        if (innerParams.showLoaderOnConfirm) {
          constructor.showLoading(); // TODO: make showLoading an *instance* method
        }

        if (innerParams.preConfirm) {
          _this.resetValidationMessage();

          var preConfirmPromise = Promise.resolve().then(function () {
            return innerParams.preConfirm(value, innerParams.extraParams);
          });

          if (innerParams.expectRejections) {
            preConfirmPromise.then(function (preConfirmValue) {
              return succeedWith(preConfirmValue || value);
            }, function (validationMessage) {
              _this.hideLoading();

              if (validationMessage) {
                _this.showValidationMessage(validationMessage);
              }
            });
          } else {
            preConfirmPromise.then(function (preConfirmValue) {
              if (isVisible(domCache.validationMessage) || preConfirmValue === false) {
                _this.hideLoading();
              } else {
                succeedWith(preConfirmValue || value);
              }
            }, function (error$$1) {
              return errorWith(error$$1);
            });
          }
        } else {
          succeedWith(value);
        }
      }; // Mouse interactions


      var onButtonEvent = function onButtonEvent(e) {
        var target = e.target;
        var confirmButton = domCache.confirmButton,
            cancelButton = domCache.cancelButton;
        var targetedConfirm = confirmButton && (confirmButton === target || confirmButton.contains(target));
        var targetedCancel = cancelButton && (cancelButton === target || cancelButton.contains(target));

        switch (e.type) {
          case 'click':
            // Clicked 'confirm'
            if (targetedConfirm && constructor.isVisible()) {
              _this.disableButtons();

              if (innerParams.input) {
                var inputValue = getInputValue();

                if (innerParams.inputValidator) {
                  _this.disableInput();

                  var validationPromise = Promise.resolve().then(function () {
                    return innerParams.inputValidator(inputValue, innerParams.extraParams);
                  });

                  if (innerParams.expectRejections) {
                    validationPromise.then(function () {
                      _this.enableButtons();

                      _this.enableInput();

                      confirm(inputValue);
                    }, function (validationMessage) {
                      _this.enableButtons();

                      _this.enableInput();

                      if (validationMessage) {
                        _this.showValidationMessage(validationMessage);
                      }
                    });
                  } else {
                    validationPromise.then(function (validationMessage) {
                      _this.enableButtons();

                      _this.enableInput();

                      if (validationMessage) {
                        _this.showValidationMessage(validationMessage);
                      } else {
                        confirm(inputValue);
                      }
                    }, function (error$$1) {
                      return errorWith(error$$1);
                    });
                  }
                } else if (!_this.getInput().checkValidity()) {
                  _this.enableButtons();

                  _this.showValidationMessage(innerParams.validationMessage);
                } else {
                  confirm(inputValue);
                }
              } else {
                confirm(true);
              } // Clicked 'cancel'

            } else if (targetedCancel && constructor.isVisible()) {
              _this.disableButtons();

              dismissWith(constructor.DismissReason.cancel);
            }

            break;

          default:
        }
      };

      var buttons = domCache.popup.querySelectorAll('button');

      for (var i = 0; i < buttons.length; i++) {
        buttons[i].onclick = onButtonEvent;
        buttons[i].onmouseover = onButtonEvent;
        buttons[i].onmouseout = onButtonEvent;
        buttons[i].onmousedown = onButtonEvent;
      } // Closing popup by close button


      domCache.closeButton.onclick = function () {
        dismissWith(constructor.DismissReason.close);
      };

      if (innerParams.toast) {
        // Closing popup by internal click
        domCache.popup.onclick = function () {
          if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
            return;
          }

          dismissWith(constructor.DismissReason.close);
        };
      } else {
        var ignoreOutsideClick = false; // Ignore click events that had mousedown on the popup but mouseup on the container
        // This can happen when the user drags a slider

        domCache.popup.onmousedown = function () {
          domCache.container.onmouseup = function (e) {
            domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't
            // have any other direct children aside of the popup

            if (e.target === domCache.container) {
              ignoreOutsideClick = true;
            }
          };
        }; // Ignore click events that had mousedown on the container but mouseup on the popup


        domCache.container.onmousedown = function () {
          domCache.popup.onmouseup = function (e) {
            domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup

            if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
              ignoreOutsideClick = true;
            }
          };
        };

        domCache.container.onclick = function (e) {
          if (ignoreOutsideClick) {
            ignoreOutsideClick = false;
            return;
          }

          if (e.target !== domCache.container) {
            return;
          }

          if (callIfFunction(innerParams.allowOutsideClick)) {
            dismissWith(constructor.DismissReason.backdrop);
          }
        };
      } // Reverse buttons (Confirm on the right side)


      if (innerParams.reverseButtons) {
        domCache.confirmButton.parentNode.insertBefore(domCache.cancelButton, domCache.confirmButton);
      } else {
        domCache.confirmButton.parentNode.insertBefore(domCache.confirmButton, domCache.cancelButton);
      } // Focus handling


      var setFocus = function setFocus(index, increment) {
        var focusableElements = getFocusableElements(innerParams.focusCancel); // search for visible elements and select the next possible match

        for (var _i = 0; _i < focusableElements.length; _i++) {
          index = index + increment; // rollover to first item

          if (index === focusableElements.length) {
            index = 0; // go to last item
          } else if (index === -1) {
            index = focusableElements.length - 1;
          }

          return focusableElements[index].focus();
        } // no visible focusable elements, focus the popup


        domCache.popup.focus();
      };

      var keydownHandler = function keydownHandler(e, innerParams) {
        if (innerParams.stopKeydownPropagation) {
          e.stopPropagation();
        }

        var arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11
        ];

        if (e.key === 'Enter' && !e.isComposing) {
          if (e.target && _this.getInput() && e.target.outerHTML === _this.getInput().outerHTML) {
            if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {
              return; // do not submit
            }

            constructor.clickConfirm();
            e.preventDefault();
          } // TAB

        } else if (e.key === 'Tab') {
          var targetElement = e.target;
          var focusableElements = getFocusableElements(innerParams.focusCancel);
          var btnIndex = -1;

          for (var _i2 = 0; _i2 < focusableElements.length; _i2++) {
            if (targetElement === focusableElements[_i2]) {
              btnIndex = _i2;
              break;
            }
          }

          if (!e.shiftKey) {
            // Cycle to the next button
            setFocus(btnIndex, 1);
          } else {
            // Cycle to the prev button
            setFocus(btnIndex, -1);
          }

          e.stopPropagation();
          e.preventDefault(); // ARROWS - switch focus between buttons
        } else if (arrowKeys.indexOf(e.key) !== -1) {
          // focus Cancel button if Confirm button is currently focused
          if (document.activeElement === domCache.confirmButton && isVisible(domCache.cancelButton)) {
            domCache.cancelButton.focus(); // and vice versa
          } else if (document.activeElement === domCache.cancelButton && isVisible(domCache.confirmButton)) {
            domCache.confirmButton.focus();
          } // ESC

        } else if ((e.key === 'Escape' || e.key === 'Esc') && callIfFunction(innerParams.allowEscapeKey) === true) {
          e.preventDefault();
          dismissWith(constructor.DismissReason.esc);
        }
      };

      if (globalState.keydownHandlerAdded) {
        globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {
          capture: globalState.keydownListenerCapture
        });
        globalState.keydownHandlerAdded = false;
      }

      if (!innerParams.toast) {
        globalState.keydownHandler = function (e) {
          return keydownHandler(e, innerParams);
        };

        globalState.keydownTarget = innerParams.keydownListenerCapture ? window : domCache.popup;
        globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
        globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {
          capture: globalState.keydownListenerCapture
        });
        globalState.keydownHandlerAdded = true;
      }

      _this.enableButtons();

      _this.hideLoading();

      _this.resetValidationMessage();

      if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
        addClass(document.body, swalClasses['toast-column']);
      } else {
        removeClass(document.body, swalClasses['toast-column']);
      } // inputs


      var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];

      var setInputPlaceholder = function setInputPlaceholder(input) {
        if (!input.placeholder || innerParams.inputPlaceholder) {
          input.placeholder = innerParams.inputPlaceholder;
        }
      };

      var input;

      for (var _i3 = 0; _i3 < inputTypes.length; _i3++) {
        var inputClass = swalClasses[inputTypes[_i3]];
        var inputContainer = getChildByClass(domCache.content, inputClass);
        input = _this.getInput(inputTypes[_i3]); // set attributes

        if (input) {
          for (var j in input.attributes) {
            if (input.attributes.hasOwnProperty(j)) {
              var attrName = input.attributes[j].name;

              if (attrName !== 'type' && attrName !== 'value') {
                input.removeAttribute(attrName);
              }
            }
          }

          for (var attr in innerParams.inputAttributes) {
            // Do not set a placeholder for <input type="range">
            // it'll crash Edge, #1298
            if (inputTypes[_i3] === 'range' && attr === 'placeholder') {
              continue;
            }

            input.setAttribute(attr, innerParams.inputAttributes[attr]);
          }
        } // set class


        inputContainer.className = inputClass;

        if (innerParams.inputClass) {
          addClass(inputContainer, innerParams.inputClass);
        }

        hide(inputContainer);
      }

      var populateInputOptions;

      switch (innerParams.input) {
        case 'text':
        case 'email':
        case 'password':
        case 'number':
        case 'tel':
        case 'url':
          {
            input = getChildByClass(domCache.content, swalClasses.input);

            if (typeof innerParams.inputValue === 'string' || typeof innerParams.inputValue === 'number') {
              input.value = innerParams.inputValue;
            } else {
              warn("Unexpected type of inputValue! Expected \"string\" or \"number\", got \"".concat(_typeof(innerParams.inputValue), "\""));
            }

            setInputPlaceholder(input);
            input.type = innerParams.input;
            show(input);
            break;
          }

        case 'file':
          {
            input = getChildByClass(domCache.content, swalClasses.file);
            setInputPlaceholder(input);
            input.type = innerParams.input;
            show(input);
            break;
          }

        case 'range':
          {
            var range = getChildByClass(domCache.content, swalClasses.range);
            var rangeInput = range.querySelector('input');
            var rangeOutput = range.querySelector('output');
            rangeInput.value = innerParams.inputValue;
            rangeInput.type = innerParams.input;
            rangeOutput.value = innerParams.inputValue;
            show(range);
            break;
          }

        case 'select':
          {
            var select = getChildByClass(domCache.content, swalClasses.select);
            select.innerHTML = '';

            if (innerParams.inputPlaceholder) {
              var placeholder = document.createElement('option');
              placeholder.innerHTML = innerParams.inputPlaceholder;
              placeholder.value = '';
              placeholder.disabled = true;
              placeholder.selected = true;
              select.appendChild(placeholder);
            }

            populateInputOptions = function populateInputOptions(inputOptions) {
              inputOptions.forEach(function (inputOption) {
                var optionValue = inputOption[0];
                var optionLabel = inputOption[1];
                var option = document.createElement('option');
                option.value = optionValue;
                option.innerHTML = optionLabel;

                if (innerParams.inputValue.toString() === optionValue.toString()) {
                  option.selected = true;
                }

                select.appendChild(option);
              });
              show(select);
              select.focus();
            };

            break;
          }

        case 'radio':
          {
            var radio = getChildByClass(domCache.content, swalClasses.radio);
            radio.innerHTML = '';

            populateInputOptions = function populateInputOptions(inputOptions) {
              inputOptions.forEach(function (inputOption) {
                var radioValue = inputOption[0];
                var radioLabel = inputOption[1];
                var radioInput = document.createElement('input');
                var radioLabelElement = document.createElement('label');
                radioInput.type = 'radio';
                radioInput.name = swalClasses.radio;
                radioInput.value = radioValue;

                if (innerParams.inputValue.toString() === radioValue.toString()) {
                  radioInput.checked = true;
                }

                var label = document.createElement('span');
                label.innerHTML = radioLabel;
                label.className = swalClasses.label;
                radioLabelElement.appendChild(radioInput);
                radioLabelElement.appendChild(label);
                radio.appendChild(radioLabelElement);
              });
              show(radio);
              var radios = radio.querySelectorAll('input');

              if (radios.length) {
                radios[0].focus();
              }
            };

            break;
          }

        case 'checkbox':
          {
            var checkbox = getChildByClass(domCache.content, swalClasses.checkbox);

            var checkboxInput = _this.getInput('checkbox');

            checkboxInput.type = 'checkbox';
            checkboxInput.value = 1;
            checkboxInput.id = swalClasses.checkbox;
            checkboxInput.checked = Boolean(innerParams.inputValue);
            var label = checkbox.querySelector('span');
            label.innerHTML = innerParams.inputPlaceholder;
            show(checkbox);
            break;
          }

        case 'textarea':
          {
            var textarea = getChildByClass(domCache.content, swalClasses.textarea);
            textarea.value = innerParams.inputValue;
            setInputPlaceholder(textarea);
            show(textarea);
            break;
          }

        case null:
          {
            break;
          }

        default:
          error("Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"".concat(innerParams.input, "\""));
          break;
      }

      if (innerParams.input === 'select' || innerParams.input === 'radio') {
        var processInputOptions = function processInputOptions(inputOptions) {
          return populateInputOptions(formatInputOptions(inputOptions));
        };

        if (isThenable(innerParams.inputOptions)) {
          constructor.showLoading();
          innerParams.inputOptions.then(function (inputOptions) {
            _this.hideLoading();

            processInputOptions(inputOptions);
          });
        } else if (_typeof(innerParams.inputOptions) === 'object') {
          processInputOptions(innerParams.inputOptions);
        } else {
          error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(innerParams.inputOptions)));
        }
      } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(innerParams.input) !== -1 && isThenable(innerParams.inputValue)) {
        constructor.showLoading();
        hide(input);
        innerParams.inputValue.then(function (inputValue) {
          input.value = innerParams.input === 'number' ? parseFloat(inputValue) || 0 : inputValue + '';
          show(input);
          input.focus();

          _this.hideLoading();
        }).catch(function (err) {
          error('Error in inputValue promise: ' + err);
          input.value = '';
          show(input);
          input.focus();

          _this.hideLoading();
        });
      }

      openPopup(innerParams);

      if (!innerParams.toast) {
        if (!callIfFunction(innerParams.allowEnterKey)) {
          if (document.activeElement && typeof document.activeElement.blur === 'function') {
            document.activeElement.blur();
          }
        } else if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
          domCache.cancelButton.focus();
        } else if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
          domCache.confirmButton.focus();
        } else {
          setFocus(-1, 1);
        }
      } // fix scroll


      domCache.container.scrollTop = 0;
    });
  }

  var instanceMethods = Object.freeze({
    hideLoading: hideLoading,
    disableLoading: hideLoading,
    getInput: getInput,
    enableButtons: enableButtons,
    disableButtons: disableButtons,
    enableConfirmButton: enableConfirmButton,
    disableConfirmButton: disableConfirmButton,
    enableInput: enableInput,
    disableInput: disableInput,
    showValidationMessage: showValidationMessage,
    resetValidationMessage: resetValidationMessage,
    resetValidationError: resetValidationError,
    showValidationError: showValidationError,
    getProgressSteps: getProgressSteps$1,
    setProgressSteps: setProgressSteps,
    showProgressSteps: showProgressSteps,
    hideProgressSteps: hideProgressSteps,
    _main: _main
  });
  var currentInstance; // SweetAlert constructor

  function SweetAlert() {
    // Prevent run in Node env

    /* istanbul ignore if */
    if (typeof window === 'undefined') {
      return;
    } // Check for the existence of Promise

    /* istanbul ignore if */


    if (typeof Promise === 'undefined') {
      error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 0) {
      error('At least 1 argument is expected!');
      return false;
    }

    currentInstance = this;
    var outerParams = Object.freeze(this.constructor.argsToParams(args));
    Object.defineProperties(this, {
      params: {
        value: outerParams,
        writable: false,
        enumerable: true
      }
    });

    var promise = this._main(this.params);

    privateProps.promise.set(this, promise);
  } // `catch` cannot be the name of a module export, so we define our thenable methods here instead


  SweetAlert.prototype.then = function (onFulfilled, onRejected) {
    var promise = privateProps.promise.get(this);
    return promise.then(onFulfilled, onRejected);
  };

  SweetAlert.prototype.catch = function (onRejected) {
    var promise = privateProps.promise.get(this);
    return promise.catch(onRejected);
  };

  SweetAlert.prototype.finally = function (onFinally) {
    var promise = privateProps.promise.get(this);
    return promise.finally(onFinally);
  }; // Assign instance methods from src/instanceMethods/*.js to prototype


  _extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor


  _extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility


  Object.keys(instanceMethods).forEach(function (key) {
    SweetAlert[key] = function () {
      if (currentInstance) {
        var _currentInstance;

        return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
      }
    };
  });
  SweetAlert.DismissReason = DismissReason;
  /* istanbul ignore next */

  SweetAlert.noop = function () {};

  var Swal = withNoNewKeyword(withGlobalDefaults(SweetAlert));
  Swal.default = Swal;
  return Swal;
});

if (typeof window !== 'undefined' && window.Sweetalert2) {
  window.Sweetalert2.version = '7.29.2';
  window.swal = window.sweetAlert = window.Swal = window.SweetAlert = window.Sweetalert2;
}

"undefined" != typeof document && function (e, t) {
  var n = e.createElement("style");
  if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);else try {
    n.innerHTML = t;
  } catch (e) {
    n.innerText = t;
  }
}(document, "@-webkit-keyframes swal2-show{0%{-webkit-transform:scale(.7);transform:scale(.7)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes swal2-show{0%{-webkit-transform:scale(.7);transform:scale(.7)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}100%{-webkit-transform:scale(1);transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}100%{-webkit-transform:scale(.5);transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{-webkit-transform:scale(1);transform:scale(1);opacity:1}100%{-webkit-transform:scale(.5);transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.875em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.875em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}100%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}100%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}50%{margin-top:1.625em;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}80%{margin-top:-.375em;-webkit-transform:scale(1.15);transform:scale(1.15)}100%{margin-top:0;-webkit-transform:scale(1);transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}50%{margin-top:1.625em;-webkit-transform:scale(.4);transform:scale(.4);opacity:0}80%{margin-top:-.375em;-webkit-transform:scale(1.15);transform:scale(1.15)}100%{margin-top:0;-webkit-transform:scale(1);transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}100%{-webkit-transform:rotateX(0);transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}100%{-webkit-transform:rotateX(0);transform:rotateX(0);opacity:1}}body.swal2-toast-shown .swal2-container{position:fixed;background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-shown{background-color:transparent}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;-webkit-transform:translateY(-50%);transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;-webkit-transform:translateY(-50%);transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}body.swal2-toast-column .swal2-toast{flex-direction:column;align-items:stretch}body.swal2-toast-column .swal2-toast .swal2-actions{flex:1;align-self:stretch;height:2.2em;margin-top:.3125em}body.swal2-toast-column .swal2-toast .swal2-loading{justify-content:center}body.swal2-toast-column .swal2-toast .swal2-input{height:2em;margin:.3125em auto;font-size:1em}body.swal2-toast-column .swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast{flex-direction:row;align-items:center;width:auto;padding:.625em;box-shadow:0 0 .625em #d9d9d9;overflow-y:hidden}.swal2-popup.swal2-toast .swal2-header{flex-direction:row}.swal2-popup.swal2-toast .swal2-title{flex-grow:1;justify-content:flex-start;margin:0 .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{position:initial;width:.8em;height:.8em;line-height:.8}.swal2-popup.swal2-toast .swal2-content{justify-content:flex-start;font-size:1em}.swal2-popup.swal2-toast .swal2-icon{width:2em;min-width:2em;height:2em;margin:0}.swal2-popup.swal2-toast .swal2-icon-text{font-size:2em;font-weight:700;line-height:1em}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{height:auto;margin:0 .3125em}.swal2-popup.swal2-toast .swal2-styled{margin:0 .3125em;padding:.3125em .625em;font-size:1em}.swal2-popup.swal2-toast .swal2-styled:focus{box-shadow:0 0 0 .0625em #fff,0 0 0 .125em rgba(50,100,150,.4)}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:2em;height:2.8125em;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.25em;left:-.9375em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:2em 2em;transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;-webkit-transform-origin:0 2em;transform-origin:0 2em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:showSweetToast .5s;animation:showSweetToast .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:hideSweetToast .2s forwards;animation:hideSweetToast .2s forwards}.swal2-popup.swal2-toast .swal2-animate-success-icon .swal2-success-line-tip{-webkit-animation:animate-toast-success-tip .75s;animation:animate-toast-success-tip .75s}.swal2-popup.swal2-toast .swal2-animate-success-icon .swal2-success-line-long{-webkit-animation:animate-toast-success-long .75s;animation:animate-toast-success-long .75s}@-webkit-keyframes showSweetToast{0%{-webkit-transform:translateY(-.625em) rotateZ(2deg);transform:translateY(-.625em) rotateZ(2deg);opacity:0}33%{-webkit-transform:translateY(0) rotateZ(-2deg);transform:translateY(0) rotateZ(-2deg);opacity:.5}66%{-webkit-transform:translateY(.3125em) rotateZ(2deg);transform:translateY(.3125em) rotateZ(2deg);opacity:.7}100%{-webkit-transform:translateY(0) rotateZ(0);transform:translateY(0) rotateZ(0);opacity:1}}@keyframes showSweetToast{0%{-webkit-transform:translateY(-.625em) rotateZ(2deg);transform:translateY(-.625em) rotateZ(2deg);opacity:0}33%{-webkit-transform:translateY(0) rotateZ(-2deg);transform:translateY(0) rotateZ(-2deg);opacity:.5}66%{-webkit-transform:translateY(.3125em) rotateZ(2deg);transform:translateY(.3125em) rotateZ(2deg);opacity:.7}100%{-webkit-transform:translateY(0) rotateZ(0);transform:translateY(0) rotateZ(0);opacity:1}}@-webkit-keyframes hideSweetToast{0%{opacity:1}33%{opacity:.5}100%{-webkit-transform:rotateZ(1deg);transform:rotateZ(1deg);opacity:0}}@keyframes hideSweetToast{0%{opacity:1}33%{opacity:.5}100%{-webkit-transform:rotateZ(1deg);transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes animate-toast-success-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes animate-toast-success-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes animate-toast-success-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes animate-toast-success-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-shown{top:auto;right:auto;bottom:auto;left:auto;background-color:transparent}body.swal2-no-backdrop .swal2-shown>.swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}body.swal2-no-backdrop .swal2-shown.swal2-top{top:0;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-top-left,body.swal2-no-backdrop .swal2-shown.swal2-top-start{top:0;left:0}body.swal2-no-backdrop .swal2-shown.swal2-top-end,body.swal2-no-backdrop .swal2-shown.swal2-top-right{top:0;right:0}body.swal2-no-backdrop .swal2-shown.swal2-center{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}body.swal2-no-backdrop .swal2-shown.swal2-center-left,body.swal2-no-backdrop .swal2-shown.swal2-center-start{top:50%;left:0;-webkit-transform:translateY(-50%);transform:translateY(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-center-end,body.swal2-no-backdrop .swal2-shown.swal2-center-right{top:50%;right:0;-webkit-transform:translateY(-50%);transform:translateY(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-bottom{bottom:0;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}body.swal2-no-backdrop .swal2-shown.swal2-bottom-left,body.swal2-no-backdrop .swal2-shown.swal2-bottom-start{bottom:0;left:0}body.swal2-no-backdrop .swal2-shown.swal2-bottom-end,body.swal2-no-backdrop .swal2-shown.swal2-bottom-right{right:0;bottom:0}.swal2-container{display:flex;position:fixed;top:0;right:0;bottom:0;left:0;flex-direction:row;align-items:center;justify-content:center;padding:10px;background-color:transparent;z-index:1060;overflow-x:hidden;-webkit-overflow-scrolling:touch}.swal2-container.swal2-top{align-items:flex-start}.swal2-container.swal2-top-left,.swal2-container.swal2-top-start{align-items:flex-start;justify-content:flex-start}.swal2-container.swal2-top-end,.swal2-container.swal2-top-right{align-items:flex-start;justify-content:flex-end}.swal2-container.swal2-center{align-items:center}.swal2-container.swal2-center-left,.swal2-container.swal2-center-start{align-items:center;justify-content:flex-start}.swal2-container.swal2-center-end,.swal2-container.swal2-center-right{align-items:center;justify-content:flex-end}.swal2-container.swal2-bottom{align-items:flex-end}.swal2-container.swal2-bottom-left,.swal2-container.swal2-bottom-start{align-items:flex-end;justify-content:flex-start}.swal2-container.swal2-bottom-end,.swal2-container.swal2-bottom-right{align-items:flex-end;justify-content:flex-end}.swal2-container.swal2-grow-fullscreen>.swal2-modal{display:flex!important;flex:1;align-self:stretch;justify-content:center}.swal2-container.swal2-grow-row>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container.swal2-grow-column{flex:1;flex-direction:column}.swal2-container.swal2-grow-column.swal2-bottom,.swal2-container.swal2-grow-column.swal2-center,.swal2-container.swal2-grow-column.swal2-top{align-items:center}.swal2-container.swal2-grow-column.swal2-bottom-left,.swal2-container.swal2-grow-column.swal2-bottom-start,.swal2-container.swal2-grow-column.swal2-center-left,.swal2-container.swal2-grow-column.swal2-center-start,.swal2-container.swal2-grow-column.swal2-top-left,.swal2-container.swal2-grow-column.swal2-top-start{align-items:flex-start}.swal2-container.swal2-grow-column.swal2-bottom-end,.swal2-container.swal2-grow-column.swal2-bottom-right,.swal2-container.swal2-grow-column.swal2-center-end,.swal2-container.swal2-grow-column.swal2-center-right,.swal2-container.swal2-grow-column.swal2-top-end,.swal2-container.swal2-grow-column.swal2-top-right{align-items:flex-end}.swal2-container.swal2-grow-column>.swal2-modal{display:flex!important;flex:1;align-content:center;justify-content:center}.swal2-container:not(.swal2-top):not(.swal2-top-start):not(.swal2-top-end):not(.swal2-top-left):not(.swal2-top-right):not(.swal2-center-start):not(.swal2-center-end):not(.swal2-center-left):not(.swal2-center-right):not(.swal2-bottom):not(.swal2-bottom-start):not(.swal2-bottom-end):not(.swal2-bottom-left):not(.swal2-bottom-right):not(.swal2-grow-fullscreen)>.swal2-modal{margin:auto}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-container .swal2-modal{margin:0!important}}.swal2-container.swal2-fade{transition:background-color .1s}.swal2-container.swal2-shown{background-color:rgba(0,0,0,.4)}.swal2-popup{display:none;position:relative;flex-direction:column;justify-content:center;width:32em;max-width:100%;padding:1.25em;border-radius:.3125em;background:#fff;font-family:inherit;font-size:1rem;box-sizing:border-box}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-popup .swal2-header{display:flex;flex-direction:column;align-items:center}.swal2-popup .swal2-title{display:block;position:relative;max-width:100%;margin:0 0 .4em;padding:0;color:#595959;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-popup .swal2-actions{flex-wrap:wrap;align-items:center;justify-content:center;margin:1.25em auto 0;z-index:1}.swal2-popup .swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-popup .swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-popup .swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-popup .swal2-actions.swal2-loading .swal2-styled.swal2-confirm{width:2.5em;height:2.5em;margin:.46875em;padding:0;border:.25em solid transparent;border-radius:100%;border-color:transparent;background-color:transparent!important;color:transparent;cursor:default;box-sizing:border-box;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-popup .swal2-actions.swal2-loading .swal2-styled.swal2-cancel{margin-right:30px;margin-left:30px}.swal2-popup .swal2-actions.swal2-loading :not(.swal2-styled).swal2-confirm::after{display:inline-block;width:15px;height:15px;margin-left:5px;border:3px solid #999;border-radius:50%;border-right-color:transparent;box-shadow:1px 1px 1px #fff;content:'';-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal}.swal2-popup .swal2-styled{margin:.3125em;padding:.625em 2em;font-weight:500;box-shadow:none}.swal2-popup .swal2-styled:not([disabled]){cursor:pointer}.swal2-popup .swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#3085d6;color:#fff;font-size:1.0625em}.swal2-popup .swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#aaa;color:#fff;font-size:1.0625em}.swal2-popup .swal2-styled:focus{outline:0;box-shadow:0 0 0 2px #fff,0 0 0 4px rgba(50,100,150,.4)}.swal2-popup .swal2-styled::-moz-focus-inner{border:0}.swal2-popup .swal2-footer{justify-content:center;margin:1.25em 0 0;padding:1em 0 0;border-top:1px solid #eee;color:#545454;font-size:1em}.swal2-popup .swal2-image{max-width:100%;margin:1.25em auto}.swal2-popup .swal2-close{position:absolute;top:0;right:0;justify-content:center;width:1.2em;height:1.2em;padding:0;transition:color .1s ease-out;border:none;border-radius:0;background:0 0;color:#ccc;font-family:serif;font-size:2.5em;line-height:1.2;cursor:pointer;overflow:hidden}.swal2-popup .swal2-close:hover{-webkit-transform:none;transform:none;color:#f27474}.swal2-popup>.swal2-checkbox,.swal2-popup>.swal2-file,.swal2-popup>.swal2-input,.swal2-popup>.swal2-radio,.swal2-popup>.swal2-select,.swal2-popup>.swal2-textarea{display:none}.swal2-popup .swal2-content{justify-content:center;margin:0;padding:0;color:#545454;font-size:1.125em;font-weight:300;line-height:normal;z-index:1;word-wrap:break-word}.swal2-popup #swal2-content{text-align:center}.swal2-popup .swal2-checkbox,.swal2-popup .swal2-file,.swal2-popup .swal2-input,.swal2-popup .swal2-radio,.swal2-popup .swal2-select,.swal2-popup .swal2-textarea{margin:1em auto}.swal2-popup .swal2-file,.swal2-popup .swal2-input,.swal2-popup .swal2-textarea{width:100%;transition:border-color .3s,box-shadow .3s;border:1px solid #d9d9d9;border-radius:.1875em;font-size:1.125em;box-shadow:inset 0 1px 1px rgba(0,0,0,.06);box-sizing:border-box}.swal2-popup .swal2-file.swal2-inputerror,.swal2-popup .swal2-input.swal2-inputerror,.swal2-popup .swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-popup .swal2-file:focus,.swal2-popup .swal2-input:focus,.swal2-popup .swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:0 0 3px #c4e6f5}.swal2-popup .swal2-file::-webkit-input-placeholder,.swal2-popup .swal2-input::-webkit-input-placeholder,.swal2-popup .swal2-textarea::-webkit-input-placeholder{color:#ccc}.swal2-popup .swal2-file:-ms-input-placeholder,.swal2-popup .swal2-input:-ms-input-placeholder,.swal2-popup .swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-popup .swal2-file::-ms-input-placeholder,.swal2-popup .swal2-input::-ms-input-placeholder,.swal2-popup .swal2-textarea::-ms-input-placeholder{color:#ccc}.swal2-popup .swal2-file::placeholder,.swal2-popup .swal2-input::placeholder,.swal2-popup .swal2-textarea::placeholder{color:#ccc}.swal2-popup .swal2-range input{width:80%}.swal2-popup .swal2-range output{width:20%;font-weight:600;text-align:center}.swal2-popup .swal2-range input,.swal2-popup .swal2-range output{height:2.625em;margin:1em auto;padding:0;font-size:1.125em;line-height:2.625em}.swal2-popup .swal2-input{height:2.625em;padding:0 .75em}.swal2-popup .swal2-input[type=number]{max-width:10em}.swal2-popup .swal2-file{font-size:1.125em}.swal2-popup .swal2-textarea{height:6.75em;padding:.75em}.swal2-popup .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;color:#545454;font-size:1.125em}.swal2-popup .swal2-checkbox,.swal2-popup .swal2-radio{align-items:center;justify-content:center}.swal2-popup .swal2-checkbox label,.swal2-popup .swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-popup .swal2-checkbox input,.swal2-popup .swal2-radio input{margin:0 .4em}.swal2-popup .swal2-validation-message{display:none;align-items:center;justify-content:center;padding:.625em;background:#f0f0f0;color:#666;font-size:1em;font-weight:300;overflow:hidden}.swal2-popup .swal2-validation-message::before{display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center;content:'!';zoom:normal}@supports (-ms-accelerator:true){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@media all and (-ms-high-contrast:none),(-ms-high-contrast:active){.swal2-range input{width:100%!important}.swal2-range output{display:none}}@-moz-document url-prefix(){.swal2-close:focus{outline:2px solid rgba(50,100,150,.4)}}.swal2-icon{position:relative;justify-content:center;width:5em;height:5em;margin:1.25em auto 1.875em;border:.25em solid transparent;border-radius:50%;line-height:5em;cursor:default;box-sizing:content-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;zoom:normal}.swal2-icon-text{font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-success{border-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;-webkit-transform:rotate(45deg);transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:3.75em 3.75em;transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:0 3.75em;transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;top:-.25em;left:-.25em;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%;z-index:2;box-sizing:content-box}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;top:.5em;left:1.625em;width:.4375em;height:5.625em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);z-index:1}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;height:.3125em;border-radius:.125em;background-color:#a5dc86;z-index:2}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.875em;width:1.5625em;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal2-progresssteps{align-items:center;margin:0 0 1.25em;padding:0;font-weight:600}.swal2-progresssteps li{display:inline-block;position:relative}.swal2-progresssteps .swal2-progresscircle{width:2em;height:2em;border-radius:2em;background:#3085d6;color:#fff;line-height:2em;text-align:center;z-index:20}.swal2-progresssteps .swal2-progresscircle:first-child{margin-left:0}.swal2-progresssteps .swal2-progresscircle:last-child{margin-right:0}.swal2-progresssteps .swal2-progresscircle.swal2-activeprogressstep{background:#3085d6}.swal2-progresssteps .swal2-progresscircle.swal2-activeprogressstep~.swal2-progresscircle{background:#add8e6}.swal2-progresssteps .swal2-progresscircle.swal2-activeprogressstep~.swal2-progressline{background:#add8e6}.swal2-progresssteps .swal2-progressline{width:2.5em;height:.4em;margin:0 -1px;background:#3085d6;z-index:10}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-show.swal2-noanimation{-webkit-animation:none;animation:none}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-hide.swal2-noanimation{-webkit-animation:none;animation:none}.swal2-rtl .swal2-close{right:auto;left:0}.swal2-animate-success-icon .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-animate-success-icon .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-animate-success-icon .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-animate-error-icon{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-animate-error-icon .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}@-webkit-keyframes swal2-rotate-loading{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:initial!important}}");
},{}],"VPle":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _apiStatusCodes = _interopRequireDefault(require("../utils/api-status-codes"));

var _inputWithIcon = _interopRequireDefault(require("../components/input-with-icon"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["mutation attemptUserLogin($organization_name: String!, $email: String!, $password: String!) {\n           login(organization_name: $organization_name, email: $email, password: $password) {\n            token,\n            user {\n              id,\n              first_name,\n              last_name,\n              email,\n              phone_number,\n              role,\n              status\n            }\n          }\n        }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["mutation attemptRequestPasswordReset($email: String!) {\n              requestPasswordReset(email: $email)\n            }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'Login',
  components: {
    InputWithIcon: _inputWithIcon.default,
    ExtendedFab: _extendedFab.default
  },
  data: function data() {
    var states = {
      INITIAL: {
        show: false
      },
      AUTHENTICATING: {
        show: false
      },
      INCORRECT_CREDENTIALS: {
        show: true,
        text: 'Invalid Username/Password',
        class: 'incorrect-credentials'
      },
      NEED_ORG_NAME: {
        show: true,
        text: 'Organization Name Required',
        class: 'need-org-name'
      },
      GENERIC_ERROR: {
        show: true,
        text: 'An Unknown Error Ocurred. Please Try Again or Contact Support',
        class: 'generic-error'
      },
      NETWORK_ERROR: {
        show: true,
        text: 'Network Error. Please Try Again',
        class: 'network-error'
      }
    };
    return {
      organizationName: '',
      username: '',
      domain: '@renascentinc.com',
      password: '',
      currentState: states.INITIAL,
      states: states
    };
  },
  computed: {
    email: function email() {
      if (this.username.indexOf('@') > -1) {
        return this.username;
      }

      return "".concat(this.username).concat(this.domain);
    }
  },
  beforeRouteEnter: function beforeRouteEnter(to, from, next) {
    window.localStorage.getItem('token') ? next('/') : next();
  },
  methods: {
    showPasswordResetError: function showPasswordResetError() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'RESET FAILURE',
        text: 'There was an error trying to request a password reset. Please make sure you typed in the correct email. If the issue persists please contact support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    requestPasswordReset: function requestPasswordReset() {
      var _this = this;

      (0, _sweetalert.default)({
        title: 'RESET PASSWORD',
        text: 'Enter your email address',
        input: 'email',
        inputPlaceholder: 'email@example.com',
        reverseButtons: true,
        showCancelButton: true,
        cancelButtonText: 'CANCEL',
        confirmButtonText: 'SUBMIT',
        confirmButtonColor: '#404040'
      }).then(function (result) {
        if (result && result.value) {
          _this.$apollo.mutate({
            mutation: (0, _graphqlTag.default)(_templateObject()),
            variables: {
              email: result.value
            }
          }).then(function (response) {
            if (!response.data.requestPasswordReset) {
              _this.showPasswordResetError();
            }
          }).catch(function () {
            _this.showPasswordResetError();
          });

          (0, _sweetalert.default)({
            type: 'success',
            text: 'Instructions for resetting your password will be sent to your email',
            timer: 2000,
            showConfirmButton: false
          });
        }
      });
    },
    attemptUserLogin: function attemptUserLogin() {
      var _this2 = this;

      this.currentState = this.states.AUTHENTICATING;
      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject2()),
        variables: {
          organization_name: this.organizationName,
          email: this.email,
          password: this.password
        }
      }).then(function (result) {
        var _result$data$login = result.data.login,
            token = _result$data$login.token,
            user = _result$data$login.user;
        user.full_name = "".concat(user.first_name, " ").concat(user.last_name);
        window.localStorage.setItem('token', token);
        window.localStorage.setItem('currentUser', JSON.stringify(user));

        _this2.$router.push({
          path: '/'
        });
      }).catch(function (error) {
        if (error.graphQLErrors && error.graphQLErrors.length) {
          var _error$graphQLErrors = _slicedToArray(error.graphQLErrors, 1),
              code = _error$graphQLErrors[0].extensions.code;

          if (code === _apiStatusCodes.default.UNAUTHENTICATED) {
            _this2.currentState = _this2.states.INCORRECT_CREDENTIALS;
          } else if (code === _apiStatusCodes.default.INSUFFICIENT_INFORMATION) {
            _this2.currentState = _this2.states.NEED_ORG_NAME;
          } else {
            _this2.currentState = _this2.states.GENERIC_ERROR;
          }
        } else if (error.networkError) {
          // remove token just in case a stale one happens to be sitting around.
          // theoretically should never happen but if it ever did the user would
          // be unable to login without clearing their localStorage
          _this2.currentState = _this2.states.NETWORK_ERROR;
        } else {
          _this2.currentState = _this2.states.GENERIC_ERROR;
        }
      });
    }
  }
};
exports.default = _default;
        var $afa8cf = exports.default || module.exports;
      
      if (typeof $afa8cf === 'function') {
        $afa8cf = $afa8cf.options;
      }
    
        /* template */
        Object.assign($afa8cf, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page login-page",class:_vm.$mq},[_c('transition',{attrs:{"name":"fade"}},[(_vm.currentState === _vm.states.AUTHENTICATING)?_c('div',{staticClass:"overlay"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_vm._m(0),_vm._v(" "),_c('div',{staticClass:"bottom-panel"},[_c('div',{staticClass:"status-message"},[_c('transition',{attrs:{"name":"fade"}},[(_vm.currentState.show)?_c('span',{class:_vm.currentState.class},[_vm._v("\n          "+_vm._s(_vm.currentState.text)+"\n        ")]):_vm._e()])],1),_vm._v(" "),_c('div',{staticClass:"login-inputs-container"},[_c('input-with-icon',{staticClass:"email-container",attrs:{"icon-class":"fa-user"}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.username),expression:"username"}],staticClass:"username-input",attrs:{"placeholder":"username","autocorrect":"off","autocapitalize":"off","spellcheck":"false"},domProps:{"value":(_vm.username)},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.attemptUserLogin($event)},"input":function($event){if($event.target.composing){ return; }_vm.username=$event.target.value}}})]),_vm._v(" "),_c('input-with-icon',{staticClass:"password-container",attrs:{"icon-class":"fa-key"}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.password),expression:"password"}],staticClass:"password-input",attrs:{"placeholder":"password","type":"password"},domProps:{"value":(_vm.password)},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.attemptUserLogin($event)},"input":function($event){if($event.target.composing){ return; }_vm.password=$event.target.value}}})]),_vm._v(" "),_c('input-with-icon',{staticClass:"organization-container",class:{ show: _vm.currentState === _vm.states.NEED_ORG_NAME },attrs:{"icon-class":"fa-building"}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.organizationName),expression:"organizationName"}],staticClass:"org-name-input",attrs:{"placeholder":"organization name","autocorrect":"off","autocapitalize":"off","spellcheck":"false"},domProps:{"value":(_vm.organizationName)},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.attemptUserLogin($event)},"input":function($event){if($event.target.composing){ return; }_vm.organizationName=$event.target.value}}})])],1),_vm._v(" "),_c('div',{staticClass:"login-action-row"},[_c('button',{staticClass:"reset-password",on:{"click":_vm.requestPasswordReset}},[_vm._v("\n        FORGOT PASSWORD?\n      ")]),_vm._v(" "),_c('extended-fab',{staticClass:"login-btn",attrs:{"on-click":_vm.attemptUserLogin,"icon-class":"fa-arrow-right","button-text":"SIGN IN"}})],1)])],1)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"top-panel"},[_c('img',{staticClass:"logo",attrs:{"src":"red_transparent_512x512.c01ec64a.png"}}),_vm._v(" "),_c('div',{staticClass:"name-container"},[_c('span',{staticClass:"retina-name"},[_vm._v("\n        RETINA\n      ")]),_vm._v(" "),_c('span',{staticClass:"renascent-name"},[_vm._v("\n        Renascent, Inc.\n      ")])])])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"graphql-tag":"MbWf","../utils/api-status-codes":"8A9v","../components/input-with-icon":"f46C","../components/extended-fab":"9Y+B","sweetalert2":"Y8u2","./../assets/icons/web/red_transparent_512x512.png":[["red_transparent_512x512.c01ec64a.png","JDi5"],"JDi5"]}],"1JEr":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (t, n) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = n() : "function" == typeof define && define.amd ? define([], n) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.VueAvatar = n() : t.VueAvatar = n();
}(this, function () {
  return function (t) {
    function n(r) {
      if (e[r]) return e[r].exports;
      var o = e[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return t[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
    }

    var e = {};
    return n.m = t, n.c = e, n.d = function (t, e, r) {
      n.o(t, e) || Object.defineProperty(t, e, {
        configurable: !1,
        enumerable: !0,
        get: r
      });
    }, n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t.default;
      } : function () {
        return t;
      };
      return n.d(e, "a", e), e;
    }, n.o = function (t, n) {
      return Object.prototype.hasOwnProperty.call(t, n);
    }, n.p = "/", n(n.s = 9);
  }([function (t, n) {
    var e = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = e);
  }, function (t, n) {
    t.exports = function (t) {
      return "object" == _typeof(t) ? null !== t : "function" == typeof t;
    };
  }, function (t, n, e) {
    t.exports = !e(3)(function () {
      return 7 != Object.defineProperty({}, "a", {
        get: function () {
          return 7;
        }
      }).a;
    });
  }, function (t, n) {
    t.exports = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  }, function (t, n) {
    var e = t.exports = {
      version: "2.5.1"
    };
    "number" == typeof __e && (__e = e);
  }, function (t, n, e) {
    var r = e(6),
        o = e(7);

    t.exports = function (t) {
      return r(o(t));
    };
  }, function (t, n, e) {
    var r = e(30);
    t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
      return "String" == r(t) ? t.split("") : Object(t);
    };
  }, function (t, n) {
    t.exports = function (t) {
      if (void 0 == t) throw TypeError("Can't call method on  " + t);
      return t;
    };
  }, function (t, n) {
    var e = Math.ceil,
        r = Math.floor;

    t.exports = function (t) {
      return isNaN(t = +t) ? 0 : (t > 0 ? r : e)(t);
    };
  }, function (t, n, e) {
    "use strict";

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.Avatar = void 0;

    var r = e(10),
        o = function (t) {
      return t && t.__esModule ? t : {
        default: t
      };
    }(r);

    n.Avatar = o.default, n.default = o.default;
  }, function (t, n, e) {
    "use strict";

    Object.defineProperty(n, "__esModule", {
      value: !0
    });
    var r = e(12),
        o = e.n(r),
        i = e(41),
        u = e(11),
        a = u(o.a, i.a, !1, null, null, null);
    n.default = a.exports;
  }, function (t, n) {
    t.exports = function (t, n, e, r, o, i) {
      var u,
          a = t = t || {},
          c = _typeof(t.default);

      "object" !== c && "function" !== c || (u = t, a = t.default);
      var s = "function" == typeof a ? a.options : a;
      n && (s.render = n.render, s.staticRenderFns = n.staticRenderFns, s._compiled = !0), e && (s.functional = !0), o && (s._scopeId = o);
      var f;

      if (i ? (f = function (t) {
        t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, t || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), r && r.call(this, t), t && t._registeredComponents && t._registeredComponents.add(i);
      }, s._ssrRegister = f) : r && (f = r), f) {
        var l = s.functional,
            p = l ? s.render : s.beforeCreate;
        l ? (s._injectStyles = f, s.render = function (t, n) {
          return f.call(n), p(t, n);
        }) : s.beforeCreate = p ? [].concat(p, f) : [f];
      }

      return {
        esModule: u,
        exports: a,
        options: s
      };
    };
  }, function (t, n, e) {
    "use strict";

    Object.defineProperty(n, "__esModule", {
      value: !0
    });

    var r = e(13),
        o = function (t) {
      return t && t.__esModule ? t : {
        default: t
      };
    }(r);

    n.default = {
      name: "avatar",
      props: {
        username: {
          type: String
        },
        initials: {
          type: String
        },
        backgroundColor: {
          type: String
        },
        color: {
          type: String
        },
        customStyle: {
          type: Object
        },
        inline: {
          type: Boolean
        },
        size: {
          type: Number,
          default: 50
        },
        src: {
          type: String
        },
        rounded: {
          type: Boolean,
          default: !0
        },
        lighten: {
          type: Number,
          default: 80
        }
      },
      data: function () {
        return {
          backgroundColors: ["#F44336", "#FF4081", "#9C27B0", "#673AB7", "#3F51B5", "#2196F3", "#03A9F4", "#00BCD4", "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFC107", "#FF9800", "#FF5722", "#795548", "#9E9E9E", "#607D8B"]
        };
      },
      mounted: function () {
        this.isImage || this.$emit("avatar-initials", this.username, this.userInitial);
      },
      computed: {
        background: function () {
          if (!this.isImage) return this.backgroundColor || this.randomBackgroundColor(this.username.length, this.backgroundColors);
        },
        fontColor: function () {
          if (!this.isImage) return this.color || this.lightenColor(this.background, this.lighten);
        },
        isImage: function () {
          return Boolean(this.src);
        },
        style: function () {
          var t = {
            display: this.inline ? "inline-flex" : "flex",
            width: this.size + "px",
            height: this.size + "px",
            borderRadius: this.rounded ? "50%" : 0,
            lineHeight: this.size + Math.floor(this.size / 20) + "px",
            fontWeight: "bold",
            alignItems: "center",
            justifyContent: "center"
          },
              n = {
            background: "transparent url('" + this.src + "') no-repeat scroll 0% 0% / " + this.size + "px " + this.size + "px content-box border-box"
          },
              e = {
            backgroundColor: this.background,
            font: Math.floor(this.size / 2.5) + "px/100px Helvetica, Arial, sans-serif",
            color: this.fontColor
          },
              r = this.isImage ? n : e;
          return (0, o.default)(t, r), t;
        },
        userInitial: function () {
          if (!this.isImage) {
            return this.initials || this.initial(this.username);
          }

          return "";
        }
      },
      methods: {
        initial: function (t) {
          for (var n = t.split(/[ -]/), e = "", r = 0; r < n.length; r++) e += n[r].charAt(0);

          return e.length > 3 && -1 !== e.search(/[A-Z]/) && (e = e.replace(/[a-z]+/g, "")), e = e.substr(0, 3).toUpperCase();
        },
        randomBackgroundColor: function (t, n) {
          return n[t % n.length];
        },
        lightenColor: function (t, n) {
          var e = !1;
          "#" === t[0] && (t = t.slice(1), e = !0);
          var r = parseInt(t, 16),
              o = (r >> 16) + n;
          o > 255 ? o = 255 : o < 0 && (o = 0);
          var i = (r >> 8 & 255) + n;
          i > 255 ? i = 255 : i < 0 && (i = 0);
          var u = (255 & r) + n;
          return u > 255 ? u = 255 : u < 0 && (u = 0), (e ? "#" : "") + (u | i << 8 | o << 16).toString(16);
        }
      }
    };
  }, function (t, n, e) {
    t.exports = {
      default: e(14),
      __esModule: !0
    };
  }, function (t, n, e) {
    e(15), t.exports = e(4).Object.assign;
  }, function (t, n, e) {
    var r = e(16);
    r(r.S + r.F, "Object", {
      assign: e(26)
    });
  }, function (t, n, e) {
    var r = e(0),
        o = e(4),
        i = e(17),
        u = e(19),
        a = function (t, n, e) {
      var c,
          s,
          f,
          l = t & a.F,
          p = t & a.G,
          d = t & a.S,
          h = t & a.P,
          v = t & a.B,
          y = t & a.W,
          g = p ? o : o[n] || (o[n] = {}),
          b = g.prototype,
          x = p ? r : d ? r[n] : (r[n] || {}).prototype;
      p && (e = n);

      for (c in e) (s = !l && x && void 0 !== x[c]) && c in g || (f = s ? x[c] : e[c], g[c] = p && "function" != typeof x[c] ? e[c] : v && s ? i(f, r) : y && x[c] == f ? function (t) {
        var n = function (n, e, r) {
          if (this instanceof t) {
            switch (arguments.length) {
              case 0:
                return new t();

              case 1:
                return new t(n);

              case 2:
                return new t(n, e);
            }

            return new t(n, e, r);
          }

          return t.apply(this, arguments);
        };

        return n.prototype = t.prototype, n;
      }(f) : h && "function" == typeof f ? i(Function.call, f) : f, h && ((g.virtual || (g.virtual = {}))[c] = f, t & a.R && b && !b[c] && u(b, c, f)));
    };

    a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, a.U = 64, a.R = 128, t.exports = a;
  }, function (t, n, e) {
    var r = e(18);

    t.exports = function (t, n, e) {
      if (r(t), void 0 === n) return t;

      switch (e) {
        case 1:
          return function (e) {
            return t.call(n, e);
          };

        case 2:
          return function (e, r) {
            return t.call(n, e, r);
          };

        case 3:
          return function (e, r, o) {
            return t.call(n, e, r, o);
          };
      }

      return function () {
        return t.apply(n, arguments);
      };
    };
  }, function (t, n) {
    t.exports = function (t) {
      if ("function" != typeof t) throw TypeError(t + " is not a function!");
      return t;
    };
  }, function (t, n, e) {
    var r = e(20),
        o = e(25);
    t.exports = e(2) ? function (t, n, e) {
      return r.f(t, n, o(1, e));
    } : function (t, n, e) {
      return t[n] = e, t;
    };
  }, function (t, n, e) {
    var r = e(21),
        o = e(22),
        i = e(24),
        u = Object.defineProperty;
    n.f = e(2) ? Object.defineProperty : function (t, n, e) {
      if (r(t), n = i(n, !0), r(e), o) try {
        return u(t, n, e);
      } catch (t) {}
      if ("get" in e || "set" in e) throw TypeError("Accessors not supported!");
      return "value" in e && (t[n] = e.value), t;
    };
  }, function (t, n, e) {
    var r = e(1);

    t.exports = function (t) {
      if (!r(t)) throw TypeError(t + " is not an object!");
      return t;
    };
  }, function (t, n, e) {
    t.exports = !e(2) && !e(3)(function () {
      return 7 != Object.defineProperty(e(23)("div"), "a", {
        get: function () {
          return 7;
        }
      }).a;
    });
  }, function (t, n, e) {
    var r = e(1),
        o = e(0).document,
        i = r(o) && r(o.createElement);

    t.exports = function (t) {
      return i ? o.createElement(t) : {};
    };
  }, function (t, n, e) {
    var r = e(1);

    t.exports = function (t, n) {
      if (!r(t)) return t;
      var e, o;
      if (n && "function" == typeof (e = t.toString) && !r(o = e.call(t))) return o;
      if ("function" == typeof (e = t.valueOf) && !r(o = e.call(t))) return o;
      if (!n && "function" == typeof (e = t.toString) && !r(o = e.call(t))) return o;
      throw TypeError("Can't convert object to primitive value");
    };
  }, function (t, n) {
    t.exports = function (t, n) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: n
      };
    };
  }, function (t, n, e) {
    "use strict";

    var r = e(27),
        o = e(38),
        i = e(39),
        u = e(40),
        a = e(6),
        c = Object.assign;
    t.exports = !c || e(3)(function () {
      var t = {},
          n = {},
          e = Symbol(),
          r = "abcdefghijklmnopqrst";
      return t[e] = 7, r.split("").forEach(function (t) {
        n[t] = t;
      }), 7 != c({}, t)[e] || Object.keys(c({}, n)).join("") != r;
    }) ? function (t, n) {
      for (var e = u(t), c = arguments.length, s = 1, f = o.f, l = i.f; c > s;) for (var p, d = a(arguments[s++]), h = f ? r(d).concat(f(d)) : r(d), v = h.length, y = 0; v > y;) l.call(d, p = h[y++]) && (e[p] = d[p]);

      return e;
    } : c;
  }, function (t, n, e) {
    var r = e(28),
        o = e(37);

    t.exports = Object.keys || function (t) {
      return r(t, o);
    };
  }, function (t, n, e) {
    var r = e(29),
        o = e(5),
        i = e(31)(!1),
        u = e(34)("IE_PROTO");

    t.exports = function (t, n) {
      var e,
          a = o(t),
          c = 0,
          s = [];

      for (e in a) e != u && r(a, e) && s.push(e);

      for (; n.length > c;) r(a, e = n[c++]) && (~i(s, e) || s.push(e));

      return s;
    };
  }, function (t, n) {
    var e = {}.hasOwnProperty;

    t.exports = function (t, n) {
      return e.call(t, n);
    };
  }, function (t, n) {
    var e = {}.toString;

    t.exports = function (t) {
      return e.call(t).slice(8, -1);
    };
  }, function (t, n, e) {
    var r = e(5),
        o = e(32),
        i = e(33);

    t.exports = function (t) {
      return function (n, e, u) {
        var a,
            c = r(n),
            s = o(c.length),
            f = i(u, s);

        if (t && e != e) {
          for (; s > f;) if ((a = c[f++]) != a) return !0;
        } else for (; s > f; f++) if ((t || f in c) && c[f] === e) return t || f || 0;

        return !t && -1;
      };
    };
  }, function (t, n, e) {
    var r = e(8),
        o = Math.min;

    t.exports = function (t) {
      return t > 0 ? o(r(t), 9007199254740991) : 0;
    };
  }, function (t, n, e) {
    var r = e(8),
        o = Math.max,
        i = Math.min;

    t.exports = function (t, n) {
      return t = r(t), t < 0 ? o(t + n, 0) : i(t, n);
    };
  }, function (t, n, e) {
    var r = e(35)("keys"),
        o = e(36);

    t.exports = function (t) {
      return r[t] || (r[t] = o(t));
    };
  }, function (t, n, e) {
    var r = e(0),
        o = r["__core-js_shared__"] || (r["__core-js_shared__"] = {});

    t.exports = function (t) {
      return o[t] || (o[t] = {});
    };
  }, function (t, n) {
    var e = 0,
        r = Math.random();

    t.exports = function (t) {
      return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++e + r).toString(36));
    };
  }, function (t, n) {
    t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }, function (t, n) {
    n.f = Object.getOwnPropertySymbols;
  }, function (t, n) {
    n.f = {}.propertyIsEnumerable;
  }, function (t, n, e) {
    var r = e(7);

    t.exports = function (t) {
      return Object(r(t));
    };
  }, function (t, n, e) {
    "use strict";

    var r = function () {
      var t = this,
          n = t.$createElement,
          e = t._self._c || n;
      return e("div", {
        staticClass: "vue-avatar--wrapper",
        style: [t.style, t.customStyle]
      }, [e("span", {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !this.isImage,
          expression: "!this.isImage"
        }]
      }, [t._v(t._s(t.userInitial))])]);
    },
        o = [],
        i = {
      render: r,
      staticRenderFns: o
    };

    n.a = i;
  }]);
});
},{}],"kMnB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  beforeRouteEnter: function beforeRouteEnter(to, from, next) {
    window.localStorage.getItem('token') ? next() : next('/login');
  }
};
exports.default = _default;
},{}],"O2n5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  IOS: 'iOS',
  ANDROID: 'Android',
  WINDOWS: 'Windows',
  OSX: 'OSX'
};
exports.default = _default;
},{}],"eLa2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _platforms = _interopRequireDefault(require("../utils/platforms"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _default = {
  beforeDestroy: function beforeDestroy() {
    if (this.nfcListenerAdded) {
      window.nfc.removeNdefListener(this.callback);
    }
  },
  data: function data() {
    var _this = this;

    return {
      nfcListenerAdded: false,
      nfcListenerEnabled: false,
      callback: function callback(tag) {
        return _this._initialNfcCallback(tag);
      }
    };
  },
  computed: {
    isNfcEnabled: function isNfcEnabled() {
      return !!window.nfc && window.nfc.enabled;
    },
    isNfcWriteEnabled: function isNfcWriteEnabled() {
      return this.isNfcEnabled && window.device.platform === _platforms.default.ANDROID;
    }
  },
  methods: {
    showReadyToScanModal: function showReadyToScanModal() {
      var _this2 = this;

      (0, _sweetalert.default)({
        title: 'READY TO SCAN',
        html: '<svg version="1.1" viewBox="0 0 24 24" class="svg-icon svg-fill" style="width: 200px; height: 200px;"><path pid="0" d="M4 20h16V4H4v16z" _fill="none"></path><path pid="1" d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H4V4h16v16zM18 6h-5c-1.1 0-2 .9-2 2v2.28c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V8h3v8H8V8h2V6H6v12h12V6z"></path><path pid="2" d="M0 0h24v24H0z" _fill="none"></path></svg>',
        showConfirmButton: false,
        showCancelButton: true
      }).then(function (_ref) {
        var dismiss = _ref.dismiss;

        if (dismiss) {
          _this2.pauseNfcListener();
        }
      });
    },
    checkIsNfcEnabled: function checkIsNfcEnabled() {
      return !!window.nfc && window.nfc.enabled;
    },
    _nfcCallback: function _nfcCallback(param) {
      var value = '';

      if (param && param.tag && param.tag.ndefMessage) {
        var _param$tag$ndefMessag = _slicedToArray(param.tag.ndefMessage, 1),
            payload = _param$tag$ndefMessag[0].payload;

        value = String.fromCharCode.apply(String, _toConsumableArray(payload)).slice(3);

        var _value$split = value.split(' - '),
            _value$split2 = _slicedToArray(_value$split, 1),
            id = _value$split2[0];

        if (id) {
          value = id;
        }
      }

      this.nfcCallback(value);
    },
    _initialNfcCallback: function _initialNfcCallback(tag) {
      if (this.nfcListenerEnabled) {
        this._nfcCallback(tag);

        this.pauseNfcListener();
      }
    },
    startNfcListener: function startNfcListener(callback) {
      var _this3 = this;

      var setup = function setup() {
        _this3.nfcListenerEnabled = true;

        if (!_this3.nfcListenerAdded) {
          window.nfc.addNdefListener(_this3.callback);
          _this3.nfcListenerAdded = true;
        }
      };

      if (window.device.platform === _platforms.default.IOS) {
        window.nfc.beginSession(setup);
      } else {
        setup();
      }
    },
    pauseNfcListener: function pauseNfcListener() {
      this.nfcListenerEnabled = false;
    },
    nfcCallback: function nfcCallback() {// default noop callback for nfc
    }
  }
};
exports.default = _default;
},{"../utils/platforms":"O2n5","sweetalert2":"Y8u2"}],"sJcJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vueAvatar = _interopRequireDefault(require("vue-avatar"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _authenticatedRoute = _interopRequireDefault(require("../mixins/authenticatedRoute"));

var _nfc = _interopRequireDefault(require("../mixins/nfc"));

var _platforms = _interopRequireDefault(require("../utils/platforms"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["mutation changePassword($current_password: String!, $new_password: String!) {\n            updateCurrentUserPassword(current_password: $current_password, new_password: $new_password)\n          }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["mutation logout {\n           logout\n        }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'Application',
  components: {
    Avatar: _vueAvatar.default
  },
  mixins: [_authenticatedRoute.default, _nfc.default],
  data: function data() {
    return {
      passwordResetLoading: false
    };
  },
  computed: {
    currentUser: function currentUser() {
      return JSON.parse(window.localStorage.getItem('currentUser'));
    },
    firstname: function firstname() {
      return this.currentUser.first_name;
    },
    lastname: function lastname() {
      return this.currentUser.last_name;
    },
    email: function email() {
      return this.currentUser.email;
    },
    role: function role() {
      return this.currentUser.role;
    },
    isAdmin: function isAdmin() {
      return this.currentUser.role === 'ADMINISTRATOR';
    }
  },
  mounted: function mounted() {
    if (this.checkIsNfcEnabled() && window.device.platform === _platforms.default.ANDROID) {
      // add a noop nfc listener to keep nfc scans on android from bubbling up to the OS
      window.nfc.addNdefListener(function () {
        return 0;
      });
    }
  },
  methods: {
    transitionToConfig: function transitionToConfig() {
      this.$router.push({
        name: 'configuration'
      });
      this.closeDrawer();
    },
    sendSupportEmail: function sendSupportEmail() {
      window.location = 'mailto:retinasupport@renascentinc.com';
    },
    closeDrawer: function closeDrawer() {
      this.$refs.drawer.toggle(false);
    },
    openDrawer: function openDrawer() {
      this.$refs.drawer.toggle(true);
    },
    signout: function signout() {
      var _this = this;

      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject())
      });
      setTimeout(function () {
        window.localStorage.removeItem('token');

        _this.$router.push({
          path: '/login'
        });
      }, 100);
    },
    changePassword: function changePassword() {
      var _this2 = this;

      (0, _sweetalert.default)({
        title: 'CHANGE PASSWORD',
        html: '<input id="current-password" type="password" class="swal2-input" placeholder="Current Password">' + '<input id="password" type="password" class="swal2-input" placeholder="New Password">' + '<input id="confirm-password" type="password" class="swal2-input" placeholder="Confirm New Password">',
        focusConfirm: true,
        showCancelButton: true,
        confirmButtonText: 'RESET',
        cancelButtonText: 'CANCEL',
        confirmButtonColor: '#404040',
        reverseButtons: true,
        preConfirm: function preConfirm() {
          var currentPassword = document.getElementById('current-password');
          var password = document.getElementById('password');
          var confirmPassword = document.getElementById('confirm-password');

          var reset = function reset() {
            _sweetalert.default.resetValidationMessage();

            currentPassword.classList.remove('error');
            confirmPassword.classList.remove('error');
            password.classList.remove('error');
          };

          if (!currentPassword.value) {
            _sweetalert.default.showValidationMessage('Current Password field is required');

            currentPassword.classList.add('error');
            setTimeout(reset, 3000);
            return false;
          }

          if (!password.value) {
            _sweetalert.default.showValidationMessage('New Password field is required');

            password.classList.add('error');
            setTimeout(reset, 3000);
            return false;
          }

          if (!confirmPassword.value) {
            _sweetalert.default.showValidationMessage('Confirm New Password field is required');

            confirmPassword.classList.add('error');
            setTimeout(reset, 3000);
            return false;
          }

          if (password.value !== confirmPassword.value) {
            _sweetalert.default.showValidationMessage('Passwords do not match');

            password.classList.add('error');
            confirmPassword.classList.add('error');
            setTimeout(reset, 3000);
            return false;
          }

          return [currentPassword.value, password.value];
        }
      }).then(function (result) {
        if (result.dismiss) {
          return;
        }

        var _result$value = _slicedToArray(result.value, 2),
            currentPassword = _result$value[0],
            newPassword = _result$value[1];

        _this2.$apollo.mutate({
          mutation: (0, _graphqlTag.default)(_templateObject2()),
          variables: {
            current_password: currentPassword,
            new_password: newPassword
          }
        }).then(function (_ref) {
          var updateCurrentUserPassword = _ref.data.updateCurrentUserPassword;

          if (updateCurrentUserPassword) {
            (0, _sweetalert.default)({
              type: 'success',
              title: 'SUCCESS',
              text: 'Successfully Changed Password',
              timer: 1500,
              showConfirmButton: false
            });
          } else {
            _this2.changePassword();

            _sweetalert.default.showValidationMessage('Current Password is invalid');
          }
        }).catch(function () {
          (0, _sweetalert.default)({
            type: 'error',
            title: 'ERROR',
            text: 'There was an error changing your password. Please try again or contact support',
            timer: 2000,
            showConfirmButton: false
          });
        });
      });
    }
  }
};
exports.default = _default;
        var $2809e0 = exports.default || module.exports;
      
      if (typeof $2809e0 === 'function') {
        $2809e0 = $2809e0.options;
      }
    
        /* template */
        Object.assign($2809e0, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"main-application",class:_vm.$mq},[_c('vue-drawer-layout',{ref:"drawer",attrs:{"drawer-width":270,"enable":false,"animatable":true,"backdrop":true,"content-drawable":_vm.$mq === 'desktop' ? true : false},on:{"mask-click":_vm.closeDrawer}},[_c('div',{staticClass:"drawer-content",attrs:{"slot":"drawer"},slot:"drawer"},[_c('div',{staticClass:"account-info"},[_c('avatar',{attrs:{"username":(_vm.firstname + " " + _vm.lastname)}}),_vm._v(" "),_c('span',{staticClass:"username"},[_c('span',[_vm._v(" "+_vm._s(_vm.firstname)+" ")]),_vm._v(" "),_c('span',[_vm._v(" "+_vm._s(_vm.lastname)+" ")])]),_vm._v(" "),_c('span',{staticClass:"role"},[_vm._v("\n          "+_vm._s(_vm.role)+"\n        ")]),_vm._v(" "),_c('span',{staticClass:"email"},[_vm._v("\n          "+_vm._s(_vm.email)+"\n        ")]),_vm._v(" "),_c('hr',{staticClass:"line"})],1),_vm._v(" "),_c('div',{staticClass:"menu-buttons"},[(_vm.isAdmin)?_c('button',{staticClass:"config menu-btn",on:{"click":_vm.transitionToConfig}},[_c('i',{staticClass:"fas menu-btn-icon fa-cog"}),_vm._v("\n          CONFIGURATION\n        ")]):_vm._e(),_vm._v(" "),_c('button',{staticClass:"help menu-btn",on:{"click":_vm.sendSupportEmail}},[_c('i',{staticClass:"fas menu-btn-icon fa-question-circle"}),_vm._v("\n          CONTACT SUPPORT\n        ")]),_vm._v(" "),_c('button',{staticClass:"change-password menu-btn",on:{"click":_vm.changePassword}},[_c('span',[_c('i',{staticClass:"fas menu-btn-icon fa-key"}),_vm._v("\n            CHANGE PASSWORD\n          ")])]),_vm._v(" "),_c('button',{staticClass:"sign-out menu-btn",on:{"click":_vm.signout}},[_c('i',{staticClass:"fas menu-btn-icon fa-sign-out-alt"}),_vm._v("\n          SIGN OUT\n        ")])])]),_vm._v(" "),_c('div',{staticClass:"main-content",attrs:{"slot":"content"},slot:"content"},[_c('transition',{attrs:{"name":"page-change"}},[_c('router-view')],1),_vm._v(" "),_c('div',{staticClass:"nav-bar"},[_c('div',{staticClass:"icon-text-container"},[_c('button',{staticClass:"fas fa-bars menu-icon",on:{"click":_vm.openDrawer}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n              MENU\n            ")])])]),_vm._v(" "),_c('div',{staticClass:"icon-text-container"},[_c('router-link',{staticClass:"fas fa-toolbox menu-icon",attrs:{"to":"/tools"}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n              TOOLS\n            ")])])],1),_vm._v(" "),_c('div',{staticClass:"icon-text-container"},[_c('router-link',{staticClass:"fas fa-book-open menu-icon",attrs:{"to":"/history"}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n              HISTORY\n            ")])])],1),_vm._v(" "),_c('div',{staticClass:"icon-text-container"},[_c('router-link',{staticClass:"fas fa-users menu-icon",attrs:{"to":"/users"}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n              USERS\n            ")])])],1)])],1)])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"vue-avatar":"1JEr","graphql-tag":"MbWf","../mixins/authenticatedRoute":"kMnB","../mixins/nfc":"eLa2","../utils/platforms":"O2n5","sweetalert2":"Y8u2"}],"xve9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'Login'
};
exports.default = _default;
        var $2a1ca8 = exports.default || module.exports;
      
      if (typeof $2a1ca8 === 'function') {
        $2a1ca8 = $2a1ca8.options;
      }
    
        /* template */
        Object.assign($2a1ca8, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page landing-page"},[_c('img',{staticClass:"logo",attrs:{"src":"red_transparent_512x512.c01ec64a.png"}}),_vm._v(" "),_c('span',{staticClass:"retina-name"},[_vm._v("\n    RETINA\n  ")])])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"./../assets/icons/web/red_transparent_512x512.png":[["red_transparent_512x512.c01ec64a.png","JDi5"],"JDi5"]}],"KW2a":[function(require,module,exports) {
var define;
!function(A,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.vueTagsInput=t():A.vueTagsInput=t()}("undefined"!=typeof self?self:this,function(){return function(A){function t(n){if(e[n])return e[n].exports;var a=e[n]={i:n,l:!1,exports:{}};return A[n].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var e={};return t.m=A,t.c=e,t.d=function(A,e,n){t.o(A,e)||Object.defineProperty(A,e,{configurable:!1,enumerable:!0,get:n})},t.n=function(A){var e=A&&A.__esModule?function(){return A.default}:function(){return A};return t.d(e,"a",e),e},t.o=function(A,t){return Object.prototype.hasOwnProperty.call(A,t)},t.p="/dist/",t(t.s=8)}([function(A,t){function e(A,t){var e=A[1]||"",a=A[3];if(!a)return e;if(t&&"function"==typeof btoa){var i=n(a);return[e].concat(a.sources.map(function(A){return"/*# sourceURL="+a.sourceRoot+A+" */"})).concat([i]).join("\n")}return""+e}function n(A){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(A))))+" */"}A.exports=function(A){var t=[];return t.toString=function(){return this.map(function(t){var n=e(t,A);return t[2]?"@media "+t[2]+"{"+n+"}":n}).join("")},t.i=function(A,e){"string"==typeof A&&(A=[[null,A,""]]);for(var n={},a=0;this.length>a;a++){var i=this[a][0];"number"==typeof i&&(n[i]=!0)}for(a=0;A.length>a;a++){var o=A[a];"number"==typeof o[0]&&n[o[0]]||(e&&!o[2]?o[2]=e:e&&(o[2]="("+o[2]+") and ("+e+")"),t.push(o))}},t}},function(A,t){A.exports="data:application/vnd.ms-fontobject;base64,aAUAAMQEAAABAAIAAAAAAAAAAAAAAAAAAAABAJABAAAAAExQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAUdPJHwAAAAAAAAAAAAAAAAAAAAAAAA4AaQBjAG8AbQBvAG8AbgAAAA4AUgBlAGcAdQBsAGEAcgAAABYAVgBlAHIAcwBpAG8AbgAgADEALgAwAAAADgBpAGMAbwBtAG8AbwBuAAAAAAAAAQAAAAsAgAADADBPUy8yDxIFrAAAALwAAABgY21hcBdW0okAAAEcAAAAVGdhc3AAAAAQAAABcAAAAAhnbHlmpZ+jMAAAAXgAAAD8aGVhZA/FmAgAAAJ0AAAANmhoZWEHgAPIAAACrAAAACRobXR4EgABvgAAAtAAAAAcbG9jYQCSAOIAAALsAAAAEG1heHAACQAfAAAC/AAAACBuYW1lmUoJ+wAAAxwAAAGGcG9zdAADAAAAAASkAAAAIAADA4ABkAAFAAACmQLMAAAAjwKZAswAAAHrADMBCQAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAEAAAOkCA8D/wABAA8AAQAAAAAEAAAAAAAAAAAAAACAAAAAAAAMAAAADAAAAHAABAAMAAAAcAAMAAQAAABwABAA4AAAACgAIAAIAAgABACDpAv/9//8AAAAAACDpAP/9//8AAf/jFwQAAwABAAAAAAAAAAAAAAABAAH//wAPAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAVgEBA74CgQAcAAABMhceARcWFwcmJy4BJyYjIgYHFyERFzY3PgE3NgIWSkNDbykpF2QQIB9VMzQ5P3AtnP6AmB0iIkspKAJVFxhSODlCIDMrKz4REislmgGAmhkVFBwICAABANYAgQMqAtUACwAAAQcXBycHJzcnNxc3Ayru7jzu7jzu7jzu7gKZ7u487u487u487u4AAQCSAIEDgAK9AAUAACUBFwEnNwGAAcQ8/gDuPPkBxDz+AO48AAAAAAEAAAAAAAAfydNRXw889QALBAAAAAAA1nUqGwAAAADWdSobAAAAAAO+AtUAAAAIAAIAAAAAAAAAAQAAA8D/wAAABAAAAAAAA74AAQAAAAAAAAAAAAAAAAAAAAcEAAAAAAAAAAAAAAACAAAABAAAVgQAANYEAACSAAAAAAAKABQAHgBQAGoAfgABAAAABwAdAAEAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEABwAAAAEAAAAAAAIABwBgAAEAAAAAAAMABwA2AAEAAAAAAAQABwB1AAEAAAAAAAUACwAVAAEAAAAAAAYABwBLAAEAAAAAAAoAGgCKAAMAAQQJAAEADgAHAAMAAQQJAAIADgBnAAMAAQQJAAMADgA9AAMAAQQJAAQADgB8AAMAAQQJAAUAFgAgAAMAAQQJAAYADgBSAAMAAQQJAAoANACkaWNvbW9vbgBpAGMAbwBtAG8AbwBuVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwaWNvbW9vbgBpAGMAbwBtAG8AbwBuaWNvbW9vbgBpAGMAbwBtAG8AbwBuUmVndWxhcgBSAGUAZwB1AGwAYQByaWNvbW9vbgBpAGMAbwBtAG8AbwBuRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="},function(A,t,e){function n(A){for(var t=0;A.length>t;t++){var e=A[t],n=l[e.id];if(n){n.refs++;for(var a=0;n.parts.length>a;a++)n.parts[a](e.parts[a]);for(;e.parts.length>a;a++)n.parts.push(i(e.parts[a]));n.parts.length>e.parts.length&&(n.parts.length=e.parts.length)}else{for(var o=[],a=0;e.parts.length>a;a++)o.push(i(e.parts[a]));l[e.id]={id:e.id,refs:1,parts:o}}}}function a(){var A=document.createElement("style");return A.type="text/css",c.appendChild(A),A}function i(A){var t,e,n=document.querySelector("style["+v+'~="'+A.id+'"]');if(n){if(p)return f;n.parentNode.removeChild(n)}if(h){var i=g++;n=d||(d=a()),t=o.bind(null,n,i,!1),e=o.bind(null,n,i,!0)}else n=a(),t=r.bind(null,n),e=function(){n.parentNode.removeChild(n)};return t(A),function(n){if(n){if(n.css===A.css&&n.media===A.media&&n.sourceMap===A.sourceMap)return;t(A=n)}else e()}}function o(A,t,e,n){var a=e?"":n.css;if(A.styleSheet)A.styleSheet.cssText=b(t,a);else{var i=document.createTextNode(a),o=A.childNodes;o[t]&&A.removeChild(o[t]),o.length?A.insertBefore(i,o[t]):A.appendChild(i)}}function r(A,t){var e=t.css,n=t.media,a=t.sourceMap;if(n&&A.setAttribute("media",n),m.ssrId&&A.setAttribute(v,t.id),a&&(e+="\n/*# sourceURL="+a.sources[0]+" */",e+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */"),A.styleSheet)A.styleSheet.cssText=e;else{for(;A.firstChild;)A.removeChild(A.firstChild);A.appendChild(document.createTextNode(e))}}var s="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!s)throw Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var u=e(15),l={},c=s&&(document.head||document.getElementsByTagName("head")[0]),d=null,g=0,p=!1,f=function(){},m=null,v="data-vue-ssr-id",h="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());A.exports=function(A,t,e,a){p=e,m=a||{};var i=u(A,t);return n(i),function(t){for(var e=[],a=0;i.length>a;a++){var o=i[a],r=l[o.id];r.refs--,e.push(r)}t?(i=u(A,t),n(i)):i=[];for(var a=0;e.length>a;a++){var r=e[a];if(0===r.refs){for(var s=0;r.parts.length>s;s++)r.parts[s]();delete l[r.id]}}}};var b=function(){var A=[];return function(t,e){return A[t]=e,A.filter(Boolean).join("\n")}}()},function(A,t){A.exports=function(A,t,e,n,a,i){var o,r=A=A||{},s=typeof A.default;"object"!==s&&"function"!==s||(o=A,r=A.default);var u="function"==typeof r?r.options:r;t&&(u.render=t.render,u.staticRenderFns=t.staticRenderFns,u._compiled=!0),e&&(u.functional=!0),a&&(u._scopeId=a);var l;if(i?(l=function(A){A=A||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,A||"undefined"==typeof __VUE_SSR_CONTEXT__||(A=__VUE_SSR_CONTEXT__),n&&n.call(this,A),A&&A._registeredComponents&&A._registeredComponents.add(i)},u._ssrRegister=l):n&&(l=n),l){var c=u.functional,d=c?u.render:u.beforeCreate;c?(u._injectStyles=l,u.render=function(A,t){return l.call(t),d(A,t)}):u.beforeCreate=d?[].concat(d,l):[l]}return{esModule:o,exports:r,options:u}}},function(A,t,e){"use strict";var n=e(16),a=e.n(n),i=e(5),o=e(6),r=e(20),s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(A){return typeof A}:function(A){return A&&"function"==typeof Symbol&&A.constructor===Symbol&&A!==Symbol.prototype?"symbol":typeof A};t.a={name:"VueTagsInput",components:{TagInput:o.a},props:r.a,data:function(){return{newTag:null,tagsCopy:null,tagsEditStatus:null,deletionMark:null,deletionMarkTime:null,selectedItem:null,focused:null}},computed:{autocompleteOpen:function(){return!!this.autocompleteAlwaysOpen||null!==this.newTag&&this.newTag.length>=this.autocompleteMinLength&&this.filteredAutocompleteItems.length>0&&this.focused},filteredAutocompleteItems:function(){var A=this,t=this.autocompleteItems.map(function(t){return Object(i.b)(t,A.tags,A.validation,!1)});return this.autocompleteFilterDuplicates?t.filter(function(t){return!A.tagsCopy.find(function(A){return A.text===t.text})}):t}},methods:{createClasses:i.a,getSelectedIndex:function(A){var t=this.filteredAutocompleteItems,e=this.selectedItem,n=t.length-1;if(0!==t.length)return null===e?0:"before"===A&&0===e?n:"after"===A&&e===n?0:"after"===A?e+1:e-1},selectDefaultItem:function(){this.selectedItem=this.addOnlyFromAutocomplete&&this.filteredAutocompleteItems.length>0?0:null},selectItem:function(A,t){A.preventDefault(),this.selectedItem=this.getSelectedIndex(t)},isSelected:function(A){return this.selectedItem===A},isMarked:function(A){return this.deletionMark===A},invokeDelete:function(){var A=this;if(this.deleteOnBackslash&&0>=this.newTag.length){var t=this.tagsCopy.length-1;null===this.deletionMark?(this.deletionMarkTime=setTimeout(function(){return A.deletionMark=null},1e3),this.deletionMark=t):this.performDeleteTag(t)}},addTagsFromPaste:function(){var A=this;this.addFromPaste&&setTimeout(function(){return A.performAddTags(A.newTag)},10)},performEditTag:function(A){var t=this;this.allowEditTags&&(this._events["before-editing-tag"]||this.editTag(A),this.$emit("before-editing-tag",{index:A,tag:this.tagsCopy[A],editTag:function(){return t.editTag(A)}}))},editTag:function(A){this.allowEditTags&&(this.toggleEditMode(A),this.focus(A))},toggleEditMode:function(A){this.allowEditTags&&!this.disabled&&this.$set(this.tagsEditStatus,A,!this.tagsEditStatus[A])},clone:function(A){return JSON.parse(JSON.stringify(A))},createChangedTag:function(A,t){var e=this.tagsCopy[A];e.text=t?t.target.value:this.tagsCopy[A].text,this.$set(this.tagsCopy,A,Object(i.b)(e,this.tagsCopy,this.validation))},focus:function(A){var t=this;this.$nextTick(function(){var e=t.$refs.tagCenter[A].querySelector("input.tag-input");e&&e.focus()})},quote:function(A){return A.replace(/([()[{*+.$^\\|?])/g,"\\$1")},cancelEdit:function(A){this.tags[A]&&(this.tagsCopy[A]=this.clone(Object(i.b)(this.tags[A],this.tags,this.validation)),this.$set(this.tagsEditStatus,A,!1))},hasForbiddingAddRule:function(A){var t=this;return A.some(function(A){var e=t.validation.find(function(t){return A===t.type});return!!e&&e.disableAdd})},createTagTexts:function(A){var t=this;return A.split(RegExp(this.separators.map(function(A){return t.quote(A)}).join("|"))).map(function(A){return{text:A}})},performDeleteTag:function(A){var t=this;this._events["before-deleting-tag"]||this.deleteTag(A),this.$emit("before-deleting-tag",{index:A,tag:this.tagsCopy[A],deleteTag:function(){return t.deleteTag(A)}})},deleteTag:function(A){this.disabled||(this.deletionMark=null,clearTimeout(this.deletionMarkTime),this.tagsCopy.splice(A,1),this._events["update:tags"]&&this.$emit("update:tags",this.tagsCopy),this.$emit("tags-changed",this.tagsCopy))},noTriggerKey:function(A,t){var e=-1!==this[t].indexOf(A.keyCode);return e&&A.preventDefault(),!e},performAddTags:function(A,t){var e=this;if(!(this.disabled||t&&this.noTriggerKey(t,"addOnKey")||"string"==typeof A&&0===A.trim().length)){var n=[];"object"===(void 0===A?"undefined":s(A))&&(n=[A]),"string"==typeof A&&(n=this.createTagTexts(A)),n.forEach(function(A){A=Object(i.b)(A,e.tags,e.validation,!1),e._events["before-adding-tag"]||e.addTag(A),e.$emit("before-adding-tag",{tag:A,addTag:function(){return e.addTag(A)}})})}},addTag:function(A){var t=this,e=this.filteredAutocompleteItems.map(function(A){return A.text});this.addOnlyFromAutocomplete&&-1===e.indexOf(A.text)||this.$nextTick(function(){return t.maxTags&&t.tagsCopy.length>=t.maxTags?t.$emit("max-tags-reached",A):t.avoidAddingDuplicates&&-1!==t.tagsCopy.map(function(A){return A.text}).indexOf(A.text)?t.$emit("adding-duplicate",A):void(!A.valid&&t.hasForbiddingAddRule(A.tiClasses)||(t.$emit("input",""),t.tagsCopy.push(A),t._events["update:tags"]&&t.$emit("update:tags",t.tagsCopy),t.$emit("tags-changed",t.tagsCopy)))})},performSaveTag:function(A,t){var e=this,n=this.tagsCopy[A];this.disabled||t&&this.noTriggerKey(t,"addOnKey")||0!==n.text.trim().length&&(this._events["before-saving-tag"]||this.saveTag(A,n),this.$emit("before-saving-tag",{index:A,tag:n,saveTag:function(){return e.saveTag(A,n)}}))},saveTag:function(A,t){if(this.avoidAddingDuplicates&&this.tagsCopy.filter(function(A){return A.text===t.text}).length>1)return this.$emit("saving-duplicate",t);!t.valid&&this.hasForbiddingAddRule(t.tiClasses)||(this.$set(this.tagsCopy,A,t),this.toggleEditMode(A),this._events["update:tags"]&&this.$emit("update:tags",this.tagsCopy),this.$emit("tags-changed",this.tagsCopy))},tagsEqual:function(){var A=this;return!this.tagsCopy.some(function(t,e){return!a()(t,A.tags[e])})},updateNewTag:function(A){var t=A.target.value;this.newTag=t,this.$emit("input",t)},initTags:function(){this.tagsCopy=Object(i.c)(this.tags,this.validation),this.tagsEditStatus=this.clone(this.tags).map(function(){return!1}),this._events["update:tags"]&&!this.tagsEqual()&&this.$emit("update:tags",this.tagsCopy)},blurred:function(A){this.$el.contains(A.target)||(this.addOnBlur&&this.focused&&this.performAddTags(this.newTag),this.focused=!1)}},watch:{value:function(A){this.addOnlyFromAutocomplete||(this.selectedItem=null),this.newTag=A},tags:{handler:function(){this.initTags()},deep:!0},autocompleteOpen:"selectDefaultItem"},created:function(){this.newTag=this.value,this.initTags()},mounted:function(){this.selectDefaultItem(),document.addEventListener("click",this.blurred)},destroyed:function(){document.removeEventListener("click",this.blurred)}}},function(A,t,e){"use strict";e.d(t,"a",function(){return a}),e.d(t,"b",function(){return i}),e.d(t,"c",function(){return o});var n=function(A,t){return t.filter(function(t){return"string"==typeof t.rule?!RegExp(t.rule).test(A):t.rule instanceof RegExp?!t.rule.test(A):"[object Function]"==={}.toString.call(t.rule)?t.rule(A):void 0}).map(function(A){return A.type})},a=function(A,t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],a=3>=arguments.length||void 0===arguments[3]||arguments[3],i=n(A,e);return(a?t.filter(function(t){return t.text===A}).length>1:-1!==t.map(function(A){return A.text}).indexOf(A))&&i.push("duplicate"),i.push(0===i.length?"valid":"invalid"),i},i=function(A){for(var t=arguments.length,e=Array(t>1?t-1:0),n=1;t>n;n++)e[n-1]=arguments[n];void 0===A.text&&(A={text:A});var i=JSON.parse(JSON.stringify(A));return i.tiClasses=a.apply(void 0,[i.text].concat(e)),i},o=function(A){for(var t=arguments.length,e=Array(t>1?t-1:0),n=1;t>n;n++)e[n-1]=arguments[n];return A.map(function(t){return i.apply(void 0,[t,A].concat(e))})}},function(A,t,e){"use strict";function n(A){e(17)}var a=e(7),i=e(19);t.a=e(3)(a.a,i.a,!1,n,"data-v-5d05513b",null).exports},function(A,t,e){"use strict";t.a={name:"TagInput",props:["scope"]}},function(A,t,e){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=e(9),a=e(5),i=e(6);e.d(t,"VueTagsInput",function(){return n.a}),e.d(t,"createClasses",function(){return a.a}),e.d(t,"createTag",function(){return a.b}),e.d(t,"createTags",function(){return a.c}),e.d(t,"TagInput",function(){return i.a}),n.a.install=function(A){return A.component(n.a.name,n.a)},"undefined"!=typeof window&&window.Vue&&window.Vue.use(n.a),t.default=n.a},function(A,t,e){"use strict";function n(A){e(10)}var a=e(4),i=e(21);t.a=e(3)(a.a,i.a,!1,n,"data-v-36b6250a",null).exports},function(A,t,e){var n=e(11);"string"==typeof n&&(n=[[A.i,n,""]]),n.locals&&(A.exports=n.locals);e(2)("e683286c",n,!0,{})},function(A,t,e){var n=e(12);t=A.exports=e(0)(!1),t.push([A.i,"@font-face{font-family:icomoon;src:url("+n(e(1))+");src:url("+n(e(1))+'#iefix) format("embedded-opentype"),url('+n(e(13))+') format("truetype"),url('+n(e(14))+') format("woff");font-weight:400;font-style:normal}[class*=" icon-"][data-v-36b6250a],[class^=icon-][data-v-36b6250a]{font-family:icomoon!important;speak:none;font-style:normal;font-weight:400;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-check[data-v-36b6250a]:before{content:"\\E902"}.icon-close[data-v-36b6250a]:before{content:"\\E901"}.icon-undo[data-v-36b6250a]:before{content:"\\E900"}ul[data-v-36b6250a]{margin:0;padding:0;list-style-type:none}[data-v-36b6250a],[data-v-36b6250a]:after,[data-v-36b6250a]:before{-webkit-box-sizing:border-box;box-sizing:border-box}input[data-v-36b6250a]:focus{outline:none}input[disabled][data-v-36b6250a]{background-color:transparent}.vue-tags-input[data-v-36b6250a]{max-width:450px;position:relative;background-color:#fff}.vue-tags-input.vue-tags-input.disabled[data-v-36b6250a]{opacity:.5}.vue-tags-input.vue-tags-input.disabled [data-v-36b6250a]{cursor:default}.input[data-v-36b6250a]{border:1px solid #ccc;padding:4px}.input[data-v-36b6250a],.tags[data-v-36b6250a]{display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.tags[data-v-36b6250a]{width:100%}.tag[data-v-36b6250a]{background-color:#5c6bc0;color:#fff;border-radius:2px;display:-webkit-box;display:-ms-flexbox;display:flex;padding:3px 5px;margin:2px;font-size:.85em}.tag[data-v-36b6250a]:focus{outline:none}.tag .content[data-v-36b6250a]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.tag .tag-center[data-v-36b6250a]{position:relative}.tag span[data-v-36b6250a]{line-height:inherit}.tag span.hidden[data-v-36b6250a]{padding-left:14px;visibility:hidden;height:0;white-space:pre}.tag .actions[data-v-36b6250a]{margin-left:2px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-size:1.15em}.tag .actions i[data-v-36b6250a]{cursor:pointer}.tag[data-v-36b6250a]:last-child{margin-right:4px}.tag.invalid[data-v-36b6250a],.tag.tag.deletion-mark[data-v-36b6250a]{background-color:#e54d42}.new-tag-input-wrapper[data-v-36b6250a]{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto;padding:3px 5px;margin:2px;font-size:.85em}.new-tag-input-wrapper input[data-v-36b6250a]{-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto;min-width:100px;border:none;padding:0;margin:0}.new-tag-input[data-v-36b6250a]{line-height:inherit}.autocomplete[data-v-36b6250a]{border:1px solid #ccc;border-top:none;position:absolute;width:100%;background-color:#fff;z-index:20}.item>div[data-v-36b6250a]{cursor:pointer;padding:3px 6px;width:100%}.selected-item[data-v-36b6250a]{background-color:#5c6bc0;color:#fff}',""])},function(A,t){A.exports=function(A){return"string"!=typeof A?A:(/^['"].*['"]$/.test(A)&&(A=A.slice(1,-1)),/["'() \t\n]/.test(A)?'"'+A.replace(/"/g,'\\"').replace(/\n/g,"\\n")+'"':A)}},function(A,t){A.exports="data:font/ttf;base64,AAEAAAALAIAAAwAwT1MvMg8SBawAAAC8AAAAYGNtYXAXVtKJAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZqWfozAAAAF4AAAA/GhlYWQPxZgIAAACdAAAADZoaGVhB4ADyAAAAqwAAAAkaG10eBIAAb4AAALQAAAAHGxvY2EAkgDiAAAC7AAAABBtYXhwAAkAHwAAAvwAAAAgbmFtZZlKCfsAAAMcAAABhnBvc3QAAwAAAAAEpAAAACAAAwOAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpAgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6QL//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAFYBAQO+AoEAHAAAATIXHgEXFhcHJicuAScmIyIGBxchERc2Nz4BNzYCFkpDQ28pKRdkECAfVTM0OT9wLZz+gJgdIiJLKSgCVRcYUjg5QiAzKys+ERIrJZoBgJoZFRQcCAgAAQDWAIEDKgLVAAsAAAEHFwcnByc3JzcXNwMq7u487u487u487u4Cme7uPO7uPO7uPO7uAAEAkgCBA4ACvQAFAAAlARcBJzcBgAHEPP4A7jz5AcQ8/gDuPAAAAAABAAAAAAAAH8nTUV8PPPUACwQAAAAAANZ1KhsAAAAA1nUqGwAAAAADvgLVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAO+AAEAAAAAAAAAAAAAAAAAAAAHBAAAAAAAAAAAAAAAAgAAAAQAAFYEAADWBAAAkgAAAAAACgAUAB4AUABqAH4AAQAAAAcAHQABAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGljb21vb24AaQBjAG8AbQBvAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGljb21vb24AaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmljb21vb24AaQBjAG8AbQBvAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="},function(A,t){A.exports="data:font/woff;base64,d09GRgABAAAAAAUQAAsAAAAABMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIFrGNtYXAAAAFoAAAAVAAAAFQXVtKJZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAPwAAAD8pZ+jMGhlYWQAAALAAAAANgAAADYPxZgIaGhlYQAAAvgAAAAkAAAAJAeAA8hobXR4AAADHAAAABwAAAAcEgABvmxvY2EAAAM4AAAAEAAAABAAkgDibWF4cAAAA0gAAAAgAAAAIAAJAB9uYW1lAAADaAAAAYYAAAGGmUoJ+3Bvc3QAAATwAAAAIAAAACAAAwAAAAMDgAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QIDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkC//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQBWAQEDvgKBABwAAAEyFx4BFxYXByYnLgEnJiMiBgcXIREXNjc+ATc2AhZKQ0NvKSkXZBAgH1UzNDk/cC2c/oCYHSIiSykoAlUXGFI4OUIgMysrPhESKyWaAYCaGRUUHAgIAAEA1gCBAyoC1QALAAABBxcHJwcnNyc3FzcDKu7uPO7uPO7uPO7uApnu7jzu7jzu7jzu7gABAJIAgQOAAr0ABQAAJQEXASc3AYABxDz+AO48+QHEPP4A7jwAAAAAAQAAAAAAAB/J01FfDzz1AAsEAAAAAADWdSobAAAAANZ1KhsAAAAAA74C1QAAAAgAAgAAAAAAAAABAAADwP/AAAAEAAAAAAADvgABAAAAAAAAAAAAAAAAAAAABwQAAAAAAAAAAAAAAAIAAAAEAABWBAAA1gQAAJIAAAAAAAoAFAAeAFAAagB+AAEAAAAHAB0AAQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAHAAAAAQAAAAAAAgAHAGAAAQAAAAAAAwAHADYAAQAAAAAABAAHAHUAAQAAAAAABQALABUAAQAAAAAABgAHAEsAAQAAAAAACgAaAIoAAwABBAkAAQAOAAcAAwABBAkAAgAOAGcAAwABBAkAAwAOAD0AAwABBAkABAAOAHwAAwABBAkABQAWACAAAwABBAkABgAOAFIAAwABBAkACgA0AKRpY29tb29uAGkAYwBvAG0AbwBvAG5WZXJzaW9uIDEuMABWAGUAcgBzAGkAbwBuACAAMQAuADBpY29tb29uAGkAYwBvAG0AbwBvAG5pY29tb29uAGkAYwBvAG0AbwBvAG5SZWd1bGFyAFIAZQBnAHUAbABhAHJpY29tb29uAGkAYwBvAG0AbwBvAG5Gb250IGdlbmVyYXRlZCBieSBJY29Nb29uLgBGAG8AbgB0ACAAZwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAC4AAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"},function(A,t){A.exports=function(A,t){for(var e=[],n={},a=0;t.length>a;a++){var i=t[a],o=i[0],r=i[1],s=i[2],u=i[3],l={id:A+":"+a,css:r,media:s,sourceMap:u};n[o]?n[o].parts.push(l):e.push(n[o]={id:o,parts:[l]})}return e}},function(A,t,e){"use strict";var n=Array.isArray,a=Object.keys,i=Object.prototype.hasOwnProperty;A.exports=function A(t,e){if(t===e)return!0;if(t&&e&&"object"==typeof t&&"object"==typeof e){var o,r,s,u=n(t),l=n(e);if(u&&l){if((r=t.length)!=e.length)return!1;for(o=r;0!=o--;)if(!A(t[o],e[o]))return!1;return!0}if(u!=l)return!1;var c=t instanceof Date,d=e instanceof Date;if(c!=d)return!1;if(c&&d)return t.getTime()==e.getTime();var g=t instanceof RegExp,p=e instanceof RegExp;if(g!=p)return!1;if(g&&p)return""+t==""+e;var f=a(t);if((r=f.length)!==a(e).length)return!1;for(o=r;0!=o--;)if(!i.call(e,f[o]))return!1;for(o=r;0!=o--;)if(s=f[o],!A(t[s],e[s]))return!1;return!0}return t!==t&&e!==e}},function(A,t,e){var n=e(18);"string"==typeof n&&(n=[[A.i,n,""]]),n.locals&&(A.exports=n.locals);e(2)("85656b4e",n,!0,{})},function(A,t,e){t=A.exports=e(0)(!1),t.push([A.i,".tag-input[data-v-5d05513b]{background-color:transparent;color:inherit;border:none;padding:0;margin:0;display:-webkit-box;display:-ms-flexbox;display:flex;top:0;position:absolute;width:100%;line-height:inherit}.tag-input[data-v-5d05513b]::-ms-clear{display:none}input[data-v-5d05513b]:focus{outline:none}input[disabled][data-v-5d05513b]{background-color:transparent}",""])},function(A,t,e){"use strict";t.a={render:function(){var A=this,t=A.$createElement,e=A._self._c||t;return A.scope.edit?e("input",{directives:[{name:"model",rawName:"v-model",value:A.scope.tag.text,expression:"scope.tag.text"}],staticClass:"tag-input",attrs:{type:"text",maxlength:A.scope.maxlength,size:"1"},domProps:{value:A.scope.tag.text},on:{input:[function(t){t.target.composing||A.$set(A.scope.tag,"text",t.target.value)},function(t){A.scope.validateTag(A.scope.index,t)}],blur:function(t){A.scope.cancelEdit(A.scope.index)},keydown:function(t){A.scope.performSaveTag(A.scope.index,t)}}}):A._e()},staticRenderFns:[]}},function(A,t,e){"use strict";var n=function(A){return!A.some(function(A){var t=!A.text;t&&console.warn('Missing property "text"',A);var e=!1;return A.classes&&(e="string"!=typeof A.classes),e&&console.warn('Property "classes" must be type of string',A),t||e})},a=function(A){return!A.some(function(A){var t="number"==typeof A&&isFinite(A)&&Math.floor(A)===A;return t||console.warn("Only numerics are allowed for this prop. Found:",A),!t})};t.a={value:{type:String,default:"",required:!0},tags:{type:Array,default:function(){return[]},validator:n},autocompleteItems:{type:Array,default:function(){return[]},validator:n},allowEditTags:{type:Boolean,default:!1},autocompleteFilterDuplicates:{default:!0,type:Boolean},addOnlyFromAutocomplete:{type:Boolean,default:!1},autocompleteMinLength:{type:Number,default:1},autocompleteAlwaysOpen:{type:Boolean,default:!1},disabled:{type:Boolean,default:!1},placeholder:{type:String,default:"Add Tag"},addOnKey:{type:Array,default:function(){return[13]},validator:a},saveOnKey:{type:Array,default:function(){return[13]},validator:a},maxTags:{type:Number},maxlength:{type:Number},validation:{type:Array,default:function(){return[]},validator:function(A){return!A.some(function(A){var t=!A.rule;t&&console.warn('Property "rule" is missing',A);var e=A.rule&&("string"==typeof A.rule||A.rule instanceof RegExp||"[object Function]"==={}.toString.call(A.rule));e||console.warn("A rule must be type of string, RegExp or function. Found:",JSON.stringify(A.rule));var n=!A.type;n&&console.warn('Property "type" is missing',A);var a=A.type&&"string"!=typeof A.type;return a&&console.warn('Property "type" must be type of string. Found:',A),!e||t||n||a})}},separators:{type:Array,default:function(){return[";"]},validator:function(A){return!A.some(function(A){var t="string"!=typeof A;return t&&console.warn("Separators must be type of string. Found:",A),t})}},avoidAddingDuplicates:{type:Boolean,default:!0},addOnBlur:{type:Boolean,default:!0},addFromPaste:{type:Boolean,default:!0},deleteOnBackslash:{default:!0,type:Boolean}}},function(A,t,e){"use strict";t.a={render:function(){var A=this,t=A.$createElement,e=A._self._c||t;return e("div",{staticClass:"vue-tags-input",class:{disabled:A.disabled}},[e("div",{staticClass:"input"},[A.tagsCopy?e("ul",{staticClass:"tags"},[A._l(A.tagsCopy,function(t,n){return e("li",{key:n,staticClass:"tag",class:[t.tiClasses,t.classes,{"deletion-mark":A.isMarked(n)}],style:t.style,attrs:{tabindex:n+1},on:{click:function(e){A.$emit("tag-clicked",{tag:t,index:n})}}},[e("div",{staticClass:"content"},[A.$scopedSlots.tagLeft?e("div",{staticClass:"tag-left"},[A._t("tagLeft",null,{tag:t,index:n,edit:A.tagsEditStatus[n],performSaveEdit:A.performSaveTag,performDelete:A.performDeleteTag,performCancelEdit:A.cancelEdit,performOpenEdit:A.performEditTag,deletionMark:A.isMarked(n)})],2):A._e(),A._v(" "),e("div",{ref:"tagCenter",refInFor:!0,staticClass:"tag-center"},[A.$scopedSlots.tagCenter?A._e():e("span",{class:{hidden:A.tagsEditStatus[n]},on:{click:function(t){A.performEditTag(n)}}},[A._v(A._s(t.text))]),A._v(" "),A.$scopedSlots.tagCenter?A._e():e("tag-input",{attrs:{scope:{edit:A.tagsEditStatus[n],maxlength:A.maxlength,tag:t,index:n,validateTag:A.createChangedTag,cancelEdit:A.cancelEdit,performSaveTag:A.performSaveTag}}}),A._v(" "),A._t("tagCenter",null,{tag:t,index:n,maxlength:A.maxlength,edit:A.tagsEditStatus[n],performSaveEdit:A.performSaveTag,performDelete:A.performDeleteTag,performCancelEdit:A.cancelEdit,validateTag:A.createChangedTag,performSaveTag:A.performSaveTag,performOpenEdit:A.performEditTag,deletionMark:A.isMarked(n)})],2),A._v(" "),A.$scopedSlots.tagRight?e("div",{staticClass:"tag-right"},[A._t("tagRight",null,{tag:t,index:n,edit:A.tagsEditStatus[n],performSaveEdit:A.performSaveTag,performDelete:A.performDeleteTag,performCancelEdit:A.cancelEdit,performOpenEdit:A.performEditTag,deletionMark:A.isMarked(n)})],2):A._e()]),A._v(" "),e("div",{staticClass:"actions"},[A.$scopedSlots.tagActions?A._e():e("i",{directives:[{name:"show",rawName:"v-show",value:A.tagsEditStatus[n],expression:"tagsEditStatus[index]"}],staticClass:"icon-undo",on:{click:function(t){A.cancelEdit(n)}}}),A._v(" "),A.$scopedSlots.tagActions?A._e():e("i",{directives:[{name:"show",rawName:"v-show",value:!A.tagsEditStatus[n],expression:"!tagsEditStatus[index]"}],staticClass:"icon-close",on:{click:function(t){A.performDeleteTag(n)}}}),A._v(" "),A.$scopedSlots.tagActions?A._t("tagActions",null,{tag:t,index:n,edit:A.tagsEditStatus[n],performSaveEdit:A.performSaveTag,performDelete:A.performDeleteTag,performCancelEdit:A.cancelEdit,performOpenEdit:A.performEditTag,deletionMark:A.isMarked(n)}):A._e()],2)])}),A._v(" "),e("li",{staticClass:"new-tag-input-wrapper"},[e("input",A._b({ref:"newTagInput",staticClass:"new-tag-input",class:[A.createClasses(A.newTag,A.tags,A.validation,!1)],attrs:{type:"text",size:"1",placeholder:A.placeholder,maxlength:A.maxlength,disabled:A.disabled},domProps:{value:A.newTag},on:{paste:A.addTagsFromPaste,keydown:[function(t){A.performAddTags(A.filteredAutocompleteItems[A.selectedItem]||A.newTag,t)},function(t){return"button"in t||8===t.keyCode?A.invokeDelete(t):null},function(t){if(!("button"in t)&&38!==t.keyCode)return null;A.selectItem(t,"before")},function(t){if(!("button"in t)&&40!==t.keyCode)return null;A.selectItem(t,"after")}],input:A.updateNewTag,blur:function(t){A.$emit("blur",t)},focus:function(t){A.focused=!0,A.$emit("focus",t)},click:function(t){!A.addOnlyFromAutocomplete&&(A.selectedItem=null)}}},"input",A.$attrs,!1))])],2):A._e()]),A._v(" "),A._t("between-elements"),A._v(" "),A.autocompleteOpen?e("div",{staticClass:"autocomplete",on:{mouseout:function(t){A.selectedItem=null}}},[e("ul",A._l(A.filteredAutocompleteItems,function(t,n){return e("li",{key:n,staticClass:"item",class:[t.tiClasses,t.classes,{"selected-item":A.isSelected(n)}],style:t.style,on:{mouseover:function(t){!A.disabled&&(A.selectedItem=n)}}},[A.$scopedSlots.autocompleteItem?A._t("autocompleteItem",null,{item:t,index:n,performAdd:A.performAddTags,selected:A.isSelected(n)}):e("div",{on:{click:function(e){A.performAddTags(t)}}},[A._v(A._s(t.text)+"\n        ")])],2)}))]):A._e()],2)},staticRenderFns:[]}}])});

},{}],"b0fn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  BRAND: 'BRAND',
  PURCHASED_FROM: 'PURCHASED_FROM',
  TYPE: 'TYPE'
};
exports.default = _default;
},{}],"HBwF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  AVAILABLE: 'AVAILABLE',
  IN_USE: 'IN_USE',
  MAINTENANCE: 'MAINTENANCE',
  BEYOND_REPAIR: 'BEYOND_REPAIR',
  LOST_OR_STOLEN: 'LOST_OR_STOLEN'
};
exports.default = _default;
},{}],"ECDW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vueTagsInput = _interopRequireDefault(require("@johmun/vue-tags-input"));

var _configurableItems = _interopRequireDefault(require("../utils/configurable-items"));

var _statuses = _interopRequireDefault(require("../utils/statuses"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["query {\n        getAllConfigurableItem {\n          id,\n          type,\n          name\n        }\n      }"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["query {\n        getAllUser {\n          id\n          first_name\n          last_name\n          type\n        }\n      }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["query {\n        getAllLocation {\n          id\n          name\n          type\n        }\n      }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'ToolSearchInput',
  components: {
    VueTagsInput: _vueTagsInput.default
  },
  props: {
    updateTags: {
      type: Function,
      required: true
    },
    disableUserSearch: {
      type: Boolean,
      required: false,
      default: false
    },
    tags: {
      type: Array,
      required: true
    },
    // TODO: fixed hacked fuzzy search clear implementation
    clearFuzzyFilter: {
      type: Boolean,
      required: true
    }
  },
  apollo: {
    getAllLocation: {
      query: (0, _graphqlTag.default)(_templateObject()),
      fetchPolicy: 'network-only'
    },
    getAllUser: {
      query: (0, _graphqlTag.default)(_templateObject2()),
      fetchPolicy: 'network-only'
    },
    getAllConfigurableItem: {
      query: (0, _graphqlTag.default)(_templateObject3()),
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    return {
      tag: ''
    };
  },
  computed: {
    autocompleteItems: function autocompleteItems() {
      var statuses = [{
        name: 'Available',
        text: 'Available',
        id: _statuses.default.AVAILABLE,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }, {
        name: 'In Use',
        text: 'In Use',
        id: _statuses.default.IN_USE,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }, {
        name: 'Maintenance',
        text: 'Maintenance',
        id: _statuses.default.MAINTENANCE,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }];
      var items = statuses.concat(this.searchableConfigItems).concat(this.locations);

      if (!this.disableUserSearch) {
        items = items.concat(this.users);
      }

      return items;
    },
    filteredItems: function filteredItems() {
      var _this = this;

      return this.autocompleteItems.filter(function (i) {
        return i.text.toLowerCase().indexOf(_this.tag.toLowerCase()) > -1;
      });
    },
    locations: function locations() {
      return (this.getAllLocation || []).map(function (location) {
        location.text = location.name;
        location.formattedType = 'Location';
        location.iconClass = 'fa-map-marker-alt';
        return location;
      });
    },
    users: function users() {
      return (this.getAllUser || []).map(function (user) {
        user.text = "".concat(user.first_name, " ").concat(user.last_name);
        user.name = user.text;
        user.formattedType = 'User';
        user.iconClass = 'fa-user';
        return user;
      });
    },
    searchableConfigItems: function searchableConfigItems() {
      var _this2 = this;

      var searchItems = [];
      var items = this.getAllConfigurableItem || [];
      items.forEach(function (item) {
        if (item.type !== _configurableItems.default.PURCHASED_FROM) {
          item.formattedType = item.type.split('_')[0].toLowerCase();
          item.text = "".concat(item.formattedType, " ").concat(item.name);
          item.iconClass = _this2.getTagIconClass(item.type);
          searchItems.push(item);
        }
      });
      return searchItems;
    }
  },
  watch: {
    clearFuzzyFilter: function clearFuzzyFilter() {
      this.tag = '';
    },
    tag: function tag(fuzzySearch) {
      if (!fuzzySearch) {
        this.tagsChanged(this.tags);
      }
    }
  },
  methods: {
    tagsChanged: function tagsChanged(newTags) {
      var fuzzySearch = null;

      if (newTags.some(function (tag) {
        return !tag.name;
      })) {
        fuzzySearch = newTags.pop().text;
        this.tag = fuzzySearch;
        document.querySelector('.fa-search').click();
        document.querySelector('.new-tag-input').blur();
      }

      this.updateTags(newTags, fuzzySearch);
    },
    getTagIconClass: function getTagIconClass(type) {
      if (type === _configurableItems.default.BRAND) {
        return 'fa-tag';
      } else if (type === _configurableItems.default.TYPE) {
        return 'fa-wrench';
      }
    }
  }
};
exports.default = _default;
        var $c86128 = exports.default || module.exports;
      
      if (typeof $c86128 === 'function') {
        $c86128 = $c86128.options;
      }
    
        /* template */
        Object.assign($c86128, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-input"},[_vm._m(0),_vm._v(" "),_c('vue-tags-input',{attrs:{"tags":_vm.tags,"autocomplete-items":_vm.filteredItems,"add-on-blur":false,"placeholder":"Search"},on:{"tags-changed":_vm.tagsChanged},scopedSlots:_vm._u([{key:"autocompleteItem",fn:function(props){return _c('button',{staticClass:"autocomplete-item",on:{"click":function () { return props.performAdd(props.item); }}},[_c('div',{staticClass:"item-name"},[_vm._v("\n        "+_vm._s(props.item.name)+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"item-category"},[_vm._v("\n        "+_vm._s(props.item.formattedType)+"\n      ")])])}},{key:"tagCenter",fn:function(props){return _c('div',{},[_c('i',{staticClass:"fas tag-icon",class:props.tag.iconClass}),_vm._v("\n      "+_vm._s(props.tag.name)+"\n    ")])}}]),model:{value:(_vm.tag),callback:function ($$v) {_vm.tag=$$v},expression:"tag"}})],1)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-icon-container"},[_c('i',{staticClass:"fas fa-search"})])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"@johmun/vue-tags-input":"KW2a","../utils/configurable-items":"b0fn","../utils/statuses":"HBwF","graphql-tag":"MbWf"}],"Yq/j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'ToolSearchResult',
  props: {
    tool: {
      type: Object,
      required: true
    },
    onSelect: {
      type: Function,
      required: false,
      default: function _default() {}
    },
    showSelect: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  computed: {
    id: function id() {
      return "#".concat(this.tool.id);
    },
    name: function name() {
      return "".concat(this.tool.brand.name, " ").concat(this.tool.type.name);
    },
    statusClass: function statusClass() {
      return this.tool.status.split('_').join('-').toLowerCase();
    },
    status: function status() {
      return this.tool.status.split('_').join(' ').toLowerCase();
    },
    assignee: function assignee() {
      return this.tool.owner.type === 'USER' ? "".concat(this.tool.owner.first_name, " ").concat(this.tool.owner.last_name) : this.tool.owner.name;
    },
    assigneeIcon: function assigneeIcon() {
      return this.tool.owner.type === 'USER' ? 'fa-user' : 'fa-map-marker-alt';
    },
    selected: function selected() {
      return this.$store.state.selectedToolsMap[this.tool.id];
    }
  },
  methods: {
    onClick: function onClick() {
      this.onSelect(this.tool.id);
    },
    toggleSelect: function toggleSelect() {
      this.$store.commit('toggleToolSelection', this.tool.id);
    }
  }
};
exports.default = _default;
        var $343e2c = exports.default || module.exports;
      
      if (typeof $343e2c === 'function') {
        $343e2c = $343e2c.options;
      }
    
        /* template */
        Object.assign($343e2c, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-result"},[_c('div',{staticClass:"main-container",on:{"click":_vm.onClick}},[_c('div',{staticClass:"row"},[_c('span',{staticClass:"title"},[_vm._v("\n        "+_vm._s(_vm.name)+"\n      ")])]),_vm._v(" "),_c('div',{staticClass:"row"},[_c('span',{staticClass:"subtitle"},[_vm._v("\n        "+_vm._s(_vm.id)+"\n      ")]),_vm._v(" "),_c('span',{staticClass:"tool-status",class:_vm.statusClass},[_vm._v("\n        "+_vm._s(_vm.status)+"\n      ")])]),_vm._v(" "),_c('div',{staticClass:"row"},[_c('i',{staticClass:"fas user-icon",class:_vm.assigneeIcon}),_vm._v(" "),_c('span',{staticClass:"tool-assignee"},[_vm._v("\n        "+_vm._s(_vm.assignee)+"\n      ")])])]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.showSelect)?_c('div',{staticClass:"tool-selection-container"},[_c('button',{staticClass:"fas checkbox",class:{ 'fa-check': _vm.selected },on:{"click":_vm.toggleSelect}})]):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"rKNI":[function(require,module,exports) {
module.exports =
/******/
function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // define __esModule on exports

  /******/


  __webpack_require__.r = function (exports) {
    /******/
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/
      Object.defineProperty(exports, Symbol.toStringTag, {
        value: 'Module'
      });
      /******/
    }
    /******/


    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    /******/
  };
  /******/

  /******/
  // create a fake namespace object

  /******/
  // mode & 1: value is a module id, require it

  /******/
  // mode & 2: merge all properties of value into the ns

  /******/
  // mode & 4: return value when already ns object

  /******/
  // mode & 8|1: behave like require

  /******/


  __webpack_require__.t = function (value, mode) {
    /******/
    if (mode & 1) value = __webpack_require__(value);
    /******/

    if (mode & 8) return value;
    /******/

    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /******/

    var ns = Object.create(null);
    /******/

    __webpack_require__.r(ns);
    /******/


    Object.defineProperty(ns, 'default', {
      enumerable: true,
      value: value
    });
    /******/

    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
      return value[key];
    }.bind(null, key));
    /******/

    return ns;
    /******/
  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "";
  /******/

  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = "fb15");
  /******/
}(
/************************************************************************/

/******/
{
  /***/
  "1eb2":
  /***/
  function (module, exports, __webpack_require__) {
    // This file is imported into lib/wc client bundles.
    if (typeof window !== 'undefined') {
      var i;

      if ((i = window.document.currentScript) && (i = i.src.match(/(.+\/)[^/]+\.js$/))) {
        __webpack_require__.p = i[1]; // eslint-disable-line
      }
    }
    /***/

  },

  /***/
  "fb15":
  /***/
  function (module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js


    var setPublicPath = __webpack_require__("1eb2"); // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"8ac48580-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SvgIcon.vue?vue&type=template&id=30190379&


    var render = function () {
      var _vm = this;

      var _h = _vm.$createElement;

      var _c = _vm._self._c || _h;

      return _c('svg', {
        class: _vm.clazz,
        style: _vm.style,
        attrs: {
          "version": "1.1",
          "viewBox": _vm.box
        },
        domProps: {
          "innerHTML": _vm._s(_vm.path)
        },
        on: {
          "click": _vm.onClick
        }
      });
    };

    var staticRenderFns = []; // CONCATENATED MODULE: ./src/components/SvgIcon.vue?vue&type=template&id=30190379&
    // CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SvgIcon.vue?vue&type=script&lang=js&
    //
    //
    //
    //

    var icons = {};
    var notLoadedIcons = [];
    var defaultWidth = '';
    var defaultHeight = '';
    var classPrefix = 'svg';
    var isStroke = false;
    /* harmony default export */

    var SvgIconvue_type_script_lang_js_ = {
      data: function data() {
        return {
          loaded: false
        };
      },
      props: {
        icon: String,
        name: String,
        width: {
          type: String,
          default: ''
        },
        height: {
          type: String,
          default: ''
        },
        scale: String,
        dir: String,
        fill: {
          type: Boolean,
          default: function _default() {
            return !isStroke;
          }
        },
        color: String,
        original: {
          type: Boolean,
          default: false
        },
        title: String
      },
      computed: {
        clazz: function clazz() {
          var clazz = "".concat(classPrefix, "-icon");

          if (this.fill) {
            clazz += " ".concat(classPrefix, "-fill");
          }

          if (this.dir) {
            clazz += " ".concat(classPrefix, "-").concat(this.dir);
          }

          return clazz;
        },
        iconName: function iconName() {
          return this.name || this.icon;
        },
        iconData: function iconData() {
          var iconData = icons[this.iconName];

          if (iconData || this.loaded) {
            return iconData;
          }

          return null;
        },
        colors: function colors() {
          if (this.color) {
            return this.color.split(' ');
          }

          return [];
        },
        path: function path() {
          var pathData = '';

          if (this.iconData) {
            pathData = this.iconData.data;
            pathData = this.setTitle(pathData); // use original color

            if (this.original) {
              pathData = this.addOriginalColor(pathData);
            }

            if (this.colors.length > 0) {
              pathData = this.addColor(pathData);
            }
          } else {
            // if no iconData, push to notLoadedIcons
            notLoadedIcons.push({
              name: this.iconName,
              component: this
            });
          }

          return this.getValidPathData(pathData);
        },
        box: function box() {
          var width = this.width || 16;
          var height = this.width || 16;

          if (this.iconData) {
            if (this.iconData.viewBox) {
              return this.iconData.viewBox;
            }

            return "0 0 ".concat(this.iconData.width, " ").concat(this.iconData.height);
          }

          return "0 0 ".concat(parseFloat(width), " ").concat(parseFloat(height));
        },
        style: function style() {
          var digitReg = /^\d+$/;
          var scale = Number(this.scale);
          var width;
          var height; // apply scale

          if (!isNaN(scale) && this.iconData) {
            width = Number(this.iconData.width) * scale + 'px';
            height = Number(this.iconData.height) * scale + 'px';
          } else {
            width = digitReg.test(this.width) ? this.width + 'px' : this.width || defaultWidth;
            height = digitReg.test(this.height) ? this.height + 'px' : this.height || defaultWidth;
          }

          var style = {};

          if (width) {
            style.width = width;
          }

          if (height) {
            style.height = height;
          }

          return style;
        }
      },
      created: function created() {
        if (icons[this.iconName]) {
          this.loaded = true;
        }
      },
      methods: {
        addColor: function addColor(data) {
          var _this = this;

          var reg = /<(path|rect|circle|polygon|line|polyline|ellipse)\s/gi;
          var i = 0;
          return data.replace(reg, function (match) {
            var color = _this.colors[i++] || _this.colors[_this.colors.length - 1];
            var fill = _this.fill; // if color is '_', ignore it

            if (color && color === '_') {
              return match;
            } // if color start with 'r-', reverse the fill value


            if (color && color.indexOf('r-') === 0) {
              fill = !fill;
              color = color.split('r-')[1];
            }

            var style = fill ? 'fill' : 'stroke';
            var reverseStyle = fill ? 'stroke' : 'fill';
            return match + "".concat(style, "=\"").concat(color, "\" ").concat(reverseStyle, "=\"none\" ");
          });
        },
        addOriginalColor: function addOriginalColor(data) {
          var styleReg = /_fill="|_stroke="/gi;
          return data.replace(styleReg, function (styleName) {
            return styleName && styleName.slice(1);
          });
        },
        getValidPathData: function getValidPathData(pathData) {
          // If use original and colors, clear double fill or stroke
          if (this.original && this.colors.length > 0) {
            var reg = /<(path|rect|circle|polygon|line|polyline|ellipse)(\sfill|\sstroke)([="\w\s\.\-\+#\$\&>]+)(fill|stroke)/gi;
            pathData = pathData.replace(reg, function (match, p1, p2, p3, p4) {
              return "<".concat(p1).concat(p2).concat(p3, "_").concat(p4);
            });
          }

          return pathData;
        },
        setTitle: function setTitle(pathData) {
          if (this.title) {
            var title = this.title.replace(/\</gi, '&lt;').replace(/>/gi, '&gt;').replace(/&/g, '&amp;');
            return "<title>".concat(title, "</title>") + pathData;
          }

          return pathData;
        },
        onClick: function onClick(e) {
          this.$emit('click', e);
        }
      },
      install: function install(Vue) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var tagName = options.tagName || 'svgicon';

        if (options.classPrefix) {
          classPrefix = options.classPrefix;
        }

        isStroke = !!options.isStroke; // default size

        options.defaultWidth && (defaultWidth = options.defaultWidth);
        options.defaultHeight && (defaultHeight = options.defaultHeight);
        Vue.component(tagName, this);
      },
      // register icons
      register: function register(data) {
        var _loop = function _loop(name) {
          if (!icons[name]) {
            icons[name] = data[name];
          } // check new register icon is not loaded, and set loaded to true


          notLoadedIcons = notLoadedIcons.filter(function (v, ix) {
            if (v.name === name) {
              v.component.$set(v.component, 'loaded', true);
            }

            return v.name !== name;
          });
        };

        for (var name in data) {
          _loop(name);
        }
      },
      icons: icons
    }; // CONCATENATED MODULE: ./src/components/SvgIcon.vue?vue&type=script&lang=js&

    /* harmony default export */

    var components_SvgIconvue_type_script_lang_js_ = SvgIconvue_type_script_lang_js_; // CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js

    /* globals __VUE_SSR_CONTEXT__ */
    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
    // This module is a runtime utility for cleaner component module output and will
    // be included in the final webpack user bundle.

    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier,
    /* server only */
    shadowMode
    /* vue-cli only */
    ) {
      // Vue.extend constructor export interop
      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports; // render functions

      if (render) {
        options.render = render;
        options.staticRenderFns = staticRenderFns;
        options._compiled = true;
      } // functional template


      if (functionalTemplate) {
        options.functional = true;
      } // scopedId


      if (scopeId) {
        options._scopeId = 'data-v-' + scopeId;
      }

      var hook;

      if (moduleIdentifier) {
        // server build
        hook = function (context) {
          // 2.3 injection
          context = context || // cached call
          this.$vnode && this.$vnode.ssrContext || // stateful
          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true

          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          } // inject component styles


          if (injectStyles) {
            injectStyles.call(this, context);
          } // register component module identifier for async chunk inferrence


          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        }; // used by ssr in case component is cached and beforeCreate
        // never gets called


        options._ssrRegister = hook;
      } else if (injectStyles) {
        hook = shadowMode ? function () {
          injectStyles.call(this, this.$root.$options.shadowRoot);
        } : injectStyles;
      }

      if (hook) {
        if (options.functional) {
          // for template-only hot-reload because in that case the render fn doesn't
          // go through the normalizer
          options._injectStyles = hook; // register for functioal component in vue file

          var originalRender = options.render;

          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          var existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }

      return {
        exports: scriptExports,
        options: options
      };
    } // CONCATENATED MODULE: ./src/components/SvgIcon.vue

    /* normalize component */


    var component = normalizeComponent(components_SvgIconvue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);
    component.options.__file = "SvgIcon.vue";
    /* harmony default export */

    var SvgIcon = component.exports; // CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js

    /* harmony default export */

    var entry_lib = __webpack_exports__["default"] = SvgIcon;
    /***/
  }
  /******/

})["default"];
},{}],"MIUb":[function(require,module,exports) {
/* eslint-disable */
var icon = require('vue-svgicon');

icon.register({
  'nfc': {
    width: 24,
    height: 24,
    viewBox: '0 0 24 24',
    data: '<path pid="0" d="M4 20h16V4H4v16z" _fill="none"/><path pid="1" d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H4V4h16v16zM18 6h-5c-1.1 0-2 .9-2 2v2.28c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V8h3v8H8V8h2V6H6v12h12V6z"/><path pid="2" d="M0 0h24v24H0z" _fill="none"/>'
  }
});
},{"vue-svgicon":"rKNI"}],"Dg/3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _platforms = _interopRequireDefault(require("../utils/platforms"));

var _nfc = _interopRequireDefault(require("../mixins/nfc"));

require("../assets/icons/svg/nfc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'NfcScan',
  mixins: [_nfc.default],
  props: {
    onScan: {
      type: Function,
      required: true
    }
  },
  methods: {
    showBlankTagMsg: function showBlankTagMsg() {
      (0, _sweetalert.default)({
        type: 'info',
        title: 'BLANK TAG',
        text: 'This Tag is Blank',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showNfcDisabledMsg: function showNfcDisabledMsg() {
      (0, _sweetalert.default)({
        type: 'info',
        title: 'NFC NOT AVAILABLE',
        text: 'If You Want To Scan NFC Tags Please Use The Mobile App on an iOS or Android Phone',
        timer: 2500,
        showConfirmButton: false
      });
    },
    nfcCallback: function nfcCallback(value) {
      if (value) {
        if (window.device.platform === _platforms.default.ANDROID) {
          _sweetalert.default.close();
        }

        this.onScan(value);
      } else {
        this.showBlankTagMsg();
      }
    },
    onClick: function onClick() {
      if (this.checkIsNfcEnabled()) {
        this.startNfcListener();

        if (window.device.platform === _platforms.default.ANDROID) {
          this.showReadyToScanModal();
        }
      } else {
        this.showNfcDisabledMsg();
      }
    }
  }
};
exports.default = _default;
        var $347943 = exports.default || module.exports;
      
      if (typeof $347943 === 'function') {
        $347943 = $347943.options;
      }
    
        /* template */
        Object.assign($347943, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"nfc-scan-container"},[_c('button',{staticClass:"nfc-scan",class:{ inactive: !_vm.checkIsNfcEnabled() },on:{"click":_vm.onClick}},[_c('svgicon',{attrs:{"icon":"nfc","width":"22","height":"22"}}),_vm._v(" "),_c('span',[_vm._v("SCAN")])],1)])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"sweetalert2":"Y8u2","../utils/platforms":"O2n5","../mixins/nfc":"eLa2","../assets/icons/svg/nfc":"MIUb"}],"VKUh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'AddResult',
  props: {
    text: {
      type: String,
      required: true
    },
    onClick: {
      type: Function,
      required: true
    }
  }
};
exports.default = _default;
        var $fc1e4c = exports.default || module.exports;
      
      if (typeof $fc1e4c === 'function') {
        $fc1e4c = $fc1e4c.options;
      }
    
        /* template */
        Object.assign($fc1e4c, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container search-result",on:{"click":_vm.onClick}},[_c('div',{staticClass:"default-text"},[_c('i',{staticClass:"fas fa-plus"}),_vm._v("\n    NEW "+_vm._s(_vm.text)+"\n  ")])])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"i+Lh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  props: {
    /**
       * Contains the currently selected value. Very similar to a
       * `value` attribute on an <input>. You can listen for changes
       * using 'change' event using v-on
       * @type {Object||String||null}
       */
    value: {
      type: Object,
      default: null
    },

    /**
       * An array of strings or objects to be used as dropdown choices.
       * If you are using an array of objects, vue-select will look for
       * a `label` key (eg. [{label: 'This is Foo', value: 'foo'}]). A
       * custom label key can be set with the `label` prop.
       * @type {Array}
       */
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
       * Disable the entire component.
       * @type {Boolean}
       */
    disabled: {
      type: Boolean,
      default: false
    },

    /**
       * Can the user clear the selected property.
       * @type {Boolean}
       */
    clearable: {
      type: Boolean,
      default: true
    },

    /**
       * Sets the max-height property on the dropdown list.
       * @deprecated
       * @type {String}
       */
    maxHeight: {
      type: String,
      default: '400px'
    },

    /**
       * Enable/disable filtering the options.
       * @type {Boolean}
       */
    searchable: {
      type: Boolean,
      default: true
    },

    /**
       * Equivalent to the `multiple` attribute on a `<select>` input.
       * @type {Boolean}
       */
    multiple: {
      type: Boolean,
      default: false
    },

    /**
       * Equivalent to the `placeholder` attribute on an `<input>`.
       * @type {String}
       */
    placeholder: {
      type: String,
      default: ''
    },

    /**
       * Sets a Vue transition property on the `.dropdown-menu`. vue-select
       * does not include CSS for transitions, you'll need to add them yourself.
       * @type {String}
       */
    transition: {
      type: String,
      default: 'fade'
    },

    /**
       * Enables/disables clearing the search text when an option is selected.
       * @type {Boolean}
       */
    clearSearchOnSelect: {
      type: Boolean,
      default: true
    },

    /**
       * Close a dropdown when an option is chosen. Set to false to keep the dropdown
       * open (useful when combined with multi-select, for example)
       * @type {Boolean}
       */
    closeOnSelect: {
      type: Boolean,
      default: true
    },

    /**
       * Tells vue-select what key to use when generating option
       * labels when each `option` is an object.
       * @type {String}
       */
    label: {
      type: String,
      default: 'label'
    },

    /**
       * Tells vue-select what key to use when generating option
       * values when each `option` is an object.
       * @type {String}
       */
    index: {
      type: String,
      default: null
    },

    /**
       * Callback to generate the label text. If {option}
       * is an object, returns option[this.label] by default.
       *
       * Label text is used for filtering comparison and
       * displaying. If you only need to adjust the
       * display, you should use the `option` and
       * `selected-option` slots.
       *
       * @type {Function}
       * @param  {Object || String} option
       * @return {String}
       */
    getOptionLabel: {
      type: Function,
      default: function _default(option) {
        if (this.index) {
          option = this.findOptionByIndexValue(option);
        }

        if (_typeof(option) === 'object') {
          if (!option.hasOwnProperty(this.label)) {
            return window.console.warn("[vue-select warn]: Label key \"option.".concat(this.label, "\" does not") + " exist in options object ".concat(JSON.stringify(option), ".\n") + 'http://sagalbot.github.io/vue-select/#ex-labels');
          }

          return option[this.label];
        }

        return option;
      }
    },

    /**
       * An optional callback function that is called each time the selected
       * value(s) change. When integrating with Vuex, use this callback to trigger
       * an action, rather than using :value.sync to retreive the selected value.
       * @type {Function}
       * @param {Object || String} val
       */
    onChange: {
      type: Function,
      default: function _default(val) {
        this.$emit('input', val);
      }
    },

    /**
       * Select the current value if selectOnTab is enabled
       */
    onTab: {
      type: Function,
      default: function _default() {
        if (this.selectOnTab) {
          this.typeAheadSelect();
        }
      }
    },

    /**
       * Enable/disable creating options from searchInput.
       * @type {Boolean}
       */
    taggable: {
      type: Boolean,
      default: false
    },

    /**
       * Set the tabindex for the input field.
       * @type {Number}
       */
    tabindex: {
      type: Number,
      default: null
    },

    /**
       * When true, newly created tags will be added to
       * the options list.
       * @type {Boolean}
       */
    pushTags: {
      type: Boolean,
      default: false
    },

    /**
       * When true, existing options will be filtered
       * by the search text. Should not be used in conjunction
       * with taggable.
       * @type {Boolean}
       */
    filterable: {
      type: Boolean,
      default: true
    },

    /**
       * Callback to determine if the provided option should
       * match the current search text. Used to determine
       * if the option should be displayed.
       * @type   {Function}
       * @param  {Object || String} option
       * @param  {String} label
       * @param  {String} search
       * @return {Boolean}
       */
    filterBy: {
      type: Function,
      default: function _default(option, label, search) {
        return (label || '').toLowerCase().indexOf(search.toLowerCase()) > -1;
      }
    },

    /**
       * Callback to filter results when search text
       * is provided. Default implementation loops
       * each option, and returns the result of
       * this.filterBy.
       * @type   {Function}
       * @param  {Array} list of options
       * @param  {String} search text
       * @param  {Object} vSelect instance
       * @return {Boolean}
       */
    filter: {
      'type': Function,
      default: function _default(options, search) {
        var _this = this;

        return options.filter(function (option) {
          var label = _this.getOptionLabel(option);

          if (typeof label === 'number') {
            label = label.toString();
          }

          return _this.filterBy(option, label, search);
        });
      }
    },

    /**
       * User defined function for adding Options
       * @type {Function}
       */
    createOption: {
      type: Function,
      default: function _default(newOption) {
        if (_typeof(this.mutableOptions[0]) === 'object') {
          newOption = _defineProperty({}, this.label, newOption);
        }

        this.$emit('option:created', newOption);
        return newOption;
      }
    },

    /**
       * When false, updating the options will not reset the select value
       * @type {Boolean}
       */
    resetOnOptionsChange: {
      type: Boolean,
      default: false
    },

    /**
       * Disable the dropdown entirely.
       * @type {Boolean}
       */
    noDrop: {
      type: Boolean,
      default: false
    },

    /**
       * Sets the id of the input element.
       * @type {String}
       * @default {null}
       */
    inputId: {
      type: String,
      default: 'search-input'
    },

    /**
       * Sets RTL support. Accepts 'ltr', 'rtl', 'auto'.
       * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir
       * @type {String}
       * @default 'auto'
       */
    dir: {
      type: String,
      default: 'auto'
    },

    /**
       * When true, hitting the 'tab' key will select the current select value
       * @type {Boolean}
       */
    selectOnTab: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      search: '',
      open: false,
      mutableValue: null,
      mutableOptions: []
    };
  },
  computed: {
    /**
       * Classes to be output on .dropdown
       * @return {Object}
       */
    dropdownClasses: function dropdownClasses() {
      return {
        open: this.dropdownOpen,
        single: !this.multiple,
        searching: this.searching,
        searchable: this.searchable,
        unsearchable: !this.searchable,
        loading: this.mutableLoading,
        rtl: this.dir === 'rtl',
        // This can be removed - styling is handled by `dir="rtl"` attribute
        disabled: this.disabled
      };
    },

    /**
       * If search text should clear on blur
       * @return {Boolean} True when single and clearSearchOnSelect
       */
    clearSearchOnBlur: function clearSearchOnBlur() {
      return this.clearSearchOnSelect && !this.multiple;
    },

    /**
       * Return the current state of the
       * search input
       * @return {Boolean} True if non empty value
       */
    searching: function searching() {
      return !!this.search;
    },

    /**
       * Return the current state of the
       * dropdown menu.
       * @return {Boolean} True if open
       */
    dropdownOpen: function dropdownOpen() {
      return this.noDrop ? false : this.open && !this.mutableLoading;
    },

    /**
       * Return the placeholder string if it's set
       * & there is no value selected.
       * @return {String} Placeholder text
       */
    searchPlaceholder: function searchPlaceholder() {
      if (this.isValueEmpty && this.placeholder) {
        return this.placeholder;
      }

      return '';
    },

    /**
       * The currently displayed options, filtered
       * by the search elements value. If tagging
       * true, the search text will be prepended
       * if it doesn't already exist.
       *
       * @return {array}
       */
    filteredOptions: function filteredOptions() {
      if (!this.filterable && !this.taggable) {
        return this.mutableOptions.slice();
      }

      var options = this.search.length ? this.filter(this.mutableOptions, this.search, this) : this.mutableOptions;

      if (this.taggable && this.search.length && !this.optionExists(this.search)) {
        options.unshift(this.search);
      }

      return options;
    },

    /**
       * Check if there aren't any options selected.
       * @return {Boolean}
       */
    isValueEmpty: function isValueEmpty() {
      if (this.mutableValue) {
        if (_typeof(this.mutableValue) === 'object') {
          return !Object.keys(this.mutableValue).length;
        }

        return !this.valueAsArray.length;
      }

      return true;
    },

    /**
       * Return the current value in array format.
       * @return {Array}
       */
    valueAsArray: function valueAsArray() {
      if (this.multiple && this.mutableValue) {
        return this.mutableValue;
      } else if (this.mutableValue) {
        return [].concat(this.mutableValue);
      }

      return [];
    },

    /**
       * Determines if the clear button should be displayed.
       * @return {Boolean}
       */
    showClearButton: function showClearButton() {
      return !this.multiple && this.clearable && !this.open && this.mutableValue != null;
    }
  },
  watch: {
    /**
       * When the value prop changes, update
       * the internal mutableValue.
       * @param  {mixed} val
       * @return {void}
       */
    value: function value(val) {
      this.mutableValue = val;
    },

    /**
       * Maybe run the onChange callback.
       * @param  {string|object} val
       * @param  {string|object} old
       * @return {void}
       */
    mutableValue: function mutableValue(val, old) {
      if (this.multiple) {
        return this.onChange ? this.onChange(val) : null;
      } else {
        return this.onChange && val !== old ? this.onChange(val) : null;
      }
    },

    /**
       * When options change, update
       * the internal mutableOptions.
       * @param  {array} val
       * @return {void}
       */
    options: function options(val) {
      this.mutableOptions = val;
    },

    /**
       * Maybe reset the mutableValue
       * when mutableOptions change.
       * @return {[type]} [description]
       */
    mutableOptions: function mutableOptions() {
      if (!this.taggable && this.resetOnOptionsChange) {
        this.mutableValue = this.multiple ? [] : null;
      }
    },

    /**
       * Always reset the mutableValue when
       * the multiple prop changes.
       * @param  {Boolean} val
       * @return {void}
       */
    multiple: function multiple(val) {
      this.mutableValue = val ? [] : null;
    }
  },

  /**
     * Clone props into mutable values,
     * attach any event listeners.
     */
  created: function created() {
    this.mutableValue = this.value;
    this.mutableOptions = this.options.slice(0);
    this.mutableLoading = this.loading;
    this.$on('option:created', this.maybePushTag);
  },
  methods: {
    /**
       * Select a given option.
       * @param  {Object|String} option
       * @return {void}
       */
    select: function select(option) {
      if (!this.isOptionSelected(option)) {
        if (this.taggable && !this.optionExists(option)) {
          option = this.createOption(option);
        }

        if (this.index) {
          if (!option.hasOwnProperty(this.index)) {
            return window.console.warn("[vue-select warn]: Index key \"option.".concat(this.index, "\" does not") + " exist in options object ".concat(JSON.stringify(option), "."));
          }

          option = option[this.index];
        }

        if (this.multiple && !this.mutableValue) {
          this.mutableValue = [option];
        } else if (this.multiple) {
          this.mutableValue.push(option);
        } else {
          this.mutableValue = option;
        }
      }

      this.onAfterSelect(option);
    },

    /**
       * De-select a given option.
       * @param  {Object|String} option
       * @return {void}
       */
    deselect: function deselect(option) {
      var _this2 = this;

      if (this.multiple) {
        var ref = -1;
        this.mutableValue.forEach(function (val) {
          if (val === option || _this2.index && val === option[_this2.index] || _typeof(val) === 'object' && val[_this2.label] === option[_this2.label]) {
            ref = val;
          }
        });
        var index = this.mutableValue.indexOf(ref);
        this.mutableValue.splice(index, 1);
      } else {
        this.mutableValue = null;
      }
    },

    /**
       * Clears the currently selected value(s)
       * @return {void}
       */
    clearSelection: function clearSelection() {
      this.mutableValue = this.multiple ? [] : null;
    },

    /**
       * Called from this.select after each selection.
       * @param  {Object|String} option
       * @return {void}
       */
    onAfterSelect: function onAfterSelect(option) {
      if (this.closeOnSelect) {
        this.open = !this.open;
        this.$refs.search.blur();
      }

      if (this.clearSearchOnSelect) {
        this.search = '';
      }
    },

    /**
       * Toggle the visibility of the dropdown menu.
       * @param  {Event} e
       * @return {void}
       */
    toggleDropdown: function toggleDropdown() {
      this.open = !this.open;

      if (this.searchable) {
        if (this.open) {
          this.$refs.search.focus();
        } else {
          this.$refs.search.blur();
        }
      }
    },

    /**
       * Check if the given option is currently selected.
       * @param  {Object|String}  option
       * @return {Boolean}        True when selected | False otherwise
       */
    isOptionSelected: function isOptionSelected(option) {
      var _this3 = this;

      var selected = false;
      this.valueAsArray.forEach(function (value) {
        if (_typeof(value) === 'object') {
          selected = _this3.optionObjectComparator(value, option);
        } else if (value === option || value === option[_this3.index]) {
          selected = true;
        }
      });
      return selected;
    },

    /**
       * Determine if two option objects are matching.
       *
       * @param value {Object}
       * @param option {Object}
       * @returns {boolean}
       */
    optionObjectComparator: function optionObjectComparator(value, option) {
      if (this.index && value === option[this.index]) {
        return true;
      } else if (value[this.label] === option[this.label] || value[this.label] === option) {
        return true;
      } else if (this.index && value[this.index] === option[this.index]) {
        return true;
      }

      return false;
    },

    /**
       * Finds an option from this.options
       * where option[this.index] matches
       * the passed in value.
       *
       * @param value {Object}
       * @returns {*}
       */
    findOptionByIndexValue: function findOptionByIndexValue(value) {
      var _this4 = this;

      this.options.forEach(function (_option) {
        if (JSON.stringify(_option[_this4.index]) === JSON.stringify(value)) {
          value = _option;
        }
      });
      return value;
    },

    /**
       * If there is any text in the search input, remove it.
       * Otherwise, blur the search input to close the dropdown.
       * @return {void}
       */
    onEscape: function onEscape() {
      if (!this.search.length) {
        this.$refs.search.blur();
      } else {
        this.search = '';
      }
    },

    /**
       * Close the dropdown on blur.
       * @emits  {search:blur}
       * @return {void}
       */
    onSearchBlur: function onSearchBlur() {
      var _this5 = this;

      if (this.mousedown && !this.searching) {
        this.mousedown = false;
      } else {
        if (this.clearSearchOnBlur) {
          setTimeout(function () {
            _this5.search = '';
            _this5.open = false;
          }, 100);
        }

        this.$emit('search:blur');
      }
    },

    /**
       * Open the dropdown on focus.
       * @emits  {search:focus}
       * @return {void}
       */
    onSearchFocus: function onSearchFocus() {
      this.$emit('search:focus');
    },

    /**
       * Delete the value on Delete keypress when there is no
       * text in the search input, & there's tags to delete
       * @return {this.value}
       */
    maybeDeleteValue: function maybeDeleteValue() {
      if (!this.$refs.search.value.length && this.mutableValue) {
        if (this.multiple) {
          return this.mutableValue.pop();
        } else {
          this.mutableValue = null;
        }
      }
    },

    /**
       * Determine if an option exists
       * within this.mutableOptions array.
       *
       * @param  {Object || String} option
       * @return {boolean}
       */
    optionExists: function optionExists(option) {
      var _this6 = this;

      var exists = false;
      this.mutableOptions.forEach(function (opt) {
        if (_typeof(opt) === 'object' && opt[_this6.label] === option) {
          exists = true;
        } else if (opt === option) {
          exists = true;
        }
      });
      return exists;
    },

    /**
       * If push-tags is true, push the
       * given option to mutableOptions.
       *
       * @param  {Object || String} option
       * @return {void}
       */
    maybePushTag: function maybePushTag(option) {
      if (this.pushTags) {
        this.mutableOptions.push(option);
      }
    },

    /**
       * Event-Handler to help workaround IE11 (probably fixes 10 as well)
       * firing a `blur` event when clicking
       * the dropdown's scrollbar, causing it
       * to collapse abruptly.
       * @return {void}
       */
    onMousedown: function onMousedown() {
      this.mousedown = true;
    }
  }
};
exports.default = _default;
        var $6e003f = exports.default || module.exports;
      
      if (typeof $6e003f === 'function') {
        $6e003f = $6e003f.options;
      }
    
        /* template */
        Object.assign($6e003f, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"dropdown v-select",class:_vm.dropdownClasses,attrs:{"dir":_vm.dir}},[_c('div',{ref:"toggle",staticClass:"dropdown-toggle",on:{"click":_vm.toggleDropdown}},[_c('div',{ref:"selectedOptions",staticClass:"vs__selected-options"},[_vm._l((_vm.valueAsArray),function(option){return _vm._t("selected-option-container",[_c('span',{key:option.index,staticClass:"selected-tag"},[_vm._t("selected-option",[_vm._v("\n            "+_vm._s(_vm.getOptionLabel(option))+"\n          ")],null,(typeof option === 'object')?option:( _obj = {}, _obj[_vm.label] = option, _obj )),_vm._v(" "),(_vm.multiple)?_c('button',{staticClass:"close",attrs:{"disabled":_vm.disabled,"type":"button","aria-label":"Remove option"},on:{"click":function($event){_vm.deselect(option)}}},[_c('span',{attrs:{"aria-hidden":"true"}},[_vm._v("\n              \n            ")])]):_vm._e()],2)],{option:(typeof option === 'object')?option:( _obj$1 = {}, _obj$1[_vm.label] = option, _obj$1 ),deselect:_vm.deselect,multiple:_vm.multiple,disabled:_vm.disabled})
var _obj;
var _obj$1;}),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.search),expression:"search"}],ref:"search",staticClass:"form-control",attrs:{"id":_vm.inputId,"disabled":_vm.disabled,"placeholder":_vm.searchPlaceholder,"tabindex":_vm.tabindex,"readonly":!_vm.searchable,"aria-expanded":_vm.dropdownOpen,"type":"search","autocomplete":"off","role":"combobox","aria-label":"Search for option"},domProps:{"value":(_vm.search)},on:{"keydown":[function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"delete",[8,46],$event.key,["Backspace","Delete"])){ return null; }return _vm.maybeDeleteValue($event)},function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"tab",9,$event.key,"Tab")){ return null; }return _vm.onTab($event)}],"keyup":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"esc",27,$event.key,"Escape")){ return null; }return _vm.onEscape($event)},"blur":_vm.onSearchBlur,"focus":_vm.onSearchFocus,"input":function($event){if($event.target.composing){ return; }_vm.search=$event.target.value}}})],2),_vm._v(" "),_c('div',{staticClass:"vs__actions"},[_c('button',{directives:[{name:"show",rawName:"v-show",value:(_vm.showClearButton),expression:"showClearButton"}],staticClass:"clear",attrs:{"disabled":_vm.disabled,"type":"button","title":"Clear selection"},on:{"click":_vm.clearSelection}},[_c('span',{attrs:{"aria-hidden":"true"}},[_vm._v("\n          \n        ")])]),_vm._v(" "),(!_vm.noDrop)?_c('i',{ref:"openIndicator",staticClass:"open-indicator",attrs:{"role":"presentation"}}):_vm._e(),_vm._v(" "),_vm._t("spinner",[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.mutableLoading),expression:"mutableLoading"}],staticClass:"spinner"},[_vm._v("\n          Loading...\n        ")])])],2)]),_vm._v(" "),_c('transition',{attrs:{"name":_vm.transition}},[(_vm.dropdownOpen)?_c('ul',{ref:"dropdownMenu",staticClass:"dropdown-menu",style:({ 'max-height': _vm.maxHeight }),attrs:{"role":"listbox"},on:{"mousedown":_vm.onMousedown}},[_vm._l((_vm.filteredOptions),function(option,idx){return _c('li',{key:idx,class:{ active: _vm.isOptionSelected(option) },attrs:{"role":"option"}},[_c('button',{staticClass:"option-container",on:{"click":function($event){_vm.select(option)}}},[_vm._t("option",[_vm._v("\n            "+_vm._s(_vm.getOptionLabel(option))+"\n          ")],null,(typeof option === 'object') ? option : ( _obj = {}, _obj[_vm.label] = option, _obj ))],2)])
var _obj;}),_vm._v(" "),(!_vm.filteredOptions.length)?_c('li',{staticClass:"no-options",attrs:{"role":"option"}},[_vm._t("no-options",[_vm._v("\n          Sorry, no matching options.\n        ")],null,{ value: _vm.search, select: _vm.select })],2):_vm._e()],2):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"cosn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  USER: 'USER',
  ADMIN: 'ADMINISTRATOR'
};
exports.default = _default;
},{}],"hUa8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _toolSearchInput = _interopRequireDefault(require("../components/tool-search-input"));

var _toolSearchResult = _interopRequireDefault(require("../components/tool-search-result"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab"));

var _nfcScan = _interopRequireDefault(require("../components/nfc-scan"));

var _addButton = _interopRequireDefault(require("../components/add-button"));

var _select = _interopRequireDefault(require("../components/select"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _roles = _interopRequireDefault(require("../utils/roles"));

var _platforms = _interopRequireDefault(require("../utils/platforms"));

var _nfc = _interopRequireDefault(require("../mixins/nfc"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["mutation transferTools($tool_id_list: [ID!]!, $to_owner_id: ID!) {\n          transferMultipleTool (tool_id_list: $tool_id_list, to_owner_id: $to_owner_id) {\n            id\n            type {\n              id\n              name\n            }\n            brand {\n              id\n              name\n            }\n            status\n            owner {\n              ... on Location {\n                 id\n                 name\n                 type\n              }\n              ... on User {\n                 id\n                 first_name\n                 last_name\n                 type\n              }\n            }\n          }\n        }"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _templateObject4() {
  var data = _taggedTemplateLiteral(["query tools($query: String, $toolFilter: ToolFilter, $pagingParameters: PagingParameters) {\n        searchTool(query: $query, toolFilter: $toolFilter, pagingParameters: $pagingParameters) {\n          id\n          type {\n            id\n            name\n          }\n          brand {\n            id\n            name\n          }\n          status\n          owner {\n            ... on Location {\n               id\n               name\n               type\n            }\n            ... on User {\n               id\n               first_name\n               last_name\n               type\n            }\n          }\n        }\n      }"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["query selectedTools($tool_ids: [ID!]!) {\n        getMultipleTool(tool_ids: $tool_ids) {\n          id\n          type {\n            id\n            name\n          }\n          brand {\n            id\n            name\n          }\n          status\n          owner {\n            ... on Location {\n               id\n               name\n               type\n            }\n            ... on User {\n               id\n               first_name\n               last_name\n               type\n            }\n          }\n        }\n      }"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["query {\n        getAllUser {\n          id\n          first_name\n          last_name\n          role\n          type\n          status\n        }\n      }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["query {\n        getAllLocation {\n          id\n          name\n          type\n        }\n      }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'Tools',
  components: {
    ToolSearchInput: _toolSearchInput.default,
    ToolSearchResult: _toolSearchResult.default,
    ExtendedFab: _extendedFab.default,
    vSelect: _select.default,
    NfcScan: _nfcScan.default,
    AddButton: _addButton.default
  },
  mixins: [_nfc.default],
  apollo: {
    getAllLocation: {
      query: (0, _graphqlTag.default)(_templateObject()),
      fetchPolicy: 'network-only'
    },
    getAllUser: {
      query: (0, _graphqlTag.default)(_templateObject2()),
      fetchPolicy: 'network-only'
    },
    getMultipleTool: {
      query: (0, _graphqlTag.default)(_templateObject3()),
      variables: function variables() {
        return {
          tool_ids: this.$store.getters.selectedTools
        };
      },
      fetchPolicy: 'network-only'
    },
    searchTool: {
      query: (0, _graphqlTag.default)(_templateObject4()),
      variables: function variables() {
        var options = {
          pagingParameters: {
            page_size: this.pageSize,
            page_number: this.pageNumber
          }
        };

        if (this.searchString) {
          options.query = this.searchString;
        }

        if (this.filters) {
          options.toolFilter = this.filters;
        }

        if (this.isNonAdminTransfer) {
          if (!options.toolFilter) {
            options.toolFilter = {};
          }

          if (!options.toolFilter.owner_ids || !options.toolFilter.owner_ids.length) {
            options.toolFilter.owner_ids = _toConsumableArray(this.locationIds).concat([this.currentUser.id]);
          }
        }

        return options;
      },
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    var states = {
      INITIAL: 'INITIAL',
      SELECTING: 'SELECTING',
      FINALIZING: 'FINALIZING'
    };
    return {
      filterMap: {
        BRAND: 'brand_ids',
        USER: 'owner_ids',
        LOCATION: 'owner_ids',
        TYPE: 'type_ids',
        STATUS: 'tool_statuses'
      },
      transferTarget: {
        id: null,
        label: 'select user'
      },
      searchTool: [],
      pageNumber: 0,
      pageSize: 15,
      searchString: null,
      filters: null,
      paginationLoading: false,
      transferInProgress: false,
      clearFuzzyFilter: false,
      tags: [],
      states: states
    };
  },
  computed: {
    infiniteScrollPageNumber: function infiniteScrollPageNumber() {
      var tools = (this.showOnlySelectedTools ? this.getMultipleTool : this.searchTool) || [];
      return Math.ceil(tools.length / this.pageSize);
    },
    currentUser: function currentUser() {
      return JSON.parse(window.localStorage.getItem('currentUser'));
    },
    isAdmin: function isAdmin() {
      return this.currentUser.role === _roles.default.ADMIN;
    },
    isNonAdminTransfer: function isNonAdminTransfer() {
      return this.currentState === this.states.SELECTING && !this.isAdmin;
    },
    showOnlySelectedTools: function showOnlySelectedTools() {
      return this.$store.state.showOnlySelectedTools;
    },
    currentState: function currentState() {
      return this.$store.state.transferState;
    },
    tools: function tools() {
      if (this.showOnlySelectedTools) {
        return this.getMultipleTool || [];
      }

      var tools = this.searchTool || [];

      if (this.isNonAdminTransfer) {
        tools = tools.filter(function (tool) {
          return tool.owner.type !== 'LOCATION' || tool.status === 'AVAILABLE';
        });
      }

      return tools;
    },
    transferTargets: function transferTargets() {
      return this.users.concat(this.locations);
    },
    users: function users() {
      if (this.getAllUser) {
        this.getAllUser.forEach(function (user) {
          user.label = "".concat(user.first_name, " ").concat(user.last_name);
        });
      }

      return this.getAllUser || [];
    },
    locationIds: function locationIds() {
      return this.locations.map(function (location) {
        return location.id;
      });
    },
    locations: function locations() {
      if (this.getAllLocation) {
        this.getAllLocation.forEach(function (location) {
          location.label = location.name;
        });
      }

      return this.getAllLocation || [];
    },
    numSelectedTools: function numSelectedTools() {
      return this.$store.getters.selectedTools.length;
    },
    formattedNumSelectedTools: function formattedNumSelectedTools() {
      return "".concat(this.numSelectedTools, " ").concat(this.numSelectedTools === 1 ? 'tool' : 'tools');
    }
  },
  mounted: function mounted() {
    if (this.checkIsNfcEnabled() && window.device.platform === _platforms.default.ANDROID) {
      // add a noop nfc listener to keep nfc scans on android from bubbling up to the OS
      window.nfc.addNdefListener(function () {
        return 0;
      });
    }
  },
  methods: {
    showTransferSuccessMsg: function showTransferSuccessMsg() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'TRANSFER SUCCESS',
        text: 'Successfully Transferred Tools',
        timer: 1500,
        showConfirmButton: false
      });
    },
    showTransferErrorMsg: function showTransferErrorMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'TRANSFER ERROR',
        text: 'Error Transferring Tools. Please Try Again or Contact Support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    clearSearchFilters: function clearSearchFilters() {
      this.filters = null;
      this.tags = [];
      this.clearFuzzyFilter = !this.clearFuzzyFilter;
    },
    resetInfiniteScroll: function resetInfiniteScroll() {
      this.hasLoadedLastPage = false;
      this.resetScrollPosition();
    },
    resetScrollPosition: function resetScrollPosition() {
      this.$refs.scrollElement.scrollTo(0, 0);
    },
    onScan: function onScan(value) {
      if (this.currentState === this.states.INITIAL) {
        this.transitionToToolInfo(value);
      } else {
        this.$store.commit('toggleToolSelection', value);
      }
    },
    transitionToToolInfo: function transitionToToolInfo(toolId) {
      this.$router.push({
        name: 'toolDetail',
        params: {
          toolId: toolId
        }
      });
    },
    transitionToAdd: function transitionToAdd() {
      this.$router.push({
        name: 'newTool'
      });
    },
    updateFilters: function updateFilters() {
      var _this = this;

      var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var fuzzySearch = arguments.length > 1 ? arguments[1] : undefined;
      this.tags = tags;
      this.searchString = fuzzySearch;
      var newFilters = tags.length ? {} : null;
      tags.forEach(function (filter) {
        var key = _this.filterMap[filter.type];

        if (!newFilters[key]) {
          newFilters[key] = [filter.id];
        } else {
          newFilters[key].push(filter.id);
        }
      });
      this.filters = newFilters;
      this.resetInfiniteScroll();
    },
    moveToSelectingState: function moveToSelectingState() {
      this.$store.commit('setShowOnlySelectedTools', false);
      this.$store.commit('updateTransferStatus', this.states.SELECTING);

      if (!this.isAdmin) {
        this.clearSearchFilters();
        this.resetScrollPosition();
      }
    },
    cancelTransfer: function cancelTransfer() {
      this.$store.commit('resetSelectedTools');
      this.$store.commit('setShowOnlySelectedTools', false);
      this.$store.commit('updateTransferStatus', this.states.INITIAL);
      this.resetInfiniteScroll();
    },
    toggleViewSelected: function toggleViewSelected() {
      this.$store.commit('toggleShowOnlySelectedTools');
      this.resetScrollPosition();
    },
    loadMore: function loadMore() {
      var _this2 = this;

      if (this.hasLoadedLastPage || !this.tools.length || this.$apollo.queries.searchTool.loading || this.showOnlySelectedTools) {
        return;
      }

      this.paginationLoading = true;
      var options = {
        pagingParameters: {
          page_size: this.pageSize,
          page_number: this.infiniteScrollPageNumber
        }
      };

      if (this.searchString) {
        options.query = this.searchString;
      }

      if (this.filters) {
        options.toolFilter = this.filters;
      }

      this.$apollo.queries.searchTool.fetchMore({
        variables: options,
        updateQuery: function updateQuery(previousResult, _ref) {
          var fetchMoreResult = _ref.fetchMoreResult;
          _this2.hasLoadedLastPage = !fetchMoreResult.searchTool.length;
          return {
            searchTool: _toConsumableArray(previousResult.searchTool).concat(_toConsumableArray(fetchMoreResult.searchTool))
          };
        }
      }).then(function () {
        _this2.paginationLoading = false;
      });
    },
    finalizeTransfer: function finalizeTransfer() {
      var _this3 = this;

      this.transferInProgress = true;
      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject5()),
        variables: {
          tool_id_list: this.$store.getters.selectedTools,
          to_owner_id: this.transferTarget.id
        }
      }).then(function (response) {
        _this3.resetScrollPosition();

        response.data.transferMultipleTool.forEach(function (tool) {
          var idx = _this3.searchTool.findIndex(function (entry) {
            return entry.id === tool.id;
          });

          _this3.searchTool[idx] = tool;
        });

        _this3.$store.commit('resetSelectedTools');

        _this3.$store.commit('setShowOnlySelectedTools', false);

        _this3.$store.commit('updateTransferStatus', _this3.states.INITIAL);

        _this3.showTransferSuccessMsg();
      }).catch(function () {
        _this3.showTransferErrorMsg();
      }).finally(function () {
        _this3.transferInProgress = false;
      });
    },
    proceedToFinalize: function proceedToFinalize() {
      this.$store.commit('setShowOnlySelectedTools', true);
      this.$store.commit('updateTransferStatus', this.states.FINALIZING);
      this.resetScrollPosition();
    }
  }
};
exports.default = _default;
        var $7ddb3a = exports.default || module.exports;
      
      if (typeof $7ddb3a === 'function') {
        $7ddb3a = $7ddb3a.options;
      }
    
        /* template */
        Object.assign($7ddb3a, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page tools-page"},[_c('div',{staticClass:"search-bar"},[_c('tool-search-input',{attrs:{"clear-fuzzy-filter":_vm.clearFuzzyFilter,"tags":_vm.tags,"update-tags":_vm.updateFilters,"disable-user-search":_vm.isNonAdminTransfer}}),_vm._v(" "),_c('nfc-scan',{attrs:{"on-scan":_vm.onScan}})],1),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.transferInProgress)?_c('div',{staticClass:"overlay"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),(_vm.$mq === 'mobile' && _vm.currentState === _vm.states.INITIAL)?_c('extended-fab',{staticClass:"transfer-btn",attrs:{"on-click":_vm.moveToSelectingState,"icon-class":"fa-exchange-alt","button-text":"TRANSFER"}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"tools-menu-container"},[_c('div',{staticClass:"floating-action-bar"},[(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.INITIAL)?_c('extended-fab',{staticClass:"transfer-btn",attrs:{"on-click":_vm.moveToSelectingState,"icon-class":"fa-exchange-alt","button-text":"TRANSFER"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.SELECTING)?_c('extended-fab',{staticClass:"cancel-fab-btn",attrs:{"on-click":_vm.cancelTransfer,"icon-class":"fa-times","button-text":"CANCEL"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.SELECTING)?_c('extended-fab',{staticClass:"view-fab-btn",attrs:{"on-click":_vm.toggleViewSelected,"icon-class":_vm.showOnlySelectedTools ? 'fa-check-square' : 'fa-list',"button-text":_vm.showOnlySelectedTools ? 'VIEW ALL' : 'VIEW SELECTED'}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.SELECTING)?_c('extended-fab',{staticClass:"view-fab-btn next-btn",class:{ disabled: _vm.numSelectedTools === 0 },attrs:{"on-click":_vm.proceedToFinalize,"disabled":_vm.numSelectedTools === 0,"icon-class":"fa-arrow-right","button-text":"NEXT"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.INITIAL)?_c('extended-fab',{staticClass:"add-btn",attrs:{"on-click":_vm.transitionToAdd,"icon-class":"fa-plus","button-text":"ADD TOOL"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.FINALIZING)?_c('extended-fab',{staticClass:"back-efab",attrs:{"on-click":_vm.moveToSelectingState,"icon-class":"fa-arrow-left","button-text":"BACK"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.FINALIZING)?_c('v-select',{staticClass:"dark-input",attrs:{"options":_vm.transferTargets,"filterable":false},model:{value:(_vm.transferTarget),callback:function ($$v) {_vm.transferTarget=$$v},expression:"transferTarget"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.currentState === _vm.states.FINALIZING)?_c('extended-fab',{staticClass:"finish-transfer",attrs:{"on-click":_vm.finalizeTransfer,"disabled":!_vm.transferTarget.id || _vm.numSelectedTools === 0,"icon-class":"fa-arrow-right","button-text":"FINISH"}}):_vm._e()],1),_vm._v(" "),_c('div',{directives:[{name:"infinite-scroll",rawName:"v-infinite-scroll",value:(_vm.loadMore),expression:"loadMore"}],ref:"scrollElement",staticClass:"tool-scroll-container",class:{ finalizing: _vm.currentState === _vm.states.FINALIZING },attrs:{"infinite-scroll-throttle-delay":"200"}},[(_vm.$mq === 'mobile' && _vm.currentState === _vm.states.INITIAL)?_c('add-button',{key:0,attrs:{"on-click":_vm.transitionToAdd,"text":"TOOL"}}):_vm._e(),_vm._v(" "),_c('transition',{attrs:{"name":"list-loading"}},[(_vm.$apollo.queries.searchTool.loading)?_c('div',{staticClass:"loading-container"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(!_vm.$apollo.queries.searchTool.loading && !_vm.tools.length)?_c('div',{staticClass:"no-tools-container"},[_c('span',{staticClass:"no-tools-text"},[_vm._v("\n            No Tools To Display\n          ")])]):_vm._e()]),_vm._v(" "),_c('transition-group',{attrs:{"name":"list-element","tag":"span"}},_vm._l((_vm.tools),function(tool){return _c('tool-search-result',{key:tool.id,attrs:{"tool":tool,"on-select":_vm.transitionToToolInfo,"show-select":_vm.currentState !== _vm.states.INITIAL}})})),_vm._v(" "),_c('transition',{attrs:{"name":"list-loading"}},[(_vm.$apollo.queries.searchTool.loading && _vm.paginationLoading)?_c('div',{staticClass:"loading-container"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()])],1)]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.$mq === 'mobile' && _vm.currentState === _vm.states.SELECTING)?_c('div',{staticClass:"nav-bar selection-action-bar"},[_c('div',{staticClass:"icon-text-container"},[_c('button',{staticClass:"fas fa-times menu-icon",on:{"click":_vm.cancelTransfer}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n            CANCEL\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"icon-text-container"},[_c('button',{staticClass:"fas menu-icon",class:{ 'fa-check-square': !_vm.showOnlySelectedTools, 'fa-list': _vm.showOnlySelectedTools },on:{"click":_vm.toggleViewSelected}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n            "+_vm._s(_vm.showOnlySelectedTools ? 'VIEW ALL' : 'VIEW SELECTED')+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"icon-text-container"},[_c('button',{staticClass:"fas fa-arrow-right menu-icon next-btn",class:{ disabled: _vm.numSelectedTools === 0 },attrs:{"disabled":_vm.numSelectedTools === 0},on:{"click":_vm.proceedToFinalize}},[_c('span',{staticClass:"icon-subtext"},[_vm._v("\n            NEXT\n          ")])])])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.$mq === 'mobile' && _vm.currentState === _vm.states.FINALIZING)?_c('div',{staticClass:"finalizing-action-bar"},[_c('div',{staticClass:"finalize-row finalize-header"},[_c('span',[_vm._v(" Transfer "+_vm._s(_vm.formattedNumSelectedTools)+" ")])]),_vm._v(" "),_c('div',{staticClass:"finalize-row finalize-middle"},[_c('span',{staticClass:"finalize-to-text"},[_vm._v("\n          To\n        ")]),_vm._v(" "),_c('v-select',{staticClass:"dark-input",attrs:{"options":_vm.transferTargets,"searchable":false},model:{value:(_vm.transferTarget),callback:function ($$v) {_vm.transferTarget=$$v},expression:"transferTarget"}})],1),_vm._v(" "),_c('div',{staticClass:"finalize-row finalize-footer"},[_c('extended-fab',{staticClass:"back-efab",attrs:{"on-click":_vm.moveToSelectingState,"outline-display":true,"icon-class":"fa-arrow-left","button-text":"BACK"}}),_vm._v(" "),_c('extended-fab',{staticClass:"finish-transfer",attrs:{"on-click":_vm.finalizeTransfer,"disabled":!_vm.transferTarget.id || _vm.numSelectedTools === 0,"icon-class":"fa-arrow-right","button-text":"FINISH"}})],1)]):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"sweetalert2":"Y8u2","../components/tool-search-input":"ECDW","../components/tool-search-result":"Yq/j","../components/extended-fab":"9Y+B","../components/nfc-scan":"Dg/3","../components/add-button":"VKUh","../components/select":"i+Lh","graphql-tag":"MbWf","../utils/roles":"cosn","../utils/platforms":"O2n5","../mixins/nfc":"eLa2"}],"hUDr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab.vue"));

var _apiStatusCodes = _interopRequireDefault(require("../utils/api-status-codes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["mutation attemptPasswordReset($new_password: String!, $password_reset_code: ID!) {\n              resetPassword(new_password: $new_password, password_reset_code: $password_reset_code)\n            }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["query checkResetCode($password_reset_code: ID!) {\n        isPasswordResetCodeValid(password_reset_code: $password_reset_code)\n      }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'PasswordReset',
  components: {
    ExtendedFab: _extendedFab.default
  },
  apollo: {
    isPasswordResetCodeValid: {
      query: (0, _graphqlTag.default)(_templateObject()),
      variables: function variables() {
        return {
          password_reset_code: this.$route.query.code
        };
      },
      result: function result(response) {
        if (!response.data.isPasswordResetCodeValid) {
          this.showInvalidTokenError();
          this.$router.push({
            path: '/login'
          });
        }
      }
    }
  },
  data: function data() {
    return {
      password: '',
      confirmPassword: ''
    };
  },
  methods: {
    showSuccessMsg: function showSuccessMsg() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'SUCCESS',
        text: 'Successfully Reset Password',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showErrorMsg: function showErrorMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'RESET FAILURE',
        text: 'There was an error trying to reset your password. Please try again or contact support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showInvalidTokenError: function showInvalidTokenError() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'INVALID TOKEN',
        text: 'Your Reset Token Has Expired. Please Try Resetting Your Password Again',
        timer: 2000,
        showConfirmButton: false
      });
    },
    attemptPasswordReset: function attemptPasswordReset() {
      var _this = this;

      this.$validator.validate().then(function (result) {
        if (result) {
          _this.$apollo.mutate({
            mutation: (0, _graphqlTag.default)(_templateObject2()),
            variables: {
              new_password: _this.password,
              password_reset_code: _this.$route.query.code
            }
          }).then(function (response) {
            if (response.data.resetPassword) {
              _this.showSuccessMsg();

              _this.$router.push({
                path: '/login'
              });
            } else {
              _this.showErrorMsg();
            }
          }).catch(function (response) {
            if (response && response.graphQLErrors.length && response.graphQLErrors[0].extensions.code === _apiStatusCodes.default.UNAUTHENTICATED) {
              _this.showInvalidTokenError();
            } else {
              _this.showErrorMsg();
            }
          });
        }
      });
    }
  }
};
exports.default = _default;
        var $9f6ed3 = exports.default || module.exports;
      
      if (typeof $9f6ed3 === 'function') {
        $9f6ed3 = $9f6ed3.options;
      }
    
        /* template */
        Object.assign($9f6ed3, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page password-reset-page"},[_c('img',{staticClass:"logo",attrs:{"src":"red_transparent_512x512.c01ec64a.png"}}),_vm._v(" "),_c('span',{staticClass:"header-text"},[_vm._v("\n    RESET YOUR PASSWORD\n  ")]),_vm._v(" "),_c('div',{staticClass:"input-card"},[_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.password),expression:"password"}],ref:"password",staticClass:"light-input",class:{'is-danger': _vm.errors.has('password')},attrs:{"name":"password","type":"password","placeholder":"Password"},domProps:{"value":(_vm.password)},on:{"input":function($event){if($event.target.composing){ return; }_vm.password=$event.target.value}}}),_vm._v(" "),_c('span',{staticClass:"is-danger error-msg"},[_vm._v("\n        "+_vm._s(_vm.errors.first('password'))+"\n      ")])]),_vm._v(" "),_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required|confirmed:password'),expression:"'required|confirmed:password'"},{name:"model",rawName:"v-model",value:(_vm.confirmPassword),expression:"confirmPassword"}],staticClass:"light-input",class:{'is-danger': _vm.errors.has('password_confirmation')},attrs:{"name":"password_confirmation","type":"password","placeholder":"Confirm Password","data-vv-as":"password"},domProps:{"value":(_vm.confirmPassword)},on:{"input":function($event){if($event.target.composing){ return; }_vm.confirmPassword=$event.target.value}}}),_vm._v(" "),_c('extended-fab',{attrs:{"on-click":_vm.attemptPasswordReset,"disabled":!_vm.password || !_vm.confirmPassword,"icon-class":"","button-text":"RESET"}})],1)])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"graphql-tag":"MbWf","sweetalert2":"Y8u2","../components/extended-fab.vue":"9Y+B","../utils/api-status-codes":"8A9v","./../assets/icons/web/red_transparent_512x512.png":[["red_transparent_512x512.c01ec64a.png","JDi5"],"JDi5"]}],"KS7g":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'HeaderCard',
  props: {
    title: {
      type: String,
      required: true
    },
    exitLink: {
      type: String,
      required: false,
      default: null
    }
  }
};
exports.default = _default;
        var $d7519d = exports.default || module.exports;
      
      if (typeof $d7519d === 'function') {
        $d7519d = $d7519d.options;
      }
    
        /* template */
        Object.assign($d7519d, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"header-card",class:{ 'no-link': !_vm.exitLink }},[(_vm.exitLink)?_c('router-link',{staticClass:"fas fa-times exit",attrs:{"to":_vm.exitLink}}):_vm._e(),_vm._v(" "),_c('span',{staticClass:"main-text"},[_vm._v("\n    "+_vm._s(_vm.title)+"\n  ")]),_vm._v(" "),(_vm.exitLink)?_c('div',{staticClass:"spacer"}):_vm._e()],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"TC0j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'Fab',
  props: {
    iconClass: {
      type: String,
      required: true
    },
    onClick: {
      type: Function,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    }
  }
};
exports.default = _default;
        var $7e4513 = exports.default || module.exports;
      
      if (typeof $7e4513 === 'function') {
        $7e4513 = $7e4513.options;
      }
    
        /* template */
        Object.assign($7e4513, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"fab",class:{ inactive: _vm.disabled },attrs:{"disabled":_vm.disabled},on:{"click":_vm.onClick}},[_c('div',{staticClass:"fab-icon-container"},[_c('i',{staticClass:"fas",class:_vm.iconClass})])])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"yzqm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fab = _interopRequireDefault(require("../components/fab"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'ConfigItem',
  components: {
    Fab: _fab.default
  },
  props: {
    configItem: {
      required: true,
      type: Object
    },
    onDelete: {
      required: true,
      type: Function
    },
    onSanctionToggle: {
      required: true,
      type: Function
    },
    onSave: {
      required: true,
      type: Function
    }
  },
  data: function data() {
    return {
      editing: false,
      changedName: ''
    };
  },
  methods: {
    deleteConfig: function deleteConfig() {
      this.$props.onDelete(this.$props.configItem);
    },
    save: function save() {
      if (this.$props.configItem.name !== this.changedName) {
        var changedConfig = {
          id: this.$props.configItem.id,
          name: this.changedName,
          sanctioned: this.$props.configItem.sanctioned
        };
        this.$props.onSave(changedConfig);
      }

      this.cancelEdit();
    },
    cancelEdit: function cancelEdit() {
      this.editing = false;
      this.changedName = '';
    },
    startEditing: function startEditing() {
      this.changedName = this.$props.configItem.name;
      this.editing = true;
    },
    toggleSanctioned: function toggleSanctioned() {
      this.$props.onSanctionToggle(this.$props.configItem);
    }
  }
};
exports.default = _default;
        var $43b0c9 = exports.default || module.exports;
      
      if (typeof $43b0c9 === 'function') {
        $43b0c9 = $43b0c9.options;
      }
    
        /* template */
        Object.assign($43b0c9, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-result",class:_vm.configItem.sanctioned ? 'sanctioned' : 'unsanctioned'},[_c('div',{staticClass:"element-container"},[(!_vm.editing)?_c('i',{staticClass:"fas fa-pen edit-icon",on:{"click":_vm.startEditing}}):_vm._e(),_vm._v(" "),(_vm.editing)?_c('i',{staticClass:"fas fa-save save-icon",on:{"click":_vm.save}}):_vm._e(),_vm._v(" "),(_vm.editing)?_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.changedName),expression:"changedName"}],domProps:{"value":(_vm.changedName)},on:{"input":function($event){if($event.target.composing){ return; }_vm.changedName=$event.target.value}}}):_vm._e(),_vm._v(" "),(_vm.editing)?_c('i',{staticClass:"fas fa-times cancel-icon",on:{"click":_vm.cancelEdit}}):_vm._e(),_vm._v(" "),(!_vm.editing)?_c('div',{staticClass:"main-container",on:{"click":_vm.startEditing}},[(!_vm.editing)?_c('div',{staticClass:"row"},[_c('span',{staticClass:"title"},[_vm._v("\n          "+_vm._s(_vm.configItem.name)+"\n        ")])]):_vm._e(),_vm._v(" "),(!_vm.editing)?_c('div',{staticClass:"row"},[_c('span',{staticClass:"subtitle"},[_vm._v("\n          "+_vm._s(_vm.configItem.sanctioned ? 'CONFIRMED' : 'NOT CONFIRMED')+"\n        ")])]):_vm._e()]):_vm._e(),_vm._v(" "),(!_vm.editing)?_c('div',{staticClass:"actions"},[(_vm.configItem.sanctioned)?_c('div',{staticClass:"action-group",on:{"click":_vm.toggleSanctioned}},[_c('fab',{attrs:{"on-click":_vm.toggleSanctioned,"icon-class":"fa-thumbs-down"}}),_vm._v("\n        REJECT\n      ")],1):_vm._e(),_vm._v(" "),(!_vm.configItem.sanctioned)?_c('div',{staticClass:"action-group",on:{"click":_vm.toggleSanctioned}},[_c('fab',{attrs:{"on-click":_vm.toggleSanctioned,"icon-class":"fa-thumbs-up"}}),_vm._v("\n        CONFIRM\n      ")],1):_vm._e(),_vm._v(" "),_c('div',{staticClass:"action-group"},[_c('fab',{attrs:{"on-click":_vm.deleteConfig,"icon-class":"fa-times"}}),_vm._v("\n        DELETE\n      ")],1)]):_vm._e()])])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"../components/fab":"TC0j"}],"mXEL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'AddResult',
  props: {
    text: {
      type: String,
      required: true
    },
    onSave: {
      type: Function,
      required: true
    }
  },
  data: function data() {
    return {
      creating: false,
      newBrand: ''
    };
  },
  methods: {
    save: function save() {
      this.creating = false;
      this.$props.onSave(this.newBrand);
      this.newBrand = '';
    },
    startCreating: function startCreating() {
      this.creating = true;
    },
    cancelCreating: function cancelCreating() {
      this.newBrand = '';
      this.creating = false;
    }
  }
};
exports.default = _default;
        var $388100 = exports.default || module.exports;
      
      if (typeof $388100 === 'function') {
        $388100 = $388100.options;
      }
    
        /* template */
        Object.assign($388100, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container search-result"},[(!_vm.creating)?_c('div',{staticClass:"default-text",on:{"click":_vm.startCreating}},[_c('i',{staticClass:"fas fa-plus"}),_vm._v("\n    NEW "+_vm._s(_vm.text)+"\n  ")]):_vm._e(),_vm._v(" "),(_vm.creating)?_c('div',{staticClass:"input-group"},[_c('i',{staticClass:"fas fa-save",on:{"click":_vm.save}}),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.newBrand),expression:"newBrand"}],attrs:{"placeholder":("Enter new " + (_vm.text.toLowerCase()))},domProps:{"value":(_vm.newBrand)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newBrand=$event.target.value}}}),_vm._v(" "),_c('i',{staticClass:"fas fa-times",on:{"click":_vm.cancelCreating}})]):_vm._e()])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"ERTQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _headerCard = _interopRequireDefault(require("../components/header-card"));

var _configItem = _interopRequireDefault(require("../components/config-item"));

var _configurableItems = _interopRequireDefault(require("../utils/configurable-items"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _addResult = _interopRequireDefault(require("../components/add-result"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n        query getAllConfigurableItem {\n          getAllConfigurableItem {\n            id\n            type\n            name\n            sanctioned\n          }\n        }\n      "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n              mutation updateConfigurableItem($item: UpdatedConfigurableItem!) {\n                updateConfigurableItem(updatedConfigurableItem: $item) {\n                  id\n                  type\n                  name\n                  sanctioned\n                }\n              }\n            "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n          mutation updateConfigurableItem($item: UpdatedConfigurableItem!) {\n            updateConfigurableItem(updatedConfigurableItem: $item) {\n              id\n              type\n              name\n              sanctioned\n            }\n          }\n        "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n              mutation createConfigurableItem($item: NewConfigurableItem!) {\n                createConfigurableItem(newConfigurableItem: $item) {\n                  type\n                  name\n                  sanctioned\n                }\n              }\n            "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n                mutation updateTool($tool: UpdatedTool!) {\n                  updateTool(updatedTool: $tool) {\n                    id\n                  }\n                }\n              "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          mutation deleteConfigurableItem($id: ID!) {\n            deleteConfigurableItem(configurable_item_id: $id) {\n              toolsWithConfigurableItem {\n                id,\n                type {\n                  id\n                },\n                brand {\n                  id\n                },\n                model_number,\n                serial_number,\n                status,\n                owner {\n                  ... on Location {\n                    id\n                  }\n                  ... on User {\n                    id\n                  }\n                },\n                purchased_from {\n                  id\n                },\n                date_purchased,\n                photo,\n                price,\n                year\n              }\n              deletedConfigurableItem {\n                id\n              }\n            }\n          }\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'Configuration',
  components: {
    HeaderCard: _headerCard.default,
    ConfigItem: _configItem.default,
    AddResult: _addResult.default
  },
  data: function data() {
    return {
      getAllConfigurableItem: null,
      tab: 0,
      replacementList: [],
      replacementType: '',
      replacementName: '',
      replaceBrandWith: null,
      replaceTypeWith: null,
      replaceSupplierWith: null,
      deleting: false,
      deletedConfig: {},
      ConfigurableItems: _configurableItems.default
    };
  },
  computed: {
    typeOptions: function typeOptions() {
      var _this = this;

      return this.types.sanctioned.filter(function (type) {
        return type.name !== _this.deletedConfig.name;
      });
    },
    supplierOptions: function supplierOptions() {
      var _this2 = this;

      return this.suppliers.sanctioned.filter(function (supplier) {
        return supplier.name !== _this2.deletedConfig.name;
      });
    },
    brandOptions: function brandOptions() {
      var _this3 = this;

      return this.brands.sanctioned.filter(function (brand) {
        return brand.name !== _this3.deletedConfig.name;
      });
    },
    titles: function titles() {
      return {
        BRAND: 'Brands',
        TYPE: 'Types',
        PURCHASED_FROM: 'Suppliers'
      };
    },
    title: function title() {
      var pages = [_configurableItems.default.BRAND, _configurableItems.default.TYPE, _configurableItems.default.PURCHASED_FROM];
      return this.titles[pages[this.tab]];
    },
    page: function page() {
      var pages = [_configurableItems.default.BRAND, _configurableItems.default.TYPE, _configurableItems.default.PURCHASED_FROM];
      return pages[this.tab];
    },
    configs: function configs() {
      if (this.page === 'BRAND') {
        return this.brands;
      } else if (this.page === 'TYPE') {
        return this.types;
      } else if (this.page === 'PURCHASED_FROM') {
        return this.suppliers;
      }

      return [];
    },
    brands: function brands() {
      var sanctionedBrands = [];
      var unsanctionedBrands = [];

      if (this.getAllConfigurableItem) {
        this.getAllConfigurableItem.forEach(function (item) {
          if (item['type'] === _configurableItems.default.BRAND && item['sanctioned'] === true) {
            sanctionedBrands.push(item);
          } else if (item['type'] === _configurableItems.default.BRAND && item['sanctioned'] === false) {
            unsanctionedBrands.push(item);
          }
        });
      }

      return {
        sanctioned: sanctionedBrands,
        unsanctioned: unsanctionedBrands
      };
    },
    types: function types() {
      var sanctionedTypes = [];
      var unsanctionedTypes = [];

      if (this.getAllConfigurableItem) {
        this.getAllConfigurableItem.forEach(function (item) {
          if (item['type'] === _configurableItems.default.TYPE && item['sanctioned'] === true) {
            sanctionedTypes.push(item);
          } else if (item['type'] === _configurableItems.default.TYPE && item['sanctioned'] === false) {
            unsanctionedTypes.push(item);
          }
        });
      }

      return {
        sanctioned: sanctionedTypes,
        unsanctioned: unsanctionedTypes
      };
    },
    suppliers: function suppliers() {
      var sanctionedSuppliers = [];
      var unsanctionedSuppliers = [];

      if (this.getAllConfigurableItem) {
        this.getAllConfigurableItem.forEach(function (item) {
          if (item['type'] === _configurableItems.default.PURCHASED_FROM && item['sanctioned'] === true) {
            sanctionedSuppliers.push(item);
          } else if (item['type'] === _configurableItems.default.PURCHASED_FROM && item['sanctioned'] === false) {
            unsanctionedSuppliers.push(item);
          }
        });
      }

      return {
        sanctioned: sanctionedSuppliers,
        unsanctioned: unsanctionedSuppliers
      };
    }
  },
  methods: {
    showInvalidItemMsg: function showInvalidItemMsg() {
      (0, _sweetalert.default)({
        type: 'warning',
        title: 'INVALID ITEM',
        text: 'You cannot create a duplicate item',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showBlankItemMsg: function showBlankItemMsg() {
      (0, _sweetalert.default)({
        type: 'warning',
        title: 'BLANK ITEM',
        text: 'You cannot create a blank item',
        timer: 1500,
        showConfirmButton: false
      });
    },
    showSuccessDelete: function showSuccessDelete() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'SUCCESS',
        text: 'Item has been deleted',
        timer: 1500,
        showConfirmButton: false
      });
    },
    showDeleteError: function showDeleteError() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'ERROR',
        text: 'There was an issue performing the delete. Please try again or contact support.',
        timer: 2000,
        showConfirmButton: false
      });
    },
    deleteConfig: function deleteConfig(config) {
      var _this4 = this;

      this.deletedConfig = config;
      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject()),
        variables: {
          id: config.id
        }
      }).then(function (response) {
        if (response.data.deleteConfigurableItem.deletedConfigurableItem) {
          _this4.showSuccessDelete();

          _this4.$apollo.queries.getAllConfigurableItem.refetch();
        } else {
          _this4.replacementList = response.data.deleteConfigurableItem.toolsWithConfigurableItem;
          var inputOptions = {};
          var configurableItems;

          if (_this4.page === _configurableItems.default.BRAND) {
            configurableItems = _this4.brandOptions;
          } else if (_this4.page === _configurableItems.default.PURCHASED_FROM) {
            configurableItems = _this4.supplierOptions;
          } else {
            configurableItems = _this4.typeOptions;
          }

          configurableItems.forEach(function (ci) {
            inputOptions[ci.id] = ci.name;
          });
          (0, _sweetalert.default)({
            title: 'DELETE ITEM',
            text: "".concat(_this4.replacementList.length, " tools are using this item. Replace with :"),
            showCancelButton: true,
            reverseButtons: true,
            cancelButtonText: 'CANCEL',
            confirmButtonText: 'REPLACE',
            confirmButtonColor: '#CE352F',
            input: 'select',
            inputPlaceholder: "Select new ".concat(_this4.title.slice(0, -1)),
            inputOptions: inputOptions,
            inputValidator: function inputValidator(value) {
              return !value && "New ".concat(_this4.title.slice(0, -1), " required");
            }
          }).then(function (_ref) {
            var value = _ref.value,
                dismiss = _ref.dismiss;

            if (dismiss) {
              return;
            }

            if (_this4.page === _configurableItems.default.BRAND) {
              _this4.replaceBrandWith = value;
            } else if (_this4.page === _configurableItems.default.PURCHASED_FROM) {
              _this4.replaceSupplierWith = value;
            } else {
              _this4.replaceTypeWith = value;
            }

            _this4.finalizeDelete();
          });
        }
      });
    },
    finalizeDelete: function finalizeDelete() {
      var _this5 = this;

      this.deleting = true;
      Promise.all(this.replacementList.map(function (tool) {
        return _this5.$apollo.mutate({
          mutation: (0, _graphqlTag.default)(_templateObject2()),
          variables: {
            tool: {
              id: tool.id,
              type_id: _this5.page === _configurableItems.default.TYPE ? _this5.replaceTypeWith : tool.type.id,
              brand_id: _this5.page === _configurableItems.default.BRAND ? _this5.replaceBrandWith : tool.brand.id,
              model_number: tool.model_number,
              serial_number: tool.serial_number,
              status: tool.status,
              owner_id: tool.owner.id,
              purchased_from_id: _this5.page === _configurableItems.default.PURCHASED_FROM ? _this5.replaceSupplierWith : tool.purchased_from && tool.purchased_from.id,
              date_purchased: tool.date_purchased,
              photo: tool.photo,
              price: tool.price,
              year: tool.year
            }
          }
        });
      })).then(function (result) {
        _this5.deleteConfig(_this5.deletedConfig);

        _this5.deletedConfig = {};
      }).catch(function () {
        _this5.showDeleteError();
      }).finally(function () {
        _this5.deleting = false;
      });
    },
    addConfig: function addConfig(name) {
      var _this6 = this;

      if (name === '') {
        this.showBlankItemMsg();
      } else {
        this.$apollo.mutate({
          mutation: (0, _graphqlTag.default)(_templateObject3()),
          variables: {
            item: {
              type: this.page,
              name: name,
              sanctioned: true
            }
          }
        }).catch(function (response) {
          _this6.showInvalidItemMsg();
        }).then(function (result) {
          _this6.$apollo.queries.getAllConfigurableItem.refetch();
        });
      }
    },
    toggleSanction: function toggleSanction(config) {
      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject4()),
        variables: {
          item: {
            id: config.id,
            name: config.name,
            sanctioned: !config.sanctioned
          }
        }
      });
    },
    saveChanges: function saveChanges(config) {
      var _this7 = this;

      if (config.name === '') {
        this.showBlankItemMsg();
      } else {
        this.$apollo.mutate({
          mutation: (0, _graphqlTag.default)(_templateObject5()),
          variables: {
            item: {
              id: config.id,
              name: config.name,
              sanctioned: config.sanctioned
            }
          }
        }).catch(function (response) {
          _this7.showInvalidItemMsg();
        }).then(function (result) {
          _this7.$apollo.queries.getAllConfigurableItem.refetch();
        });
      }
    },
    incrementTab: function incrementTab() {
      this.tab = ++this.tab % 3;
    },
    decrementTab: function decrementTab() {
      this.tab = (this.tab + 2) % 3;
    }
  },
  apollo: {
    getAllConfigurableItem: {
      query: (0, _graphqlTag.default)(_templateObject6()),
      fetchPolicy: 'network-only'
    }
  }
};
exports.default = _default;
        var $87103d = exports.default || module.exports;
      
      if (typeof $87103d === 'function') {
        $87103d = $87103d.options;
      }
    
        /* template */
        Object.assign($87103d, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page configuration-page"},[_c('transition',{attrs:{"name":"fade"}},[(_vm.deleting)?_c('div',{staticClass:"overlay"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('header-card',{attrs:{"title":_vm.title}}),_vm._v(" "),_c('div',{staticClass:"navigation"},[_c('i',{staticClass:"fas fa-arrow-left",on:{"click":_vm.decrementTab}}),_vm._v(" "),_c('i',{staticClass:"fas fa-arrow-right",on:{"click":_vm.incrementTab}})]),_vm._v(" "),_c('div',{staticClass:"config-menu-container"},[_c('div',{staticClass:"configs"},[(_vm.title === 'Brands')?_c('add-result',{attrs:{"on-save":_vm.addConfig,"text":"BRAND"}}):_vm._e(),_vm._v(" "),(_vm.title === 'Types')?_c('add-result',{attrs:{"on-save":_vm.addConfig,"text":"TYPE"}}):_vm._e(),_vm._v(" "),(_vm.title === 'Suppliers')?_c('add-result',{attrs:{"on-save":_vm.addConfig,"text":"SUPPLIER"}}):_vm._e(),_vm._v(" "),_vm._l((_vm.configs.unsanctioned),function(config){return _c('config-item',{key:config.id,attrs:{"config-item":config,"on-delete":_vm.deleteConfig,"on-sanction-toggle":_vm.toggleSanction,"on-save":_vm.saveChanges}})}),_vm._v(" "),_vm._l((_vm.configs.sanctioned),function(config){return _c('config-item',{key:config.id,attrs:{"config-item":config,"on-delete":_vm.deleteConfig,"on-sanction-toggle":_vm.toggleSanction,"on-save":_vm.saveChanges}})})],2)])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"../components/header-card":"KS7g","../components/config-item":"yzqm","../utils/configurable-items":"b0fn","graphql-tag":"MbWf","../components/add-result":"mXEL","sweetalert2":"Y8u2"}],"Tf7T":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  TRANSFER: 'TRANSFER',
  UPDATE: 'UPDATE',
  CREATE: 'CREATE'
};
exports.default = _default;
},{}],"IPWF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _configurableItems = _interopRequireDefault(require("../utils/configurable-items"));

var _vueTagsInput = _interopRequireDefault(require("@johmun/vue-tags-input"));

var _historyActions = _interopRequireDefault(require("../utils/history-actions"));

var _statuses = _interopRequireDefault(require("../utils/statuses"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject4() {
  var data = _taggedTemplateLiteral(["query {\n        getAllConfigurableItem {\n          id,\n          type,\n          name\n        }\n      }"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["query {\n        getAllUser {\n          id\n          first_name\n          last_name\n          type\n        }\n      }"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["query {\n        getAllLocation {\n          id\n          name\n          type\n        }\n      }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["query tools {\n        getAllTool {\n          id\n        }\n      }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'HistorySearchInput',
  components: {
    VueTagsInput: _vueTagsInput.default
  },
  props: {
    updateTags: {
      type: Function,
      required: true
    },
    tags: {
      type: Array,
      required: true
    },
    allowToolIdSearch: {
      type: Boolean,
      required: false,
      default: true
    }
  },
  apollo: {
    getAllTool: {
      query: (0, _graphqlTag.default)(_templateObject()),
      fetchPolicy: 'network-only'
    },
    getAllLocation: {
      query: (0, _graphqlTag.default)(_templateObject2()),
      fetchPolicy: 'network-only'
    },
    getAllUser: {
      query: (0, _graphqlTag.default)(_templateObject3()),
      fetchPolicy: 'network-only'
    },
    getAllConfigurableItem: {
      query: (0, _graphqlTag.default)(_templateObject4()),
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    return {
      tag: ''
    };
  },
  computed: {
    autocompleteItems: function autocompleteItems() {
      var statuses = [{
        name: 'Available',
        text: 'Available',
        id: _statuses.default.AVAILABLE,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }, {
        name: 'In Use',
        text: 'In Use',
        id: _statuses.default.IN_USE,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }, {
        name: 'Maintenance',
        text: 'Maintenance',
        id: _statuses.default.MAINTENANCE,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }, {
        name: 'Lost or Stolen',
        text: 'Lost or Stolen',
        id: _statuses.default.LOST_OR_STOLEN,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }, {
        name: 'Beyond Repair',
        text: 'Beyond Repair',
        id: _statuses.default.BEYOND_REPAIR,
        iconClass: 'fa-info-circle',
        type: 'STATUS',
        formattedType: 'Status'
      }];
      var actions = [{
        name: 'Create',
        text: 'Create',
        id: _historyActions.default.CREATE,
        iconClass: 'fa-info-circle',
        type: 'ACTION',
        formattedType: 'Action'
      }, {
        name: 'Update',
        text: 'Update',
        id: _historyActions.default.UPDATE,
        iconClass: 'fa-info-circle',
        type: 'ACTION',
        formattedType: 'Action'
      }, {
        name: 'Transfer',
        text: 'Transfer',
        id: _historyActions.default.TRANSFER,
        iconClass: 'fa-info-circle',
        type: 'ACTION',
        formattedType: 'Action'
      }];
      var items = actions.concat(statuses).concat(this.users).concat(this.locations).concat(this.searchableConfigItems);

      if (this.allowToolIdSearch) {
        items = items.concat(this.tools);
      }

      return items;
    },
    filteredItems: function filteredItems() {
      var _this = this;

      return this.autocompleteItems.filter(function (i) {
        return i.text.toLowerCase().indexOf(_this.tag.toLowerCase()) > -1;
      });
    },
    locations: function locations() {
      return (this.getAllLocation || []).map(function (location) {
        location.text = location.name;
        location.formattedType = 'Location';
        location.iconClass = 'fa-map-marker-alt';
        return location;
      });
    },
    tools: function tools() {
      return (this.getAllTool || []).map(function (tool) {
        tool.text = tool.id;
        tool.name = tool.text;
        tool.formattedType = 'Tool';
        tool.type = 'TOOL';
        tool.iconClass = 'fa-wrench';
        return tool;
      });
    },
    users: function users() {
      return (this.getAllUser || []).map(function (user) {
        user.text = "".concat(user.first_name, " ").concat(user.last_name);
        user.name = user.text;
        user.formattedType = 'User';
        user.iconClass = 'fa-user';
        return user;
      });
    },
    searchableConfigItems: function searchableConfigItems() {
      var _this2 = this;

      var searchItems = [];
      var items = this.getAllConfigurableItem || [];
      items.forEach(function (item) {
        if (item.type !== _configurableItems.default.PURCHASED_FROM) {
          item.formattedType = item.type.split('_')[0].toLowerCase();
          item.text = "".concat(item.formattedType, " ").concat(item.name);
          item.iconClass = _this2.getTagIconClass(item.type);
          searchItems.push(item);
        }
      });
      return searchItems;
    }
  },
  methods: {
    getTagIconClass: function getTagIconClass(type) {
      if (type === _configurableItems.default.BRAND) {
        return 'fa-tag';
      } else if (type === _configurableItems.default.TYPE) {
        return 'fa-wrench';
      }
    }
  }
};
exports.default = _default;
        var $11a239 = exports.default || module.exports;
      
      if (typeof $11a239 === 'function') {
        $11a239 = $11a239.options;
      }
    
        /* template */
        Object.assign($11a239, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-input"},[_vm._m(0),_vm._v(" "),_c('vue-tags-input',{attrs:{"tags":_vm.tags,"autocomplete-items":_vm.filteredItems,"add-only-from-autocomplete":true,"placeholder":"Search"},on:{"tags-changed":_vm.updateTags},scopedSlots:_vm._u([{key:"autocompleteItem",fn:function(props){return _c('button',{staticClass:"autocomplete-item",on:{"click":function () { return props.performAdd(props.item); }}},[_c('div',{staticClass:"item-name"},[_vm._v("\n        "+_vm._s(props.item.name)+"\n      ")]),_vm._v(" "),_c('div',{staticClass:"item-category"},[_vm._v("\n        "+_vm._s(props.item.formattedType)+"\n      ")])])}},{key:"tagCenter",fn:function(props){return _c('div',{},[_c('i',{staticClass:"fas tag-icon",class:props.tag.iconClass}),_vm._v("\n      "+_vm._s(props.tag.name)+"\n    ")])}}]),model:{value:(_vm.tag),callback:function ($$v) {_vm.tag=$$v},expression:"tag"}})],1)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-icon-container"},[_c('i',{staticClass:"fas fa-search"})])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"../utils/configurable-items":"b0fn","@johmun/vue-tags-input":"KW2a","../utils/history-actions":"Tf7T","../utils/statuses":"HBwF","graphql-tag":"MbWf"}],"g5I+":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"GTq6":[function(require,module,exports) {
var define;
var global = arguments[3];
var process = require("process");
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





},{"process":"g5I+"}],"kRE6":[function(require,module,exports) {
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":"GTq6"}],"Up3p":[function(require,module,exports) {
var define;
var global = arguments[3];
var process = require("process");
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.jsPDF=e()}(this,function(){"use strict";var t,y,e,I,i,o,a,h,C,T,d,p,F,n,r,s,c,P,E,q,g,m,w,l,v,b,x,S,u,k,_,f,A,O,B,R,j,D,M,U,N,z,L,H,W,G,V,Y,X,J,K,Q,Z,vt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},$=function(pt){var gt="1.3",mt={a0:[2383.94,3370.39],a1:[1683.78,2383.94],a2:[1190.55,1683.78],a3:[841.89,1190.55],a4:[595.28,841.89],a5:[419.53,595.28],a6:[297.64,419.53],a7:[209.76,297.64],a8:[147.4,209.76],a9:[104.88,147.4],a10:[73.7,104.88],b0:[2834.65,4008.19],b1:[2004.09,2834.65],b2:[1417.32,2004.09],b3:[1000.63,1417.32],b4:[708.66,1000.63],b5:[498.9,708.66],b6:[354.33,498.9],b7:[249.45,354.33],b8:[175.75,249.45],b9:[124.72,175.75],b10:[87.87,124.72],c0:[2599.37,3676.54],c1:[1836.85,2599.37],c2:[1298.27,1836.85],c3:[918.43,1298.27],c4:[649.13,918.43],c5:[459.21,649.13],c6:[323.15,459.21],c7:[229.61,323.15],c8:[161.57,229.61],c9:[113.39,161.57],c10:[79.37,113.39],dl:[311.81,623.62],letter:[612,792],"government-letter":[576,756],legal:[612,1008],"junior-legal":[576,360],ledger:[1224,792],tabloid:[792,1224],"credit-card":[153,243]};function wt(o){var a={};this.subscribe=function(t,e,n){if("function"!=typeof e)return!1;a.hasOwnProperty(t)||(a[t]={});var r=Math.random().toString(35);return a[t][r]=[e,!!n],r},this.unsubscribe=function(t){for(var e in a)if(a[e][t])return delete a[e][t],!0;return!1},this.publish=function(t){if(a.hasOwnProperty(t)){var e=Array.prototype.slice.call(arguments,1),n=[];for(var r in a[t]){var i=a[t][r];try{i[0].apply(o,e)}catch(t){pt.console&&console.error("jsPDF PubSub Error",t.message,t)}i[1]&&n.push(r)}n.length&&n.forEach(this.unsubscribe)}}}function yt(t,e,n,r){var i={};"object"===(void 0===t?"undefined":vt(t))&&(t=(i=t).orientation,e=i.unit||e,n=i.format||n,r=i.compress||i.compressPdf||r),e=e||"mm",n=n||"a4",t=(""+(t||"P")).toLowerCase();(""+n).toLowerCase();var K,w,y,o,u,v,a,s,h,c,l,f=!!r&&"function"==typeof Uint8Array,Q=i.textColor||"0 g",d=i.drawColor||"0 G",Z=i.fontSize||16,$=i.charSpace||0,tt=i.R2L||!1,et=i.lineHeight||1.15,p=i.lineWidth||.200025,g="00000000000000000000000000000000",m=2,b=!1,x=[],nt={},S={},k=0,_=[],A=[],I=[],C=[],T=[],F=0,P=0,E=0,q={title:"",subject:"",author:"",keywords:"",creator:""},O={},rt=new wt(O),B=i.hotfixes||[],R=function(t){var e,n=t.ch1,r=t.ch2,i=t.ch3,o=t.ch4,a=(t.precision,"draw"===t.pdfColorType?["G","RG","K"]:["g","rg","k"]);if("string"==typeof n&&"#"!==n.charAt(0)){var s=new RGBColor(n);s.ok&&(n=s.toHex())}if("string"==typeof n&&/^#[0-9A-Fa-f]{3}$/.test(n)&&(n="#"+n[1]+n[1]+n[2]+n[2]+n[3]+n[3]),"string"==typeof n&&/^#[0-9A-Fa-f]{6}$/.test(n)){var h=parseInt(n.substr(1),16);n=h>>16&255,r=h>>8&255,i=255&h}if(void 0===r||void 0===o&&n===r&&r===i)if("string"==typeof n)e=n+" "+a[0];else switch(t.precision){case 2:e=N(n/255)+" "+a[0];break;case 3:default:e=z(n/255)+" "+a[0]}else if(void 0===o||"object"===(void 0===o?"undefined":vt(o))){if("string"==typeof n)e=[n,r,i,a[1]].join(" ");else switch(t.precision){case 2:e=[N(n/255),N(r/255),N(i/255),a[1]].join(" ");break;default:case 3:e=[z(n/255),z(r/255),z(i/255),a[1]].join(" ")}o&&0===o.a&&(e=["255","255","255",a[1]].join(" "))}else if("string"==typeof n)e=[n,r,i,o,a[2]].join(" ");else switch(t.precision){case 2:e=[N(n),N(r),N(i),N(o),a[2]].join(" ");break;case 3:default:e=[z(n),z(r),z(i),z(o),a[2]].join(" ")}return e},j=function(t){var e=function(t){return("0"+parseInt(t)).slice(-2)},n=t.getTimezoneOffset(),r=n<0?"+":"-",i=Math.floor(Math.abs(n/60)),o=Math.abs(n%60),a=[r,e(i),"'",e(o),"'"].join("");return["D:",t.getFullYear(),e(t.getMonth()+1),e(t.getDate()),e(t.getHours()),e(t.getMinutes()),e(t.getSeconds()),a].join("")},D=function(t){var e;return void 0===(void 0===t?"undefined":vt(t))&&(t=new Date),e="object"===(void 0===t?"undefined":vt(t))&&"[object Date]"===Object.prototype.toString.call(t)?j(t):/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|\-0[0-9]|\-1[0-1])\'(0[0-9]|[1-5][0-9])\'?$/.test(t)?t:j(new Date),c=e},M=function(t){var e=c;return"jsDate"===t&&(e=function(t){var e=parseInt(t.substr(2,4),10),n=parseInt(t.substr(6,2),10)-1,r=parseInt(t.substr(8,2),10),i=parseInt(t.substr(10,2),10),o=parseInt(t.substr(12,2),10),a=parseInt(t.substr(14,2),10);parseInt(t.substr(16,2),10),parseInt(t.substr(20,2),10);return new Date(e,n,r,i,o,a,0)}(c)),e},U=function(t){return t=t||"12345678901234567890123456789012".split("").map(function(){return"ABCDEF0123456789".charAt(Math.floor(16*Math.random()))}).join(""),g=t},N=function(t){return t.toFixed(2)},z=function(t){return t.toFixed(3)},it=function(t){t="string"==typeof t?t:t.toString(),b?_[o].push(t):(E+=t.length+1,C.push(t))},L=function(){return x[++m]=E,it(m+" 0 obj"),m},H=function(t){it("stream"),it(t),it("endstream")},W=function(){for(var t in it("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"),it("/Font <<"),nt)nt.hasOwnProperty(t)&&it("/"+t+" "+nt[t].objectNumber+" 0 R");it(">>"),it("/XObject <<"),rt.publish("putXobjectDict"),it(">>")},G=function(){!function(){for(var t in nt)nt.hasOwnProperty(t)&&(e=nt[t],rt.publish("putFont",{font:e,out:it,newObject:L}),!0!==e.isAlreadyPutted&&(e.objectNumber=L(),it("<<"),it("/Type /Font"),it("/BaseFont /"+e.postScriptName),it("/Subtype /Type1"),"string"==typeof e.encoding&&it("/Encoding /"+e.encoding),it("/FirstChar 32"),it("/LastChar 255"),it(">>"),it("endobj")));var e}(),rt.publish("putResources"),x[2]=E,it("2 0 obj"),it("<<"),W(),it(">>"),it("endobj"),rt.publish("postPutResources")},V=function(t,e,n){S.hasOwnProperty(e)||(S[e]={}),S[e][n]=t},Y=function(t,e,n,r){var i="F"+(Object.keys(nt).length+1).toString(10),o=nt[i]={id:i,postScriptName:t,fontName:e,fontStyle:n,encoding:r,metadata:{}};return V(i,e,n),rt.publish("addFont",o),i},ot=function(t,e){return function(t,e){var n,r,i,o,a,s,h,c,l;if(i=(e=e||{}).sourceEncoding||"Unicode",a=e.outputEncoding,(e.autoencode||a)&&nt[K].metadata&&nt[K].metadata[i]&&nt[K].metadata[i].encoding&&(o=nt[K].metadata[i].encoding,!a&&nt[K].encoding&&(a=nt[K].encoding),!a&&o.codePages&&(a=o.codePages[0]),"string"==typeof a&&(a=o[a]),a)){for(h=!1,s=[],n=0,r=t.length;n<r;n++)(c=a[t.charCodeAt(n)])?s.push(String.fromCharCode(c)):s.push(t[n]),s[n].charCodeAt(0)>>8&&(h=!0);t=s.join("")}for(n=t.length;void 0===h&&0!==n;)t.charCodeAt(n-1)>>8&&(h=!0),n--;if(!h)return t;for(s=e.noBOM?[]:[254,255],n=0,r=t.length;n<r;n++){if((l=(c=t.charCodeAt(n))>>8)>>8)throw new Error("Character at position "+n+" of string '"+t+"' exceeds 16bits. Cannot be encoded into UCS-2 BE");s.push(l),s.push(c-(l<<8))}return String.fromCharCode.apply(void 0,s)}(t,e).replace(/\\/g,"\\\\").replace(/\(/g,"\\(").replace(/\)/g,"\\)")},X=function(){(function(t,e){var n="string"==typeof e&&e.toLowerCase();if("string"==typeof t){var r=t.toLowerCase();mt.hasOwnProperty(r)&&(t=mt[r][0]/w,e=mt[r][1]/w)}if(Array.isArray(t)&&(e=t[1],t=t[0]),n){switch(n.substr(0,1)){case"l":t<e&&(n="s");break;case"p":e<t&&(n="s")}"s"===n&&(y=t,t=e,e=y)}b=!0,_[++k]=[],I[k]={width:Number(t)||u,height:Number(e)||v},A[k]={},J(k)}).apply(this,arguments),it(N(p*w)+" w"),it(d),0!==F&&it(F+" J"),0!==P&&it(P+" j"),rt.publish("addPage",{pageNumber:k})},J=function(t){0<t&&t<=k&&(u=I[o=t].width,v=I[t].height)},at=function(t,e,n){var r,i=void 0;return n=n||{},t=void 0!==t?t:nt[K].fontName,e=void 0!==e?e:nt[K].fontStyle,r=t.toLowerCase(),void 0!==S[r]&&void 0!==S[r][e]?i=S[r][e]:void 0!==S[t]&&void 0!==S[t][e]?i=S[t][e]:!1===n.disableWarning&&console.warn("Unable to look up font label for font '"+t+"', '"+e+"'. Refer to getFontList() for available fonts."),i||n.noFallback||null==(i=S.times[e])&&(i=S.times.normal),i},st=function(){b=!1,m=2,E=0,C=[],x=[],T=[],rt.publish("buildDocument"),it("%PDF-"+gt),it("%"),function(){var t,e,n,r,i,o,a,s,h,c=[];for(a=pt.adler32cs||yt.API.adler32cs,f&&void 0===a&&(f=!1),t=1;t<=k;t++){if(c.push(L()),s=(u=I[t].width)*w,h=(v=I[t].height)*w,it("<</Type /Page"),it("/Parent 1 0 R"),it("/Resources 2 0 R"),it("/MediaBox [0 0 "+N(s)+" "+N(h)+"]"),rt.publish("putPage",{pageNumber:t,page:_[t]}),it("/Contents "+(m+1)+" 0 R"),it(">>"),it("endobj"),e=_[t].join("\n"),L(),f){for(n=[],r=e.length;r--;)n[r]=e.charCodeAt(r);o=a.from(e),(i=new Deflater(6)).append(new Uint8Array(n)),e=i.flush(),(n=new Uint8Array(e.length+6)).set(new Uint8Array([120,156])),n.set(e,2),n.set(new Uint8Array([255&o,o>>8&255,o>>16&255,o>>24&255]),e.length+2),e=String.fromCharCode.apply(null,n),it("<</Length "+e.length+" /Filter [/FlateDecode]>>")}else it("<</Length "+e.length+">>");H(e),it("endobj")}x[1]=E,it("1 0 obj"),it("<</Type /Pages");var l="/Kids [";for(r=0;r<k;r++)l+=c[r]+" 0 R ";it(l+"]"),it("/Count "+k),it(">>"),it("endobj"),rt.publish("postPutPages")}(),function(){rt.publish("putAdditionalObjects");for(var t=0;t<T.length;t++){var e=T[t];x[e.objId]=E,it(e.objId+" 0 obj"),it(e.content),it("endobj")}m+=T.length,rt.publish("postPutAdditionalObjects")}(),G(),L(),it("<<"),function(){for(var t in it("/Producer (jsPDF "+yt.version+")"),q)q.hasOwnProperty(t)&&q[t]&&it("/"+t.substr(0,1).toUpperCase()+t.substr(1)+" ("+ot(q[t])+")");it("/CreationDate ("+c+")")}(),it(">>"),it("endobj"),L(),it("<<"),function(){switch(it("/Type /Catalog"),it("/Pages 1 0 R"),s||(s="fullwidth"),s){case"fullwidth":it("/OpenAction [3 0 R /FitH null]");break;case"fullheight":it("/OpenAction [3 0 R /FitV null]");break;case"fullpage":it("/OpenAction [3 0 R /Fit]");break;case"original":it("/OpenAction [3 0 R /XYZ null null 1]");break;default:var t=""+s;"%"===t.substr(t.length-1)&&(s=parseInt(s)/100),"number"==typeof s&&it("/OpenAction [3 0 R /XYZ null null "+N(s)+"]")}switch(h||(h="continuous"),h){case"continuous":it("/PageLayout /OneColumn");break;case"single":it("/PageLayout /SinglePage");break;case"two":case"twoleft":it("/PageLayout /TwoColumnLeft");break;case"tworight":it("/PageLayout /TwoColumnRight")}a&&it("/PageMode /"+a),rt.publish("putCatalog")}(),it(">>"),it("endobj");var t,e=E,n="0000000000";for(it("xref"),it("0 "+(m+1)),it(n+" 65535 f "),t=1;t<=m;t++){var r=x[t];it("function"==typeof r?(n+x[t]()).slice(-10)+" 00000 n ":(n+x[t]).slice(-10)+" 00000 n ")}return it("trailer"),it("<<"),it("/Size "+(m+1)),it("/Root "+m+" 0 R"),it("/Info "+(m-1)+" 0 R"),it("/ID [ <"+g+"> <"+g+"> ]"),it(">>"),it("startxref"),it(""+e),it("%%EOF"),b=!0,C.join("\n")},ht=function(t){var e="S";return"F"===t?e="f":"FD"===t||"DF"===t?e="B":"f"!==t&&"f*"!==t&&"B"!==t&&"B*"!==t||(e=t),e},ct=function(){for(var t=st(),e=t.length,n=new ArrayBuffer(e),r=new Uint8Array(n);e--;)r[e]=t.charCodeAt(e);return n},lt=function(){return new Blob([ct()],{type:"application/pdf"})},ut=((l=function(t,e){var n="dataur"===(""+t).substr(0,6)?"data:application/pdf;base64,"+btoa(st()):0;switch(t){case void 0:return st();case"save":if("object"===("undefined"==typeof navigator?"undefined":vt(navigator))&&navigator.getUserMedia&&(void 0===pt.URL||void 0===pt.URL.createObjectURL))return O.output("dataurlnewwindow");bt(lt(),e),"function"==typeof bt.unload&&pt.setTimeout&&setTimeout(bt.unload,911);break;case"arraybuffer":return ct();case"blob":return lt();case"bloburi":case"bloburl":return pt.URL&&pt.URL.createObjectURL(lt())||void 0;case"datauristring":case"dataurlstring":return n;case"dataurlnewwindow":var r=pt.open(n);if(r||"undefined"==typeof safari)return r;case"datauri":case"dataurl":return pt.document.location.href=n;default:throw new Error('Output type "'+t+'" is not supported.')}}).foo=function(){try{return l.apply(this,arguments)}catch(t){var e=t.stack||"";~e.indexOf(" at ")&&(e=e.split(" at ")[1]);var n="Error in function "+e.split("\n")[0].split("<")[0]+": "+t.message;if(!pt.console)throw new Error(n);pt.console.error(n,t),pt.alert&&alert(n)}},(l.foo.bar=l).foo),ft=function(t){return!0===Array.isArray(B)&&-1<B.indexOf(t)};switch(e){case"pt":w=1;break;case"mm":w=72/25.4;break;case"cm":w=72/2.54;break;case"in":w=72;break;case"px":w=1==ft("px_scaling")?.75:96/72;break;case"pc":case"em":w=12;break;case"ex":w=6;break;default:throw"Invalid unit: "+e}for(var dt in D(),U(),O.internal={pdfEscape:ot,getStyle:ht,getFont:function(){return nt[at.apply(O,arguments)]},getFontSize:function(){return Z},getCharSpace:function(){return $},getTextColor:function(){var t=Q.split(" ");if(2===t.length&&"g"===t[1]){var e=parseFloat(t[0]);t=[e,e,e,"r"]}for(var n="#",r=0;r<3;r++)n+=("0"+Math.floor(255*parseFloat(t[r])).toString(16)).slice(-2);return n},getLineHeight:function(){return Z*et},write:function(t){it(1===arguments.length?t:Array.prototype.join.call(arguments," "))},getCoordinateString:function(t){return N(t*w)},getVerticalCoordinateString:function(t){return N((v-t)*w)},collections:{},newObject:L,newAdditionalObject:function(){var t=2*_.length+1,e={objId:t+=T.length,content:""};return T.push(e),e},newObjectDeferred:function(){return x[++m]=function(){return E},m},newObjectDeferredBegin:function(t){x[t]=E},putStream:H,events:rt,scaleFactor:w,pageSize:{getWidth:function(){return u},getHeight:function(){return v}},output:function(t,e){return ut(t,e)},getNumberOfPages:function(){return _.length-1},pages:_,out:it,f2:N,getPageInfo:function(t){return{objId:2*(t-1)+3,pageNumber:t,pageContext:A[t]}},getCurrentPageInfo:function(){return{objId:2*(o-1)+3,pageNumber:o,pageContext:A[o]}},getPDFVersion:function(){return gt},hasHotfix:ft},O.addPage=function(){return X.apply(this,arguments),this},O.setPage=function(){return J.apply(this,arguments),this},O.insertPage=function(t){return this.addPage(),this.movePage(o,t),this},O.movePage=function(t,e){if(e<t){for(var n=_[t],r=I[t],i=A[t],o=t;e<o;o--)_[o]=_[o-1],I[o]=I[o-1],A[o]=A[o-1];_[e]=n,I[e]=r,A[e]=i,this.setPage(e)}else if(t<e){for(n=_[t],r=I[t],i=A[t],o=t;o<e;o++)_[o]=_[o+1],I[o]=I[o+1],A[o]=A[o+1];_[e]=n,I[e]=r,A[e]=i,this.setPage(e)}return this},O.deletePage=function(){return function(t){0<t&&t<=k&&(_.splice(t,1),I.splice(t,1),--k<o&&(o=k),this.setPage(o))}.apply(this,arguments),this},O.setCreationDate=function(t){return D(t),this},O.getCreationDate=function(t){return M(t)},O.setFileId=function(t){return U(t),this},O.getFileId=function(){return g},O.setDisplayMode=function(t,e,n){if(s=t,h=e,-1==[void 0,null,"UseNone","UseOutlines","UseThumbs","FullScreen"].indexOf(a=n))throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "'+n+'" is not recognized.');return this},O.text=function(t,e,n,i){var r,o,a="",s=et,h=this;function c(t){for(var e,n=t.concat(),r=[],i=n.length;i--;)"string"==typeof(e=n.shift())?r.push(e):"[object Array]"===Object.prototype.toString.call(t)&&1===e.length?r.push(e[0]):r.push([e[0],e[1],e[2]]);return r}function l(t,e){var n;if("string"==typeof t)n=e(t)[0];else if("[object Array]"===Object.prototype.toString.call(t)){for(var r,i,o=t.concat(),a=[],s=o.length;s--;)"string"==typeof(r=o.shift())?a.push(e(r)[0]):"[object Array]"===Object.prototype.toString.call(r)&&"string"===r[0]&&(i=e(r[0],r[1],r[2]),a.push([i[0],i[1],i[2]]));n=a}return n}"number"==typeof t&&(o=n,n=e,e=t,t=o);var u=i,f=arguments[4],d=arguments[5];"object"===(void 0===u?"undefined":vt(u))&&null!==u||("string"==typeof f&&(d=f,f=null),"string"==typeof u&&(d=u,u=null),"number"==typeof u&&(f=u,u=null),i={flags:u,angle:f,align:d});var p=!1,g=!0;if("string"==typeof t)p=!0;else if("[object Array]"===Object.prototype.toString.call(t)){for(var m,w=t.concat(),y=[],v=w.length;v--;)("string"!=typeof(m=w.shift())||"[object Array]"===Object.prototype.toString.call(m)&&"string"!=typeof m[0])&&(g=!1);p=g}if(!1===p)throw new Error('Type of text must be string or Array. "'+t+'" is not recognized.');var b=nt[K].encoding;"WinAnsiEncoding"!==b&&"StandardEncoding"!==b||(t=l(t,function(t,e,n){return[(r=t,r=r.split("\t").join(Array(i.TabLen||9).join(" ")),ot(r,u)),e,n];var r})),"string"==typeof t&&(t=t.match(/[\r?\n]/)?t.split(/\r\n|\r|\n/g):[t]),0<(j=i.maxWidth||0)&&("string"==typeof t?t=h.splitTextToSize(t,j):"[object Array]"===Object.prototype.toString.call(t)&&(t=h.splitTextToSize(t.join(" "),j)));var x={text:t,x:e,y:n,options:i,mutex:{pdfEscape:ot,activeFontKey:K,fonts:nt,activeFontSize:Z}};rt.publish("preProcessText",x),t=x.text;f=(i=x.options).angle;var S=h.internal.scaleFactor,k=(h.internal.pageSize.getHeight(),[]);if(f){f*=Math.PI/180;var _=Math.cos(f),A=Math.sin(f),I=function(t){return t.toFixed(2)};k=[I(_),I(A),I(-1*A),I(_)]}void 0!==(R=i.charSpace)&&(a+=R+" Tc\n");i.lang;var C=-1,T=i.renderingMode||i.stroke,F=h.internal.getCurrentPageInfo().pageContext;switch(T){case 0:case!1:case"fill":C=0;break;case 1:case!0:case"stroke":C=1;break;case 2:case"fillThenStroke":C=2;break;case 3:case"invisible":C=3;break;case 4:case"fillAndAddForClipping":C=4;break;case 5:case"strokeAndAddPathForClipping":C=5;break;case 6:case"fillThenStrokeAndAddToPathForClipping":C=6;break;case 7:case"addToPathForClipping":C=7}var P=F.usedRenderingMode||-1;-1!==C?a+=C+" Tr\n":-1!==P&&(a+="0 Tr\n"),-1!==C&&(F.usedRenderingMode=C);d=i.align||"left";var E=Z*s,q=h.internal.pageSize.getHeight(),O=h.internal.pageSize.getWidth(),B=(S=h.internal.scaleFactor,nt[K]),R=i.charSpace||$,j=i.maxWidth||0,D=(u={},[]);if("[object Array]"===Object.prototype.toString.call(t)){var M,U;y=c(t);"left"!==d&&(U=y.map(function(t){return h.getStringUnitWidth(t,{font:B,charSpace:R,fontSize:Z})*Z/S}));var N,z=Math.max.apply(Math,U),L=0;if("right"===d){e-=U[0],t=[];var H=0;for(v=y.length;H<v;H++)z-U[H],0===H?(N=e*S,M=(q-n)*S):(N=(L-U[H])*S,M=-E),t.push([y[H],N,M]),L=U[H]}else if("center"===d){e-=U[0]/2,t=[];for(H=0,v=y.length;H<v;H++)(z-U[H])/2,0===H?(N=e*S,M=(q-n)*S):(N=(L-U[H])/2*S,M=-E),t.push([y[H],N,M]),L=U[H]}else if("left"===d){t=[];for(H=0,v=y.length;H<v;H++)M=0===H?(q-n)*S:-E,N=0===H?e*S:0,t.push(y[H])}else{if("justify"!==d)throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');t=[];for(j=0!==j?j:O,H=0,v=y.length;H<v;H++)M=0===H?(q-n)*S:-E,N=0===H?e*S:0,H<v-1&&D.push(((j-U[H])/(y[H].split(" ").length-1)*S).toFixed(2)),t.push([y[H],N,M])}}!0===("boolean"==typeof i.R2L?i.R2L:tt)&&(t=l(t,function(t,e,n){return[t.split("").reverse().join(""),e,n]}));x={text:t,x:e,y:n,options:i,mutex:{pdfEscape:ot,activeFontKey:K,fonts:nt,activeFontSize:Z}};rt.publish("postProcessText",x),t=x.text,r=x.mutex.isHex;y=c(t);t=[];var W,G,V,Y=0,X=(v=y.length,"");for(H=0;H<v;H++)X="","[object Array]"!==Object.prototype.toString.call(y[H])?(W=parseFloat(e*S).toFixed(2),G=parseFloat((q-n)*S).toFixed(2),V=(r?"<":"(")+y[H]+(r?">":")")):"[object Array]"===Object.prototype.toString.call(y[H])&&(W=parseFloat(y[H][1]).toFixed(2),G=parseFloat(y[H][2]).toFixed(2),V=(r?"<":"(")+y[H][0]+(r?">":")"),Y=1),void 0!==D&&void 0!==D[H]&&(X=D[H]+" Tw\n"),0!==k.length&&0===H?t.push(X+k.join(" ")+" "+W+" "+G+" Tm\n"+V):1===Y||0===Y&&0===H?t.push(X+W+" "+G+" Td\n"+V):t.push(X+V);t=0===Y?t.join(" Tj\nT* "):t.join(" Tj\n"),t+=" Tj\n";var J="BT\n/"+K+" "+Z+" Tf\n"+(Z*s).toFixed(2)+" TL\n"+Q+"\n";return J+=a,J+=t,it(J+="ET"),h},O.lstext=function(t,e,n,r){console.warn("jsPDF.lstext is deprecated");for(var i=0,o=t.length;i<o;i++,e+=r)this.text(t[i],e,n);return this},O.line=function(t,e,n,r){return this.lines([[n-t,r-e]],t,e)},O.clip=function(){it("W"),it("S")},O.clip_fixed=function(t){it("evenodd"===t?"W*":"W"),it("n")},O.lines=function(t,e,n,r,i,o){var a,s,h,c,l,u,f,d,p,g,m;for("number"==typeof t&&(y=n,n=e,e=t,t=y),r=r||[1,1],it(z(e*w)+" "+z((v-n)*w)+" m "),a=r[0],s=r[1],c=t.length,g=e,m=n,h=0;h<c;h++)2===(l=t[h]).length?(g=l[0]*a+g,m=l[1]*s+m,it(z(g*w)+" "+z((v-m)*w)+" l")):(u=l[0]*a+g,f=l[1]*s+m,d=l[2]*a+g,p=l[3]*s+m,g=l[4]*a+g,m=l[5]*s+m,it(z(u*w)+" "+z((v-f)*w)+" "+z(d*w)+" "+z((v-p)*w)+" "+z(g*w)+" "+z((v-m)*w)+" c"));return o&&it(" h"),null!==i&&it(ht(i)),this},O.rect=function(t,e,n,r,i){ht(i);return it([N(t*w),N((v-e)*w),N(n*w),N(-r*w),"re"].join(" ")),null!==i&&it(ht(i)),this},O.triangle=function(t,e,n,r,i,o,a){return this.lines([[n-t,r-e],[i-n,o-r],[t-i,e-o]],t,e,[1,1],a,!0),this},O.roundedRect=function(t,e,n,r,i,o,a){var s=4/3*(Math.SQRT2-1);return this.lines([[n-2*i,0],[i*s,0,i,o-o*s,i,o],[0,r-2*o],[0,o*s,-i*s,o,-i,o],[2*i-n,0],[-i*s,0,-i,-o*s,-i,-o],[0,2*o-r],[0,-o*s,i*s,-o,i,-o]],t+i,e,[1,1],a),this},O.ellipse=function(t,e,n,r,i){var o=4/3*(Math.SQRT2-1)*n,a=4/3*(Math.SQRT2-1)*r;return it([N((t+n)*w),N((v-e)*w),"m",N((t+n)*w),N((v-(e-a))*w),N((t+o)*w),N((v-(e-r))*w),N(t*w),N((v-(e-r))*w),"c"].join(" ")),it([N((t-o)*w),N((v-(e-r))*w),N((t-n)*w),N((v-(e-a))*w),N((t-n)*w),N((v-e)*w),"c"].join(" ")),it([N((t-n)*w),N((v-(e+a))*w),N((t-o)*w),N((v-(e+r))*w),N(t*w),N((v-(e+r))*w),"c"].join(" ")),it([N((t+o)*w),N((v-(e+r))*w),N((t+n)*w),N((v-(e+a))*w),N((t+n)*w),N((v-e)*w),"c"].join(" ")),null!==i&&it(ht(i)),this},O.circle=function(t,e,n,r){return this.ellipse(t,e,n,n,r)},O.setProperties=function(t){for(var e in q)q.hasOwnProperty(e)&&t[e]&&(q[e]=t[e]);return this},O.setFontSize=function(t){return Z=t,this},O.setFont=function(t,e){return K=at(t,e),this},O.setFontStyle=O.setFontType=function(t){return K=at(void 0,t),this},O.getFontList=function(){var t,e,n,r={};for(t in S)if(S.hasOwnProperty(t))for(e in r[t]=n=[],S[t])S[t].hasOwnProperty(e)&&n.push(e);return r},O.addFont=function(t,e,n,r){Y(t,e,n,r=r||"Identity-H")},O.setLineWidth=function(t){return it((t*w).toFixed(2)+" w"),this},O.setDrawColor=function(t,e,n,r){return it(R({ch1:t,ch2:e,ch3:n,ch4:r,pdfColorType:"draw",precision:2})),this},O.setFillColor=function(t,e,n,r){return it(R({ch1:t,ch2:e,ch3:n,ch4:r,pdfColorType:"fill",precision:2})),this},O.setTextColor=function(t,e,n,r){return Q=R({ch1:t,ch2:e,ch3:n,ch4:r,pdfColorType:"text",precision:3}),this},O.setCharSpace=function(t){return $=t,this},O.setR2L=function(t){return tt=t,this},O.CapJoinStyles={0:0,butt:0,but:0,miter:0,1:1,round:1,rounded:1,circle:1,2:2,projecting:2,project:2,square:2,bevel:2},O.setLineCap=function(t){var e=this.CapJoinStyles[t];if(void 0===e)throw new Error("Line cap style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return it((F=e)+" J"),this},O.setLineJoin=function(t){var e=this.CapJoinStyles[t];if(void 0===e)throw new Error("Line join style of '"+t+"' is not recognized. See or extend .CapJoinStyles property for valid styles");return it((P=e)+" j"),this},O.output=ut,O.save=function(t){O.output("save",t)},yt.API)yt.API.hasOwnProperty(dt)&&("events"===dt&&yt.API.events.length?function(t,e){var n,r,i;for(i=e.length-1;-1!==i;i--)n=e[i][0],r=e[i][1],t.subscribe.apply(t,[n].concat("function"==typeof r?[r]:r))}(rt,yt.API.events):O[dt]=yt.API[dt]);return function(){for(var t="helvetica",e="times",n="courier",r="normal",i="bold",o="italic",a="bolditalic",s=[["Helvetica",t,r,"WinAnsiEncoding"],["Helvetica-Bold",t,i,"WinAnsiEncoding"],["Helvetica-Oblique",t,o,"WinAnsiEncoding"],["Helvetica-BoldOblique",t,a,"WinAnsiEncoding"],["Courier",n,r,"WinAnsiEncoding"],["Courier-Bold",n,i,"WinAnsiEncoding"],["Courier-Oblique",n,o,"WinAnsiEncoding"],["Courier-BoldOblique",n,a,"WinAnsiEncoding"],["Times-Roman",e,r,"WinAnsiEncoding"],["Times-Bold",e,i,"WinAnsiEncoding"],["Times-Italic",e,o,"WinAnsiEncoding"],["Times-BoldItalic",e,a,"WinAnsiEncoding"],["ZapfDingbats","zapfdingbats",r,null],["Symbol","symbol",r,null]],h=0,c=s.length;h<c;h++){var l=Y(s[h][0],s[h][1],s[h][2],s[h][3]),u=s[h][0].split("-");V(l,u[0],u[1]||"")}rt.publish("addFonts",{fonts:nt,dictionary:S})}(),K="F1",X(n,t),rt.publish("initialized"),O}return yt.API={events:[]},yt.version="0.0.0","function"==typeof define&&define.amd?define("jsPDF",function(){return yt}):"undefined"!=typeof module&&module.exports?(module.exports=yt,module.exports.jsPDF=yt):pt.jsPDF=yt,yt}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||"undefined"!=typeof global&&global||Function('return typeof this === "object" && this.content')()||Function("return this")());
/** @preserve
   * jsPDF - PDF Document creation from JavaScript
   * Version 1.4.1 Built on 2018-06-06T07:49:34.040Z
   *                           CommitID 3233f44044
   *
   * Copyright (c) 2010-2016 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, willow-systems.com
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Licensed under the MIT License
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   */
/**
   * jsPDF AcroForm Plugin Copyright (c) 2016 Alexander Weidt,
   * https://github.com/BiggA94
   * 
   * Licensed under the MIT License. http://opensource.org/licenses/mit-license
   */
!function(n,t){var l,a,e=1,r=function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t},s=function(t){return t*(e/1)},h=function(t){var e=new I,n=N.internal.getHeight(t)||0,r=N.internal.getWidth(t)||0;return e.BBox=[0,0,r.toFixed(2),n.toFixed(2)],e},i=function(t,e,n){t=t||0;var r=1;if(r<<=e-1,1==(n=n||1))t=t|r;else t=t&~r;return t},o=function(t,e,n){n=n||1.3,t=t||0;return 1==e.readOnly&&(t=i(t,1)),1==e.required&&(t=i(t,2)),1==e.noExport&&(t=i(t,3)),1==e.multiline&&(t=i(t,13)),e.password&&(t=i(t,14)),e.noToggleToOff&&(t=i(t,15)),e.radio&&(t=i(t,16)),e.pushbutton&&(t=i(t,17)),e.combo&&(t=i(t,18)),e.edit&&(t=i(t,19)),e.sort&&(t=i(t,20)),e.fileSelect&&1.4<=n&&(t=i(t,21)),e.multiSelect&&1.4<=n&&(t=i(t,22)),e.doNotSpellCheck&&1.4<=n&&(t=i(t,23)),1==e.doNotScroll&&1.4<=n&&(t=i(t,24)),e.richText&&1.4<=n&&(t=i(t,25)),t},u=function(t){var e=t[0],n=t[1],r=t[2],i=t[3],o={};return Array.isArray(e)?(e[0]=s(e[0]),e[1]=s(e[1]),e[2]=s(e[2]),e[3]=s(e[3])):(e=s(e),n=s(n),r=s(r),i=s(i)),o.lowerLeft_X=e||0,o.lowerLeft_Y=s(a)-n-i||0,o.upperRight_X=e+r||0,o.upperRight_Y=s(a)-n||0,[o.lowerLeft_X.toFixed(2),o.lowerLeft_Y.toFixed(2),o.upperRight_X.toFixed(2),o.upperRight_Y.toFixed(2)]},f=function(t){if(t.appearanceStreamContent)return t.appearanceStreamContent;if(t.V||t.DV){var e=[],n=t.V||t.DV,r=c(t,n);e.push("/Tx BMC"),e.push("q"),e.push("/F1 "+r.fontSize.toFixed(2)+" Tf"),e.push("1 0 0 1 0 0 Tm"),e.push("BT"),e.push(r.text),e.push("ET"),e.push("Q"),e.push("EMC");var i=new h(t);return i.stream=e.join("\n"),i}},c=function(t,e,i,n){n=n||12,i=i||"helvetica";var r={text:"",fontSize:""},o=(e=")"==(e="("==e.substr(0,1)?e.substr(1):e).substr(e.length-1)?e.substr(0,e.length-1):e).split(" "),a=n,s=N.internal.getHeight(t)||0;s=s<0?-s:s;var h=N.internal.getWidth(t)||0;h=h<0?-h:h;var c=function(t,e,n){if(t+1<o.length){var r=e+" "+o[t+1];return A(r,n+"px",i).width<=h-4}return!1};a++;t:for(;;){e="";var l=A("3",--a+"px",i).height,u=t.multiline?s-a:(s-l)/2,f=-2,d=u+=2,p=0,g=0,m=0;if(a<=0){a=12,e="(...) Tj\n",e+="% Width of Text: "+A(e,"1px").width+", FieldWidth:"+h+"\n";break}m=A(o[0]+" ",a+"px",i).width;var w="",y=0;for(var v in o){w=" "==(w+=o[v]+" ").substr(w.length-1)?w.substr(0,w.length-1):w;var b=parseInt(v);m=A(w+" ",a+"px",i).width;var x=c(b,w,a),S=v>=o.length-1;if(!x||S){if(x||S){if(S)g=b;else if(t.multiline&&s<(l+2)*(y+2)+2)continue t}else{if(!t.multiline)continue t;if(s<(l+2)*(y+2)+2)continue t;g=b}for(var k="",_=p;_<=g;_++)k+=o[_]+" ";switch(k=" "==k.substr(k.length-1)?k.substr(0,k.length-1):k,m=A(k,a+"px",i).width,t.Q){case 2:f=h-m-2;break;case 1:f=(h-m)/2;break;case 0:default:f=2}e+=f.toFixed(2)+" "+d.toFixed(2)+" Td\n",e+="("+k+") Tj\n",e+=-f.toFixed(2)+" 0 Td\n",d=-(a+2),m=0,p=g+1,y++,w=""}else w+=" "}break}return r.text=e,r.fontSize=a,r},A=function(t,e,n){n=n||"helvetica";var r=l.internal.getFont(n),i=l.getStringUnitWidth(t,{font:r,fontSize:parseFloat(e),charSpace:0})*parseFloat(e);return{height:l.getStringUnitWidth("3",{font:r,fontSize:parseFloat(e),charSpace:0})*parseFloat(e)*1.5,width:i}},d={fields:[],xForms:[],acroFormDictionaryRoot:null,printedOut:!1,internal:null,isInitialized:!1},p=function(){for(var t in l.internal.acroformPlugin.acroFormDictionaryRoot.Fields){var e=l.internal.acroformPlugin.acroFormDictionaryRoot.Fields[t];e.hasAnnotation&&m.call(l,e)}},g=function(t){l.internal.acroformPlugin.printedOut&&(l.internal.acroformPlugin.printedOut=!1,l.internal.acroformPlugin.acroFormDictionaryRoot=null),l.internal.acroformPlugin.acroFormDictionaryRoot||x.call(l),l.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t)},m=function(t){var e={type:"reference",object:t};l.annotationPlugin.annotations[l.internal.getPageInfo(t.page).pageNumber].push(e)},w=function(){void 0!==l.internal.acroformPlugin.acroFormDictionaryRoot?l.internal.write("/AcroForm "+l.internal.acroformPlugin.acroFormDictionaryRoot.objId+" 0 R"):console.log("Root missing...")},y=function(){l.internal.events.unsubscribe(l.internal.acroformPlugin.acroFormDictionaryRoot._eventID),delete l.internal.acroformPlugin.acroFormDictionaryRoot._eventID,l.internal.acroformPlugin.printedOut=!0},v=function(t){var e=!t;t||(l.internal.newObjectDeferredBegin(l.internal.acroformPlugin.acroFormDictionaryRoot.objId),l.internal.out(l.internal.acroformPlugin.acroFormDictionaryRoot.getString()));t=t||l.internal.acroformPlugin.acroFormDictionaryRoot.Kids;for(var n in t){var r=t[n],i=r.Rect;r.Rect&&(r.Rect=u.call(this,r.Rect)),l.internal.newObjectDeferredBegin(r.objId);var o=r.objId+" 0 obj\n<<\n";if("object"===(void 0===r?"undefined":vt(r))&&"function"==typeof r.getContent&&(o+=r.getContent()),r.Rect=i,r.hasAppearanceStream&&!r.appearanceStreamContent){var a=f.call(this,r);o+="/AP << /N "+a+" >>\n",l.internal.acroformPlugin.xForms.push(a)}if(r.appearanceStreamContent){for(var s in o+="/AP << ",r.appearanceStreamContent){var h=r.appearanceStreamContent[s];if(o+="/"+s+" ",o+="<< ",1<=Object.keys(h).length||Array.isArray(h))for(var n in h){var c;"function"==typeof(c=h[n])&&(c=c.call(this,r)),o+="/"+n+" "+c+" ",0<=l.internal.acroformPlugin.xForms.indexOf(c)||l.internal.acroformPlugin.xForms.push(c)}else"function"==typeof(c=h)&&(c=c.call(this,r)),o+="/"+n+" "+c+" \n",0<=l.internal.acroformPlugin.xForms.indexOf(c)||l.internal.acroformPlugin.xForms.push(c);o+=" >>\n"}o+=">>\n"}o+=">>\nendobj\n",l.internal.out(o)}e&&b.call(this,l.internal.acroformPlugin.xForms)},b=function(t){for(var e in t){var n=e,r=t[e];l.internal.newObjectDeferredBegin(r&&r.objId);var i="";"object"===(void 0===r?"undefined":vt(r))&&"function"==typeof r.getString&&(i=r.getString()),l.internal.out(i),delete t[n]}},x=function(){if(void 0!==this.internal&&(void 0===this.internal.acroformPlugin||!1===this.internal.acroformPlugin.isInitialized)){if(l=this,T.FieldNum=0,this.internal.acroformPlugin=JSON.parse(JSON.stringify(d)),this.internal.acroformPlugin.acroFormDictionaryRoot)throw new Error("Exception while creating AcroformDictionary");e=l.internal.scaleFactor,a=l.internal.pageSize.getHeight(),l.internal.acroformPlugin.acroFormDictionaryRoot=new C,l.internal.acroformPlugin.acroFormDictionaryRoot._eventID=l.internal.events.subscribe("postPutResources",y),l.internal.events.subscribe("buildDocument",p),l.internal.events.subscribe("putCatalog",w),l.internal.events.subscribe("postPutPages",v),l.internal.acroformPlugin.isInitialized=!0}},S=function(t){if(Array.isArray(t)){var e=" [";for(var n in t){e+=t[n].toString(),e+=n<t.length-1?" ":""}return e+="]"}},k=function(t){return 0!==(t=t||"").indexOf("(")&&(t="("+t),")"!=t.substring(t.length-1)&&(t+=")"),t},_=function(){var t;Object.defineProperty(this,"objId",{get:function(){return t||(t=l.internal.newObjectDeferred()),t||console.log("Couldn't create Object ID"),t},configurable:!1})};_.prototype.toString=function(){return this.objId+" 0 R"},_.prototype.getString=function(){var t=this.objId+" 0 obj\n<<";return t+=this.getContent()+">>\n",this.stream&&(t+="stream\n",t+=this.stream,t+="\nendstream\n"),t+="endobj\n"},_.prototype.getContent=function(){var t="";return t+=function(t){var e="",n=Object.keys(t).filter(function(t){return"content"!=t&&"appearanceStreamContent"!=t&&"_"!=t.substring(0,1)});for(var r in n){var i=n[r],o=t[i];o&&(Array.isArray(o)?e+="/"+i+" "+S(o)+"\n":e+=o instanceof _?"/"+i+" "+o.objId+" 0 R\n":"/"+i+" "+o+"\n")}return e}(this)};var I=function(){var e;_.call(this),this.Type="/XObject",this.Subtype="/Form",this.FormType=1,this.BBox,this.Matrix,this.Resources="2 0 R",this.PieceInfo,Object.defineProperty(this,"Length",{enumerable:!0,get:function(){return void 0!==e?e.length:0}}),Object.defineProperty(this,"stream",{enumerable:!1,set:function(t){e=t.trim()},get:function(){return e||null}})};r(I,_);var C=function(){_.call(this);var t=[];Object.defineProperty(this,"Kids",{enumerable:!1,configurable:!0,get:function(){return 0<t.length?t:void 0}}),Object.defineProperty(this,"Fields",{enumerable:!0,configurable:!0,get:function(){return t}}),this.DA};r(C,_);var T=function t(){var e;_.call(this),Object.defineProperty(this,"Rect",{enumerable:!0,configurable:!1,get:function(){if(e)return e},set:function(t){e=t}});var n,r,i,o,a="";Object.defineProperty(this,"FT",{enumerable:!0,set:function(t){a=t},get:function(){return a}}),Object.defineProperty(this,"T",{enumerable:!0,configurable:!1,set:function(t){n=t},get:function(){if(!n||n.length<1){if(this instanceof j)return;return"(FieldObject"+t.FieldNum+++")"}return"("==n.substring(0,1)&&n.substring(n.length-1)?n:"("+n+")"}}),Object.defineProperty(this,"DA",{enumerable:!0,get:function(){if(r)return"("+r+")"},set:function(t){r=t}}),Object.defineProperty(this,"DV",{enumerable:!0,configurable:!0,get:function(){if(i)return i},set:function(t){i=t}}),Object.defineProperty(this,"V",{enumerable:!0,configurable:!0,get:function(){if(o)return o},set:function(t){o=t}}),Object.defineProperty(this,"Type",{enumerable:!0,get:function(){return this.hasAnnotation?"/Annot":null}}),Object.defineProperty(this,"Subtype",{enumerable:!0,get:function(){return this.hasAnnotation?"/Widget":null}}),this.BG,Object.defineProperty(this,"hasAnnotation",{enumerable:!1,get:function(){return!!(this.Rect||this.BC||this.BG)}}),Object.defineProperty(this,"hasAppearanceStream",{enumerable:!1,configurable:!0,writable:!0}),Object.defineProperty(this,"page",{enumerable:!1,configurable:!0,writable:!0})};r(T,_);var F=function(){T.call(this),this.FT="/Ch",this.Opt=[],this.V="()",this.TI=0;var e=!1;Object.defineProperty(this,"combo",{enumerable:!1,get:function(){return e},set:function(t){e=t}}),Object.defineProperty(this,"edit",{enumerable:!0,set:function(t){1==t?(this._edit=!0,this.combo=!0):this._edit=!1},get:function(){return!!this._edit&&this._edit},configurable:!1}),this.hasAppearanceStream=!0};r(F,T);var P=function(){F.call(this),this.combo=!1};r(P,F);var E=function(){P.call(this),this.combo=!0};r(E,P);var q=function(){E.call(this),this.edit=!0};r(q,E);var O=function(){T.call(this),this.FT="/Btn"};r(O,T);var B=function(){O.call(this);var e=!0;Object.defineProperty(this,"pushbutton",{enumerable:!1,get:function(){return e},set:function(t){e=t}})};r(B,O);var R=function(){O.call(this);var e=!0;Object.defineProperty(this,"radio",{enumerable:!1,get:function(){return e},set:function(t){e=t}});var n,t=[];Object.defineProperty(this,"Kids",{enumerable:!0,get:function(){if(0<t.length)return t}}),Object.defineProperty(this,"__Kids",{get:function(){return t}}),Object.defineProperty(this,"noToggleToOff",{enumerable:!1,get:function(){return n},set:function(t){n=t}})};r(R,O);var j=function(t,e){T.call(this),this.Parent=t,this._AppearanceType=N.RadioButton.Circle,this.appearanceStreamContent=this._AppearanceType.createAppearanceStream(e),this.F=i(this.F,3,1),this.MK=this._AppearanceType.createMK(),this.AS="/Off",this._Name=e};r(j,T),R.prototype.setAppearance=function(t){if("createAppearanceStream"in t&&"createMK"in t)for(var e in this.__Kids){var n=this.__Kids[e];n.appearanceStreamContent=t.createAppearanceStream(n._Name),n.MK=t.createMK()}else console.log("Couldn't assign Appearance to RadioButton. Appearance was Invalid!")},R.prototype.createOption=function(t){this.__Kids.length;var e=new j(this,t);return this.__Kids.push(e),n.addField(e),e};var D=function(){O.call(this),this.appearanceStreamContent=N.CheckBox.createAppearanceStream(),this.MK=N.CheckBox.createMK(),this.AS="/On",this.V="/On"};r(D,O);var M=function(){var e,n;T.call(this),this.DA=N.createDefaultAppearanceStream(),this.F=4,Object.defineProperty(this,"V",{get:function(){return e?k(e):e},enumerable:!0,set:function(t){e=t}}),Object.defineProperty(this,"DV",{get:function(){return n?k(n):n},enumerable:!0,set:function(t){n=t}});var r=!1;Object.defineProperty(this,"multiline",{enumerable:!1,get:function(){return r},set:function(t){r=t}});var i=!1;Object.defineProperty(this,"fileSelect",{enumerable:!1,get:function(){return i},set:function(t){i=t}});var o=!1;Object.defineProperty(this,"doNotSpellCheck",{enumerable:!1,get:function(){return o},set:function(t){o=t}});var a=!1;Object.defineProperty(this,"doNotScroll",{enumerable:!1,get:function(){return a},set:function(t){a=t}});var s=!1;Object.defineProperty(this,"MaxLen",{enumerable:!0,get:function(){return s},set:function(t){s=t}}),Object.defineProperty(this,"hasAppearanceStream",{enumerable:!1,get:function(){return this.V||this.DV}})};r(M,T);var U=function(){M.call(this);var e=!0;Object.defineProperty(this,"password",{enumerable:!1,get:function(){return e},set:function(t){e=t}})};r(U,M);var N={CheckBox:{createAppearanceStream:function(){return{N:{On:N.CheckBox.YesNormal},D:{On:N.CheckBox.YesPushDown,Off:N.CheckBox.OffPushDown}}},createMK:function(){return"<< /CA (3)>>"},YesPushDown:function(t){var e=h(t),n=[],r=l.internal.getFont("zapfdingbats","normal").id;t.Q=1;var i=c(t,"3","ZapfDingbats",50);return n.push("0.749023 g"),n.push("0 0 "+N.internal.getWidth(t).toFixed(2)+" "+N.internal.getHeight(t).toFixed(2)+" re"),n.push("f"),n.push("BMC"),n.push("q"),n.push("0 0 1 rg"),n.push("/"+r+" "+i.fontSize.toFixed(2)+" Tf 0 g"),n.push("BT"),n.push(i.text),n.push("ET"),n.push("Q"),n.push("EMC"),e.stream=n.join("\n"),e},YesNormal:function(t){var e=h(t),n=l.internal.getFont("zapfdingbats","normal").id,r=[];t.Q=1;var i=N.internal.getHeight(t),o=N.internal.getWidth(t),a=c(t,"3","ZapfDingbats",.9*i);return r.push("1 g"),r.push("0 0 "+o.toFixed(2)+" "+i.toFixed(2)+" re"),r.push("f"),r.push("q"),r.push("0 0 1 rg"),r.push("0 0 "+(o-1).toFixed(2)+" "+(i-1).toFixed(2)+" re"),r.push("W"),r.push("n"),r.push("0 g"),r.push("BT"),r.push("/"+n+" "+a.fontSize.toFixed(2)+" Tf 0 g"),r.push(a.text),r.push("ET"),r.push("Q"),e.stream=r.join("\n"),e},OffPushDown:function(t){var e=h(t),n=[];return n.push("0.749023 g"),n.push("0 0 "+N.internal.getWidth(t).toFixed(2)+" "+N.internal.getHeight(t).toFixed(2)+" re"),n.push("f"),e.stream=n.join("\n"),e}},RadioButton:{Circle:{createAppearanceStream:function(t){var e={D:{Off:N.RadioButton.Circle.OffPushDown},N:{}};return e.N[t]=N.RadioButton.Circle.YesNormal,e.D[t]=N.RadioButton.Circle.YesPushDown,e},createMK:function(){return"<< /CA (l)>>"},YesNormal:function(t){var e=h(t),n=[],r=N.internal.getWidth(t)<=N.internal.getHeight(t)?N.internal.getWidth(t)/4:N.internal.getHeight(t)/4;r*=.9;var i=N.internal.Bezier_C;return n.push("q"),n.push("1 0 0 1 "+N.internal.getWidth(t)/2+" "+N.internal.getHeight(t)/2+" cm"),n.push(r+" 0 m"),n.push(r+" "+r*i+" "+r*i+" "+r+" 0 "+r+" c"),n.push("-"+r*i+" "+r+" -"+r+" "+r*i+" -"+r+" 0 c"),n.push("-"+r+" -"+r*i+" -"+r*i+" -"+r+" 0 -"+r+" c"),n.push(r*i+" -"+r+" "+r+" -"+r*i+" "+r+" 0 c"),n.push("f"),n.push("Q"),e.stream=n.join("\n"),e},YesPushDown:function(t){var e=h(t),n=[],r=N.internal.getWidth(t)<=N.internal.getHeight(t)?N.internal.getWidth(t)/4:N.internal.getHeight(t)/4,i=2*(r*=.9),o=i*N.internal.Bezier_C,a=r*N.internal.Bezier_C;return n.push("0.749023 g"),n.push("q"),n.push("1 0 0 1 "+(N.internal.getWidth(t)/2).toFixed(2)+" "+(N.internal.getHeight(t)/2).toFixed(2)+" cm"),n.push(i+" 0 m"),n.push(i+" "+o+" "+o+" "+i+" 0 "+i+" c"),n.push("-"+o+" "+i+" -"+i+" "+o+" -"+i+" 0 c"),n.push("-"+i+" -"+o+" -"+o+" -"+i+" 0 -"+i+" c"),n.push(o+" -"+i+" "+i+" -"+o+" "+i+" 0 c"),n.push("f"),n.push("Q"),n.push("0 g"),n.push("q"),n.push("1 0 0 1 "+(N.internal.getWidth(t)/2).toFixed(2)+" "+(N.internal.getHeight(t)/2).toFixed(2)+" cm"),n.push(r+" 0 m"),n.push(r+" "+a+" "+a+" "+r+" 0 "+r+" c"),n.push("-"+a+" "+r+" -"+r+" "+a+" -"+r+" 0 c"),n.push("-"+r+" -"+a+" -"+a+" -"+r+" 0 -"+r+" c"),n.push(a+" -"+r+" "+r+" -"+a+" "+r+" 0 c"),n.push("f"),n.push("Q"),e.stream=n.join("\n"),e},OffPushDown:function(t){var e=h(t),n=[],r=N.internal.getWidth(t)<=N.internal.getHeight(t)?N.internal.getWidth(t)/4:N.internal.getHeight(t)/4,i=2*(r*=.9),o=i*N.internal.Bezier_C;return n.push("0.749023 g"),n.push("q"),n.push("1 0 0 1 "+(N.internal.getWidth(t)/2).toFixed(2)+" "+(N.internal.getHeight(t)/2).toFixed(2)+" cm"),n.push(i+" 0 m"),n.push(i+" "+o+" "+o+" "+i+" 0 "+i+" c"),n.push("-"+o+" "+i+" -"+i+" "+o+" -"+i+" 0 c"),n.push("-"+i+" -"+o+" -"+o+" -"+i+" 0 -"+i+" c"),n.push(o+" -"+i+" "+i+" -"+o+" "+i+" 0 c"),n.push("f"),n.push("Q"),e.stream=n.join("\n"),e}},Cross:{createAppearanceStream:function(t){var e={D:{Off:N.RadioButton.Cross.OffPushDown},N:{}};return e.N[t]=N.RadioButton.Cross.YesNormal,e.D[t]=N.RadioButton.Cross.YesPushDown,e},createMK:function(){return"<< /CA (8)>>"},YesNormal:function(t){var e=h(t),n=[],r=N.internal.calculateCross(t);return n.push("q"),n.push("1 1 "+(N.internal.getWidth(t)-2).toFixed(2)+" "+(N.internal.getHeight(t)-2).toFixed(2)+" re"),n.push("W"),n.push("n"),n.push(r.x1.x.toFixed(2)+" "+r.x1.y.toFixed(2)+" m"),n.push(r.x2.x.toFixed(2)+" "+r.x2.y.toFixed(2)+" l"),n.push(r.x4.x.toFixed(2)+" "+r.x4.y.toFixed(2)+" m"),n.push(r.x3.x.toFixed(2)+" "+r.x3.y.toFixed(2)+" l"),n.push("s"),n.push("Q"),e.stream=n.join("\n"),e},YesPushDown:function(t){var e=h(t),n=N.internal.calculateCross(t),r=[];return r.push("0.749023 g"),r.push("0 0 "+N.internal.getWidth(t).toFixed(2)+" "+N.internal.getHeight(t).toFixed(2)+" re"),r.push("f"),r.push("q"),r.push("1 1 "+(N.internal.getWidth(t)-2).toFixed(2)+" "+(N.internal.getHeight(t)-2).toFixed(2)+" re"),r.push("W"),r.push("n"),r.push(n.x1.x.toFixed(2)+" "+n.x1.y.toFixed(2)+" m"),r.push(n.x2.x.toFixed(2)+" "+n.x2.y.toFixed(2)+" l"),r.push(n.x4.x.toFixed(2)+" "+n.x4.y.toFixed(2)+" m"),r.push(n.x3.x.toFixed(2)+" "+n.x3.y.toFixed(2)+" l"),r.push("s"),r.push("Q"),e.stream=r.join("\n"),e},OffPushDown:function(t){var e=h(t),n=[];return n.push("0.749023 g"),n.push("0 0 "+N.internal.getWidth(t).toFixed(2)+" "+N.internal.getHeight(t).toFixed(2)+" re"),n.push("f"),e.stream=n.join("\n"),e}}},createDefaultAppearanceStream:function(t){return"/F1 0 Tf 0 g"}};N.internal={Bezier_C:.551915024494,calculateCross:function(t){var e,n,r=N.internal.getWidth(t),i=N.internal.getHeight(t),o=(n=i)<(e=r)?n:e;return{x1:{x:(r-o)/2,y:(i-o)/2+o},x2:{x:(r-o)/2+o,y:(i-o)/2},x3:{x:(r-o)/2,y:(i-o)/2},x4:{x:(r-o)/2+o,y:(i-o)/2+o}}}},N.internal.getWidth=function(t){var e=0;return"object"===(void 0===t?"undefined":vt(t))&&(e=s(t.Rect[2])),e},N.internal.getHeight=function(t){var e=0;return"object"===(void 0===t?"undefined":vt(t))&&(e=s(t.Rect[3])),e},n.addField=function(t){return x.call(this),t instanceof M?this.addTextField.call(this,t):t instanceof F?this.addChoiceField.call(this,t):t instanceof O?this.addButton.call(this,t):t instanceof j?g.call(this,t):t&&g.call(this,t),t.page=l.internal.getCurrentPageInfo().pageNumber,this},n.addButton=function(t){x.call(this);var e=t||new T;e.FT="/Btn",e.Ff=o(e.Ff,t,l.internal.getPDFVersion()),g.call(this,e)},n.addTextField=function(t){x.call(this);var e=t||new T;e.FT="/Tx",e.Ff=o(e.Ff,t,l.internal.getPDFVersion()),g.call(this,e)},n.addChoiceField=function(t){x.call(this);var e=t||new T;e.FT="/Ch",e.Ff=o(e.Ff,t,l.internal.getPDFVersion()),g.call(this,e)},"object"==(void 0===t?"undefined":vt(t))&&(t.ChoiceField=F,t.ListBox=P,t.ComboBox=E,t.EditBox=q,t.Button=O,t.PushButton=B,t.RadioButton=R,t.CheckBox=D,t.TextField=M,t.PasswordField=U,t.AcroForm={Appearance:N}),n.AcroFormChoiceField=F,n.AcroFormListBox=P,n.AcroFormComboBox=E,n.AcroFormEditBox=q,n.AcroFormButton=O,n.AcroFormPushButton=B,n.AcroFormRadioButton=R,n.AcroFormCheckBox=D,n.AcroFormTextField=M,n.AcroFormPasswordField=U,n.AcroForm={ChoiceField:F,ListBox:P,ComboBox:E,EditBox:q,Button:O,PushButton:B,RadioButton:R,CheckBox:D,TextField:M,PasswordField:U}}($.API,"undefined"!=typeof window&&window||"undefined"!=typeof global&&global),$.API.addHTML=function(t,p,g,s,m){if("undefined"==typeof html2canvas&&"undefined"==typeof rasterizeHTML)throw new Error("You need either https://github.com/niklasvh/html2canvas or https://github.com/cburgmer/rasterizeHTML.js");"number"!=typeof p&&(s=p,m=g),"function"==typeof s&&(m=s,s=null),"function"!=typeof m&&(m=function(){});var e=this.internal,w=e.scaleFactor,y=e.pageSize.getWidth(),v=e.pageSize.getHeight();if((s=s||{}).onrendered=function(h){p=parseInt(p)||0,g=parseInt(g)||0;var t=s.dim||{},c=Object.assign({top:0,right:0,bottom:0,left:0,useFor:"content"},s.margin),e=t.h||Math.min(v,h.height/w),l=t.w||Math.min(y,h.width/w)-p,u=s.format||"JPEG",f=s.imageCompression||"SLOW";if(h.height>v-c.top-c.bottom&&s.pagesplit){var d=function(t,e,n,r,i){var o=document.createElement("canvas");o.height=i,o.width=r;var a=o.getContext("2d");return a.mozImageSmoothingEnabled=!1,a.webkitImageSmoothingEnabled=!1,a.msImageSmoothingEnabled=!1,a.imageSmoothingEnabled=!1,a.fillStyle=s.backgroundColor||"#ffffff",a.fillRect(0,0,r,i),a.drawImage(t,e,n,r,i,0,0,r,i),o},n=function(){for(var t,e,n=0,r=0,i={},o=!1;;){var a;if(r=0,i.top=0!==n?c.top:g,i.left=0!==n?c.left:p,o=(y-c.left-c.right)*w<h.width,"content"===c.useFor?0===n?(t=Math.min((y-c.left)*w,h.width),e=Math.min((v-c.top)*w,h.height-n)):(t=Math.min(y*w,h.width),e=Math.min(v*w,h.height-n),i.top=0):(t=Math.min((y-c.left-c.right)*w,h.width),e=Math.min((v-c.bottom-c.top)*w,h.height-n)),o)for(;;){"content"===c.useFor&&(0===r?t=Math.min((y-c.left)*w,h.width):(t=Math.min(y*w,h.width-r),i.left=0));var s=[a=d(h,r,n,t,e),i.left,i.top,a.width/w,a.height/w,u,null,f];if(this.addImage.apply(this,s),(r+=t)>=h.width)break;this.addPage()}else s=[a=d(h,0,n,t,e),i.left,i.top,a.width/w,a.height/w,u,null,f],this.addImage.apply(this,s);if((n+=e)>=h.height)break;this.addPage()}m(l,n,null,s)}.bind(this);if("CANVAS"===h.nodeName){var r=new Image;r.onload=n,r.src=h.toDataURL("image/png"),h=r}else n()}else{var i=Math.random().toString(35),o=[h,p,g,l,e,u,i,f];this.addImage.apply(this,o),m(l,e,i,o)}}.bind(this),"undefined"!=typeof html2canvas&&!s.rstz)return html2canvas(t,s);if("undefined"!=typeof rasterizeHTML){var n="drawDocument";return"string"==typeof t&&(n=/^http/.test(t)?"drawURL":"drawHTML"),s.width=s.width||y*w,rasterizeHTML[n](t,void 0,s).then(function(t){s.onrendered(t.image)},function(t){m(null,t)})}return null},
/** @preserve
   * jsPDF addImage plugin
   * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
   *               2013 Chris Dowling, https://github.com/gingerchris
   *               2013 Trinh Ho, https://github.com/ineedfat
   *               2013 Edwin Alejandro Perez, https://github.com/eaparango
   *               2013 Norah Smith, https://github.com/burnburnrocket
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 James Robb, https://github.com/jamesbrobb
   *
   * 
   */
function(b){var x="addImage_",h={PNG:[[137,80,78,71]],TIFF:[[77,77,0,42],[73,73,42,0]],JPEG:[[255,216,255,224,void 0,void 0,74,70,73,70,0],[255,216,255,225,void 0,void 0,69,120,105,102,0,0]],JPEG2000:[[0,0,0,12,106,80,32,32]],GIF87a:[[71,73,70,56,55,97]],GIF89a:[[71,73,70,56,57,97]],BMP:[[66,77],[66,65],[67,73],[67,80],[73,67],[80,84]]};b.getImageFileTypeByImageData=function(t,e){var n,r;e=e||"UNKNOWN";var i,o,a,s="UNKNOWN";for(a in h)for(i=h[a],n=0;n<i.length;n+=1){for(o=!0,r=0;r<i[n].length;r+=1)if(void 0!==i[n][r]&&i[n][r]!==t.charCodeAt(r)){o=!1;break}if(!0===o){s=a;break}}return"UNKOWN"===s&&"UNKNOWN"!==e&&(console.warn('FileType of Image not recognized. Processing image as "'+e+'".'),s=e),s};var n=function t(e){var n=this.internal.newObject(),r=this.internal.write,i=this.internal.putStream;if(e.n=n,r("<</Type /XObject"),r("/Subtype /Image"),r("/Width "+e.w),r("/Height "+e.h),e.cs===this.color_spaces.INDEXED?r("/ColorSpace [/Indexed /DeviceRGB "+(e.pal.length/3-1)+" "+("smask"in e?n+2:n+1)+" 0 R]"):(r("/ColorSpace /"+e.cs),e.cs===this.color_spaces.DEVICE_CMYK&&r("/Decode [1 0 1 0 1 0 1 0]")),r("/BitsPerComponent "+e.bpc),"f"in e&&r("/Filter /"+e.f),"dp"in e&&r("/DecodeParms <<"+e.dp+">>"),"trns"in e&&e.trns.constructor==Array){for(var o="",a=0,s=e.trns.length;a<s;a++)o+=e.trns[a]+" "+e.trns[a]+" ";r("/Mask ["+o+"]")}if("smask"in e&&r("/SMask "+(n+1)+" 0 R"),r("/Length "+e.data.length+">>"),i(e.data),r("endobj"),"smask"in e){var h="/Predictor "+e.p+" /Colors 1 /BitsPerComponent "+e.bpc+" /Columns "+e.w,c={w:e.w,h:e.h,cs:"DeviceGray",bpc:e.bpc,dp:h,data:e.smask};"f"in e&&(c.f=e.f),t.call(this,c)}e.cs===this.color_spaces.INDEXED&&(this.internal.newObject(),r("<< /Length "+e.pal.length+">>"),i(this.arrayBufferToBinaryString(new Uint8Array(e.pal))),r("endobj"))},S=function(){var t=this.internal.collections[x+"images"];for(var e in t)n.call(this,t[e])},k=function(){var t,e=this.internal.collections[x+"images"],n=this.internal.write;for(var r in e)n("/I"+(t=e[r]).i,t.n,"0","R")},_=function(t){return"function"==typeof b["process"+t.toUpperCase()]},A=function(t){return"object"===(void 0===t?"undefined":vt(t))&&1===t.nodeType},I=function(t,e){if("IMG"===t.nodeName&&t.hasAttribute("src")){var n=""+t.getAttribute("src");if(0===n.indexOf("data:image/"))return n;!e&&/\.png(?:[?#].*)?$/i.test(n)&&(e="png")}if("CANVAS"===t.nodeName)var r=t;else{(r=document.createElement("canvas")).width=t.clientWidth||t.width,r.height=t.clientHeight||t.height;var i=r.getContext("2d");if(!i)throw"addImage requires canvas to be supported by browser.";i.drawImage(t,0,0,r.width,r.height)}return r.toDataURL("png"==(""+e).toLowerCase()?"image/png":"image/jpeg")},C=function(t,e){var n;if(e)for(var r in e)if(t===e[r].alias){n=e[r];break}return n};b.color_spaces={DEVICE_RGB:"DeviceRGB",DEVICE_GRAY:"DeviceGray",DEVICE_CMYK:"DeviceCMYK",CAL_GREY:"CalGray",CAL_RGB:"CalRGB",LAB:"Lab",ICC_BASED:"ICCBased",INDEXED:"Indexed",PATTERN:"Pattern",SEPARATION:"Separation",DEVICE_N:"DeviceN"},b.decode={DCT_DECODE:"DCTDecode",FLATE_DECODE:"FlateDecode",LZW_DECODE:"LZWDecode",JPX_DECODE:"JPXDecode",JBIG2_DECODE:"JBIG2Decode",ASCII85_DECODE:"ASCII85Decode",ASCII_HEX_DECODE:"ASCIIHexDecode",RUN_LENGTH_DECODE:"RunLengthDecode",CCITT_FAX_DECODE:"CCITTFaxDecode"},b.image_compression={NONE:"NONE",FAST:"FAST",MEDIUM:"MEDIUM",SLOW:"SLOW"},b.sHashCode=function(t){return t=t||"",Array.prototype.reduce&&t.split("").reduce(function(t,e){return(t=(t<<5)-t+e.charCodeAt(0))&t},0)},b.isString=function(t){return"string"==typeof t},b.validateStringAsBase64=function(t){var e=!0;return(t=t||"").length%4!=0&&(e=!1),!1===/[A-Za-z0-9\/]+/.test(t.substr(0,t.length-2))&&(e=!1),!1===/[A-Za-z0-9\/][A-Za-z0-9+\/]|[A-Za-z0-9+\/]=|==/.test(t.substr(-2))&&(e=!1),e},b.extractInfoFromBase64DataURI=function(t){return/^data:([\w]+?\/([\w]+?));base64,(.+)$/g.exec(t)},b.supportsArrayBuffer=function(){return"undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array},b.isArrayBuffer=function(t){return!!this.supportsArrayBuffer()&&t instanceof ArrayBuffer},b.isArrayBufferView=function(t){return!!this.supportsArrayBuffer()&&("undefined"!=typeof Uint32Array&&(t instanceof Int8Array||t instanceof Uint8Array||"undefined"!=typeof Uint8ClampedArray&&t instanceof Uint8ClampedArray||t instanceof Int16Array||t instanceof Uint16Array||t instanceof Int32Array||t instanceof Uint32Array||t instanceof Float32Array||t instanceof Float64Array))},b.binaryStringToUint8Array=function(t){for(var e=t.length,n=new Uint8Array(e),r=0;r<e;r++)n[r]=t.charCodeAt(r);return n},b.arrayBufferToBinaryString=function(t){if("function"==typeof atob)return atob(this.arrayBufferToBase64(t));if("function"==typeof TextDecoder){var e=new TextDecoder("ascii");if("ascii"===e.encoding)return e.decode(t)}for(var n=this.isArrayBuffer(t)?t:new Uint8Array(t),r=20480,i="",o=Math.ceil(n.byteLength/r),a=0;a<o;a++)i+=String.fromCharCode.apply(null,n.slice(a*r,a*r+r));return i},b.arrayBufferToBase64=function(t){for(var e,n="",r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=new Uint8Array(t),o=i.byteLength,a=o%3,s=o-a,h=0;h<s;h+=3)n+=r[(16515072&(e=i[h]<<16|i[h+1]<<8|i[h+2]))>>18]+r[(258048&e)>>12]+r[(4032&e)>>6]+r[63&e];return 1==a?n+=r[(252&(e=i[s]))>>2]+r[(3&e)<<4]+"==":2==a&&(n+=r[(64512&(e=i[s]<<8|i[s+1]))>>10]+r[(1008&e)>>4]+r[(15&e)<<2]+"="),n},b.createImageInfo=function(t,e,n,r,i,o,a,s,h,c,l,u,f){var d={alias:s,w:e,h:n,cs:r,bpc:i,i:a,data:t};return o&&(d.f=o),h&&(d.dp=h),c&&(d.trns=c),l&&(d.pal=l),u&&(d.smask=u),f&&(d.p=f),d},b.addImage=function(t,e,n,r,i,o,a,s,h){var c="";if("string"!=typeof e){var l=o;o=i,i=r,r=n,n=e,e=l}if("object"===(void 0===t?"undefined":vt(t))&&!A(t)&&"imageData"in t){var u=t;t=u.imageData,e=u.format||e,n=u.x||n||0,r=u.y||r||0,i=u.w||i,o=u.h||o,a=u.alias||a,s=u.compression||s,h=u.rotation||u.angle||h}if(isNaN(n)||isNaN(r))throw console.error("jsPDF.addImage: Invalid coordinates",arguments),new Error("Invalid coordinates passed to jsPDF.addImage");var f,d,p,g,m,w,y,v=function(){var t=this.internal.collections[x+"images"];return t||(this.internal.collections[x+"images"]=t={},this.internal.events.subscribe("putResources",S),this.internal.events.subscribe("putXobjectDict",k)),t}.call(this);if(!(f=C(t,v))&&(A(t)&&(t=I(t,e)),(null==(y=a)||0===y.length)&&(a="string"==typeof(w=t)&&b.sHashCode(w)),!(f=C(a,v)))){if(this.isString(t)&&(""!==(c=this.convertStringToImageData(t))?t=c:void 0!==(c=this.loadImageFile(t))&&(t=c)),e=this.getImageFileTypeByImageData(t,e),!_(e))throw new Error("addImage does not support files of type '"+e+"', please ensure that a plugin for '"+e+"' support is added.");if(this.supportsArrayBuffer()&&(t instanceof Uint8Array||(d=t,t=this.binaryStringToUint8Array(t))),!(f=this["process"+e.toUpperCase()](t,(m=0,(g=v)&&(m=Object.keys?Object.keys(g).length:function(t){var e=0;for(var n in t)t.hasOwnProperty(n)&&e++;return e}(g)),m),a,((p=s)&&"string"==typeof p&&(p=p.toUpperCase()),p in b.image_compression?p:b.image_compression.NONE),d)))throw new Error("An unkwown error occurred whilst processing the image")}return function(t,e,n,r,i,o,a,s){var h=function(t,e,n){return t||e||(e=t=-96),t<0&&(t=-1*n.w*72/t/this.internal.scaleFactor),e<0&&(e=-1*n.h*72/e/this.internal.scaleFactor),0===t&&(t=e*n.w/n.h),0===e&&(e=t*n.h/n.w),[t,e]}.call(this,n,r,i),c=this.internal.getCoordinateString,l=this.internal.getVerticalCoordinateString;if(n=h[0],r=h[1],a[o]=i,s){s*=Math.PI/180;var u=Math.cos(s),f=Math.sin(s),d=function(t){return t.toFixed(4)},p=[d(u),d(f),d(-1*f),d(u),0,0,"cm"]}this.internal.write("q"),s?(this.internal.write([1,"0","0",1,c(t),l(e+r),"cm"].join(" ")),this.internal.write(p.join(" ")),this.internal.write([c(n),"0","0",c(r),"0","0","cm"].join(" "))):this.internal.write([c(n),"0","0",c(r),c(t),l(e+r),"cm"].join(" ")),this.internal.write("/I"+i.i+" Do"),this.internal.write("Q")}.call(this,n,r,i,o,f,f.i,v,h),this},b.convertStringToImageData=function(t){var e,n="";this.isString(t)&&(null!==(e=this.extractInfoFromBase64DataURI(t))?b.validateStringAsBase64(e[3])&&(n=atob(e[3])):b.validateStringAsBase64(t)&&(n=atob(t)));return n};var c=function(t,e){return t.subarray(e,e+5)};b.processJPEG=function(t,e,n,r,i,o){var a,s=this.decode.DCT_DECODE;if(!this.isString(t)&&!this.isArrayBuffer(t)&&!this.isArrayBufferView(t))return null;if(this.isString(t)&&(a=function(t){var e;if(255===!t.charCodeAt(0)||216===!t.charCodeAt(1)||255===!t.charCodeAt(2)||224===!t.charCodeAt(3)||!t.charCodeAt(6)==="J".charCodeAt(0)||!t.charCodeAt(7)==="F".charCodeAt(0)||!t.charCodeAt(8)==="I".charCodeAt(0)||!t.charCodeAt(9)==="F".charCodeAt(0)||0===!t.charCodeAt(10))throw new Error("getJpegSize requires a binary string jpeg file");for(var n=256*t.charCodeAt(4)+t.charCodeAt(5),r=4,i=t.length;r<i;){if(r+=n,255!==t.charCodeAt(r))throw new Error("getJpegSize could not find the size of the image");if(192===t.charCodeAt(r+1)||193===t.charCodeAt(r+1)||194===t.charCodeAt(r+1)||195===t.charCodeAt(r+1)||196===t.charCodeAt(r+1)||197===t.charCodeAt(r+1)||198===t.charCodeAt(r+1)||199===t.charCodeAt(r+1))return e=256*t.charCodeAt(r+5)+t.charCodeAt(r+6),[256*t.charCodeAt(r+7)+t.charCodeAt(r+8),e,t.charCodeAt(r+9)];r+=2,n=256*t.charCodeAt(r)+t.charCodeAt(r+1)}}(t)),this.isArrayBuffer(t)&&(t=new Uint8Array(t)),this.isArrayBufferView(t)&&(a=function(t){if(65496!=(t[0]<<8|t[1]))throw new Error("Supplied data is not a JPEG");for(var e,n=t.length,r=(t[4]<<8)+t[5],i=4;i<n;){if(r=((e=c(t,i+=r))[2]<<8)+e[3],(192===e[1]||194===e[1])&&255===e[0]&&7<r)return{width:((e=c(t,i+5))[2]<<8)+e[3],height:(e[0]<<8)+e[1],numcomponents:e[4]};i+=2}throw new Error("getJpegSizeFromBytes could not find the size of the image")}(t),t=i||this.arrayBufferToBinaryString(t)),void 0===o)switch(a.numcomponents){case 1:o=this.color_spaces.DEVICE_GRAY;break;case 4:o=this.color_spaces.DEVICE_CMYK;break;default:case 3:o=this.color_spaces.DEVICE_RGB}return this.createImageInfo(t,a.width,a.height,o,8,s,e,n)},b.processJPG=function(){return this.processJPEG.apply(this,arguments)},b.loadImageFile=function(t,e,n){e=e||!0,n=n||function(){};Object.prototype.toString.call("undefined"!=typeof process?process:0);if(void 0!==("undefined"==typeof window?"undefined":vt(window))&&"object"===("undefined"==typeof location?"undefined":vt(location))&&"http"===location.protocol.substr(0,4))return function(t,e,n){var r=new XMLHttpRequest,i=[],o=0,a=function(t){var e=t.length,n=String.fromCharCode;for(o=0;o<e;o+=1)i.push(n(255&t.charCodeAt(o)));return i.join("")};if(r.open("GET",t,!e),r.overrideMimeType("text/plain; charset=x-user-defined"),!1===e&&(r.onload=function(){return a(this.responseText)}),r.send(null),200===r.status)return e?a(r.responseText):void 0;console.warn('Unable to load file "'+t+'"')}(t,e)},b.getImageProperties=function(t){var e,n,r="";if(A(t)&&(t=I(t)),this.isString(t)&&(""!==(r=this.convertStringToImageData(t))?t=r:void 0!==(r=this.loadImageFile(t))&&(t=r)),n=this.getImageFileTypeByImageData(t),!_(n))throw new Error("addImage does not support files of type '"+n+"', please ensure that a plugin for '"+n+"' support is added.");if(this.supportsArrayBuffer()&&(t instanceof Uint8Array||(t=this.binaryStringToUint8Array(t))),!(e=this["process"+n.toUpperCase()](t)))throw new Error("An unkwown error occurred whilst processing the image");return{fileType:n,width:e.w,height:e.h,colorSpace:e.cs,compressionMode:e.f,bitsPerComponent:e.bpc}}}($.API),
/**
   * jsPDF Annotations PlugIn
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
t=$.API,y={annotations:[],f2:function(t){return t.toFixed(2)},notEmpty:function(t){if(void 0!==t&&""!=t)return!0}},$.API.annotationPlugin=y,$.API.events.push(["addPage",function(t){this.annotationPlugin.annotations[t.pageNumber]=[]}]),t.events.push(["putPage",function(t){for(var e=this.annotationPlugin.annotations[t.pageNumber],n=!1,r=0;r<e.length&&!n;r++)switch((h=e[r]).type){case"link":if(y.notEmpty(h.options.url)||y.notEmpty(h.options.pageNumber)){n=!0;break}case"reference":case"text":case"freetext":n=!0}if(0!=n){this.internal.write("/Annots [");var i=this.annotationPlugin.f2,o=this.internal.scaleFactor,a=this.internal.pageSize.getHeight(),s=this.internal.getPageInfo(t.pageNumber);for(r=0;r<e.length;r++){var h;switch((h=e[r]).type){case"reference":this.internal.write(" "+h.object.objId+" 0 R ");break;case"text":var c=this.internal.newAdditionalObject(),l=this.internal.newAdditionalObject(),u=h.title||"Note";m="<</Type /Annot /Subtype /Text "+(d="/Rect ["+i(h.bounds.x*o)+" "+i(a-(h.bounds.y+h.bounds.h)*o)+" "+i((h.bounds.x+h.bounds.w)*o)+" "+i((a-h.bounds.y)*o)+"] ")+"/Contents ("+h.contents+")",m+=" /Popup "+l.objId+" 0 R",m+=" /P "+s.objId+" 0 R",m+=" /T ("+u+") >>",c.content=m;var f=c.objId+" 0 R";m="<</Type /Annot /Subtype /Popup "+(d="/Rect ["+i((h.bounds.x+30)*o)+" "+i(a-(h.bounds.y+h.bounds.h)*o)+" "+i((h.bounds.x+h.bounds.w+30)*o)+" "+i((a-h.bounds.y)*o)+"] ")+" /Parent "+f,h.open&&(m+=" /Open true"),m+=" >>",l.content=m,this.internal.write(c.objId,"0 R",l.objId,"0 R");break;case"freetext":var d="/Rect ["+i(h.bounds.x*o)+" "+i((a-h.bounds.y)*o)+" "+i(h.bounds.x+h.bounds.w*o)+" "+i(a-(h.bounds.y+h.bounds.h)*o)+"] ",p=h.color||"#000000";m="<</Type /Annot /Subtype /FreeText "+d+"/Contents ("+h.contents+")",m+=" /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#"+p+")",m+=" /Border [0 0 0]",m+=" >>",this.internal.write(m);break;case"link":if(h.options.name){var g=this.annotations._nameMap[h.options.name];h.options.pageNumber=g.page,h.options.top=g.y}else h.options.top||(h.options.top=0);d="/Rect ["+i(h.x*o)+" "+i((a-h.y)*o)+" "+i((h.x+h.w)*o)+" "+i((a-(h.y+h.h))*o)+"] ";var m="";if(h.options.url)m="<</Type /Annot /Subtype /Link "+d+"/Border [0 0 0] /A <</S /URI /URI ("+h.options.url+") >>";else if(h.options.pageNumber)switch(m="<</Type /Annot /Subtype /Link "+d+"/Border [0 0 0] /Dest ["+(t=this.internal.getPageInfo(h.options.pageNumber)).objId+" 0 R",h.options.magFactor=h.options.magFactor||"XYZ",h.options.magFactor){case"Fit":m+=" /Fit]";break;case"FitH":m+=" /FitH "+h.options.top+"]";break;case"FitV":h.options.left=h.options.left||0,m+=" /FitV "+h.options.left+"]";break;case"XYZ":default:var w=i((a-h.options.top)*o);h.options.left=h.options.left||0,void 0===h.options.zoom&&(h.options.zoom=0),m+=" /XYZ "+h.options.left+" "+w+" "+h.options.zoom+"]"}""!=m&&(m+=" >>",this.internal.write(m))}}this.internal.write("]")}}]),t.createAnnotation=function(t){switch(t.type){case"link":this.link(t.bounds.x,t.bounds.y,t.bounds.w,t.bounds.h,t);break;case"text":case"freetext":this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push(t)}},t.link=function(t,e,n,r,i){this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({x:t,y:e,w:n,h:r,options:i,type:"link"})},t.textWithLink=function(t,e,n,r){var i=this.getTextWidth(t),o=this.internal.getLineHeight()/this.internal.scaleFactor;return this.text(t,e,n),n+=.2*o,this.link(e,n-o,i,o,r),i},t.getTextWidth=function(t){var e=this.internal.getFontSize();return this.getStringUnitWidth(t)*e/this.internal.scaleFactor},t.getLineHeight=function(){return this.internal.getLineHeight()},function(t){var a=Object.keys({ar:"Arabic (Standard)","ar-DZ":"Arabic (Algeria)","ar-BH":"Arabic (Bahrain)","ar-EG":"Arabic (Egypt)","ar-IQ":"Arabic (Iraq)","ar-JO":"Arabic (Jordan)","ar-KW":"Arabic (Kuwait)","ar-LB":"Arabic (Lebanon)","ar-LY":"Arabic (Libya)","ar-MA":"Arabic (Morocco)","ar-OM":"Arabic (Oman)","ar-QA":"Arabic (Qatar)","ar-SA":"Arabic (Saudi Arabia)","ar-SY":"Arabic (Syria)","ar-TN":"Arabic (Tunisia)","ar-AE":"Arabic (U.A.E.)","ar-YE":"Arabic (Yemen)",fa:"Persian","fa-IR":"Persian/Iran",ur:"Urdu"}),u={1569:[65152],1570:[65153,65154,65153,65154],1571:[65155,65156,65155,65156],1572:[65157,65158],1573:[65159,65160,65159,65160],1574:[65161,65162,65163,65164],1575:[65165,65166,65165,65166],1576:[65167,65168,65169,65170],1577:[65171,65172],1578:[65173,65174,65175,65176],1579:[65177,65178,65179,65180],1580:[65181,65182,65183,65184],1581:[65185,65186,65187,65188],1582:[65189,65190,65191,65192],1583:[65193,65194,65193],1584:[65195,65196,65195],1585:[65197,65198,65197],1586:[65199,65200,65199],1587:[65201,65202,65203,65204],1588:[65205,65206,65207,65208],1589:[65209,65210,65211,65212],1590:[65213,65214,65215,65216],1591:[65217,65218,65219,65220],1592:[65221,65222,65223,65224],1593:[65225,65226,65227,65228],1594:[65229,65230,65231,65232],1601:[65233,65234,65235,65236],1602:[65237,65238,65239,65240],1603:[65241,65242,65243,65244],1604:[65245,65246,65247,65248],1605:[65249,65250,65251,65252],1606:[65253,65254,65255,65256],1607:[65257,65258,65259,65260],1608:[65261,65262,65261],1609:[65263,65264,64488,64489],1610:[65265,65266,65267,65268],1649:[64336,64337],1655:[64477],1657:[64358,64359,64360,64361],1658:[64350,64351,64352,64353],1659:[64338,64339,64340,64341],1662:[64342,64343,64344,64345],1663:[64354,64355,64356,64357],1664:[64346,64347,64348,64349],1667:[64374,64375,64376,64377],1668:[64370,64371,64372,64373],1670:[64378,64379,64380,64381],1671:[64382,64383,64384,64385],1672:[64392,64393],1676:[64388,64389],1677:[64386,64387],1678:[64390,64391],1681:[64396,64397],1688:[64394,64395,64394],1700:[64362,64363,64364,64365],1702:[64366,64367,64368,64369],1705:[64398,64399,64400,64401],1709:[64467,64468,64469,64470],1711:[64402,64403,64404,64405],1713:[64410,64411,64412,64413],1715:[64406,64407,64408,64409],1722:[64414,64415],1723:[64416,64417,64418,64419],1726:[64426,64427,64428,64429],1728:[64420,64421],1729:[64422,64423,64424,64425],1733:[64480,64481],1734:[64473,64474],1735:[64471,64472],1736:[64475,64476],1737:[64482,64483],1739:[64478,64479],1740:[64508,64509,64510,64511],1744:[64484,64485,64486,64487],1746:[64430,64431],1747:[64432,64433]},f={1570:[65269,65270,65269,65270],1571:[65271,65272,65271,65272],1573:[65273,65274,65273,65274],1575:[65275,65276,65275,65276]},d={1570:[65153,65154,65153,65154],1571:[65155,65156,65155,65156],1573:[65159,65160,65159,65160],1575:[65165,65166,65165,65166]},p={1612:64606,1613:64607,1614:64608,1615:64609,1616:64610},e=[1570,1571,1573,1575],n=[1569,1570,1571,1572,1573,1575,1577,1583,1584,1585,1586,1608,1688],o=0,s=1,h=2,c=3;function g(t){return void 0!==t&&void 0!==u[t.charCodeAt(0)]}function l(t){return void 0!==t&&0<=n.indexOf(t.charCodeAt(0))}function m(t){return void 0!==t&&0<=e.indexOf(t.charCodeAt(0))}function w(t){return g(t)&&2<=u[t.charCodeAt(0)].length}function y(t,e,n,r){return g(t)?(r=r||{},u=Object.assign(u,r),!w(t)||!g(e)&&!g(n)||!g(n)&&l(e)||l(t)&&!g(e)||l(t)&&m(e)||l(t)&&l(e)?(u=Object.assign(u,d),o):g(i=t)&&4==u[i.charCodeAt(0)].length&&g(e)&&!l(e)&&g(n)&&w(n)?(u=Object.assign(u,d),c):l(t)||!g(n)?(u=Object.assign(u,d),s):(u=Object.assign(u,d),h)):-1;var i}var v=t.processArabic=function(t,e){t=t||"",e=e||!1;var n,r,i,o="",a=0,s=0,h="",c="",l="";for(a=0;a<t.length;a+=1)h=t[a],c=t[a-1],l=t[a+1],g(h)?void 0!==c&&1604===c.charCodeAt(0)&&m(h)?(s=y(h,t[a-2],t[a+1],f),n=String.fromCharCode(f[h.charCodeAt(0)][s]),o=o.substr(0,o.length-1)+n):void 0!==c&&1617===c.charCodeAt(0)&&(void 0!==(r=h)&&void 0!==p[r.charCodeAt(0)])?(s=y(h,t[a-2],t[a+1],d),n=String.fromCharCode(p[h.charCodeAt(0)][s]),o=o.substr(0,o.length-1)+n):(s=y(h,c,l,d),o+=String.fromCharCode(u[h.charCodeAt(0)][s])):o+=e?{"(":")",")":"("}[i=h]||i:h;return e?o.split("").reverse().join(""):o};t.events.push(["preProcessText",function(t){var e=t.text,n=(t.x,t.y,t.options||{}),r=(t.mutex,n.lang),i=[];if(0<=a.indexOf(r)){if("[object Array]"===Object.prototype.toString.call(e)){var o=0;for(i=[],o=0;o<e.length;o+=1)"[object Array]"===Object.prototype.toString.call(e[o])?i.push([v(e[o][0],!0),e[o][1],e[o][2]]):i.push([v(e[o],!0)]);t.text=i}else t.text=v(e,!0);void 0===n.charSpace&&(t.options.charSpace=0),!0===n.R2L&&(t.options.R2L=!1)}}])}($.API),$.API.autoPrint=function(t){var e;switch((t=t||{}).variant=t.variant||"non-conform",t.variant){case"javascript":this.addJS("print({});");break;case"non-conform":default:this.internal.events.subscribe("postPutResources",function(){e=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /Named"),this.internal.out("/Type /Action"),this.internal.out("/N /Print"),this.internal.out(">>"),this.internal.out("endobj")}),this.internal.events.subscribe("putCatalog",function(){this.internal.out("/OpenAction "+e+" 0 R")})}return this},(
/**
   * jsPDF Canvas PlugIn
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
e=$.API).events.push(["initialized",function(){this.canvas.pdf=this}]),e.canvas={getContext:function(t){return(this.pdf.context2d._canvas=this).pdf.context2d},childNodes:[]},Object.defineProperty(e.canvas,"width",{get:function(){return this._width},set:function(t){this._width=t,this.getContext("2d").pageWrapX=t+1}}),Object.defineProperty(e.canvas,"height",{get:function(){return this._height},set:function(t){this._height=t,this.getContext("2d").pageWrapY=t+1}}),
/** ====================================================================
   * jsPDF Cell plugin
   * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
   *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Hall, james@parall.ax
   *               2014 Diego Casorran, https://github.com/diegocr
   *
   * 
   * ====================================================================
   */
I=$.API,C={x:void 0,y:void 0,w:void 0,h:void 0,ln:void 0},T=1,d=function(t,e,n,r,i){C={x:t,y:e,w:n,h:r,ln:i}},p=function(){return C},F={left:0,top:0,bottom:0},I.setHeaderFunction=function(t){h=t},I.getTextDimensions=function(e){i=this.internal.getFont().fontName,o=this.table_font_size||this.internal.getFontSize(),a=this.internal.getFont().fontStyle;var t,n,r=19.049976/25.4;(n=document.createElement("font")).id="jsPDFCell";try{n.style.fontStyle=a}catch(t){n.style.fontWeight=a}n.style.fontSize=o+"pt",n.style.fontFamily=i;try{n.textContent=e}catch(t){n.innerText=e}return document.body.appendChild(n),t={w:(n.offsetWidth+1)*r,h:(n.offsetHeight+1)*r},document.body.removeChild(n),t},I.cellAddPage=function(){var t=this.margins||F;this.addPage(),d(t.left,t.top,void 0,void 0),T+=1},I.cellInitialize=function(){C={x:void 0,y:void 0,w:void 0,h:void 0,ln:void 0},T=1},I.cell=function(t,e,n,r,i,o,a){var s=p(),h=!1;if(void 0!==s.ln)if(s.ln===o)t=s.x+s.w,e=s.y;else{var c=this.margins||F;s.y+s.h+r+13>=this.internal.pageSize.getHeight()-c.bottom&&(this.cellAddPage(),h=!0,this.printHeaders&&this.tableHeaderRow&&this.printHeaderRow(o,!0)),e=p().y+p().h,h&&(e=23)}if(void 0!==i[0])if(this.printingHeaderRow?this.rect(t,e,n,r,"FD"):this.rect(t,e,n,r),"right"===a){i instanceof Array||(i=[i]);for(var l=0;l<i.length;l++){var u=i[l],f=this.getStringUnitWidth(u)*this.internal.getFontSize();this.text(u,t+n-f-3,e+this.internal.getLineHeight()*(l+1))}}else this.text(i,t+3,e+this.internal.getLineHeight());return d(t,e,n,r,o),this},I.arrayMax=function(t,e){var n,r,i,o=t[0];for(n=0,r=t.length;n<r;n+=1)i=t[n],e?-1===e(o,i)&&(o=i):o<i&&(o=i);return o},I.table=function(t,e,n,r,i){if(!n)throw"No data for PDF table";var o,a,s,h,c,l,u,f,d,p,g=[],m=[],w={},y={},v=[],b=[],x=!1,S=!0,k=12,_=F;if(_.width=this.internal.pageSize.getWidth(),i&&(!0===i.autoSize&&(x=!0),!1===i.printHeaders&&(S=!1),i.fontSize&&(k=i.fontSize),i.css&&void 0!==i.css["font-size"]&&(k=16*i.css["font-size"]),i.margins&&(_=i.margins)),this.lnMod=0,C={x:void 0,y:void 0,w:void 0,h:void 0,ln:void 0},T=1,this.printHeaders=S,this.margins=_,this.setFontSize(k),this.table_font_size=k,null==r)g=Object.keys(n[0]);else if(r[0]&&"string"!=typeof r[0])for(a=0,s=r.length;a<s;a+=1)o=r[a],g.push(o.name),m.push(o.prompt),y[o.name]=o.width*(19.049976/25.4);else g=r;if(x)for(p=function(t){return t[o]},a=0,s=g.length;a<s;a+=1){for(w[o=g[a]]=n.map(p),v.push(this.getTextDimensions(m[a]||o).w),u=0,h=(l=w[o]).length;u<h;u+=1)c=l[u],v.push(this.getTextDimensions(c).w);y[o]=I.arrayMax(v),v=[]}if(S){var A=this.calculateLineHeight(g,y,m.length?m:g);for(a=0,s=g.length;a<s;a+=1)o=g[a],b.push([t,e,y[o],A,String(m.length?m[a]:o)]);this.setTableHeaderRow(b),this.printHeaderRow(1,!1)}for(a=0,s=n.length;a<s;a+=1)for(f=n[a],A=this.calculateLineHeight(g,y,f),u=0,d=g.length;u<d;u+=1)o=g[u],this.cell(t,e,y[o],A,f[o],a+2,o.align);return this.lastCellPos=C,this.table_x=t,this.table_y=e,this},I.calculateLineHeight=function(t,e,n){for(var r,i=0,o=0;o<t.length;o++){n[r=t[o]]=this.splitTextToSize(String(n[r]),e[r]-3);var a=this.internal.getLineHeight()*n[r].length+3;i<a&&(i=a)}return i},I.setTableHeaderRow=function(t){this.tableHeaderRow=t},I.printHeaderRow=function(t,e){if(!this.tableHeaderRow)throw"Property tableHeaderRow does not exist.";var n,r,i,o;if(this.printingHeaderRow=!0,void 0!==h){var a=h(this,T);d(a[0],a[1],a[2],a[3],-1)}this.setFontStyle("bold");var s=[];for(i=0,o=this.tableHeaderRow.length;i<o;i+=1)this.setFillColor(200,200,200),n=this.tableHeaderRow[i],e&&(this.margins.top=13,n[1]=this.margins&&this.margins.top||0,s.push(n)),r=[].concat(n),this.cell.apply(this,r.concat(t));0<s.length&&this.setTableHeaderRow(s),this.setFontStyle("normal"),this.printingHeaderRow=!1},
/**
   * jsPDF Context2D PlugIn Copyright (c) 2014 Steven Spungin (TwelveTone LLC) steven@twelvetone.tv
   *
   * Licensed under the MIT License. http://opensource.org/licenses/mit-license
   */
function(t){t.events.push(["initialized",function(){((this.context2d.pdf=this).context2d.internal.pdf=this).context2d.ctx=new e,this.context2d.ctxStack=[],this.context2d.path=[]}]),t.context2d={pageWrapXEnabled:!1,pageWrapYEnabled:!1,pageWrapX:9999999,pageWrapY:9999999,ctx:new e,f2:function(t){return t.toFixed(2)},fillRect:function(t,e,n,r){if(!this._isFillTransparent()){t=this._wrapX(t),e=this._wrapY(e);var i=this._matrix_map_rect(this.ctx._transform,{x:t,y:e,w:n,h:r});this.pdf.rect(i.x,i.y,i.w,i.h,"f")}},strokeRect:function(t,e,n,r){if(!this._isStrokeTransparent()){t=this._wrapX(t),e=this._wrapY(e);var i=this._matrix_map_rect(this.ctx._transform,{x:t,y:e,w:n,h:r});this.pdf.rect(i.x,i.y,i.w,i.h,"s")}},clearRect:function(t,e,n,r){if(!this.ctx.ignoreClearRect){t=this._wrapX(t),e=this._wrapY(e);var i=this._matrix_map_rect(this.ctx._transform,{x:t,y:e,w:n,h:r});this.save(),this.setFillStyle("#ffffff"),this.pdf.rect(i.x,i.y,i.w,i.h,"f"),this.restore()}},save:function(){this.ctx._fontSize=this.pdf.internal.getFontSize();var t=new e;t.copy(this.ctx),this.ctxStack.push(this.ctx),this.ctx=t},restore:function(){this.ctx=this.ctxStack.pop(),this.setFillStyle(this.ctx.fillStyle),this.setStrokeStyle(this.ctx.strokeStyle),this.setFont(this.ctx.font),this.pdf.setFontSize(this.ctx._fontSize),this.setLineCap(this.ctx.lineCap),this.setLineWidth(this.ctx.lineWidth),this.setLineJoin(this.ctx.lineJoin)},rect:function(t,e,n,r){this.moveTo(t,e),this.lineTo(t+n,e),this.lineTo(t+n,e+r),this.lineTo(t,e+r),this.lineTo(t,e),this.closePath()},beginPath:function(){this.path=[]},closePath:function(){this.path.push({type:"close"})},_getRGBA:function(t){var e,n,r,i,o=new RGBColor(t);if(!t)return{r:0,g:0,b:0,a:0,style:t};if(this.internal.rxTransparent.test(t))i=r=n=e=0;else{var a=this.internal.rxRgb.exec(t);null!=a?(e=parseInt(a[1]),n=parseInt(a[2]),r=parseInt(a[3]),i=1):null!=(a=this.internal.rxRgba.exec(t))?(e=parseInt(a[1]),n=parseInt(a[2]),r=parseInt(a[3]),i=parseFloat(a[4])):(i=1,"#"!=t.charAt(0)&&(t=o.ok?o.toHex():"#000000"),4===t.length?(e=t.substring(1,2),e+=e,n=t.substring(2,3),n+=n,r=t.substring(3,4),r+=r):(e=t.substring(1,3),n=t.substring(3,5),r=t.substring(5,7)),e=parseInt(e,16),n=parseInt(n,16),r=parseInt(r,16))}return{r:e,g:n,b:r,a:i,style:t}},setFillStyle:function(t){var e=this._getRGBA(t);this.ctx.fillStyle=t,this.ctx._isFillTransparent=0===e.a,this.ctx._fillOpacity=e.a,this.pdf.setFillColor(e.r,e.g,e.b,{a:e.a}),this.pdf.setTextColor(e.r,e.g,e.b,{a:e.a})},setStrokeStyle:function(t){var e=this._getRGBA(t);this.ctx.strokeStyle=e.style,this.ctx._isStrokeTransparent=0===e.a,this.ctx._strokeOpacity=e.a,0===e.a?this.pdf.setDrawColor(255,255,255):(e.a,this.pdf.setDrawColor(e.r,e.g,e.b))},fillText:function(t,e,n,r){if(!this._isFillTransparent()){e=this._wrapX(e),n=this._wrapY(n);var i=this._matrix_map_point(this.ctx._transform,[e,n]);e=i[0],n=i[1];var o=57.2958*this._matrix_rotation(this.ctx._transform);if(0<this.ctx._clip_path.length){var a;(a=window.outIntercept?"group"===window.outIntercept.type?window.outIntercept.stream:window.outIntercept:this.internal.getCurrentPage()).push("q");var s=this.path;this.path=this.ctx._clip_path,this.ctx._clip_path=[],this._fill(null,!0),this.ctx._clip_path=this.path,this.path=s}var h=1;try{h=this._matrix_decompose(this._getTransform()).scale[0]}catch(t){console.warn(t)}if(h<.01)this.pdf.text(t,e,this._getBaseline(n),null,o);else{var c=this.pdf.internal.getFontSize();this.pdf.setFontSize(c*h),this.pdf.text(t,e,this._getBaseline(n),null,o),this.pdf.setFontSize(c)}0<this.ctx._clip_path.length&&a.push("Q")}},strokeText:function(t,e,n,r){if(!this._isStrokeTransparent()){e=this._wrapX(e),n=this._wrapY(n);var i=this._matrix_map_point(this.ctx._transform,[e,n]);e=i[0],n=i[1];var o=57.2958*this._matrix_rotation(this.ctx._transform);if(0<this.ctx._clip_path.length){var a;(a=window.outIntercept?"group"===window.outIntercept.type?window.outIntercept.stream:window.outIntercept:this.internal.getCurrentPage()).push("q");var s=this.path;this.path=this.ctx._clip_path,this.ctx._clip_path=[],this._fill(null,!0),this.ctx._clip_path=this.path,this.path=s}var h=1;try{h=this._matrix_decompose(this._getTransform()).scale[0]}catch(t){console.warn(t)}if(1===h)this.pdf.text(t,e,this._getBaseline(n),{stroke:!0},o);else{var c=this.pdf.internal.getFontSize();this.pdf.setFontSize(c*h),this.pdf.text(t,e,this._getBaseline(n),{stroke:!0},o),this.pdf.setFontSize(c)}0<this.ctx._clip_path.length&&a.push("Q")}},setFont:function(t){if(this.ctx.font=t,null!=(c=/\s*(\w+)\s+(\w+)\s+(\w+)\s+([\d\.]+)(px|pt|em)\s+(.*)?/.exec(t))){var e=c[1],n=(c[2],c[3]),r=c[4],i=c[5],o=c[6];r="px"===i?Math.floor(parseFloat(r)):"em"===i?Math.floor(parseFloat(r)*this.pdf.getFontSize()):Math.floor(parseFloat(r)),this.pdf.setFontSize(r),"bold"===n||"700"===n?this.pdf.setFontStyle("bold"):"italic"===e?this.pdf.setFontStyle("italic"):this.pdf.setFontStyle("normal"),l="bold"===n||"700"===n?"italic"===e?"bolditalic":"bold":"italic"===e?"italic":"normal";for(var a=o.toLowerCase().split(/\s*,\s*/),s="Times",h=0;h<a.length;h++){if(void 0!==this.pdf.internal.getFont(a[h],l,{noFallback:!0,disableWarning:!0})){s=a[h];break}if("bolditalic"===l&&void 0!==this.pdf.internal.getFont(a[h],"bold",{noFallback:!0,disableWarning:!0}))s=a[h],l="bold";else if(void 0!==this.pdf.internal.getFont(a[h],"normal",{noFallback:!0,disableWarning:!0})){s=a[h],l="normal";break}}this.pdf.setFont(s,l)}else{var c=/\s*(\d+)(pt|px|em)\s+([\w "]+)\s*([\w "]+)?/.exec(t);if(null!=c){var l,u=c[1],f=(c[2],c[3]);(l=c[4])||(l="normal"),u="em"===i?Math.floor(parseFloat(r)*this.pdf.getFontSize()):Math.floor(parseFloat(u)),this.pdf.setFontSize(u),this.pdf.setFont(f,l)}}},setTextBaseline:function(t){this.ctx.textBaseline=t},getTextBaseline:function(){return this.ctx.textBaseline},setTextAlign:function(t){this.ctx.textAlign=t},getTextAlign:function(){return this.ctx.textAlign},setLineWidth:function(t){this.ctx.lineWidth=t,this.pdf.setLineWidth(t)},setLineCap:function(t){this.ctx.lineCap=t,this.pdf.setLineCap(t)},setLineJoin:function(t){this.ctx.lineJoin=t,this.pdf.setLineJoin(t)},moveTo:function(t,e){t=this._wrapX(t),e=this._wrapY(e);var n=this._matrix_map_point(this.ctx._transform,[t,e]),r={type:"mt",x:t=n[0],y:e=n[1]};this.path.push(r)},_wrapX:function(t){return this.pageWrapXEnabled?t%this.pageWrapX:t},_wrapY:function(t){return this.pageWrapYEnabled?(this._gotoPage(this._page(t)),(t-this.lastBreak)%this.pageWrapY):t},transform:function(t,e,n,r,i,o){this.ctx._transform=this._matrix_multiply(this.ctx._transform,[t,e,n,r,i,o])},setTransform:function(t,e,n,r,i,o){this.ctx._transform=[t,e,n,r,i,o]},_getTransform:function(){return this.ctx._transform},lastBreak:0,pageBreaks:[],_page:function(t){if(this.pageWrapYEnabled){for(var e=this.lastBreak=0,n=0,r=0;r<this.pageBreaks.length;r++)if(t>=this.pageBreaks[r]){e++,0===this.lastBreak&&n++;var i=this.pageBreaks[r]-this.lastBreak;this.lastBreak=this.pageBreaks[r],n+=Math.floor(i/this.pageWrapY)}if(0===this.lastBreak)n+=Math.floor(t/this.pageWrapY)+1;return n+e}return this.pdf.internal.getCurrentPageInfo().pageNumber},_gotoPage:function(t){},lineTo:function(t,e){t=this._wrapX(t),e=this._wrapY(e);var n=this._matrix_map_point(this.ctx._transform,[t,e]),r={type:"lt",x:t=n[0],y:e=n[1]};this.path.push(r)},bezierCurveTo:function(t,e,n,r,i,o){var a;t=this._wrapX(t),e=this._wrapY(e),n=this._wrapX(n),r=this._wrapY(r),i=this._wrapX(i),o=this._wrapY(o),i=(a=this._matrix_map_point(this.ctx._transform,[i,o]))[0],o=a[1];var s={type:"bct",x1:t=(a=this._matrix_map_point(this.ctx._transform,[t,e]))[0],y1:e=a[1],x2:n=(a=this._matrix_map_point(this.ctx._transform,[n,r]))[0],y2:r=a[1],x:i,y:o};this.path.push(s)},quadraticCurveTo:function(t,e,n,r){var i;t=this._wrapX(t),e=this._wrapY(e),n=this._wrapX(n),r=this._wrapY(r),n=(i=this._matrix_map_point(this.ctx._transform,[n,r]))[0],r=i[1];var o={type:"qct",x1:t=(i=this._matrix_map_point(this.ctx._transform,[t,e]))[0],y1:e=i[1],x:n,y:r};this.path.push(o)},arc:function(t,e,n,r,i,o){if(t=this._wrapX(t),e=this._wrapY(e),!this._matrix_is_identity(this.ctx._transform)){var a=this._matrix_map_point(this.ctx._transform,[t,e]);t=a[0],e=a[1];var s=this._matrix_map_point(this.ctx._transform,[0,0]),h=this._matrix_map_point(this.ctx._transform,[0,n]);n=Math.sqrt(Math.pow(h[0]-s[0],2)+Math.pow(h[1]-s[1],2))}var c={type:"arc",x:t,y:e,radius:n,startAngle:r,endAngle:i,anticlockwise:o};this.path.push(c)},drawImage:function(t,e,n,r,i,o,a,s,h){void 0!==o&&(e=o,n=a,r=s,i=h),e=this._wrapX(e),n=this._wrapY(n);var c,l=this._matrix_map_rect(this.ctx._transform,{x:e,y:n,w:r,h:i}),u=(this._matrix_map_rect(this.ctx._transform,{x:o,y:a,w:s,h:h}),/data:image\/(\w+).*/i.exec(t));c=null!=u?u[1]:"png",this.pdf.addImage(t,c,l.x,l.y,l.w,l.h)},_matrix_multiply:function(t,e){var n=e[0],r=e[1],i=e[2],o=e[3],a=e[4],s=e[5],h=n*t[0]+r*t[2],c=i*t[0]+o*t[2],l=a*t[0]+s*t[2]+t[4];return r=n*t[1]+r*t[3],o=i*t[1]+o*t[3],s=a*t[1]+s*t[3]+t[5],[n=h,r,i=c,o,a=l,s]},_matrix_rotation:function(t){return Math.atan2(t[2],t[0])},_matrix_decompose:function(t){var e=t[0],n=t[1],r=t[2],i=t[3],o=Math.sqrt(e*e+n*n),a=(e/=o)*r+(n/=o)*i;r-=e*a,i-=n*a;var s=Math.sqrt(r*r+i*i);return a/=s,e*(i/=s)<n*(r/=s)&&(e=-e,n=-n,a=-a,o=-o),{scale:[o,0,0,s,0,0],translate:[1,0,0,1,t[4],t[5]],rotate:[e,n,-n,e,0,0],skew:[1,0,a,1,0,0]}},_matrix_map_point:function(t,e){var n=t[0],r=t[1],i=t[2],o=t[3],a=t[4],s=t[5],h=e[0],c=e[1];return[h*n+c*i+a,h*r+c*o+s]},_matrix_map_point_obj:function(t,e){var n=this._matrix_map_point(t,[e.x,e.y]);return{x:n[0],y:n[1]}},_matrix_map_rect:function(t,e){var n=this._matrix_map_point(t,[e.x,e.y]),r=this._matrix_map_point(t,[e.x+e.w,e.y+e.h]);return{x:n[0],y:n[1],w:r[0]-n[0],h:r[1]-n[1]}},_matrix_is_identity:function(t){return 1==t[0]&&(0==t[1]&&(0==t[2]&&(1==t[3]&&(0==t[4]&&0==t[5]))))},rotate:function(t){var e=[Math.cos(t),Math.sin(t),-Math.sin(t),Math.cos(t),0,0];this.ctx._transform=this._matrix_multiply(this.ctx._transform,e)},scale:function(t,e){var n=[t,0,0,e,0,0];this.ctx._transform=this._matrix_multiply(this.ctx._transform,n)},translate:function(t,e){var n=[1,0,0,1,t,e];this.ctx._transform=this._matrix_multiply(this.ctx._transform,n)},stroke:function(){if(0<this.ctx._clip_path.length){var t;(t=window.outIntercept?"group"===window.outIntercept.type?window.outIntercept.stream:window.outIntercept:this.internal.getCurrentPage()).push("q");var e=this.path;this.path=this.ctx._clip_path,this.ctx._clip_path=[],this._stroke(!0),this.ctx._clip_path=this.path,this.path=e,this._stroke(!1),t.push("Q")}else this._stroke(!1)},_stroke:function(t){if(t||!this._isStrokeTransparent()){for(var e=[],n=this.path,r=0;r<n.length;r++){var i=n[r];switch(i.type){case"mt":e.push({start:i,deltas:[],abs:[]});break;case"lt":var o=[i.x-n[r-1].x,i.y-n[r-1].y];e[e.length-1].deltas.push(o),e[e.length-1].abs.push(i);break;case"bct":o=[i.x1-n[r-1].x,i.y1-n[r-1].y,i.x2-n[r-1].x,i.y2-n[r-1].y,i.x-n[r-1].x,i.y-n[r-1].y];e[e.length-1].deltas.push(o);break;case"qct":var a=n[r-1].x+2/3*(i.x1-n[r-1].x),s=n[r-1].y+2/3*(i.y1-n[r-1].y),h=i.x+2/3*(i.x1-i.x),c=i.y+2/3*(i.y1-i.y),l=i.x,u=i.y;o=[a-n[r-1].x,s-n[r-1].y,h-n[r-1].x,c-n[r-1].y,l-n[r-1].x,u-n[r-1].y];e[e.length-1].deltas.push(o);break;case"arc":0==e.length&&e.push({start:{x:0,y:0},deltas:[],abs:[]}),e[e.length-1].arc=!0,Array.isArray(e[e.length-1].abs)&&e[e.length-1].abs.push(i)}}for(r=0;r<e.length;r++){var f;if(f=r==e.length-1?"s":null,e[r].arc)for(var d=e[r].abs,p=0;p<d.length;p++){var g=d[p],m=360*g.startAngle/(2*Math.PI),w=360*g.endAngle/(2*Math.PI),y=g.x,v=g.y;this.internal.arc2(this,y,v,g.radius,m,w,g.anticlockwise,f,t)}else{y=e[r].start.x,v=e[r].start.y;t?(this.pdf.lines(e[r].deltas,y,v,null,null),this.pdf.clip_fixed()):this.pdf.lines(e[r].deltas,y,v,null,f)}}}},_isFillTransparent:function(){return this.ctx._isFillTransparent||0==this.globalAlpha},_isStrokeTransparent:function(){return this.ctx._isStrokeTransparent||0==this.globalAlpha},fill:function(t){if(0<this.ctx._clip_path.length){var e;(e=window.outIntercept?"group"===window.outIntercept.type?window.outIntercept.stream:window.outIntercept:this.internal.getCurrentPage()).push("q");var n=this.path;this.path=this.ctx._clip_path,this.ctx._clip_path=[],this._fill(t,!0),this.ctx._clip_path=this.path,this.path=n,this._fill(t,!1),e.push("Q")}else this._fill(t,!1)},_fill:function(t,e){if(!this._isFillTransparent()){var n,r="function"==typeof this.pdf.internal.newObject2;n=window.outIntercept?"group"===window.outIntercept.type?window.outIntercept.stream:window.outIntercept:this.internal.getCurrentPage();var i=[],o=window.outIntercept;if(r)switch(this.ctx.globalCompositeOperation){case"normal":case"source-over":break;case"destination-in":case"destination-out":var a=this.pdf.internal.newStreamObject(),s=this.pdf.internal.newObject2();s.push("<</Type /ExtGState"),s.push("/SMask <</S /Alpha /G "+a.objId+" 0 R>>"),s.push(">>");var h="MASK"+s.objId;this.pdf.internal.addGraphicsState(h,s.objId);var c="/"+h+" gs";n.splice(0,0,"q"),n.splice(1,0,c),n.push("Q"),window.outIntercept=a;break;default:var l="/"+this.pdf.internal.blendModeMap[this.ctx.globalCompositeOperation.toUpperCase()];l&&this.pdf.internal.out(l+" gs")}var u=this.ctx.globalAlpha;if(this.ctx._fillOpacity<1&&(u=this.ctx._fillOpacity),r){var f=this.pdf.internal.newObject2();f.push("<</Type /ExtGState"),f.push("/CA "+u),f.push("/ca "+u),f.push(">>");h="GS_O_"+f.objId;this.pdf.internal.addGraphicsState(h,f.objId),this.pdf.internal.out("/"+h+" gs")}for(var d=this.path,p=0;p<d.length;p++){var g=d[p];switch(g.type){case"mt":i.push({start:g,deltas:[],abs:[]});break;case"lt":var m=[g.x-d[p-1].x,g.y-d[p-1].y];i[i.length-1].deltas.push(m),i[i.length-1].abs.push(g);break;case"bct":m=[g.x1-d[p-1].x,g.y1-d[p-1].y,g.x2-d[p-1].x,g.y2-d[p-1].y,g.x-d[p-1].x,g.y-d[p-1].y];i[i.length-1].deltas.push(m);break;case"qct":var w=d[p-1].x+2/3*(g.x1-d[p-1].x),y=d[p-1].y+2/3*(g.y1-d[p-1].y),v=g.x+2/3*(g.x1-g.x),b=g.y+2/3*(g.y1-g.y),x=g.x,S=g.y;m=[w-d[p-1].x,y-d[p-1].y,v-d[p-1].x,b-d[p-1].y,x-d[p-1].x,S-d[p-1].y];i[i.length-1].deltas.push(m);break;case"arc":0===i.length&&i.push({deltas:[],abs:[]}),i[i.length-1].arc=!0,Array.isArray(i[i.length-1].abs)&&i[i.length-1].abs.push(g);break;case"close":i.push({close:!0})}}for(p=0;p<i.length;p++){var k;if(p==i.length-1?(k="f","evenodd"===t&&(k+="*")):k=null,i[p].close)this.pdf.internal.out("h"),k&&this.pdf.internal.out(k);else if(i[p].arc){i[p].start&&this.internal.move2(this,i[p].start.x,i[p].start.y);for(var _=i[p].abs,A=0;A<_.length;A++){var I=_[A];if(void 0!==I.startAngle){var C=360*I.startAngle/(2*Math.PI),T=360*I.endAngle/(2*Math.PI),F=I.x,P=I.y;if(0===A&&this.internal.move2(this,F,P),this.internal.arc2(this,F,P,I.radius,C,T,I.anticlockwise,null,e),A===_.length-1&&i[p].start){F=i[p].start.x,P=i[p].start.y;this.internal.line2(E,F,P)}}else this.internal.line2(E,I.x,I.y)}}else{F=i[p].start.x,P=i[p].start.y;e?(this.pdf.lines(i[p].deltas,F,P,null,null),this.pdf.clip_fixed()):this.pdf.lines(i[p].deltas,F,P,null,k)}}window.outIntercept=o}},pushMask:function(){if("function"==typeof this.pdf.internal.newObject2){var t=this.pdf.internal.newStreamObject(),e=this.pdf.internal.newObject2();e.push("<</Type /ExtGState"),e.push("/SMask <</S /Alpha /G "+t.objId+" 0 R>>"),e.push(">>");var n="MASK"+e.objId;this.pdf.internal.addGraphicsState(n,e.objId);var r="/"+n+" gs";this.pdf.internal.out(r)}else console.log("jsPDF v2 not enabled")},clip:function(){if(0<this.ctx._clip_path.length)for(var t=0;t<this.path.length;t++)this.ctx._clip_path.push(this.path[t]);else this.ctx._clip_path=this.path;this.path=[]},measureText:function(n){var r=this.pdf;return{getWidth:function(){var t=r.internal.getFontSize(),e=r.getStringUnitWidth(n)*t/r.internal.scaleFactor;return e*=1.3333},get width(){return this.getWidth(n)}}},_getBaseline:function(t){var e=parseInt(this.pdf.internal.getFontSize()),n=.25*e;switch(this.ctx.textBaseline){case"bottom":return t-n;case"top":return t+e;case"hanging":return t+e-n;case"middle":return t+e/2-n;case"ideographic":return t;case"alphabetic":default:return t}}};var E=t.context2d;function e(){this._isStrokeTransparent=!1,this._strokeOpacity=1,this.strokeStyle="#000000",this.fillStyle="#000000",this._isFillTransparent=!1,this._fillOpacity=1,this.font="12pt times",this.textBaseline="alphabetic",this.textAlign="start",this.lineWidth=1,this.lineJoin="miter",this.lineCap="butt",this._transform=[1,0,0,1,0,0],this.globalCompositeOperation="normal",this.globalAlpha=1,this._clip_path=[],this.ignoreClearRect=!1,this.copy=function(t){this._isStrokeTransparent=t._isStrokeTransparent,this._strokeOpacity=t._strokeOpacity,this.strokeStyle=t.strokeStyle,this._isFillTransparent=t._isFillTransparent,this._fillOpacity=t._fillOpacity,this.fillStyle=t.fillStyle,this.font=t.font,this.lineWidth=t.lineWidth,this.lineJoin=t.lineJoin,this.lineCap=t.lineCap,this.textBaseline=t.textBaseline,this.textAlign=t.textAlign,this._fontSize=t._fontSize,this._transform=t._transform.slice(0),this.globalCompositeOperation=t.globalCompositeOperation,this.globalAlpha=t.globalAlpha,this._clip_path=t._clip_path.slice(0),this.ignoreClearRect=t.ignoreClearRect}}Object.defineProperty(E,"fillStyle",{set:function(t){this.setFillStyle(t)},get:function(){return this.ctx.fillStyle}}),Object.defineProperty(E,"strokeStyle",{set:function(t){this.setStrokeStyle(t)},get:function(){return this.ctx.strokeStyle}}),Object.defineProperty(E,"lineWidth",{set:function(t){this.setLineWidth(t)},get:function(){return this.ctx.lineWidth}}),Object.defineProperty(E,"lineCap",{set:function(t){this.setLineCap(t)},get:function(){return this.ctx.lineCap}}),Object.defineProperty(E,"lineJoin",{set:function(t){this.setLineJoin(t)},get:function(){return this.ctx.lineJoin}}),Object.defineProperty(E,"miterLimit",{set:function(t){this.ctx.miterLimit=t},get:function(){return this.ctx.miterLimit}}),Object.defineProperty(E,"textBaseline",{set:function(t){this.setTextBaseline(t)},get:function(){return this.getTextBaseline()}}),Object.defineProperty(E,"textAlign",{set:function(t){this.setTextAlign(t)},get:function(){return this.getTextAlign()}}),Object.defineProperty(E,"font",{set:function(t){this.setFont(t)},get:function(){return this.ctx.font}}),Object.defineProperty(E,"globalCompositeOperation",{set:function(t){this.ctx.globalCompositeOperation=t},get:function(){return this.ctx.globalCompositeOperation}}),Object.defineProperty(E,"globalAlpha",{set:function(t){this.ctx.globalAlpha=t},get:function(){return this.ctx.globalAlpha}}),Object.defineProperty(E,"canvas",{get:function(){return{parentNode:!1,style:!1}}}),Object.defineProperty(E,"ignoreClearRect",{set:function(t){this.ctx.ignoreClearRect=t},get:function(){return this.ctx.ignoreClearRect}}),E.internal={},E.internal.rxRgb=/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/,E.internal.rxRgba=/rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/,E.internal.rxTransparent=/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/,E.internal.arc=function(t,e,n,r,i,o,a,s){for(var h=this.pdf.internal.scaleFactor,c=this.pdf.internal.pageSize.getHeight(),l=this.pdf.internal.f2,u=i*(Math.PI/180),f=o*(Math.PI/180),d=this.createArc(r,u,f,a),p=0;p<d.length;p++){var g=d[p];0===p?this.pdf.internal.out([l((g.x1+e)*h),l((c-(g.y1+n))*h),"m",l((g.x2+e)*h),l((c-(g.y2+n))*h),l((g.x3+e)*h),l((c-(g.y3+n))*h),l((g.x4+e)*h),l((c-(g.y4+n))*h),"c"].join(" ")):this.pdf.internal.out([l((g.x2+e)*h),l((c-(g.y2+n))*h),l((g.x3+e)*h),l((c-(g.y3+n))*h),l((g.x4+e)*h),l((c-(g.y4+n))*h),"c"].join(" ")),t._lastPoint={x:e,y:n}}null!==s&&this.pdf.internal.out(this.pdf.internal.getStyle(s))},E.internal.arc2=function(t,e,n,r,i,o,a,s,h){var c=e,l=n;h?(this.arc(t,c,l,r,i,o,a,null),this.pdf.clip_fixed()):this.arc(t,c,l,r,i,o,a,s)},E.internal.move2=function(t,e,n){var r=this.pdf.internal.scaleFactor,i=this.pdf.internal.pageSize.getHeight(),o=this.pdf.internal.f2;this.pdf.internal.out([o(e*r),o((i-n)*r),"m"].join(" ")),t._lastPoint={x:e,y:n}},E.internal.line2=function(t,e,n){var r=this.pdf.internal.scaleFactor,i=this.pdf.internal.pageSize.getHeight(),o=this.pdf.internal.f2,a={x:e,y:n};this.pdf.internal.out([o(a.x*r),o((i-a.y)*r),"l"].join(" ")),t._lastPoint=a},E.internal.createArc=function(t,e,n,r){var i=2*Math.PI,o=Math.PI/2,a=e;for((a<i||i<a)&&(a%=i),a<0&&(a=i+a);n<e;)e-=i;var s=Math.abs(n-e);s<i&&r&&(s=i-s);for(var h=[],c=r?-1:1,l=a;1e-5<s;){var u=l+c*Math.min(s,o);h.push(this.createSmallArc(t,l,u)),s-=Math.abs(u-l),l=u}return h},E.internal.getCurrentPage=function(){return this.pdf.internal.pages[this.pdf.internal.getCurrentPageInfo().pageNumber]},E.internal.createSmallArc=function(t,e,n){var r=(n-e)/2,i=t*Math.cos(r),o=t*Math.sin(r),a=i,s=-o,h=a*a+s*s,c=h+a*i+s*o,l=4/3*(Math.sqrt(2*h*c)-c)/(a*o-s*i),u=a-l*s,f=s+l*a,d=u,p=-f,g=r+e,m=Math.cos(g),w=Math.sin(g);return{x1:t*Math.cos(e),y1:t*Math.sin(e),x2:u*m-f*w,y2:u*w+f*m,x3:d*m-p*w,y3:d*w+p*m,x4:t*Math.cos(n),y4:t*Math.sin(n)}}}($.API,"undefined"!=typeof self&&self||"undefined"!=typeof window&&window||"undefined"!=typeof global&&global||Function('return typeof this === "object" && this.content')()||Function("return this")()),
/** @preserve
   * jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser
   * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Daniel Husar, https://github.com/danielhusar
   *               2014 Wolfgang Gassler, https://github.com/woolfg
   *               2014 Steven Spungin, https://github.com/flamenco
   *
   * 
   * ====================================================================
   */
function(t){var T,F,i,a,s,h,c,l,P,v,f,u,d,n,E,q,p,g,m,O;T=function(){return function(t){return e.prototype=t,new e};function e(){}}(),v=function(t){var e,n,r,i,o,a,s;for(n=0,r=t.length,e=void 0,a=i=!1;!i&&n!==r;)(e=t[n]=t[n].trimLeft())&&(i=!0),n++;for(n=r-1;r&&!a&&-1!==n;)(e=t[n]=t[n].trimRight())&&(a=!0),n--;for(o=/\s+$/g,s=!0,n=0;n!==r;)"\u2028"!=t[n]&&(e=t[n].replace(/\s+/g," "),s&&(e=e.trimLeft()),e&&(s=o.test(e)),t[n]=e),n++;return t},u=function(t){var e,n,r;for(e=void 0,n=(r=t.split(",")).shift();!e&&n;)e=i[n.trim().toLowerCase()],n=r.shift();return e},d=function(t){var e;return-1<(t="auto"===t?"0px":t).indexOf("em")&&!isNaN(Number(t.replace("em","")))&&(t=18.719*Number(t.replace("em",""))+"px"),-1<t.indexOf("pt")&&!isNaN(Number(t.replace("pt","")))&&(t=1.333*Number(t.replace("pt",""))+"px"),void 0,16,(e=n[t])?e:void 0!==(e={"xx-small":9,"x-small":11,small:13,medium:16,large:19,"x-large":23,"xx-large":28,auto:0}[t])?n[t]=e/16:(e=parseFloat(t))?n[t]=e/16:(e=t.match(/([\d\.]+)(px)/),Array.isArray(e)&&3===e.length?n[t]=parseFloat(e[1])/16:n[t]=1)},P=function(t){var e,n,r,i,o;return o=t,i=document.defaultView&&document.defaultView.getComputedStyle?document.defaultView.getComputedStyle(o,null):o.currentStyle?o.currentStyle:o.style,n=void 0,(e={})["font-family"]=u((r=function(t){return t=t.replace(/-\D/g,function(t){return t.charAt(1).toUpperCase()}),i[t]})("font-family"))||"times",e["font-style"]=a[r("font-style")]||"normal",e["text-align"]=s[r("text-align")]||"left","bold"===(n=h[r("font-weight")]||"normal")&&("normal"===e["font-style"]?e["font-style"]=n:e["font-style"]=n+e["font-style"]),e["font-size"]=d(r("font-size"))||1,e["line-height"]=d(r("line-height"))||1,e.display="inline"===r("display")?"inline":"block",n="block"===e.display,e["margin-top"]=n&&d(r("margin-top"))||0,e["margin-bottom"]=n&&d(r("margin-bottom"))||0,e["padding-top"]=n&&d(r("padding-top"))||0,e["padding-bottom"]=n&&d(r("padding-bottom"))||0,e["margin-left"]=n&&d(r("margin-left"))||0,e["margin-right"]=n&&d(r("margin-right"))||0,e["padding-left"]=n&&d(r("padding-left"))||0,e["padding-right"]=n&&d(r("padding-right"))||0,e["page-break-before"]=r("page-break-before")||"auto",e.float=c[r("cssFloat")]||"none",e.clear=l[r("clear")]||"none",e.color=r("color"),e},E=function(t,e,n){var r,i,o,a,s;if(o=!1,a=i=void 0,r=n["#"+t.id])if("function"==typeof r)o=r(t,e);else for(i=0,a=r.length;!o&&i!==a;)o=r[i](t,e),i++;if(r=n[t.nodeName],!o&&r)if("function"==typeof r)o=r(t,e);else for(i=0,a=r.length;!o&&i!==a;)o=r[i](t,e),i++;for(s="string"==typeof t.className?t.className.split(" "):[],i=0;i<s.length;i++)if(r=n["."+s[i]],!o&&r)if("function"==typeof r)o=r(t,e);else for(i=0,a=r.length;!o&&i!==a;)o=r[i](t,e),i++;return o},O=function(t,e){var n,r,i,o,a,s,h,c,l;for(n=[],r=[],i=0,l=t.rows[0].cells.length,h=t.clientWidth;i<l;)c=t.rows[0].cells[i],r[i]={name:c.textContent.toLowerCase().replace(/\s+/g,""),prompt:c.textContent.replace(/\r?\n/g,""),width:c.clientWidth/h*e.pdf.internal.pageSize.getWidth()},i++;for(i=1;i<t.rows.length;){for(s=t.rows[i],a={},o=0;o<s.cells.length;)a[r[o].name]=s.cells[o].textContent.replace(/\r?\n/g,""),o++;n.push(a),i++}return{rows:n,headers:r}};var B={SCRIPT:1,STYLE:1,NOSCRIPT:1,OBJECT:1,EMBED:1,SELECT:1},R=1;F=function(t,i,e){var n,r,o,a,s,h,c,l;for(r=t.childNodes,n=void 0,(s="block"===(o=P(t)).display)&&(i.setBlockBoundary(),i.setBlockStyle(o)),a=0,h=r.length;a<h;){if("object"===(void 0===(n=r[a])?"undefined":vt(n))){if(i.executeWatchFunctions(n),1===n.nodeType&&"HEADER"===n.nodeName){var u=n,f=i.pdf.margins_doc.top;i.pdf.internal.events.subscribe("addPage",function(t){i.y=f,F(u,i,e),i.pdf.margins_doc.top=i.y+10,i.y+=10},!1)}if(8===n.nodeType&&"#comment"===n.nodeName)~n.textContent.indexOf("ADD_PAGE")&&(i.pdf.addPage(),i.y=i.pdf.margins_doc.top);else if(1!==n.nodeType||B[n.nodeName])if(3===n.nodeType){var d=n.nodeValue;if(n.nodeValue&&"LI"===n.parentNode.nodeName)if("OL"===n.parentNode.parentNode.nodeName)d=R+++". "+d;else{var p=o["font-size"],g=(3-.75*p)*i.pdf.internal.scaleFactor,m=.75*p*i.pdf.internal.scaleFactor,w=1.74*p/i.pdf.internal.scaleFactor;l=function(t,e){this.pdf.circle(t+g,e+m,w,"FD")}}16&n.ownerDocument.body.compareDocumentPosition(n)&&i.addText(d,o)}else"string"==typeof n&&i.addText(n,o);else{var y;if("IMG"===n.nodeName){var v=n.getAttribute("src");y=q[i.pdf.sHashCode(v)||v]}if(y){i.pdf.internal.pageSize.getHeight()-i.pdf.margins_doc.bottom<i.y+n.height&&i.y>i.pdf.margins_doc.top&&(i.pdf.addPage(),i.y=i.pdf.margins_doc.top,i.executeWatchFunctions(n));var b=P(n),x=i.x,S=12/i.pdf.internal.scaleFactor,k=(b["margin-left"]+b["padding-left"])*S,_=(b["margin-right"]+b["padding-right"])*S,A=(b["margin-top"]+b["padding-top"])*S,I=(b["margin-bottom"]+b["padding-bottom"])*S;void 0!==b.float&&"right"===b.float?x+=i.settings.width-n.width-_:x+=k,i.pdf.addImage(y,x,i.y+A,n.width,n.height),y=void 0,"right"===b.float||"left"===b.float?(i.watchFunctions.push(function(t,e,n,r){return i.y>=e?(i.x+=t,i.settings.width+=n,!0):!!(r&&1===r.nodeType&&!B[r.nodeName]&&i.x+r.width>i.pdf.margins_doc.left+i.pdf.margins_doc.width)&&(i.x+=t,i.y=e,i.settings.width+=n,!0)}.bind(this,"left"===b.float?-n.width-k-_:0,i.y+n.height+A+I,n.width)),i.watchFunctions.push(function(t,e,n){return!(i.y<t&&e===i.pdf.internal.getNumberOfPages())||1===n.nodeType&&"both"===P(n).clear&&(i.y=t,!0)}.bind(this,i.y+n.height,i.pdf.internal.getNumberOfPages())),i.settings.width-=n.width+k+_,"left"===b.float&&(i.x+=n.width+k+_)):i.y+=n.height+A+I}else if("TABLE"===n.nodeName)c=O(n,i),i.y+=10,i.pdf.table(i.x,i.y,c.rows,c.headers,{autoSize:!1,printHeaders:e.printHeaders,margins:i.pdf.margins_doc,css:P(n)}),i.y=i.pdf.lastCellPos.y+i.pdf.lastCellPos.h+20;else if("OL"===n.nodeName||"UL"===n.nodeName)R=1,E(n,i,e)||F(n,i,e),i.y+=10;else if("LI"===n.nodeName){var C=i.x;i.x+=20/i.pdf.internal.scaleFactor,i.y+=3,E(n,i,e)||F(n,i,e),i.x=C}else"BR"===n.nodeName?(i.y+=o["font-size"]*i.pdf.internal.scaleFactor,i.addText("\u2028",T(o))):E(n,i,e)||F(n,i,e)}}a++}if(e.outY=i.y,s)return i.setBlockBoundary(l)},q={},p=function(t,o,e,n){var a,r=t.getElementsByTagName("img"),i=r.length,s=0;function h(){o.pdf.internal.events.publish("imagesLoaded"),n(a)}function c(e,n,r){if(e){var i=new Image;a=++s,i.crossOrigin="",i.onerror=i.onload=function(){if(i.complete&&(0===i.src.indexOf("data:image/")&&(i.width=n||i.width||0,i.height=r||i.height||0),i.width+i.height)){var t=o.pdf.sHashCode(e)||e;q[t]=q[t]||i}--s||h()},i.src=e}}for(;i--;)c(r[i].getAttribute("src"),r[i].width,r[i].height);return s||h()},g=function(t,o,a){var s=t.getElementsByTagName("footer");if(0<s.length){s=s[0];var e=o.pdf.internal.write,n=o.y;o.pdf.internal.write=function(){},F(s,o,a);var h=Math.ceil(o.y-n)+5;o.y=n,o.pdf.internal.write=e,o.pdf.margins_doc.bottom+=h;for(var r=function(t){var e=void 0!==t?t.pageNumber:1,n=o.y;o.y=o.pdf.internal.pageSize.getHeight()-o.pdf.margins_doc.bottom,o.pdf.margins_doc.bottom-=h;for(var r=s.getElementsByTagName("span"),i=0;i<r.length;++i)-1<(" "+r[i].className+" ").replace(/[\n\t]/g," ").indexOf(" pageCounter ")&&(r[i].innerHTML=e),-1<(" "+r[i].className+" ").replace(/[\n\t]/g," ").indexOf(" totalPages ")&&(r[i].innerHTML="###jsPDFVarTotalPages###");F(s,o,a),o.pdf.margins_doc.bottom+=h,o.y=n},i=s.getElementsByTagName("span"),c=0;c<i.length;++c)-1<(" "+i[c].className+" ").replace(/[\n\t]/g," ").indexOf(" totalPages ")&&o.pdf.internal.events.subscribe("htmlRenderingFinished",o.pdf.putTotalPages.bind(o.pdf,"###jsPDFVarTotalPages###"),!0);o.pdf.internal.events.subscribe("addPage",r,!1),r(),B.FOOTER=1}},m=function(t,e,n,r,i,o){if(!e)return!1;var a,s,h,c;"string"==typeof e||e.parentNode||(e=""+e.innerHTML),"string"==typeof e&&(a=e.replace(/<\/?script[^>]*?>/gi,""),c="jsPDFhtmlText"+Date.now().toString()+(1e3*Math.random()).toFixed(0),(h=document.createElement("div")).style.cssText="position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;",h.innerHTML='<iframe style="height:1px;width:1px" name="'+c+'" />',document.body.appendChild(h),(s=window.frames[c]).document.open(),s.document.writeln(a),s.document.close(),e=s.document.body);var l,u=new f(t,n,r,i);return p.call(this,e,u,i.elementHandlers,function(t){g(e,u,i.elementHandlers),F(e,u,i.elementHandlers),u.pdf.internal.events.publish("htmlRenderingFinished"),l=u.dispose(),"function"==typeof o?o(l):t&&console.error("jsPDF Warning: rendering issues? provide a callback to fromHTML!")}),l||{x:u.x,y:u.y}},(f=function(t,e,n,r){return this.pdf=t,this.x=e,this.y=n,this.settings=r,this.watchFunctions=[],this.init(),this}).prototype.init=function(){return this.paragraph={text:[],style:[]},this.pdf.internal.write("q")},f.prototype.dispose=function(){return this.pdf.internal.write("Q"),{x:this.x,y:this.y,ready:!0}},f.prototype.executeWatchFunctions=function(t){var e=!1,n=[];if(0<this.watchFunctions.length){for(var r=0;r<this.watchFunctions.length;++r)!0===this.watchFunctions[r](t)?e=!0:n.push(this.watchFunctions[r]);this.watchFunctions=n}return e},f.prototype.splitFragmentsIntoLines=function(t,e){var n,r,i,o,a,s,h,c,l,u,f,d,p,g;for(12,u=this.pdf.internal.scaleFactor,o={},s=h=c=g=a=i=l=r=void 0,d=[f=[]],n=0,p=this.settings.width;t.length;)if(a=t.shift(),g=e.shift(),a)if((i=o[(r=g["font-family"])+(l=g["font-style"])])||(i=this.pdf.internal.getFont(r,l).metadata.Unicode,o[r+l]=i),c={widths:i.widths,kerning:i.kerning,fontSize:12*g["font-size"],textIndent:n},h=this.pdf.getStringUnitWidth(a,c)*c.fontSize/u,"\u2028"==a)f=[],d.push(f);else if(p<n+h){for(s=this.pdf.splitTextToSize(a,p,c),f.push([s.shift(),g]);s.length;)f=[[s.shift(),g]],d.push(f);n=this.pdf.getStringUnitWidth(f[0][0],c)*c.fontSize/u}else f.push([a,g]),n+=h;if(void 0!==g["text-align"]&&("center"===g["text-align"]||"right"===g["text-align"]||"justify"===g["text-align"]))for(var m=0;m<d.length;++m){var w=this.pdf.getStringUnitWidth(d[m][0][0],c)*c.fontSize/u;0<m&&(d[m][0][1]=T(d[m][0][1]));var y=p-w;if("right"===g["text-align"])d[m][0][1]["margin-left"]=y;else if("center"===g["text-align"])d[m][0][1]["margin-left"]=y/2;else if("justify"===g["text-align"]){var v=d[m][0][0].split(" ").length-1;d[m][0][1]["word-spacing"]=y/v,m===d.length-1&&(d[m][0][1]["word-spacing"]=0)}}return d},f.prototype.RenderTextFragment=function(t,e){var n,r;r=0,this.pdf.internal.pageSize.getHeight()-this.pdf.margins_doc.bottom<this.y+this.pdf.internal.getFontSize()&&(this.pdf.internal.write("ET","Q"),this.pdf.addPage(),this.y=this.pdf.margins_doc.top,this.pdf.internal.write("q","BT",this.getPdfColor(e.color),this.pdf.internal.getCoordinateString(this.x),this.pdf.internal.getVerticalCoordinateString(this.y),"Td"),r=Math.max(r,e["line-height"],e["font-size"]),this.pdf.internal.write(0,(-12*r).toFixed(2),"Td")),n=this.pdf.internal.getFont(e["font-family"],e["font-style"]);var i=this.getPdfColor(e.color);i!==this.lastTextColor&&(this.pdf.internal.write(i),this.lastTextColor=i),void 0!==e["word-spacing"]&&0<e["word-spacing"]&&this.pdf.internal.write(e["word-spacing"].toFixed(2),"Tw"),this.pdf.internal.write("/"+n.id,(12*e["font-size"]).toFixed(2),"Tf","("+this.pdf.internal.pdfEscape(t)+") Tj"),void 0!==e["word-spacing"]&&this.pdf.internal.write(0,"Tw")},f.prototype.getPdfColor=function(t){var e,n,r,i=new RGBColor(t),o=/rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+\s*)\)/.exec(t);if(null!=o?(e=parseInt(o[1]),n=parseInt(o[2]),r=parseInt(o[3])):("#"!=t.charAt(0)&&(t=i.ok?i.toHex():"#000000"),e=t.substring(1,3),e=parseInt(e,16),n=t.substring(3,5),n=parseInt(n,16),r=t.substring(5,7),r=parseInt(r,16)),"string"==typeof e&&/^#[0-9A-Fa-f]{6}$/.test(e)){var a=parseInt(e.substr(1),16);e=a>>16&255,n=a>>8&255,r=255&a}var s=this.f3;return 0===e&&0===n&&0===r||void 0===n?s(e/255)+" g":[s(e/255),s(n/255),s(r/255),"rg"].join(" ")},f.prototype.f3=function(t){return t.toFixed(3)},f.prototype.renderParagraph=function(t){var e,n,r,i,o,a,s,h,c,l,u,f,d;if(r=v(this.paragraph.text),f=this.paragraph.style,e=this.paragraph.blockstyle,this.paragraph.priorblockstyle||{},this.paragraph={text:[],style:[],blockstyle:{},priorblockstyle:e},r.join("").trim()){s=this.splitFragmentsIntoLines(r,f),h=a=void 0,n=12/this.pdf.internal.scaleFactor,this.priorMarginBottom=this.priorMarginBottom||0,u=(Math.max((e["margin-top"]||0)-this.priorMarginBottom,0)+(e["padding-top"]||0))*n,l=((e["margin-bottom"]||0)+(e["padding-bottom"]||0))*n,this.priorMarginBottom=e["margin-bottom"]||0,"always"===e["page-break-before"]&&(this.pdf.addPage(),this.y=0,u=((e["margin-top"]||0)+(e["padding-top"]||0))*n),c=this.pdf.internal.write,o=i=void 0,this.y+=u,c("q","BT 0 g",this.pdf.internal.getCoordinateString(this.x),this.pdf.internal.getVerticalCoordinateString(this.y),"Td");for(var p=0;s.length;){for(i=h=0,o=(a=s.shift()).length;i!==o;)a[i][0].trim()&&(h=Math.max(h,a[i][1]["line-height"],a[i][1]["font-size"]),d=7*a[i][1]["font-size"]),i++;var g=0,m=0;for(void 0!==a[0][1]["margin-left"]&&0<a[0][1]["margin-left"]&&(g=(m=this.pdf.internal.getCoordinateString(a[0][1]["margin-left"]))-p,p=m),c(g+Math.max(e["margin-left"]||0,0)*n,(-12*h).toFixed(2),"Td"),i=0,o=a.length;i!==o;)a[i][0]&&this.RenderTextFragment(a[i][0],a[i][1]),i++;if(this.y+=h*n,this.executeWatchFunctions(a[0][1])&&0<s.length){var w=[],y=[];s.forEach(function(t){for(var e=0,n=t.length;e!==n;)t[e][0]&&(w.push(t[e][0]+" "),y.push(t[e][1])),++e}),s=this.splitFragmentsIntoLines(v(w),y),c("ET","Q"),c("q","BT 0 g",this.pdf.internal.getCoordinateString(this.x),this.pdf.internal.getVerticalCoordinateString(this.y),"Td")}}return t&&"function"==typeof t&&t.call(this,this.x-9,this.y-d/2),c("ET","Q"),this.y+=l}},f.prototype.setBlockBoundary=function(t){return this.renderParagraph(t)},f.prototype.setBlockStyle=function(t){return this.paragraph.blockstyle=t},f.prototype.addText=function(t,e){return this.paragraph.text.push(t),this.paragraph.style.push(e)},i={helvetica:"helvetica","sans-serif":"helvetica","times new roman":"times",serif:"times",times:"times",monospace:"courier",courier:"courier"},h={100:"normal",200:"normal",300:"normal",400:"normal",500:"bold",600:"bold",700:"bold",800:"bold",900:"bold",normal:"normal",bold:"bold",bolder:"bold",lighter:"normal"},a={normal:"normal",italic:"italic",oblique:"italic"},s={left:"left",right:"right",center:"center",justify:"justify"},c={none:"none",right:"right",left:"left"},l={none:"none",both:"both"},n={normal:1},t.fromHTML=function(t,e,n,r,i,o){return this.margins_doc=o||{top:0,bottom:0},r||(r={}),r.elementHandlers||(r.elementHandlers={}),m(this,t,isNaN(e)?4:e,isNaN(n)?4:n,r,i)}}($.API),$.API.addJS=function(t){return s=t,this.internal.events.subscribe("postPutResources",function(t){n=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/Names [(EmbeddedJS) "+(n+1)+" 0 R]"),this.internal.out(">>"),this.internal.out("endobj"),r=this.internal.newObject(),this.internal.out("<<"),this.internal.out("/S /JavaScript"),this.internal.out("/JS ("+s+")"),this.internal.out(">>"),this.internal.out("endobj")}),this.internal.events.subscribe("putCatalog",function(){void 0!==n&&void 0!==r&&this.internal.out("/Names <</JavaScript "+n+" 0 R>>")}),this},(
/**
   * jsPDF Outline PlugIn
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
c=$.API).events.push(["postPutResources",function(){var t=this,e=/^(\d+) 0 obj$/;if(0<this.outline.root.children.length)for(var n=t.outline.render().split(/\r\n/),r=0;r<n.length;r++){var i=n[r],o=e.exec(i);if(null!=o){var a=o[1];t.internal.newObjectDeferredBegin(a)}t.internal.write(i)}if(this.outline.createNamedDestinations){var s=this.internal.pages.length,h=[];for(r=0;r<s;r++){var c=t.internal.newObject();h.push(c);var l=t.internal.getPageInfo(r+1);t.internal.write("<< /D["+l.objId+" 0 R /XYZ null null null]>> endobj")}var u=t.internal.newObject();for(t.internal.write("<< /Names [ "),r=0;r<h.length;r++)t.internal.write("(page_"+(r+1)+")"+h[r]+" 0 R");t.internal.write(" ] >>","endobj"),t.internal.newObject(),t.internal.write("<< /Dests "+u+" 0 R"),t.internal.write(">>","endobj")}}]),c.events.push(["putCatalog",function(){0<this.outline.root.children.length&&(this.internal.write("/Outlines",this.outline.makeRef(this.outline.root)),this.outline.createNamedDestinations&&this.internal.write("/Names "+namesOid+" 0 R"))}]),c.events.push(["initialized",function(){var o=this;o.outline={createNamedDestinations:!1,root:{children:[]}},o.outline.add=function(t,e,n){var r={title:e,options:n,children:[]};return null==t&&(t=this.root),t.children.push(r),r},o.outline.render=function(){return this.ctx={},this.ctx.val="",this.ctx.pdf=o,this.genIds_r(this.root),this.renderRoot(this.root),this.renderItems(this.root),this.ctx.val},o.outline.genIds_r=function(t){t.id=o.internal.newObjectDeferred();for(var e=0;e<t.children.length;e++)this.genIds_r(t.children[e])},o.outline.renderRoot=function(t){this.objStart(t),this.line("/Type /Outlines"),0<t.children.length&&(this.line("/First "+this.makeRef(t.children[0])),this.line("/Last "+this.makeRef(t.children[t.children.length-1]))),this.line("/Count "+this.count_r({count:0},t)),this.objEnd()},o.outline.renderItems=function(t){for(var e=0;e<t.children.length;e++){var n=t.children[e];this.objStart(n),this.line("/Title "+this.makeString(n.title)),this.line("/Parent "+this.makeRef(t)),0<e&&this.line("/Prev "+this.makeRef(t.children[e-1])),e<t.children.length-1&&this.line("/Next "+this.makeRef(t.children[e+1])),0<n.children.length&&(this.line("/First "+this.makeRef(n.children[0])),this.line("/Last "+this.makeRef(n.children[n.children.length-1])));var r=this.count=this.count_r({count:0},n);if(0<r&&this.line("/Count "+r),n.options&&n.options.pageNumber){var i=o.internal.getPageInfo(n.options.pageNumber);this.line("/Dest ["+i.objId+" 0 R /XYZ 0 "+this.ctx.pdf.internal.pageSize.getHeight()*this.ctx.pdf.internal.scaleFactor+" 0]")}this.objEnd()}for(e=0;e<t.children.length;e++)n=t.children[e],this.renderItems(n)},o.outline.line=function(t){this.ctx.val+=t+"\r\n"},o.outline.makeRef=function(t){return t.id+" 0 R"},o.outline.makeString=function(t){return"("+o.internal.pdfEscape(t)+")"},o.outline.objStart=function(t){this.ctx.val+="\r\n"+t.id+" 0 obj\r\n<<\r\n"},o.outline.objEnd=function(t){this.ctx.val+=">> \r\nendobj\r\n"},o.outline.count_r=function(t,e){for(var n=0;n<e.children.length;n++)t.count++,this.count_r(t,e.children[n]);return t.count}}]),
/**@preserve
   *  ====================================================================
   * jsPDF PNG PlugIn
   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
   *
   * 
   * ====================================================================
   */
P=$.API,E=function(){var t="function"==typeof Deflater;if(!t)throw new Error("requires deflate.js for compression");return t},q=function(t,e,n,r){var i=5,o=b;switch(r){case P.image_compression.FAST:i=3,o=v;break;case P.image_compression.MEDIUM:i=6,o=x;break;case P.image_compression.SLOW:i=9,o=S}t=w(t,e,n,o);var a=new Uint8Array(g(i)),s=m(t),h=new Deflater(i),c=h.append(t),l=h.flush(),u=a.length+c.length+l.length,f=new Uint8Array(u+4);return f.set(a),f.set(c,a.length),f.set(l,a.length+c.length),f[u++]=s>>>24&255,f[u++]=s>>>16&255,f[u++]=s>>>8&255,f[u++]=255&s,P.arrayBufferToBinaryString(f)},g=function(t,e){var n=Math.LOG2E*Math.log(32768)-8<<4|8,r=n<<8;return r|=Math.min(3,(e-1&255)>>1)<<6,r|=0,[n,255&(r+=31-r%31)]},m=function(t,e){for(var n,r=1,i=0,o=t.length,a=0;0<o;){for(o-=n=e<o?e:o;i+=r+=t[a++],--n;);r%=65521,i%=65521}return(i<<16|r)>>>0},w=function(t,e,n,r){for(var i,o,a,s=t.length/e,h=new Uint8Array(t.length+s),c=k(),l=0;l<s;l++){if(a=l*e,i=t.subarray(a,a+e),r)h.set(r(i,n,o),a+l);else{for(var u=0,f=c.length,d=[];u<f;u++)d[u]=c[u](i,n,o);var p=_(d.concat());h.set(d[p],a+l)}o=i}return h},l=function(t,e,n){var r=Array.apply([],t);return r.unshift(0),r},v=function(t,e,n){var r,i=[],o=0,a=t.length;for(i[0]=1;o<a;o++)r=t[o-e]||0,i[o+1]=t[o]-r+256&255;return i},b=function(t,e,n){var r,i=[],o=0,a=t.length;for(i[0]=2;o<a;o++)r=n&&n[o]||0,i[o+1]=t[o]-r+256&255;return i},x=function(t,e,n){var r,i,o=[],a=0,s=t.length;for(o[0]=3;a<s;a++)r=t[a-e]||0,i=n&&n[a]||0,o[a+1]=t[a]+256-(r+i>>>1)&255;return o},S=function(t,e,n){var r,i,o,a,s=[],h=0,c=t.length;for(s[0]=4;h<c;h++)r=t[h-e]||0,i=n&&n[h]||0,o=n&&n[h-e]||0,a=u(r,i,o),s[h+1]=t[h]-a+256&255;return s},u=function(t,e,n){var r=t+e-n,i=Math.abs(r-t),o=Math.abs(r-e),a=Math.abs(r-n);return i<=o&&i<=a?t:o<=a?e:n},k=function(){return[l,v,b,x,S]},_=function(t){for(var e,n,r,i=0,o=t.length;i<o;)((e=f(t[i].slice(1)))<n||!n)&&(n=e,r=i),i++;return r},f=function(t){for(var e=0,n=t.length,r=0;e<n;)r+=Math.abs(t[e++]);return r},P.processPNG=function(t,e,n,r,i){var o,a,s,h,c,l,u=this.color_spaces.DEVICE_RGB,f=this.decode.FLATE_DECODE,d=8;if(this.isArrayBuffer(t)&&(t=new Uint8Array(t)),this.isArrayBufferView(t)){if("function"!=typeof PNG||"function"!=typeof kt)throw new Error("PNG support requires png.js and zlib.js");if(t=(o=new PNG(t)).imgData,d=o.bits,u=o.colorSpace,h=o.colors,-1!==[4,6].indexOf(o.colorType)){if(8===o.bits)for(var p,g=(I=32==o.pixelBitlength?new Uint32Array(o.decodePixels().buffer):16==o.pixelBitlength?new Uint16Array(o.decodePixels().buffer):new Uint8Array(o.decodePixels().buffer)).length,m=new Uint8Array(g*o.colors),w=new Uint8Array(g),y=o.pixelBitlength-o.bits,v=0,b=0;v<g;v++){for(x=I[v],p=0;p<y;)m[b++]=x>>>p&255,p+=o.bits;w[v]=x>>>p&255}if(16===o.bits){g=(I=new Uint32Array(o.decodePixels().buffer)).length,m=new Uint8Array(g*(32/o.pixelBitlength)*o.colors),w=new Uint8Array(g*(32/o.pixelBitlength));for(var x,S=1<o.colors,k=b=v=0;v<g;)x=I[v++],m[b++]=x>>>0&255,S&&(m[b++]=x>>>16&255,x=I[v++],m[b++]=x>>>0&255),w[k++]=x>>>16&255;d=8}r!==P.image_compression.NONE&&E()?(t=q(m,o.width*o.colors,o.colors,r),l=q(w,o.width,1,r)):(t=m,l=w,f=null)}if(3===o.colorType&&(u=this.color_spaces.INDEXED,c=o.palette,o.transparency.indexed)){var _=o.transparency.indexed,A=0;for(v=0,g=_.length;v<g;++v)A+=_[v];if((A/=255)==g-1&&-1!==_.indexOf(0))s=[_.indexOf(0)];else if(A!==g){var I=o.decodePixels();for(w=new Uint8Array(I.length),v=0,g=I.length;v<g;v++)w[v]=_[I[v]];l=q(w,o.width,1)}}var C=function(t){var e;switch(t){case P.image_compression.FAST:e=11;break;case P.image_compression.MEDIUM:e=13;break;case P.image_compression.SLOW:e=14;break;default:e=12}return e}(r);return a=f===this.decode.FLATE_DECODE?"/Predictor "+C+" /Colors "+h+" /BitsPerComponent "+d+" /Columns "+o.width:"/Colors "+h+" /BitsPerComponent "+d+" /Columns "+o.width,(this.isArrayBuffer(t)||this.isArrayBufferView(t))&&(t=this.arrayBufferToBinaryString(t)),(l&&this.isArrayBuffer(l)||this.isArrayBufferView(l))&&(l=this.arrayBufferToBinaryString(l)),this.createImageInfo(t,o.width,o.height,u,d,f,e,n,a,s,c,l,C)}throw new Error("Unsupported PNG image data, try using JPEG instead.")},(
/**
   * jsPDF gif Support PlugIn
   * Copyright (c) 2017 Aras Abbasi 
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
A=$.API).processGIF89A=function(t,e,n,r,i){var o=new mt(t),a=o.width,s=o.height,h=[];o.decodeAndBlitFrameRGBA(0,h);var c={data:h,width:a,height:s},l=new yt(100).encode(c,100);return A.processJPEG.call(this,l,e,n,r)},A.processGIF87A=A.processGIF89A,(
/**
   * jsPDF bmp Support PlugIn
   * Copyright (c) 2018 Aras Abbasi 
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
O=$.API).processBMP=function(t,e,n,r,i){var o=new xt(t,!1),a=o.width,s=o.height,h={data:o.getData(),width:a,height:s},c=new yt(100).encode(h,100);return O.processJPEG.call(this,c,e,n,r)},$.API.setLanguage=function(t){return void 0===this.internal.languageSettings&&(this.internal.languageSettings={},this.internal.languageSettings.isSubscribed=!1),void 0!=={af:"Afrikaans",sq:"Albanian",ar:"Arabic (Standard)","ar-DZ":"Arabic (Algeria)","ar-BH":"Arabic (Bahrain)","ar-EG":"Arabic (Egypt)","ar-IQ":"Arabic (Iraq)","ar-JO":"Arabic (Jordan)","ar-KW":"Arabic (Kuwait)","ar-LB":"Arabic (Lebanon)","ar-LY":"Arabic (Libya)","ar-MA":"Arabic (Morocco)","ar-OM":"Arabic (Oman)","ar-QA":"Arabic (Qatar)","ar-SA":"Arabic (Saudi Arabia)","ar-SY":"Arabic (Syria)","ar-TN":"Arabic (Tunisia)","ar-AE":"Arabic (U.A.E.)","ar-YE":"Arabic (Yemen)",an:"Aragonese",hy:"Armenian",as:"Assamese",ast:"Asturian",az:"Azerbaijani",eu:"Basque",be:"Belarusian",bn:"Bengali",bs:"Bosnian",br:"Breton",bg:"Bulgarian",my:"Burmese",ca:"Catalan",ch:"Chamorro",ce:"Chechen",zh:"Chinese","zh-HK":"Chinese (Hong Kong)","zh-CN":"Chinese (PRC)","zh-SG":"Chinese (Singapore)","zh-TW":"Chinese (Taiwan)",cv:"Chuvash",co:"Corsican",cr:"Cree",hr:"Croatian",cs:"Czech",da:"Danish",nl:"Dutch (Standard)","nl-BE":"Dutch (Belgian)",en:"English","en-AU":"English (Australia)","en-BZ":"English (Belize)","en-CA":"English (Canada)","en-IE":"English (Ireland)","en-JM":"English (Jamaica)","en-NZ":"English (New Zealand)","en-PH":"English (Philippines)","en-ZA":"English (South Africa)","en-TT":"English (Trinidad & Tobago)","en-GB":"English (United Kingdom)","en-US":"English (United States)","en-ZW":"English (Zimbabwe)",eo:"Esperanto",et:"Estonian",fo:"Faeroese",fj:"Fijian",fi:"Finnish",fr:"French (Standard)","fr-BE":"French (Belgium)","fr-CA":"French (Canada)","fr-FR":"French (France)","fr-LU":"French (Luxembourg)","fr-MC":"French (Monaco)","fr-CH":"French (Switzerland)",fy:"Frisian",fur:"Friulian",gd:"Gaelic (Scots)","gd-IE":"Gaelic (Irish)",gl:"Galacian",ka:"Georgian",de:"German (Standard)","de-AT":"German (Austria)","de-DE":"German (Germany)","de-LI":"German (Liechtenstein)","de-LU":"German (Luxembourg)","de-CH":"German (Switzerland)",el:"Greek",gu:"Gujurati",ht:"Haitian",he:"Hebrew",hi:"Hindi",hu:"Hungarian",is:"Icelandic",id:"Indonesian",iu:"Inuktitut",ga:"Irish",it:"Italian (Standard)","it-CH":"Italian (Switzerland)",ja:"Japanese",kn:"Kannada",ks:"Kashmiri",kk:"Kazakh",km:"Khmer",ky:"Kirghiz",tlh:"Klingon",ko:"Korean","ko-KP":"Korean (North Korea)","ko-KR":"Korean (South Korea)",la:"Latin",lv:"Latvian",lt:"Lithuanian",lb:"Luxembourgish",mk:"FYRO Macedonian",ms:"Malay",ml:"Malayalam",mt:"Maltese",mi:"Maori",mr:"Marathi",mo:"Moldavian",nv:"Navajo",ng:"Ndonga",ne:"Nepali",no:"Norwegian",nb:"Norwegian (Bokmal)",nn:"Norwegian (Nynorsk)",oc:"Occitan",or:"Oriya",om:"Oromo",fa:"Persian","fa-IR":"Persian/Iran",pl:"Polish",pt:"Portuguese","pt-BR":"Portuguese (Brazil)",pa:"Punjabi","pa-IN":"Punjabi (India)","pa-PK":"Punjabi (Pakistan)",qu:"Quechua",rm:"Rhaeto-Romanic",ro:"Romanian","ro-MO":"Romanian (Moldavia)",ru:"Russian","ru-MO":"Russian (Moldavia)",sz:"Sami (Lappish)",sg:"Sango",sa:"Sanskrit",sc:"Sardinian",sd:"Sindhi",si:"Singhalese",sr:"Serbian",sk:"Slovak",sl:"Slovenian",so:"Somani",sb:"Sorbian",es:"Spanish","es-AR":"Spanish (Argentina)","es-BO":"Spanish (Bolivia)","es-CL":"Spanish (Chile)","es-CO":"Spanish (Colombia)","es-CR":"Spanish (Costa Rica)","es-DO":"Spanish (Dominican Republic)","es-EC":"Spanish (Ecuador)","es-SV":"Spanish (El Salvador)","es-GT":"Spanish (Guatemala)","es-HN":"Spanish (Honduras)","es-MX":"Spanish (Mexico)","es-NI":"Spanish (Nicaragua)","es-PA":"Spanish (Panama)","es-PY":"Spanish (Paraguay)","es-PE":"Spanish (Peru)","es-PR":"Spanish (Puerto Rico)","es-ES":"Spanish (Spain)","es-UY":"Spanish (Uruguay)","es-VE":"Spanish (Venezuela)",sx:"Sutu",sw:"Swahili",sv:"Swedish","sv-FI":"Swedish (Finland)","sv-SV":"Swedish (Sweden)",ta:"Tamil",tt:"Tatar",te:"Teluga",th:"Thai",tig:"Tigre",ts:"Tsonga",tn:"Tswana",tr:"Turkish",tk:"Turkmen",uk:"Ukrainian",hsb:"Upper Sorbian",ur:"Urdu",ve:"Venda",vi:"Vietnamese",vo:"Volapuk",wa:"Walloon",cy:"Welsh",xh:"Xhosa",ji:"Yiddish",zu:"Zulu"}[t]&&(this.internal.languageSettings.languageCode=t,!1===this.internal.languageSettings.isSubscribed&&(this.internal.events.subscribe("putCatalog",function(){this.internal.write("/Lang ("+this.internal.languageSettings.languageCode+")")}),this.internal.languageSettings.isSubscribed=!0)),this},
/** @preserve
   * jsPDF split_text_to_size plugin - MIT license.
   * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
   *               2014 Diego Casorran, https://github.com/diegocr
   */
B=$.API,R=B.getCharWidthsArray=function(t,e){var n,r,i,o=(e=e||{}).font||this.internal.getFont(),a=e.fontSize||this.internal.getFontSize(),s=e.charSpace||this.internal.getCharSpace(),h=e.widths?e.widths:o.metadata.Unicode.widths,c=h.fof?h.fof:1,l=e.kerning?e.kerning:o.metadata.Unicode.kerning,u=l.fof?l.fof:1,f=0,d=h[0]||c,p=[];for(n=0,r=t.length;n<r;n++)i=t.charCodeAt(n),"function"==typeof o.metadata.widthOfString?p.push((o.metadata.widthOfGlyph(o.metadata.characterToGlyph(i))+s*(1e3/a)||0)/1e3):p.push((h[i]||d)/c+(l[i]&&l[i][f]||0)/u),f=i;return p},j=B.getArraySum=function(t){for(var e=t.length,n=0;e;)n+=t[--e];return n},D=B.getStringUnitWidth=function(t,e){var n=(e=e||{}).fontSize||this.internal.getFontSize(),r=e.font||this.internal.getFont(),i=e.charSpace||this.internal.getCharSpace();return"function"==typeof r.metadata.widthOfString?r.metadata.widthOfString(t,n,i)/n:j(R.apply(this,arguments))},M=function(t,e,n,r){for(var i=[],o=0,a=t.length,s=0;o!==a&&s+e[o]<n;)s+=e[o],o++;i.push(t.slice(0,o));var h=o;for(s=0;o!==a;)s+e[o]>r&&(i.push(t.slice(h,o)),s=0,h=o),s+=e[o],o++;return h!==o&&i.push(t.slice(h,o)),i},U=function(t,e,n){n||(n={});var r,i,o,a,s,h,c=[],l=[c],u=n.textIndent||0,f=0,d=0,p=t.split(" "),g=R.apply(this,[" ",n])[0];if(h=-1===n.lineIndent?p[0].length+2:n.lineIndent||0){var m=Array(h).join(" "),w=[];p.map(function(t){1<(t=t.split(/\s*\n/)).length?w=w.concat(t.map(function(t,e){return(e&&t.length?"\n":"")+t})):w.push(t[0])}),p=w,h=D.apply(this,[m,n])}for(o=0,a=p.length;o<a;o++){var y=0;if(r=p[o],h&&"\n"==r[0]&&(r=r.substr(1),y=1),i=R.apply(this,[r,n]),e<u+f+(d=j(i))||y){if(e<d){for(s=M.apply(this,[r,i,e-(u+f),e]),c.push(s.shift()),c=[s.pop()];s.length;)l.push([s.shift()]);d=j(i.slice(r.length-(c[0]?c[0].length:0)))}else c=[r];l.push(c),u=d+h,f=g}else c.push(r),u+=f+d,f=g}if(h)var v=function(t,e){return(e?m:"")+t.join(" ")};else v=function(t){return t.join(" ")};return l.map(v)},B.splitTextToSize=function(t,e,n){var r,i=(n=n||{}).fontSize||this.internal.getFontSize(),o=function(t){var e={0:1},n={};if(t.widths&&t.kerning)return{widths:t.widths,kerning:t.kerning};var r=this.internal.getFont(t.fontName,t.fontStyle),i="Unicode";return r.metadata[i]?{widths:r.metadata[i].widths||e,kerning:r.metadata[i].kerning||n}:{font:r.metadata,fontSize:this.internal.getFontSize(),charSpace:this.internal.getCharSpace()}}.call(this,n);r=Array.isArray(t)?t:t.split(/\r?\n/);var a=1*this.internal.scaleFactor*e/i;o.textIndent=n.textIndent?1*n.textIndent*this.internal.scaleFactor/i:0,o.lineIndent=n.lineIndent;var s,h,c=[];for(s=0,h=r.length;s<h;s++)c=c.concat(U.apply(this,[r[s],a,o]));return c},
/** @preserve 
  jsPDF standard_fonts_metrics plugin
  Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
  MIT license.
  */
N=$.API,L={codePages:["WinAnsiEncoding"],WinAnsiEncoding:(z=function(t){for(var e="klmnopqrstuvwxyz",n={},r=0;r<e.length;r++)n[e[r]]="0123456789abcdef"[r];var i,o,a,s,h,c={},l=1,u=c,f=[],d="",p="",g=t.length-1;for(r=1;r!=g;)h=t[r],r+=1,"'"==h?o?(s=o.join(""),o=i):o=[]:o?o.push(h):"{"==h?(f.push([u,s]),u={},s=i):"}"==h?((a=f.pop())[0][a[1]]=u,s=i,u=a[0]):"-"==h?l=-1:s===i?n.hasOwnProperty(h)?(d+=n[h],s=parseInt(d,16)*l,l=1,d=""):d+=h:n.hasOwnProperty(h)?(p+=n[h],u[s]=parseInt(p,16)*l,l=1,s=i,p=""):p+=h;return c})("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")},H={Unicode:{Courier:L,"Courier-Bold":L,"Courier-BoldOblique":L,"Courier-Oblique":L,Helvetica:L,"Helvetica-Bold":L,"Helvetica-BoldOblique":L,"Helvetica-Oblique":L,"Times-Roman":L,"Times-Bold":L,"Times-BoldItalic":L,"Times-Italic":L}
/** 
    Resources:
    Font metrics data is reprocessed derivative of contents of
    "Font Metrics for PDF Core 14 Fonts" package, which exhibits the following copyright and license:
    
    Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated. All Rights Reserved.
    
    This file and the 14 PostScript(R) AFM files it accompanies may be used,
    copied, and distributed for any purpose and without charge, with or without
    modification, provided that all copyright notices are retained; that the AFM
    files are not distributed without this file; that all modifications to this
    file or any of the AFM files are prominently noted in the modified file(s);
    and that this paragraph is not modified. Adobe Systems has no responsibility
    or obligation to support the use of the AFM files.
    
    */},W={Unicode:{"Courier-Oblique":z("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-BoldItalic":z("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),"Helvetica-Bold":z("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),Courier:z("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-BoldOblique":z("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Bold":z("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),Symbol:z("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),Helvetica:z("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),"Helvetica-BoldOblique":z("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),ZapfDingbats:z("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),"Courier-Bold":z("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),"Times-Italic":z("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),"Times-Roman":z("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),"Helvetica-Oblique":z("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")}},N.events.push(["addFont",function(t){var e,n,r,i="Unicode";(e=W[i][t.postScriptName])&&((n=t.metadata[i]?t.metadata[i]:t.metadata[i]={}).widths=e.widths,n.kerning=e.kerning),(r=H[i][t.postScriptName])&&((n=t.metadata[i]?t.metadata[i]:t.metadata[i]={}).encoding=r).codePages&&r.codePages.length&&(t.encoding=r.codePages[0])}]),G=$,"undefined"!=typeof self&&self||"undefined"!=typeof global&&global||"undefined"!=typeof window&&window||Function("return this")(),G.API.events.push(["addFont",function(t){G.API.existsFileInVFS(t.postScriptName)?(t.metadata=G.API.TTFFont.open(t.postScriptName,t.fontName,G.API.getFileFromVFS(t.postScriptName),t.encoding),t.metadata.Unicode=t.metadata.Unicode||{encoding:{},kerning:{},widths:[]}):14<t.id.slice(1)&&console.error("Font does not exist in FileInVFS, import fonts or remove declaration doc.addFont('"+t.postScriptName+"').")}]),(
/** @preserve
  jsPDF SVG plugin
  Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
  */
V=$.API).addSvg=function(t,e,n,r,i){if(void 0===e||void 0===n)throw new Error("addSVG needs values for 'x' and 'y'");function o(t){for(var e=parseFloat(t[1]),n=parseFloat(t[2]),r=[],i=3,o=t.length;i<o;)"c"===t[i]?(r.push([parseFloat(t[i+1]),parseFloat(t[i+2]),parseFloat(t[i+3]),parseFloat(t[i+4]),parseFloat(t[i+5]),parseFloat(t[i+6])]),i+=7):"l"===t[i]?(r.push([parseFloat(t[i+1]),parseFloat(t[i+2])]),i+=3):i+=1;return[e,n,r]}var a,s,h,c,l,u,f,d,p=(c=document,d=c.createElement("iframe"),l=".jsPDF_sillysvg_iframe {display:none;position:absolute;}",(f=(u=c).createElement("style")).type="text/css",f.styleSheet?f.styleSheet.cssText=l:f.appendChild(u.createTextNode(l)),u.getElementsByTagName("head")[0].appendChild(f),d.name="childframe",d.setAttribute("width",0),d.setAttribute("height",0),d.setAttribute("frameborder","0"),d.setAttribute("scrolling","no"),d.setAttribute("seamless","seamless"),d.setAttribute("class","jsPDF_sillysvg_iframe"),c.body.appendChild(d),d),g=(a=t,(h=((s=p).contentWindow||s.contentDocument).document).write(a),h.close(),h.getElementsByTagName("svg")[0]),m=[1,1],w=parseFloat(g.getAttribute("width")),y=parseFloat(g.getAttribute("height"));w&&y&&(r&&i?m=[r/w,i/y]:r?m=[r/w,r/w]:i&&(m=[i/y,i/y]));var v,b,x,S,k=g.childNodes;for(v=0,b=k.length;v<b;v++)(x=k[v]).tagName&&"PATH"===x.tagName.toUpperCase()&&((S=o(x.getAttribute("d").split(" ")))[0]=S[0]*m[0]+e,S[1]=S[1]*m[1]+n,this.lines.call(this,S[2],S[0],S[1],m));return this},V.addSVG=V.addSvg,V.addSvgAsImage=function(t,e,n,r,i,o,a,s){if(isNaN(e)||isNaN(n))throw console.error("jsPDF.addSvgAsImage: Invalid coordinates",arguments),new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");if(isNaN(r)||isNaN(i))throw console.error("jsPDF.addSvgAsImage: Invalid measurements",arguments),new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");var h=document.createElement("canvas");h.width=r,h.height=i;var c=h.getContext("2d");return c.fillStyle="#fff",c.fillRect(0,0,h.width,h.height),canvg(h,t,{ignoreMouse:!0,ignoreAnimation:!0,ignoreDimensions:!0,ignoreClear:!0}),this.addImage(h.toDataURL("image/jpeg",1),e,n,r,i,a,s),this},$.API.putTotalPages=function(t){for(var e=new RegExp(t,"g"),n=1;n<=this.internal.getNumberOfPages();n++)for(var r=0;r<this.internal.pages[n].length;r++)this.internal.pages[n][r]=this.internal.pages[n][r].replace(e,this.internal.getNumberOfPages());return this},$.API.viewerPreferences=function(t,e){var n;t=t||{},e=e||!1;var r,i,o={HideToolbar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideMenubar:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},HideWindowUI:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},FitWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},CenterWindow:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.3},DisplayDocTitle:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.4},NonFullScreenPageMode:{defaultValue:"UseNone",value:"UseNone",type:"name",explicitSet:!1,valueSet:["UseNone","UseOutlines","UseThumbs","UseOC"],pdfVersion:1.3},Direction:{defaultValue:"L2R",value:"L2R",type:"name",explicitSet:!1,valueSet:["L2R","R2L"],pdfVersion:1.3},ViewArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},ViewClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintArea:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintClip:{defaultValue:"CropBox",value:"CropBox",type:"name",explicitSet:!1,valueSet:["MediaBox","CropBox","TrimBox","BleedBox","ArtBox"],pdfVersion:1.4},PrintScaling:{defaultValue:"AppDefault",value:"AppDefault",type:"name",explicitSet:!1,valueSet:["AppDefault","None"],pdfVersion:1.6},Duplex:{defaultValue:"",value:"none",type:"name",explicitSet:!1,valueSet:["Simplex","DuplexFlipShortEdge","DuplexFlipLongEdge","none"],pdfVersion:1.7},PickTrayByPDFSize:{defaultValue:!1,value:!1,type:"boolean",explicitSet:!1,valueSet:[!0,!1],pdfVersion:1.7},PrintPageRange:{defaultValue:"",value:"",type:"array",explicitSet:!1,valueSet:null,pdfVersion:1.7},NumCopies:{defaultValue:1,value:1,type:"integer",explicitSet:!1,valueSet:null,pdfVersion:1.7}},a=Object.keys(o),s=[],h=0,c=0,l=0,u=!0;function f(t,e){var n,r=!1;for(n=0;n<t.length;n+=1)t[n]===e&&(r=!0);return r}if(void 0===this.internal.viewerpreferences&&(this.internal.viewerpreferences={},this.internal.viewerpreferences.configuration=JSON.parse(JSON.stringify(o)),this.internal.viewerpreferences.isSubscribed=!1),n=this.internal.viewerpreferences.configuration,"reset"===t||!0===e){var d=a.length;for(l=0;l<d;l+=1)n[a[l]].value=n[a[l]].defaultValue,n[a[l]].explicitSet=!1}if("object"===(void 0===t?"undefined":vt(t)))for(r in t)if(i=t[r],f(a,r)&&void 0!==i){if("boolean"===n[r].type&&"boolean"==typeof i)n[r].value=i;else if("name"===n[r].type&&f(n[r].valueSet,i))n[r].value=i;else if("integer"===n[r].type&&Number.isInteger(i))n[r].value=i;else if("array"===n[r].type){for(h=0;h<i.length;h+=1)if(u=!0,1===i[h].length&&"number"==typeof i[h][0])s.push(String(i[h]));else if(1<i[h].length){for(c=0;c<i[h].length;c+=1)"number"!=typeof i[h][c]&&(u=!1);!0===u&&s.push(String(i[h].join("-")))}n[r].value=String(s)}else n[r].value=n[r].defaultValue;n[r].explicitSet=!0}return!1===this.internal.viewerpreferences.isSubscribed&&(this.internal.events.subscribe("putCatalog",function(){var t,e=[];for(t in n)!0===n[t].explicitSet&&("name"===n[t].type?e.push("/"+t+" /"+n[t].value):e.push("/"+t+" "+n[t].value));0!==e.length&&this.internal.write("/ViewerPreferences\n<<\n"+e.join("\n")+"\n>>")}),this.internal.viewerpreferences.isSubscribed=!0),this.internal.viewerpreferences.configuration=n,this},
/** ==================================================================== 
   * jsPDF XMP metadata plugin
   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
   * 
   * 
   * ====================================================================
   */
Y=$.API,K=J=X="",Y.addMetadata=function(t,e){return J=e||"http://jspdf.default.namespaceuri/",X=t,this.internal.events.subscribe("postPutResources",function(){if(X){var t='<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="'+J+'"><jspdf:metadata>',e=unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')),n=unescape(encodeURIComponent(t)),r=unescape(encodeURIComponent(X)),i=unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")),o=unescape(encodeURIComponent("</x:xmpmeta>")),a=n.length+r.length+i.length+e.length+o.length;K=this.internal.newObject(),this.internal.write("<< /Type /Metadata /Subtype /XML /Length "+a+" >>"),this.internal.write("stream"),this.internal.write(e+n+r+i+o),this.internal.write("endstream"),this.internal.write("endobj")}else K=""}),this.internal.events.subscribe("putCatalog",function(){K&&this.internal.write("/Metadata "+K+" 0 R")}),this},function(l,t){var e=l.API,m=[0];e.events.push(["putFont",function(t){!function(t,e,n){if(t.metadata instanceof l.API.TTFFont&&"Identity-H"===t.encoding){for(var r=t.metadata.Unicode.widths,i=t.metadata.subset.encode(m),o="",a=0;a<i.length;a++)o+=String.fromCharCode(i[a]);var s=n();e("<<"),e("/Length "+o.length),e("/Length1 "+o.length),e(">>"),e("stream"),e(o),e("endstream"),e("endobj");var h=n();e("<<"),e("/Type /FontDescriptor"),e("/FontName /"+t.fontName),e("/FontFile2 "+s+" 0 R"),e("/FontBBox "+l.API.PDFObject.convert(t.metadata.bbox)),e("/Flags "+t.metadata.flags),e("/StemV "+t.metadata.stemV),e("/ItalicAngle "+t.metadata.italicAngle),e("/Ascent "+t.metadata.ascender),e("/Descent "+t.metadata.decender),e("/CapHeight "+t.metadata.capHeight),e(">>"),e("endobj");var c=n();e("<<"),e("/Type /Font"),e("/BaseFont /"+t.fontName),e("/FontDescriptor "+h+" 0 R"),e("/W "+l.API.PDFObject.convert(r)),e("/CIDToGIDMap /Identity"),e("/DW 1000"),e("/Subtype /CIDFontType2"),e("/CIDSystemInfo"),e("<<"),e("/Supplement 0"),e("/Registry (Adobe)"),e("/Ordering ("+t.encoding+")"),e(">>"),e(">>"),e("endobj"),t.objectNumber=n(),e("<<"),e("/Type /Font"),e("/Subtype /Type0"),e("/BaseFont /"+t.fontName),e("/Encoding /"+t.encoding),e("/DescendantFonts ["+c+" 0 R]"),e(">>"),e("endobj"),t.isAlreadyPutted=!0}}(t.font,t.out,t.newObject)}]);e.events.push(["putFont",function(t){!function(t,e,n){if(t.metadata instanceof l.API.TTFFont&&"WinAnsiEncoding"===t.encoding){t.metadata.Unicode.widths;for(var r=t.metadata.rawData,i="",o=0;o<r.length;o++)i+=String.fromCharCode(r[o]);var a=n();e("<<"),e("/Length "+i.length),e("/Length1 "+i.length),e(">>"),e("stream"),e(i),e("endstream"),e("endobj");var s=n();for(e("<<"),e("/Descent "+t.metadata.decender),e("/CapHeight "+t.metadata.capHeight),e("/StemV "+t.metadata.stemV),e("/Type /FontDescriptor"),e("/FontFile2 "+a+" 0 R"),e("/Flags 96"),e("/FontBBox "+l.API.PDFObject.convert(t.metadata.bbox)),e("/FontName /"+t.fontName),e("/ItalicAngle "+t.metadata.italicAngle),e("/Ascent "+t.metadata.ascender),e(">>"),e("endobj"),t.objectNumber=n(),o=0;o<t.metadata.hmtx.widths.length;o++)t.metadata.hmtx.widths[o]=parseInt(t.metadata.hmtx.widths[o]*(1e3/t.metadata.head.unitsPerEm));e("<</Subtype/TrueType/Type/Font/BaseFont/"+t.fontName+"/FontDescriptor "+s+" 0 R/Encoding/"+t.encoding+" /FirstChar 29 /LastChar 255 /Widths "+l.API.PDFObject.convert(t.metadata.hmtx.widths)+">>"),e("endobj"),t.isAlreadyPutted=!0}}(t.font,t.out,t.newObject)}]);var c=function(t){var e,n,r=t.text||"",i=t.x,o=t.y,a=t.options||{},s=t.mutex||{},h=s.pdfEscape,c=s.activeFontKey,l=s.fonts,u=(s.activeFontSize,""),f=0,d="",p=l[n=c].encoding;if("Identity-H"!==l[n].encoding)return{text:r,x:i,y:o,options:a,mutex:s};for(d=r,n=c,"[object Array]"===Object.prototype.toString.call(r)&&(d=r[0]),f=0;f<d.length;f+=1)l[n].metadata.hasOwnProperty("cmap")&&(e=l[n].metadata.cmap.unicode.codeMap[d[f].charCodeAt(0)]),e?u+=d[f]:d[f].charCodeAt(0)<256&&l[n].metadata.hasOwnProperty("Unicode")?u+=d[f]:u+="";var g="";return parseInt(n.slice(1))<14||"WinAnsiEncoding"===p?g=function(t){for(var e="",n=0;n<t.length;n++)e+=""+t.charCodeAt(n).toString(16);return e}(h(u,n)):"Identity-H"===p&&(g=function(t,e){for(var n,r=e.metadata.Unicode.widths,i=["","0","00","000","0000"],o=[""],a=0,s=t.length;a<s;++a){if(n=e.metadata.characterToGlyph(t.charCodeAt(a)),m.push(n),-1==r.indexOf(n)&&(r.push(n),r.push([parseInt(e.metadata.widthOfGlyph(n),10)])),"0"==n)return o.join("");n=n.toString(16),o.push(i[4-n.length],n)}return o.join("")}(u,l[n])),s.isHex=!0,{text:g,x:i,y:o,options:a,mutex:s}};e.events.push(["postProcessText",function(t){var e=t.text||"",n=t.x,r=t.y,i=t.options,o=t.mutex,a=(i.lang,[]),s={text:e,x:n,y:r,options:i,mutex:o};if("[object Array]"===Object.prototype.toString.call(e)){var h=0;for(h=0;h<e.length;h+=1)"[object Array]"===Object.prototype.toString.call(e[h])&&3===e[h].length?a.push([c(Object.assign({},s,{text:e[h][0]})).text,e[h][1],e[h][2]]):a.push(c(Object.assign({},s,{text:e[h]})).text);t.text=a}else t.text=c(Object.assign({},s,{text:e})).text}])}($,"undefined"!=typeof self&&self||"undefined"!=typeof global&&global||"undefined"!=typeof window&&window||Function("return this")()),Q=$.API,Z={},Q.existsFileInVFS=function(t){return Z.hasOwnProperty(t)},Q.addFileToVFS=function(t,e){return Z[t]=e,this},Q.getFileFromVFS=function(t){return Z.hasOwnProperty(t)?Z[t]:null},function(t){if(t.URL=t.URL||t.webkitURL,t.Blob&&t.URL)try{return new Blob}catch(t){}var s=t.BlobBuilder||t.WebKitBlobBuilder||t.MozBlobBuilder||function(t){var s=function(t){return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1]},e=function(){this.data=[]},h=function(t,e,n){this.data=t,this.size=t.length,this.type=e,this.encoding=n},n=e.prototype,r=h.prototype,c=t.FileReaderSync,l=function(t){this.code=this[this.name=t]},i="NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "),o=i.length,a=t.URL||t.webkitURL||t,u=a.createObjectURL,f=a.revokeObjectURL,d=a,p=t.btoa,g=t.atob,m=t.ArrayBuffer,w=t.Uint8Array,y=/^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;for(h.fake=r.fake=!0;o--;)l.prototype[i[o]]=o+1;return a.createObjectURL||(d=t.URL=function(t){var e,n=document.createElementNS("http://www.w3.org/1999/xhtml","a");return n.href=t,"origin"in n||("data:"===n.protocol.toLowerCase()?n.origin=null:(e=t.match(y),n.origin=e&&e[1])),n}),d.createObjectURL=function(t){var e,n=t.type;return null===n&&(n="application/octet-stream"),t instanceof h?(e="data:"+n,"base64"===t.encoding?e+";base64,"+t.data:"URI"===t.encoding?e+","+decodeURIComponent(t.data):p?e+";base64,"+p(t.data):e+","+encodeURIComponent(t.data)):u?u.call(a,t):void 0},d.revokeObjectURL=function(t){"data:"!==t.substring(0,5)&&f&&f.call(a,t)},n.append=function(t){var e=this.data;if(w&&(t instanceof m||t instanceof w)){for(var n="",r=new w(t),i=0,o=r.length;i<o;i++)n+=String.fromCharCode(r[i]);e.push(n)}else if("Blob"===s(t)||"File"===s(t)){if(!c)throw new l("NOT_READABLE_ERR");var a=new c;e.push(a.readAsBinaryString(t))}else t instanceof h?"base64"===t.encoding&&g?e.push(g(t.data)):"URI"===t.encoding?e.push(decodeURIComponent(t.data)):"raw"===t.encoding&&e.push(t.data):("string"!=typeof t&&(t+=""),e.push(unescape(encodeURIComponent(t))))},n.getBlob=function(t){return arguments.length||(t=null),new h(this.data.join(""),t,"raw")},n.toString=function(){return"[object BlobBuilder]"},r.slice=function(t,e,n){var r=arguments.length;return r<3&&(n=null),new h(this.data.slice(t,1<r?e:this.data.length),n,this.encoding)},r.toString=function(){return"[object Blob]"},r.close=function(){this.size=0,delete this.data},e}(t);t.Blob=function(t,e){var n=e&&e.type||"",r=new s;if(t)for(var i=0,o=t.length;i<o;i++)Uint8Array&&t[i]instanceof Uint8Array?r.append(t[i].buffer):r.append(t[i]);var a=r.getBlob(n);return!a.slice&&a.webkitSlice&&(a.slice=a.webkitSlice),a};var e=Object.getPrototypeOf||function(t){return t.__proto__};t.Blob.prototype=e(new t.Blob)}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||window.content||window);var tt,et,nt,rt,it,ot,at,st,ht,ct,lt,ut,ft,dt,pt,gt,bt=bt||function(s){if(!(void 0===s||"undefined"!=typeof navigator&&/MSIE [1-9]\./.test(navigator.userAgent))){var t=s.document,h=function(){return s.URL||s.webkitURL||s},c=t.createElementNS("http://www.w3.org/1999/xhtml","a"),l="download"in c,u=/constructor/i.test(s.HTMLElement)||s.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),d=function(t){(s.setImmediate||s.setTimeout)(function(){throw t},0)},p=function(t){setTimeout(function(){"string"==typeof t?h().revokeObjectURL(t):t.remove()},4e4)},g=function(t){return/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type)?new Blob([String.fromCharCode(65279),t],{type:t.type}):t},r=function(t,n,e){e||(t=g(t));var r,i=this,o="application/octet-stream"===t.type,a=function(){!function(t,e,n){for(var r=(e=[].concat(e)).length;r--;){var i=t["on"+e[r]];if("function"==typeof i)try{i.call(t,n||t)}catch(t){d(t)}}}(i,"writestart progress write writeend".split(" "))};if(i.readyState=i.INIT,l)return r=h().createObjectURL(t),void setTimeout(function(){var t,e;c.href=r,c.download=n,t=c,e=new MouseEvent("click"),t.dispatchEvent(e),a(),p(r),i.readyState=i.DONE});!function(){if((f||o&&u)&&s.FileReader){var e=new FileReader;return e.onloadend=function(){var t=f?e.result:e.result.replace(/^data:[^;]*;/,"data:attachment/file;");s.open(t,"_blank")||(s.location.href=t),t=void 0,i.readyState=i.DONE,a()},e.readAsDataURL(t),i.readyState=i.INIT}r||(r=h().createObjectURL(t)),o?s.location.href=r:s.open(r,"_blank")||(s.location.href=r);i.readyState=i.DONE,a(),p(r)}()},e=r.prototype;return"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob?function(t,e,n){return e=e||t.name||"download",n||(t=g(t)),navigator.msSaveOrOpenBlob(t,e)}:(e.abort=function(){},e.readyState=e.INIT=0,e.WRITING=1,e.DONE=2,e.error=e.onwritestart=e.onprogress=e.onwrite=e.onabort=e.onerror=e.onwriteend=null,function(t,e,n){return new r(t,e||t.name||"download",n)})}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||window.content);function mt(x){var t=0;if(71!==x[t++]||73!==x[t++]||70!==x[t++]||56!==x[t++]||56!=(x[t++]+1&253)||97!==x[t++])throw"Invalid GIF 87a/89a header.";var S=x[t++]|x[t++]<<8,e=x[t++]|x[t++]<<8,n=x[t++],r=n>>7,i=1<<(7&n)+1;x[t++];x[t++];var o=null;r&&(o=t,t+=3*i);var a=!0,s=[],h=0,c=null,l=0,u=null;for(this.width=S,this.height=e;a&&t<x.length;)switch(x[t++]){case 33:switch(x[t++]){case 255:if(11!==x[t]||78==x[t+1]&&69==x[t+2]&&84==x[t+3]&&83==x[t+4]&&67==x[t+5]&&65==x[t+6]&&80==x[t+7]&&69==x[t+8]&&50==x[t+9]&&46==x[t+10]&&48==x[t+11]&&3==x[t+12]&&1==x[t+13]&&0==x[t+16])t+=14,u=x[t++]|x[t++]<<8,t++;else for(t+=12;;){if(0===(_=x[t++]))break;t+=_}break;case 249:if(4!==x[t++]||0!==x[t+4])throw"Invalid graphics extension block.";var f=x[t++];h=x[t++]|x[t++]<<8,c=x[t++],0==(1&f)&&(c=null),l=f>>2&7,t++;break;case 254:for(;;){if(0===(_=x[t++]))break;t+=_}break;default:throw"Unknown graphic control label: 0x"+x[t-1].toString(16)}break;case 44:var d=x[t++]|x[t++]<<8,p=x[t++]|x[t++]<<8,g=x[t++]|x[t++]<<8,m=x[t++]|x[t++]<<8,w=x[t++],y=w>>6&1,v=o,b=!1;if(w>>7){b=!0;v=t,t+=3*(1<<(7&w)+1)}var k=t;for(t++;;){var _;if(0===(_=x[t++]))break;t+=_}s.push({x:d,y:p,width:g,height:m,has_local_palette:b,palette_offset:v,data_offset:k,data_length:t-k,transparent_index:c,interlaced:!!y,delay:h,disposal:l});break;case 59:a=!1;break;default:throw"Unknown gif block: 0x"+x[t-1].toString(16)}this.numFrames=function(){return s.length},this.loopCount=function(){return u},this.frameInfo=function(t){if(t<0||t>=s.length)throw"Frame index out of range.";return s[t]},this.decodeAndBlitFrameBGRA=function(t,e){var n=this.frameInfo(t),r=n.width*n.height,i=new Uint8Array(r);wt(x,n.data_offset,i,r);var o=n.palette_offset,a=n.transparent_index;null===a&&(a=256);var s=n.width,h=S-s,c=s,l=4*(n.y*S+n.x),u=4*((n.y+n.height)*S+n.x),f=l,d=4*h;!0===n.interlaced&&(d+=4*(s+h)*7);for(var p=8,g=0,m=i.length;g<m;++g){var w=i[g];if(0===c&&(c=s,u<=(f+=d)&&(d=h+4*(s+h)*(p-1),f=l+(s+h)*(p<<1),p>>=1)),w===a)f+=4;else{var y=x[o+3*w],v=x[o+3*w+1],b=x[o+3*w+2];e[f++]=b,e[f++]=v,e[f++]=y,e[f++]=255}--c}},this.decodeAndBlitFrameRGBA=function(t,e){var n=this.frameInfo(t),r=n.width*n.height,i=new Uint8Array(r);wt(x,n.data_offset,i,r);var o=n.palette_offset,a=n.transparent_index;null===a&&(a=256);var s=n.width,h=S-s,c=s,l=4*(n.y*S+n.x),u=4*((n.y+n.height)*S+n.x),f=l,d=4*h;!0===n.interlaced&&(d+=4*(s+h)*7);for(var p=8,g=0,m=i.length;g<m;++g){var w=i[g];if(0===c&&(c=s,u<=(f+=d)&&(d=h+4*(s+h)*(p-1),f=l+(s+h)*(p<<1),p>>=1)),w===a)f+=4;else{var y=x[o+3*w],v=x[o+3*w+1],b=x[o+3*w+2];e[f++]=y,e[f++]=v,e[f++]=b,e[f++]=255}--c}}}function wt(t,e,n,r){for(var i=t[e++],o=1<<i,a=o+1,s=a+1,h=i+1,c=(1<<h)-1,l=0,u=0,f=0,d=t[e++],p=new Int32Array(4096),g=null;;){for(;l<16&&0!==d;)u|=t[e++]<<l,l+=8,1===d?d=t[e++]:--d;if(l<h)break;var m=u&c;if(u>>=h,l-=h,m!==o){if(m===a)break;for(var w=m<s?m:g,y=0,v=w;o<v;)v=p[v]>>8,++y;var b=v;if(r<f+y+(w!==m?1:0))return void console.log("Warning, gif stream longer than expected.");n[f++]=b;var x=f+=y;for(w!==m&&(n[f++]=b),v=w;y--;)v=p[v],n[--x]=255&v,v>>=8;null!==g&&s<4096&&(p[s++]=g<<8|b,c+1<=s&&h<12&&(++h,c=c<<1|1)),g=m}else s=a+1,c=(1<<(h=i+1))-1,g=null}return f!==r&&console.log("Warning, gif stream shorter than expected."),n}"undefined"!=typeof module&&module.exports?module.exports.saveAs=bt:"undefined"!=typeof define&&null!==define&&null!==define.amd&&define("FileSaver.js",function(){return bt})
/*
   * Copyright (c) 2012 chick307 <chick307@gmail.com>
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */,$.API.adler32cs=(ot="function"==typeof ArrayBuffer&&"function"==typeof Uint8Array,at=null,st=function(){if(!ot)return function(){return!1};try{var t={};"function"==typeof t.Buffer&&(at=t.Buffer)}catch(t){}return function(t){return t instanceof ArrayBuffer||null!==at&&t instanceof at}}(),ht=null!==at?function(t){return new at(t,"utf8").toString("binary")}:function(t){return unescape(encodeURIComponent(t))},ct=65521,lt=function(t,e){for(var n=65535&t,r=t>>>16,i=0,o=e.length;i<o;i++)n=(n+(255&e.charCodeAt(i)))%ct,r=(r+n)%ct;return(r<<16|n)>>>0},ut=function(t,e){for(var n=65535&t,r=t>>>16,i=0,o=e.length;i<o;i++)n=(n+e[i])%ct,r=(r+n)%ct;return(r<<16|n)>>>0},dt=(ft={}).Adler32=(((it=(rt=function(t){if(!(this instanceof rt))throw new TypeError("Constructor cannot called be as a function.");if(!isFinite(t=null==t?1:+t))throw new Error("First arguments needs to be a finite number.");this.checksum=t>>>0}).prototype={}).constructor=rt).from=((tt=function(t){if(!(this instanceof rt))throw new TypeError("Constructor cannot called be as a function.");if(null==t)throw new Error("First argument needs to be a string.");this.checksum=lt(1,t.toString())}).prototype=it,tt),rt.fromUtf8=((et=function(t){if(!(this instanceof rt))throw new TypeError("Constructor cannot called be as a function.");if(null==t)throw new Error("First argument needs to be a string.");var e=ht(t.toString());this.checksum=lt(1,e)}).prototype=it,et),ot&&(rt.fromBuffer=((nt=function(t){if(!(this instanceof rt))throw new TypeError("Constructor cannot called be as a function.");if(!st(t))throw new Error("First argument needs to be ArrayBuffer.");var e=new Uint8Array(t);return this.checksum=ut(1,e)}).prototype=it,nt)),it.update=function(t){if(null==t)throw new Error("First argument needs to be a string.");return t=t.toString(),this.checksum=lt(this.checksum,t)},it.updateUtf8=function(t){if(null==t)throw new Error("First argument needs to be a string.");var e=ht(t.toString());return this.checksum=lt(this.checksum,e)},ot&&(it.updateBuffer=function(t){if(!st(t))throw new Error("First argument needs to be ArrayBuffer.");var e=new Uint8Array(t);return this.checksum=ut(this.checksum,e)}),it.clone=function(){return new dt(this.checksum)},rt),ft.from=function(t){if(null==t)throw new Error("First argument needs to be a string.");return lt(1,t.toString())},ft.fromUtf8=function(t){if(null==t)throw new Error("First argument needs to be a string.");var e=ht(t.toString());return lt(1,e)},ot&&(ft.fromBuffer=function(t){if(!st(t))throw new Error("First argument need to be ArrayBuffer.");var e=new Uint8Array(t);return ut(1,e)}),ft);try{exports.GifWriter=function(w,t,e,n){var y=0,r=void 0===(n=void 0===n?{}:n).loop?null:n.loop,v=void 0===n.palette?null:n.palette;if(t<=0||e<=0||65535<t||65535<e)throw"Width/Height invalid.";function b(t){var e=t.length;if(e<2||256<e||e&e-1)throw"Invalid code/color length, must be power of 2 and 2 .. 256.";return e}w[y++]=71,w[y++]=73,w[y++]=70,w[y++]=56,w[y++]=57,w[y++]=97;var i=0,o=0;if(null!==v){for(var a=b(v);a>>=1;)++i;if(a=1<<i,--i,void 0!==n.background){if(a<=(o=n.background))throw"Background index out of range.";if(0===o)throw"Background index explicitly passed as 0."}}if(w[y++]=255&t,w[y++]=t>>8&255,w[y++]=255&e,w[y++]=e>>8&255,w[y++]=(null!==v?128:0)|i,w[y++]=o,w[y++]=0,null!==v)for(var s=0,h=v.length;s<h;++s){var c=v[s];w[y++]=c>>16&255,w[y++]=c>>8&255,w[y++]=255&c}if(null!==r){if(r<0||65535<r)throw"Loop count invalid.";w[y++]=33,w[y++]=255,w[y++]=11,w[y++]=78,w[y++]=69,w[y++]=84,w[y++]=83,w[y++]=67,w[y++]=65,w[y++]=80,w[y++]=69,w[y++]=50,w[y++]=46,w[y++]=48,w[y++]=3,w[y++]=1,w[y++]=255&r,w[y++]=r>>8&255,w[y++]=0}var x=!1;this.addFrame=function(t,e,n,r,i,o){if(!0===x&&(--y,x=!1),o=void 0===o?{}:o,t<0||e<0||65535<t||65535<e)throw"x/y invalid.";if(n<=0||r<=0||65535<n||65535<r)throw"Width/Height invalid.";if(i.length<n*r)throw"Not enough pixels for the frame size.";var a=!0,s=o.palette;if(null==s&&(a=!1,s=v),null==s)throw"Must supply either a local or global palette.";for(var h=b(s),c=0;h>>=1;)++c;h=1<<c;var l=void 0===o.delay?0:o.delay,u=void 0===o.disposal?0:o.disposal;if(u<0||3<u)throw"Disposal out of range.";var f=!1,d=0;if(void 0!==o.transparent&&null!==o.transparent&&(f=!0,(d=o.transparent)<0||h<=d))throw"Transparent color index.";if((0!==u||f||0!==l)&&(w[y++]=33,w[y++]=249,w[y++]=4,w[y++]=u<<2|(!0===f?1:0),w[y++]=255&l,w[y++]=l>>8&255,w[y++]=d,w[y++]=0),w[y++]=44,w[y++]=255&t,w[y++]=t>>8&255,w[y++]=255&e,w[y++]=e>>8&255,w[y++]=255&n,w[y++]=n>>8&255,w[y++]=255&r,w[y++]=r>>8&255,w[y++]=!0===a?128|c-1:0,!0===a)for(var p=0,g=s.length;p<g;++p){var m=s[p];w[y++]=m>>16&255,w[y++]=m>>8&255,w[y++]=255&m}y=function(e,n,t,r){e[n++]=t;var i=n++,o=1<<t,a=o-1,s=o+1,h=s+1,c=t+1,l=0,u=0;function f(t){for(;t<=l;)e[n++]=255&u,u>>=8,l-=8,n===i+256&&(e[i]=255,i=n++)}function d(t){u|=t<<l,l+=c,f(8)}var p=r[0]&a,g={};d(o);for(var m=1,w=r.length;m<w;++m){var y=r[m]&a,v=p<<8|y,b=g[v];if(void 0===b){for(u|=p<<l,l+=c;8<=l;)e[n++]=255&u,u>>=8,l-=8,n===i+256&&(e[i]=255,i=n++);4096===h?(d(o),h=s+1,c=t+1,g={}):(1<<c<=h&&++c,g[v]=h++),p=y}else p=b}return d(p),d(s),f(1),i+1===n?e[i]=0:(e[i]=n-i-1,e[n++]=0),n}(w,y,c<2?2:c,i)},this.end=function(){return!1===x&&(w[y++]=59,x=!0),y}},exports.GifReader=mt}catch(t){}
/*
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */function yt(t){var S,k,_,A,e,u=Math.floor,I=new Array(64),C=new Array(64),T=new Array(64),F=new Array(64),w=new Array(65535),y=new Array(65535),Q=new Array(64),v=new Array(64),P=[],E=0,q=7,O=new Array(64),B=new Array(64),R=new Array(64),n=new Array(256),j=new Array(2048),b=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],D=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],M=[0,1,2,3,4,5,6,7,8,9,10,11],U=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],N=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],z=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],L=[0,1,2,3,4,5,6,7,8,9,10,11],H=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],W=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function r(t,e){for(var n=0,r=0,i=new Array,o=1;o<=16;o++){for(var a=1;a<=t[o];a++)i[e[r]]=[],i[e[r]][0]=n,i[e[r]][1]=o,r++,n++;n*=2}return i}function G(t){for(var e=t[0],n=t[1]-1;0<=n;)e&1<<n&&(E|=1<<q),n--,--q<0&&(255==E?(V(255),V(0)):V(E),q=7,E=0)}function V(t){P.push(t)}function Y(t){V(t>>8&255),V(255&t)}function X(t,e,n,r,i){for(var o,a=i[0],s=i[240],h=function(t,e){var n,r,i,o,a,s,h,c,l,u,f=0;for(l=0;l<8;++l){n=t[f],r=t[f+1],i=t[f+2],o=t[f+3],a=t[f+4],s=t[f+5],h=t[f+6];var d=n+(c=t[f+7]),p=n-c,g=r+h,m=r-h,w=i+s,y=i-s,v=o+a,b=o-a,x=d+v,S=d-v,k=g+w,_=g-w;t[f]=x+k,t[f+4]=x-k;var A=.707106781*(_+S);t[f+2]=S+A,t[f+6]=S-A;var I=.382683433*((x=b+y)-(_=m+p)),C=.5411961*x+I,T=1.306562965*_+I,F=.707106781*(k=y+m),P=p+F,E=p-F;t[f+5]=E+C,t[f+3]=E-C,t[f+1]=P+T,t[f+7]=P-T,f+=8}for(l=f=0;l<8;++l){n=t[f],r=t[f+8],i=t[f+16],o=t[f+24],a=t[f+32],s=t[f+40],h=t[f+48];var q=n+(c=t[f+56]),O=n-c,B=r+h,R=r-h,j=i+s,D=i-s,M=o+a,U=o-a,N=q+M,z=q-M,L=B+j,H=B-j;t[f]=N+L,t[f+32]=N-L;var W=.707106781*(H+z);t[f+16]=z+W,t[f+48]=z-W;var G=.382683433*((N=U+D)-(H=R+O)),V=.5411961*N+G,Y=1.306562965*H+G,X=.707106781*(L=D+R),J=O+X,K=O-X;t[f+40]=K+V,t[f+24]=K-V,t[f+8]=J+Y,t[f+56]=J-Y,f++}for(l=0;l<64;++l)u=t[l]*e[l],Q[l]=0<u?u+.5|0:u-.5|0;return Q}(t,e),c=0;c<64;++c)v[b[c]]=h[c];var l=v[0]-n;n=v[0],0==l?G(r[0]):(G(r[y[o=32767+l]]),G(w[o]));for(var u=63;0<u&&0==v[u];u--);if(0==u)return G(a),n;for(var f,d=1;d<=u;){for(var p=d;0==v[d]&&d<=u;++d);var g=d-p;if(16<=g){f=g>>4;for(var m=1;m<=f;++m)G(s);g&=15}o=32767+v[d],G(i[(g<<4)+y[o]]),G(w[o]),d++}return 63!=u&&G(a),n}function J(t){if(t<=0&&(t=1),100<t&&(t=100),e!=t){(function(t){for(var e=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],n=0;n<64;n++){var r=u((e[n]*t+50)/100);r<1?r=1:255<r&&(r=255),I[b[n]]=r}for(var i=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],o=0;o<64;o++){var a=u((i[o]*t+50)/100);a<1?a=1:255<a&&(a=255),C[b[o]]=a}for(var s=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],h=0,c=0;c<8;c++)for(var l=0;l<8;l++)T[h]=1/(I[b[h]]*s[c]*s[l]*8),F[h]=1/(C[b[h]]*s[c]*s[l]*8),h++})(t<50?Math.floor(5e3/t):Math.floor(200-2*t)),e=t}}this.encode=function(t,e){var n,r;(new Date).getTime();e&&J(e),P=new Array,E=0,q=7,Y(65496),Y(65504),Y(16),V(74),V(70),V(73),V(70),V(0),V(1),V(1),V(0),Y(1),Y(1),V(0),V(0),function(){Y(65499),Y(132),V(0);for(var t=0;t<64;t++)V(I[t]);V(1);for(var e=0;e<64;e++)V(C[e])}(),n=t.width,r=t.height,Y(65472),Y(17),V(8),Y(r),Y(n),V(3),V(1),V(17),V(0),V(2),V(17),V(1),V(3),V(17),V(1),function(){Y(65476),Y(418),V(0);for(var t=0;t<16;t++)V(D[t+1]);for(var e=0;e<=11;e++)V(M[e]);V(16);for(var n=0;n<16;n++)V(U[n+1]);for(var r=0;r<=161;r++)V(N[r]);V(1);for(var i=0;i<16;i++)V(z[i+1]);for(var o=0;o<=11;o++)V(L[o]);V(17);for(var a=0;a<16;a++)V(H[a+1]);for(var s=0;s<=161;s++)V(W[s])}(),Y(65498),Y(12),V(3),V(1),V(0),V(2),V(17),V(3),V(17),V(0),V(63),V(0);var i=0,o=0,a=0;E=0,q=7,this.encode.displayName="_encode_";for(var s,h,c,l,u,f,d,p,g,m=t.data,w=t.width,y=t.height,v=4*w,b=0;b<y;){for(s=0;s<v;){for(f=u=v*b+s,d=-1,g=p=0;g<64;g++)f=u+(p=g>>3)*v+(d=4*(7&g)),y<=b+p&&(f-=v*(b+1+p-y)),v<=s+d&&(f-=s+d-v+4),h=m[f++],c=m[f++],l=m[f++],O[g]=(j[h]+j[c+256>>0]+j[l+512>>0]>>16)-128,B[g]=(j[h+768>>0]+j[c+1024>>0]+j[l+1280>>0]>>16)-128,R[g]=(j[h+1280>>0]+j[c+1536>>0]+j[l+1792>>0]>>16)-128;i=X(O,T,i,S,_),o=X(B,F,o,k,A),a=X(R,F,a,k,A),s+=32}b+=8}if(0<=q){var x=[];x[1]=q+1,x[0]=(1<<q+1)-1,G(x)}return Y(65497),new Uint8Array(P)},function(){(new Date).getTime();t||(t=50),function(){for(var t=String.fromCharCode,e=0;e<256;e++)n[e]=t(e)}(),S=r(D,M),k=r(z,L),_=r(U,N),A=r(H,W),function(){for(var t=1,e=2,n=1;n<=15;n++){for(var r=t;r<e;r++)y[32767+r]=n,w[32767+r]=[],w[32767+r][1]=n,w[32767+r][0]=r;for(var i=-(e-1);i<=-t;i++)y[32767+i]=n,w[32767+i]=[],w[32767+i][1]=n,w[32767+i][0]=e-1+i;t<<=1,e<<=1}}(),function(){for(var t=0;t<256;t++)j[t]=19595*t,j[t+256>>0]=38470*t,j[t+512>>0]=7471*t+32768,j[t+768>>0]=-11059*t,j[t+1024>>0]=-21709*t,j[t+1280>>0]=32768*t+8421375,j[t+1536>>0]=-27439*t,j[t+1792>>0]=-5329*t}(),J(t),(new Date).getTime()}()}try{module.exports=yt}catch(t){}function xt(t,e){if(this.pos=0,this.buffer=t,this.datav=new DataView(t.buffer),this.is_with_alpha=!!e,this.bottom_up=!0,this.flag=String.fromCharCode(this.buffer[0])+String.fromCharCode(this.buffer[1]),this.pos+=2,-1===["BM","BA","CI","CP","IC","PT"].indexOf(this.flag))throw new Error("Invalid BMP File");this.parseHeader(),this.parseBGR()}xt.prototype.parseHeader=function(){if(this.fileSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.reserved=this.datav.getUint32(this.pos,!0),this.pos+=4,this.offset=this.datav.getUint32(this.pos,!0),this.pos+=4,this.headerSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.width=this.datav.getUint32(this.pos,!0),this.pos+=4,this.height=this.datav.getInt32(this.pos,!0),this.pos+=4,this.planes=this.datav.getUint16(this.pos,!0),this.pos+=2,this.bitPP=this.datav.getUint16(this.pos,!0),this.pos+=2,this.compress=this.datav.getUint32(this.pos,!0),this.pos+=4,this.rawSize=this.datav.getUint32(this.pos,!0),this.pos+=4,this.hr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.vr=this.datav.getUint32(this.pos,!0),this.pos+=4,this.colors=this.datav.getUint32(this.pos,!0),this.pos+=4,this.importantColors=this.datav.getUint32(this.pos,!0),this.pos+=4,16===this.bitPP&&this.is_with_alpha&&(this.bitPP=15),this.bitPP<15){var t=0===this.colors?1<<this.bitPP:this.colors;this.palette=new Array(t);for(var e=0;e<t;e++){var n=this.datav.getUint8(this.pos++,!0),r=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),o=this.datav.getUint8(this.pos++,!0);this.palette[e]={red:i,green:r,blue:n,quad:o}}}this.height<0&&(this.height*=-1,this.bottom_up=!1)},xt.prototype.parseBGR=function(){this.pos=this.offset;try{var t="bit"+this.bitPP,e=this.width*this.height*4;this.data=new Uint8Array(e),this[t]()}catch(t){console.log("bit decode error:"+t)}},xt.prototype.bit1=function(){var t=Math.ceil(this.width/8),e=t%4,n=0<=this.height?this.height-1:-this.height;for(n=this.height-1;0<=n;n--){for(var r=this.bottom_up?n:this.height-1-n,i=0;i<t;i++)for(var o=this.datav.getUint8(this.pos++,!0),a=r*this.width*4+8*i*4,s=0;s<8&&8*i+s<this.width;s++){var h=this.palette[o>>7-s&1];this.data[a+4*s]=h.blue,this.data[a+4*s+1]=h.green,this.data[a+4*s+2]=h.red,this.data[a+4*s+3]=255}0!=e&&(this.pos+=4-e)}},xt.prototype.bit4=function(){for(var t=Math.ceil(this.width/2),e=t%4,n=this.height-1;0<=n;n--){for(var r=this.bottom_up?n:this.height-1-n,i=0;i<t;i++){var o=this.datav.getUint8(this.pos++,!0),a=r*this.width*4+2*i*4,s=o>>4,h=15&o,c=this.palette[s];if(this.data[a]=c.blue,this.data[a+1]=c.green,this.data[a+2]=c.red,this.data[a+3]=255,2*i+1>=this.width)break;c=this.palette[h],this.data[a+4]=c.blue,this.data[a+4+1]=c.green,this.data[a+4+2]=c.red,this.data[a+4+3]=255}0!=e&&(this.pos+=4-e)}},xt.prototype.bit8=function(){for(var t=this.width%4,e=this.height-1;0<=e;e--){for(var n=this.bottom_up?e:this.height-1-e,r=0;r<this.width;r++){var i=this.datav.getUint8(this.pos++,!0),o=n*this.width*4+4*r;if(i<this.palette.length){var a=this.palette[i];this.data[o]=a.red,this.data[o+1]=a.green,this.data[o+2]=a.blue,this.data[o+3]=255}else this.data[o]=255,this.data[o+1]=255,this.data[o+2]=255,this.data[o+3]=255}0!=t&&(this.pos+=4-t)}},xt.prototype.bit15=function(){for(var t=this.width%3,e=parseInt("11111",2),n=this.height-1;0<=n;n--){for(var r=this.bottom_up?n:this.height-1-n,i=0;i<this.width;i++){var o=this.datav.getUint16(this.pos,!0);this.pos+=2;var a=(o&e)/e*255|0,s=(o>>5&e)/e*255|0,h=(o>>10&e)/e*255|0,c=o>>15?255:0,l=r*this.width*4+4*i;this.data[l]=h,this.data[l+1]=s,this.data[l+2]=a,this.data[l+3]=c}this.pos+=t}},xt.prototype.bit16=function(){for(var t=this.width%3,e=parseInt("11111",2),n=parseInt("111111",2),r=this.height-1;0<=r;r--){for(var i=this.bottom_up?r:this.height-1-r,o=0;o<this.width;o++){var a=this.datav.getUint16(this.pos,!0);this.pos+=2;var s=(a&e)/e*255|0,h=(a>>5&n)/n*255|0,c=(a>>11)/e*255|0,l=i*this.width*4+4*o;this.data[l]=c,this.data[l+1]=h,this.data[l+2]=s,this.data[l+3]=255}this.pos+=t}},xt.prototype.bit24=function(){for(var t=this.height-1;0<=t;t--){for(var e=this.bottom_up?t:this.height-1-t,n=0;n<this.width;n++){var r=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),o=this.datav.getUint8(this.pos++,!0),a=e*this.width*4+4*n;this.data[a]=o,this.data[a+1]=i,this.data[a+2]=r,this.data[a+3]=255}this.pos+=this.width%4}},xt.prototype.bit32=function(){for(var t=this.height-1;0<=t;t--)for(var e=this.bottom_up?t:this.height-1-t,n=0;n<this.width;n++){var r=this.datav.getUint8(this.pos++,!0),i=this.datav.getUint8(this.pos++,!0),o=this.datav.getUint8(this.pos++,!0),a=this.datav.getUint8(this.pos++,!0),s=e*this.width*4+4*n;this.data[s]=o,this.data[s+1]=i,this.data[s+2]=r,this.data[s+3]=a}},xt.prototype.getData=function(){return this.data};try{module.exports=function(t){var e=new xt(t);return{data:e.getData(),width:e.width,height:e.height}}}catch(t){}
/*
   Copyright (c) 2013 Gildas Lormeau. All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright 
   notice, this list of conditions and the following disclaimer in 
   the documentation and/or other materials provided with the distribution.

   3. The names of the authors may not be used to endorse or promote products
   derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
   INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
/*
   Copyright (c) 2013 Gildas Lormeau. All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright 
   notice, this list of conditions and the following disclaimer in 
   the documentation and/or other materials provided with the distribution.

   3. The names of the authors may not be used to endorse or promote products
   derived from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
   INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
!function(t){var p=15,g=573,e=[0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,0,0,16,17,18,18,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29];function ut(){var d=this;function h(t,e){for(var n=0;n|=1&t,t>>>=1,n<<=1,0<--e;);return n>>>1}d.build_tree=function(t){var e,n,r,i=d.dyn_tree,o=d.stat_desc.static_tree,a=d.stat_desc.elems,s=-1;for(t.heap_len=0,t.heap_max=g,e=0;e<a;e++)0!==i[2*e]?(t.heap[++t.heap_len]=s=e,t.depth[e]=0):i[2*e+1]=0;for(;t.heap_len<2;)i[2*(r=t.heap[++t.heap_len]=s<2?++s:0)]=1,t.depth[r]=0,t.opt_len--,o&&(t.static_len-=o[2*r+1]);for(d.max_code=s,e=Math.floor(t.heap_len/2);1<=e;e--)t.pqdownheap(i,e);for(r=a;e=t.heap[1],t.heap[1]=t.heap[t.heap_len--],t.pqdownheap(i,1),n=t.heap[1],t.heap[--t.heap_max]=e,t.heap[--t.heap_max]=n,i[2*r]=i[2*e]+i[2*n],t.depth[r]=Math.max(t.depth[e],t.depth[n])+1,i[2*e+1]=i[2*n+1]=r,t.heap[1]=r++,t.pqdownheap(i,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t){var e,n,r,i,o,a,s=d.dyn_tree,h=d.stat_desc.static_tree,c=d.stat_desc.extra_bits,l=d.stat_desc.extra_base,u=d.stat_desc.max_length,f=0;for(i=0;i<=p;i++)t.bl_count[i]=0;for(s[2*t.heap[t.heap_max]+1]=0,e=t.heap_max+1;e<g;e++)u<(i=s[2*s[2*(n=t.heap[e])+1]+1]+1)&&(i=u,f++),s[2*n+1]=i,n>d.max_code||(t.bl_count[i]++,o=0,l<=n&&(o=c[n-l]),a=s[2*n],t.opt_len+=a*(i+o),h&&(t.static_len+=a*(h[2*n+1]+o)));if(0!==f){do{for(i=u-1;0===t.bl_count[i];)i--;t.bl_count[i]--,t.bl_count[i+1]+=2,t.bl_count[u]--,f-=2}while(0<f);for(i=u;0!==i;i--)for(n=t.bl_count[i];0!==n;)(r=t.heap[--e])>d.max_code||(s[2*r+1]!=i&&(t.opt_len+=(i-s[2*r+1])*s[2*r],s[2*r+1]=i),n--)}}(t),function(t,e,n){var r,i,o,a=[],s=0;for(r=1;r<=p;r++)a[r]=s=s+n[r-1]<<1;for(i=0;i<=e;i++)0!==(o=t[2*i+1])&&(t[2*i]=h(a[o]++,o))}(i,d.max_code,t.bl_count)}}function ft(t,e,n,r,i){var o=this;o.static_tree=t,o.extra_bits=e,o.extra_base=n,o.elems=r,o.max_length=i}ut._length_code=[0,1,2,3,4,5,6,7,8,8,9,9,10,10,11,11,12,12,12,12,13,13,13,13,14,14,14,14,15,15,15,15,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28],ut.base_length=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],ut.base_dist=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],ut.d_code=function(t){return t<256?e[t]:e[256+(t>>>7)]},ut.extra_lbits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ut.extra_dbits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],ut.extra_blbits=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ut.bl_order=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],ft.static_ltree=[12,8,140,8,76,8,204,8,44,8,172,8,108,8,236,8,28,8,156,8,92,8,220,8,60,8,188,8,124,8,252,8,2,8,130,8,66,8,194,8,34,8,162,8,98,8,226,8,18,8,146,8,82,8,210,8,50,8,178,8,114,8,242,8,10,8,138,8,74,8,202,8,42,8,170,8,106,8,234,8,26,8,154,8,90,8,218,8,58,8,186,8,122,8,250,8,6,8,134,8,70,8,198,8,38,8,166,8,102,8,230,8,22,8,150,8,86,8,214,8,54,8,182,8,118,8,246,8,14,8,142,8,78,8,206,8,46,8,174,8,110,8,238,8,30,8,158,8,94,8,222,8,62,8,190,8,126,8,254,8,1,8,129,8,65,8,193,8,33,8,161,8,97,8,225,8,17,8,145,8,81,8,209,8,49,8,177,8,113,8,241,8,9,8,137,8,73,8,201,8,41,8,169,8,105,8,233,8,25,8,153,8,89,8,217,8,57,8,185,8,121,8,249,8,5,8,133,8,69,8,197,8,37,8,165,8,101,8,229,8,21,8,149,8,85,8,213,8,53,8,181,8,117,8,245,8,13,8,141,8,77,8,205,8,45,8,173,8,109,8,237,8,29,8,157,8,93,8,221,8,61,8,189,8,125,8,253,8,19,9,275,9,147,9,403,9,83,9,339,9,211,9,467,9,51,9,307,9,179,9,435,9,115,9,371,9,243,9,499,9,11,9,267,9,139,9,395,9,75,9,331,9,203,9,459,9,43,9,299,9,171,9,427,9,107,9,363,9,235,9,491,9,27,9,283,9,155,9,411,9,91,9,347,9,219,9,475,9,59,9,315,9,187,9,443,9,123,9,379,9,251,9,507,9,7,9,263,9,135,9,391,9,71,9,327,9,199,9,455,9,39,9,295,9,167,9,423,9,103,9,359,9,231,9,487,9,23,9,279,9,151,9,407,9,87,9,343,9,215,9,471,9,55,9,311,9,183,9,439,9,119,9,375,9,247,9,503,9,15,9,271,9,143,9,399,9,79,9,335,9,207,9,463,9,47,9,303,9,175,9,431,9,111,9,367,9,239,9,495,9,31,9,287,9,159,9,415,9,95,9,351,9,223,9,479,9,63,9,319,9,191,9,447,9,127,9,383,9,255,9,511,9,0,7,64,7,32,7,96,7,16,7,80,7,48,7,112,7,8,7,72,7,40,7,104,7,24,7,88,7,56,7,120,7,4,7,68,7,36,7,100,7,20,7,84,7,52,7,116,7,3,8,131,8,67,8,195,8,35,8,163,8,99,8,227,8],ft.static_dtree=[0,5,16,5,8,5,24,5,4,5,20,5,12,5,28,5,2,5,18,5,10,5,26,5,6,5,22,5,14,5,30,5,1,5,17,5,9,5,25,5,5,5,21,5,13,5,29,5,3,5,19,5,11,5,27,5,7,5,23,5],ft.static_l_desc=new ft(ft.static_ltree,ut.extra_lbits,257,286,p),ft.static_d_desc=new ft(ft.static_dtree,ut.extra_dbits,0,30,p),ft.static_bl_desc=new ft(null,ut.extra_blbits,0,19,7);function n(t,e,n,r,i){var o=this;o.good_length=t,o.max_lazy=e,o.nice_length=n,o.max_chain=r,o.func=i}var dt=[new n(0,0,0,0,0),new n(4,4,8,4,1),new n(4,5,16,8,1),new n(4,6,32,32,1),new n(4,4,16,16,2),new n(8,16,32,32,2),new n(8,16,128,128,2),new n(8,32,128,256,2),new n(32,128,258,1024,2),new n(32,258,258,4096,2)],pt=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],gt=262;function mt(t,e,n,r){var i=t[2*e],o=t[2*n];return i<o||i==o&&r[e]<=r[n]}function r(){var h,c,l,u,f,d,p,g,i,m,w,y,v,a,b,x,S,k,_,A,I,C,T,F,P,E,q,O,B,R,s,j,D,M,U,N,z,o,L,H,W,G=this,V=new ut,Y=new ut,X=new ut;function J(){var t;for(t=0;t<286;t++)s[2*t]=0;for(t=0;t<30;t++)j[2*t]=0;for(t=0;t<19;t++)D[2*t]=0;s[512]=1,G.opt_len=G.static_len=0,N=o=0}function K(t,e){var n,r,i=-1,o=t[1],a=0,s=7,h=4;for(0===o&&(s=138,h=3),t[2*(e+1)+1]=65535,n=0;n<=e;n++)r=o,o=t[2*(n+1)+1],++a<s&&r==o||(a<h?D[2*r]+=a:0!==r?(r!=i&&D[2*r]++,D[32]++):a<=10?D[34]++:D[36]++,i=r,(a=0)===o?(s=138,h=3):r==o?(s=6,h=3):(s=7,h=4))}function Q(t){G.pending_buf[G.pending++]=t}function Z(t){Q(255&t),Q(t>>>8&255)}function $(t,e){var n,r=e;16-r<W?(Z(H|=(n=t)<<W&65535),H=n>>>16-W,W+=r-16):(H|=t<<W&65535,W+=r)}function tt(t,e){var n=2*t;$(65535&e[n],65535&e[n+1])}function et(t,e){var n,r,i=-1,o=t[1],a=0,s=7,h=4;for(0===o&&(s=138,h=3),n=0;n<=e;n++)if(r=o,o=t[2*(n+1)+1],!(++a<s&&r==o)){if(a<h)for(;tt(r,D),0!=--a;);else 0!==r?(r!=i&&(tt(r,D),a--),tt(16,D),$(a-3,2)):a<=10?(tt(17,D),$(a-3,3)):(tt(18,D),$(a-11,7));i=r,(a=0)===o?(s=138,h=3):r==o?(s=6,h=3):(s=7,h=4)}}function nt(){16==W?(Z(H),W=H=0):8<=W&&(Q(255&H),H>>>=8,W-=8)}function rt(t,e){var n,r,i;if(G.pending_buf[z+2*N]=t>>>8&255,G.pending_buf[z+2*N+1]=255&t,G.pending_buf[M+N]=255&e,N++,0===t?s[2*e]++:(o++,t--,s[2*(ut._length_code[e]+256+1)]++,j[2*ut.d_code(t)]++),0==(8191&N)&&2<q){for(n=8*N,r=I-S,i=0;i<30;i++)n+=j[2*i]*(5+ut.extra_dbits[i]);if(n>>>=3,o<Math.floor(N/2)&&n<Math.floor(r/2))return!0}return N==U-1}function it(t,e){var n,r,i,o,a=0;if(0!==N)for(;n=G.pending_buf[z+2*a]<<8&65280|255&G.pending_buf[z+2*a+1],r=255&G.pending_buf[M+a],a++,0===n?tt(r,t):(tt((i=ut._length_code[r])+256+1,t),0!==(o=ut.extra_lbits[i])&&$(r-=ut.base_length[i],o),tt(i=ut.d_code(--n),e),0!==(o=ut.extra_dbits[i])&&$(n-=ut.base_dist[i],o)),a<N;);tt(256,t),L=t[513]}function ot(){8<W?Z(H):0<W&&Q(255&H),W=H=0}function at(t,e,n){var r,i,o;$(0+(n?1:0),3),r=t,i=e,o=!0,ot(),L=8,o&&(Z(i),Z(~i)),G.pending_buf.set(g.subarray(r,r+i),G.pending),G.pending+=i}function e(t,e,n){var r,i,o=0;0<q?(V.build_tree(G),Y.build_tree(G),o=function(){var t;for(K(s,V.max_code),K(j,Y.max_code),X.build_tree(G),t=18;3<=t&&0===D[2*ut.bl_order[t]+1];t--);return G.opt_len+=3*(t+1)+5+5+4,t}(),r=G.opt_len+3+7>>>3,(i=G.static_len+3+7>>>3)<=r&&(r=i)):r=i=e+5,e+4<=r&&-1!=t?at(t,e,n):i==r?($(2+(n?1:0),3),it(ft.static_ltree,ft.static_dtree)):($(4+(n?1:0),3),function(t,e,n){var r;for($(t-257,5),$(e-1,5),$(n-4,4),r=0;r<n;r++)$(D[2*ut.bl_order[r]+1],3);et(s,t-1),et(j,e-1)}(V.max_code+1,Y.max_code+1,o+1),it(s,j)),J(),n&&ot()}function st(t){e(0<=S?S:-1,I-S,t),S=I,h.flush_pending()}function ht(){var t,e,n,r;do{if(0===(r=i-T-I)&&0===I&&0===T)r=f;else if(-1==r)r--;else if(f+f-gt<=I){for(g.set(g.subarray(f,f+f),0),C-=f,I-=f,S-=f,n=t=v;e=65535&w[--n],w[n]=f<=e?e-f:0,0!=--t;);for(n=t=f;e=65535&m[--n],m[n]=f<=e?e-f:0,0!=--t;);r+=f}if(0===h.avail_in)return;t=h.read_buf(g,I+T,r),3<=(T+=t)&&(y=((y=255&g[I])<<x^255&g[I+1])&b)}while(T<gt&&0!==h.avail_in)}function ct(t){var e,n,r=P,i=I,o=F,a=f-gt<I?I-(f-gt):0,s=R,h=p,c=I+258,l=g[i+o-1],u=g[i+o];B<=F&&(r>>=2),T<s&&(s=T);do{if(g[(e=t)+o]==u&&g[e+o-1]==l&&g[e]==g[i]&&g[++e]==g[i+1]){i+=2,e++;do{}while(g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&g[++i]==g[++e]&&i<c);if(n=258-(c-i),i=c-258,o<n){if(C=t,s<=(o=n))break;l=g[i+o-1],u=g[i+o]}}}while((t=65535&m[t&h])>a&&0!=--r);return o<=T?o:T}function lt(t){return t.total_in=t.total_out=0,t.msg=null,G.pending=0,G.pending_out=0,c=113,u=0,V.dyn_tree=s,V.stat_desc=ft.static_l_desc,Y.dyn_tree=j,Y.stat_desc=ft.static_d_desc,X.dyn_tree=D,X.stat_desc=ft.static_bl_desc,W=H=0,L=8,J(),function(){var t;for(i=2*f,t=w[v-1]=0;t<v-1;t++)w[t]=0;E=dt[q].max_lazy,B=dt[q].good_length,R=dt[q].nice_length,P=dt[q].max_chain,k=F=2,y=A=T=S=I=0}(),0}G.depth=[],G.bl_count=[],G.heap=[],s=[],j=[],D=[],G.pqdownheap=function(t,e){for(var n=G.heap,r=n[e],i=e<<1;i<=G.heap_len&&(i<G.heap_len&&mt(t,n[i+1],n[i],G.depth)&&i++,!mt(t,r,n[i],G.depth));)n[e]=n[i],e=i,i<<=1;n[e]=r},G.deflateInit=function(t,e,n,r,i,o){return r||(r=8),i||(i=8),o||(o=0),t.msg=null,-1==e&&(e=6),i<1||9<i||8!=r||n<9||15<n||e<0||9<e||o<0||2<o?-2:(t.dstate=G,p=(f=1<<(d=n))-1,b=(v=1<<(a=i+7))-1,x=Math.floor((a+3-1)/3),g=new Uint8Array(2*f),m=[],w=[],U=1<<i+6,G.pending_buf=new Uint8Array(4*U),l=4*U,z=Math.floor(U/2),M=3*U,q=e,O=o,lt(t))},G.deflateEnd=function(){return 42!=c&&113!=c&&666!=c?-2:(G.pending_buf=null,g=m=w=null,G.dstate=null,113==c?-3:0)},G.deflateParams=function(t,e,n){var r=0;return-1==e&&(e=6),e<0||9<e||n<0||2<n?-2:(dt[q].func!=dt[e].func&&0!==t.total_in&&(r=t.deflate(1)),q!=e&&(E=dt[q=e].max_lazy,B=dt[q].good_length,R=dt[q].nice_length,P=dt[q].max_chain),O=n,r)},G.deflateSetDictionary=function(t,e,n){var r,i=n,o=0;if(!e||42!=c)return-2;if(i<3)return 0;for(f-gt<i&&(o=n-(i=f-gt)),g.set(e.subarray(o,o+i),0),S=I=i,y=((y=255&g[0])<<x^255&g[1])&b,r=0;r<=i-3;r++)y=(y<<x^255&g[r+2])&b,m[r&p]=w[y],w[y]=r;return 0},G.deflate=function(t,e){var n,r,i,o,a,s;if(4<e||e<0)return-2;if(!t.next_out||!t.next_in&&0!==t.avail_in||666==c&&4!=e)return t.msg=pt[4],-2;if(0===t.avail_out)return t.msg=pt[7],-5;if(h=t,o=u,u=e,42==c&&(r=8+(d-8<<4)<<8,3<(i=(q-1&255)>>1)&&(i=3),r|=i<<6,0!==I&&(r|=32),c=113,Q((s=r+=31-r%31)>>8&255),Q(255&s)),0!==G.pending){if(h.flush_pending(),0===h.avail_out)return u=-1,0}else if(0===h.avail_in&&e<=o&&4!=e)return h.msg=pt[7],-5;if(666==c&&0!==h.avail_in)return t.msg=pt[7],-5;if(0!==h.avail_in||0!==T||0!=e&&666!=c){switch(a=-1,dt[q].func){case 0:a=function(t){var e,n=65535;for(l-5<n&&(n=l-5);;){if(T<=1){if(ht(),0===T&&0==t)return 0;if(0===T)break}if(I+=T,e=S+n,((T=0)===I||e<=I)&&(T=I-e,I=e,st(!1),0===h.avail_out))return 0;if(f-gt<=I-S&&(st(!1),0===h.avail_out))return 0}return st(4==t),0===h.avail_out?4==t?2:0:4==t?3:1}(e);break;case 1:a=function(t){for(var e,n=0;;){if(T<gt){if(ht(),T<gt&&0==t)return 0;if(0===T)break}if(3<=T&&(y=(y<<x^255&g[I+2])&b,n=65535&w[y],m[I&p]=w[y],w[y]=I),0!==n&&(I-n&65535)<=f-gt&&2!=O&&(k=ct(n)),3<=k)if(e=rt(I-C,k-3),T-=k,k<=E&&3<=T){for(k--;y=(y<<x^255&g[++I+2])&b,n=65535&w[y],m[I&p]=w[y],w[y]=I,0!=--k;);I++}else I+=k,k=0,y=((y=255&g[I])<<x^255&g[I+1])&b;else e=rt(0,255&g[I]),T--,I++;if(e&&(st(!1),0===h.avail_out))return 0}return st(4==t),0===h.avail_out?4==t?2:0:4==t?3:1}(e);break;case 2:a=function(t){for(var e,n,r=0;;){if(T<gt){if(ht(),T<gt&&0==t)return 0;if(0===T)break}if(3<=T&&(y=(y<<x^255&g[I+2])&b,r=65535&w[y],m[I&p]=w[y],w[y]=I),F=k,_=C,k=2,0!==r&&F<E&&(I-r&65535)<=f-gt&&(2!=O&&(k=ct(r)),k<=5&&(1==O||3==k&&4096<I-C)&&(k=2)),3<=F&&k<=F){for(n=I+T-3,e=rt(I-1-_,F-3),T-=F-1,F-=2;++I<=n&&(y=(y<<x^255&g[I+2])&b,r=65535&w[y],m[I&p]=w[y],w[y]=I),0!=--F;);if(A=0,k=2,I++,e&&(st(!1),0===h.avail_out))return 0}else if(0!==A){if((e=rt(0,255&g[I-1]))&&st(!1),I++,T--,0===h.avail_out)return 0}else A=1,I++,T--}return 0!==A&&(e=rt(0,255&g[I-1]),A=0),st(4==t),0===h.avail_out?4==t?2:0:4==t?3:1}(e)}if(2!=a&&3!=a||(c=666),0==a||2==a)return 0===h.avail_out&&(u=-1),0;if(1==a){if(1==e)$(2,3),tt(256,ft.static_ltree),nt(),1+L+10-W<9&&($(2,3),tt(256,ft.static_ltree),nt()),L=7;else if(at(0,0,!1),3==e)for(n=0;n<v;n++)w[n]=0;if(h.flush_pending(),0===h.avail_out)return u=-1,0}}return 4!=e?0:1}}function i(){var t=this;t.next_in_index=0,t.next_out_index=0,t.avail_in=0,t.total_in=0,t.avail_out=0,t.total_out=0}i.prototype={deflateInit:function(t,e){return this.dstate=new r,e||(e=p),this.dstate.deflateInit(this,t,e)},deflate:function(t){return this.dstate?this.dstate.deflate(this,t):-2},deflateEnd:function(){if(!this.dstate)return-2;var t=this.dstate.deflateEnd();return this.dstate=null,t},deflateParams:function(t,e){return this.dstate?this.dstate.deflateParams(this,t,e):-2},deflateSetDictionary:function(t,e){return this.dstate?this.dstate.deflateSetDictionary(this,t,e):-2},read_buf:function(t,e,n){var r=this,i=r.avail_in;return n<i&&(i=n),0===i?0:(r.avail_in-=i,t.set(r.next_in.subarray(r.next_in_index,r.next_in_index+i),e),r.next_in_index+=i,r.total_in+=i,i)},flush_pending:function(){var t=this,e=t.dstate.pending;e>t.avail_out&&(e=t.avail_out),0!==e&&(t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out,t.dstate.pending_out+e),t.next_out_index),t.next_out_index+=e,t.dstate.pending_out+=e,t.total_out+=e,t.avail_out-=e,t.dstate.pending-=e,0===t.dstate.pending&&(t.dstate.pending_out=0))}};var o=t.zip||t;o.Deflater=o._jzlib_Deflater=function(t){var s=new i,h=new Uint8Array(512),e=t?t.level:-1;void 0===e&&(e=-1),s.deflateInit(e),s.next_out=h,this.append=function(t,e){var n,r=[],i=0,o=0,a=0;if(t.length){s.next_in_index=0,s.next_in=t,s.avail_in=t.length;do{if(s.next_out_index=0,s.avail_out=512,0!=s.deflate(0))throw new Error("deflating: "+s.msg);s.next_out_index&&(512==s.next_out_index?r.push(new Uint8Array(h)):r.push(new Uint8Array(h.subarray(0,s.next_out_index)))),a+=s.next_out_index,e&&0<s.next_in_index&&s.next_in_index!=i&&(e(s.next_in_index),i=s.next_in_index)}while(0<s.avail_in||0===s.avail_out);return n=new Uint8Array(a),r.forEach(function(t){n.set(t,o),o+=t.length}),n}},this.flush=function(){var t,e,n=[],r=0,i=0;do{if(s.next_out_index=0,s.avail_out=512,1!=(t=s.deflate(4))&&0!=t)throw new Error("deflating: "+s.msg);0<512-s.avail_out&&n.push(new Uint8Array(h.subarray(0,s.next_out_index))),i+=s.next_out_index}while(0<s.avail_in||0===s.avail_out);return s.deflateEnd(),e=new Uint8Array(i),n.forEach(function(t){e.set(t,r),r+=t.length}),e}}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||"undefined"!=typeof global&&global||Function('return typeof this === "object" && this.content')()||Function("return this")()),
/**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
   * @license Use it if you like it
   */
function(t){function f(t){var e;this.ok=!1,"#"==t.charAt(0)&&(t=t.substr(1,6)),t=(t=t.replace(/ /g,"")).toLowerCase();var l={aliceblue:"f0f8ff",antiquewhite:"faebd7",aqua:"00ffff",aquamarine:"7fffd4",azure:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"000000",blanchedalmond:"ffebcd",blue:"0000ff",blueviolet:"8a2be2",brown:"a52a2a",burlywood:"deb887",cadetblue:"5f9ea0",chartreuse:"7fff00",chocolate:"d2691e",coral:"ff7f50",cornflowerblue:"6495ed",cornsilk:"fff8dc",crimson:"dc143c",cyan:"00ffff",darkblue:"00008b",darkcyan:"008b8b",darkgoldenrod:"b8860b",darkgray:"a9a9a9",darkgreen:"006400",darkkhaki:"bdb76b",darkmagenta:"8b008b",darkolivegreen:"556b2f",darkorange:"ff8c00",darkorchid:"9932cc",darkred:"8b0000",darksalmon:"e9967a",darkseagreen:"8fbc8f",darkslateblue:"483d8b",darkslategray:"2f4f4f",darkturquoise:"00ced1",darkviolet:"9400d3",deeppink:"ff1493",deepskyblue:"00bfff",dimgray:"696969",dodgerblue:"1e90ff",feldspar:"d19275",firebrick:"b22222",floralwhite:"fffaf0",forestgreen:"228b22",fuchsia:"ff00ff",gainsboro:"dcdcdc",ghostwhite:"f8f8ff",gold:"ffd700",goldenrod:"daa520",gray:"808080",green:"008000",greenyellow:"adff2f",honeydew:"f0fff0",hotpink:"ff69b4",indianred:"cd5c5c",indigo:"4b0082",ivory:"fffff0",khaki:"f0e68c",lavender:"e6e6fa",lavenderblush:"fff0f5",lawngreen:"7cfc00",lemonchiffon:"fffacd",lightblue:"add8e6",lightcoral:"f08080",lightcyan:"e0ffff",lightgoldenrodyellow:"fafad2",lightgrey:"d3d3d3",lightgreen:"90ee90",lightpink:"ffb6c1",lightsalmon:"ffa07a",lightseagreen:"20b2aa",lightskyblue:"87cefa",lightslateblue:"8470ff",lightslategray:"778899",lightsteelblue:"b0c4de",lightyellow:"ffffe0",lime:"00ff00",limegreen:"32cd32",linen:"faf0e6",magenta:"ff00ff",maroon:"800000",mediumaquamarine:"66cdaa",mediumblue:"0000cd",mediumorchid:"ba55d3",mediumpurple:"9370d8",mediumseagreen:"3cb371",mediumslateblue:"7b68ee",mediumspringgreen:"00fa9a",mediumturquoise:"48d1cc",mediumvioletred:"c71585",midnightblue:"191970",mintcream:"f5fffa",mistyrose:"ffe4e1",moccasin:"ffe4b5",navajowhite:"ffdead",navy:"000080",oldlace:"fdf5e6",olive:"808000",olivedrab:"6b8e23",orange:"ffa500",orangered:"ff4500",orchid:"da70d6",palegoldenrod:"eee8aa",palegreen:"98fb98",paleturquoise:"afeeee",palevioletred:"d87093",papayawhip:"ffefd5",peachpuff:"ffdab9",peru:"cd853f",pink:"ffc0cb",plum:"dda0dd",powderblue:"b0e0e6",purple:"800080",red:"ff0000",rosybrown:"bc8f8f",royalblue:"4169e1",saddlebrown:"8b4513",salmon:"fa8072",sandybrown:"f4a460",seagreen:"2e8b57",seashell:"fff5ee",sienna:"a0522d",silver:"c0c0c0",skyblue:"87ceeb",slateblue:"6a5acd",slategray:"708090",snow:"fffafa",springgreen:"00ff7f",steelblue:"4682b4",tan:"d2b48c",teal:"008080",thistle:"d8bfd8",tomato:"ff6347",turquoise:"40e0d0",violet:"ee82ee",violetred:"d02090",wheat:"f5deb3",white:"ffffff",whitesmoke:"f5f5f5",yellow:"ffff00",yellowgreen:"9acd32"};for(var n in l)t==n&&(t=l[n]);for(var u=[{re:/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,example:["rgb(123, 234, 45)","rgb(255,234,245)"],process:function(t){return[parseInt(t[1]),parseInt(t[2]),parseInt(t[3])]}},{re:/^(\w{2})(\w{2})(\w{2})$/,example:["#00ff00","336699"],process:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/^(\w{1})(\w{1})(\w{1})$/,example:["#fb0","f0f"],process:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}}],r=0;r<u.length;r++){var i=u[r].re,o=u[r].process,a=i.exec(t);a&&(e=o(a),this.r=e[0],this.g=e[1],this.b=e[2],this.ok=!0)}this.r=this.r<0||isNaN(this.r)?0:255<this.r?255:this.r,this.g=this.g<0||isNaN(this.g)?0:255<this.g?255:this.g,this.b=this.b<0||isNaN(this.b)?0:255<this.b?255:this.b,this.toRGB=function(){return"rgb("+this.r+", "+this.g+", "+this.b+")"},this.toHex=function(){var t=this.r.toString(16),e=this.g.toString(16),n=this.b.toString(16);return 1==t.length&&(t="0"+t),1==e.length&&(e="0"+e),1==n.length&&(n="0"+n),"#"+t+e+n},this.getHelpXML=function(){for(var t=new Array,e=0;e<u.length;e++)for(var n=u[e].example,r=0;r<n.length;r++)t[t.length]=n[r];for(var i in l)t[t.length]=i;var o=document.createElement("ul");o.setAttribute("id","rgbcolor-examples");for(e=0;e<t.length;e++)try{var a=document.createElement("li"),s=new f(t[e]),h=document.createElement("div");h.style.cssText="margin: 3px; border: 1px solid black; background:"+s.toHex()+"; color:"+s.toHex(),h.appendChild(document.createTextNode("test"));var c=document.createTextNode(" "+t[e]+" -> "+s.toRGB()+" -> "+s.toHex());a.appendChild(h),a.appendChild(c),o.appendChild(a)}catch(t){}return o}}"undefined"!=typeof define&&define.amd?define("RGBColor",function(){return f}):"undefined"!=typeof module&&module.exports&&(module.exports=f),t.RGBColor=f}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||"undefined"!=typeof global&&global||Function('return typeof this === "object" && this.content')()||Function("return this")()),function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.html2canvas=t()}}(function(){return function o(a,s,h){function c(n,t){if(!s[n]){if(!a[n]){var e="function"==typeof require&&require;if(!t&&e)return e(n,!0);if(l)return l(n,!0);var r=new Error("Cannot find module '"+n+"'");throw r.code="MODULE_NOT_FOUND",r}var i=s[n]={exports:{}};a[n][0].call(i.exports,function(t){var e=a[n][1][t];return c(e||t)},i,i.exports,o,a,s,h)}return s[n].exports}for(var l="function"==typeof require&&require,t=0;t<h.length;t++)c(h[t]);return c}({1:[function(t,q,O){(function(E){!function(t){var e="object"==typeof O&&O,n="object"==typeof q&&q&&q.exports==e&&q,r="object"==typeof E&&E;r.global!==r&&r.window!==r||(t=r);var i,o,w=2147483647,y=36,v=1,b=26,a=38,s=700,x=72,S=128,k="-",h=/^xn--/,c=/[^ -~]/,l=/\x2E|\u3002|\uFF0E|\uFF61/g,u={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},f=y-v,_=Math.floor,A=String.fromCharCode;function I(t){throw RangeError(u[t])}function d(t,e){for(var n=t.length;n--;)t[n]=e(t[n]);return t}function p(t,e){return d(t.split(l),e).join(".")}function C(t){for(var e,n,r=[],i=0,o=t.length;i<o;)55296<=(e=t.charCodeAt(i++))&&e<=56319&&i<o?56320==(64512&(n=t.charCodeAt(i++)))?r.push(((1023&e)<<10)+(1023&n)+65536):(r.push(e),i--):r.push(e);return r}function T(t){return d(t,function(t){var e="";return 65535<t&&(e+=A((t-=65536)>>>10&1023|55296),t=56320|1023&t),e+=A(t)}).join("")}function F(t,e){return t+22+75*(t<26)-((0!=e)<<5)}function P(t,e,n){var r=0;for(t=n?_(t/s):t>>1,t+=_(t/e);f*b>>1<t;r+=y)t=_(t/f);return _(r+(f+1)*t/(t+a))}function g(t){var e,n,r,i,o,a,s,h,c,l,u,f=[],d=t.length,p=0,g=S,m=x;for((n=t.lastIndexOf(k))<0&&(n=0),r=0;r<n;++r)128<=t.charCodeAt(r)&&I("not-basic"),f.push(t.charCodeAt(r));for(i=0<n?n+1:0;i<d;){for(o=p,a=1,s=y;d<=i&&I("invalid-input"),u=t.charCodeAt(i++),(y<=(h=u-48<10?u-22:u-65<26?u-65:u-97<26?u-97:y)||h>_((w-p)/a))&&I("overflow"),p+=h*a,!(h<(c=s<=m?v:m+b<=s?b:s-m));s+=y)a>_(w/(l=y-c))&&I("overflow"),a*=l;m=P(p-o,e=f.length+1,0==o),_(p/e)>w-g&&I("overflow"),g+=_(p/e),p%=e,f.splice(p++,0,g)}return T(f)}function m(t){var e,n,r,i,o,a,s,h,c,l,u,f,d,p,g,m=[];for(f=(t=C(t)).length,e=S,o=x,a=n=0;a<f;++a)(u=t[a])<128&&m.push(A(u));for(r=i=m.length,i&&m.push(k);r<f;){for(s=w,a=0;a<f;++a)e<=(u=t[a])&&u<s&&(s=u);for(s-e>_((w-n)/(d=r+1))&&I("overflow"),n+=(s-e)*d,e=s,a=0;a<f;++a)if((u=t[a])<e&&++n>w&&I("overflow"),u==e){for(h=n,c=y;!(h<(l=c<=o?v:o+b<=c?b:c-o));c+=y)g=h-l,p=y-l,m.push(A(F(l+g%p,0))),h=_(g/p);m.push(A(F(h,0))),o=P(n,d,r==i),n=0,++r}++n,++e}return m.join("")}if(i={version:"1.2.4",ucs2:{decode:C,encode:T},decode:g,encode:m,toASCII:function(t){return p(t,function(t){return c.test(t)?"xn--"+m(t):t})},toUnicode:function(t){return p(t,function(t){return h.test(t)?g(t.slice(4).toLowerCase()):t})}},e&&!e.nodeType)if(n)n.exports=i;else for(o in i)i.hasOwnProperty(o)&&(e[o]=i[o]);else t.punycode=i}(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],2:[function(t,e,n){var i=t("./log");function u(t,e){for(var n=3===t.nodeType?document.createTextNode(t.nodeValue):t.cloneNode(!1),r=t.firstChild;r;)!0!==e&&1===r.nodeType&&"SCRIPT"===r.nodeName||n.appendChild(u(r,e)),r=r.nextSibling;return 1===t.nodeType&&(n._scrollTop=t.scrollTop,n._scrollLeft=t.scrollLeft,"CANVAS"===t.nodeName?function(e,t){try{t&&(t.width=e.width,t.height=e.height,t.getContext("2d").putImageData(e.getContext("2d").getImageData(0,0,e.width,e.height),0,0))}catch(t){i("Unable to copy canvas content from",e,t)}}(t,n):"TEXTAREA"!==t.nodeName&&"SELECT"!==t.nodeName||(n.value=t.value)),n}e.exports=function(o,t,e,n,a,s,h){var c=u(o.documentElement,a.javascriptEnabled),l=t.createElement("iframe");return l.className="html2canvas-container",l.style.visibility="hidden",l.style.position="fixed",l.style.left="-10000px",l.style.top="0px",l.style.border="0",l.width=e,l.height=n,l.scrolling="no",t.body.appendChild(l),new Promise(function(e){var t,n,r,i=l.contentWindow.document;l.contentWindow.onload=l.onload=function(){var t=setInterval(function(){0<i.body.childNodes.length&&(!function t(e){if(1===e.nodeType){e.scrollTop=e._scrollTop,e.scrollLeft=e._scrollLeft;for(var n=e.firstChild;n;)t(n),n=n.nextSibling}}(i.documentElement),clearInterval(t),"view"===a.type&&(l.contentWindow.scrollTo(s,h),!/(iPad|iPhone|iPod)/g.test(navigator.userAgent)||l.contentWindow.scrollY===h&&l.contentWindow.scrollX===s||(i.documentElement.style.top=-h+"px",i.documentElement.style.left=-s+"px",i.documentElement.style.position="absolute")),e(l))},50)},i.open(),i.write("<!DOCTYPE html><html></html>"),n=s,r=h,!(t=o).defaultView||n===t.defaultView.pageXOffset&&r===t.defaultView.pageYOffset||t.defaultView.scrollTo(n,r),i.replaceChild(i.adoptNode(c),i.documentElement),i.close()})}},{"./log":13}],3:[function(t,e,n){function r(t){this.r=0,this.g=0,this.b=0,this.a=null;this.fromArray(t)||this.namedColor(t)||this.rgb(t)||this.rgba(t)||this.hex6(t)||this.hex3(t)}r.prototype.darken=function(t){var e=1-t;return new r([Math.round(this.r*e),Math.round(this.g*e),Math.round(this.b*e),this.a])},r.prototype.isTransparent=function(){return 0===this.a},r.prototype.isBlack=function(){return 0===this.r&&0===this.g&&0===this.b},r.prototype.fromArray=function(t){return Array.isArray(t)&&(this.r=Math.min(t[0],255),this.g=Math.min(t[1],255),this.b=Math.min(t[2],255),3<t.length&&(this.a=t[3])),Array.isArray(t)};var i=/^#([a-f0-9]{3})$/i;r.prototype.hex3=function(t){var e;return null!==(e=t.match(i))&&(this.r=parseInt(e[1][0]+e[1][0],16),this.g=parseInt(e[1][1]+e[1][1],16),this.b=parseInt(e[1][2]+e[1][2],16)),null!==e};var o=/^#([a-f0-9]{6})$/i;r.prototype.hex6=function(t){var e=null;return null!==(e=t.match(o))&&(this.r=parseInt(e[1].substring(0,2),16),this.g=parseInt(e[1].substring(2,4),16),this.b=parseInt(e[1].substring(4,6),16)),null!==e};var a=/^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;r.prototype.rgb=function(t){var e;return null!==(e=t.match(a))&&(this.r=Number(e[1]),this.g=Number(e[2]),this.b=Number(e[3])),null!==e};var s=/^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;r.prototype.rgba=function(t){var e;return null!==(e=t.match(s))&&(this.r=Number(e[1]),this.g=Number(e[2]),this.b=Number(e[3]),this.a=Number(e[4])),null!==e},r.prototype.toString=function(){return null!==this.a&&1!==this.a?"rgba("+[this.r,this.g,this.b,this.a].join(",")+")":"rgb("+[this.r,this.g,this.b].join(",")+")"},r.prototype.namedColor=function(t){t=t.toLowerCase();var e=h[t];if(e)this.r=e[0],this.g=e[1],this.b=e[2];else if("transparent"===t)return this.r=this.g=this.b=this.a=0,!0;return!!e},r.prototype.isColor=!0;var h={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]};e.exports=r},{}],4:[function(t,e,n){var p=t("./support"),d=t("./renderers/canvas"),g=t("./imageloader"),m=t("./nodeparser"),r=t("./nodecontainer"),w=t("./log"),i=t("./utils"),y=t("./clone"),v=t("./proxy").loadUrlDocument,b=i.getBounds,x="data-html2canvas-node",S=0;function o(t,e){var n,r,i=S++;if((e=e||{}).logging&&(w.options.logging=!0,w.options.start=Date.now()),e.async=void 0===e.async||e.async,e.allowTaint=void 0!==e.allowTaint&&e.allowTaint,e.removeContainer=void 0===e.removeContainer||e.removeContainer,e.javascriptEnabled=void 0!==e.javascriptEnabled&&e.javascriptEnabled,e.imageTimeout=void 0===e.imageTimeout?1e4:e.imageTimeout,e.renderer="function"==typeof e.renderer?e.renderer:d,e.strict=!!e.strict,"string"==typeof t){if("string"!=typeof e.proxy)return Promise.reject("Proxy must be used when rendering url");var o=null!=e.width?e.width:window.innerWidth,a=null!=e.height?e.height:window.innerHeight;return v((n=t,r=document.createElement("a"),r.href=n,r.href=r.href,r),e.proxy,document,o,a,e).then(function(t){return k(t.contentWindow.document.documentElement,t,e,o,a)})}var s,h,c,l,u,f=(void 0===t?[document.documentElement]:t.length?t:[t])[0];return f.setAttribute(x+i,i),(s=f.ownerDocument,h=e,c=f.ownerDocument.defaultView.innerWidth,l=f.ownerDocument.defaultView.innerHeight,u=i,y(s,s,c,l,h,s.defaultView.pageXOffset,s.defaultView.pageYOffset).then(function(t){w("Document cloned");var e=x+u,n="["+e+"='"+u+"']";s.querySelector(n).removeAttribute(e);var r=t.contentWindow,i=r.document.querySelector(n),o="function"==typeof h.onclone?Promise.resolve(h.onclone(r.document)):Promise.resolve(!0);return o.then(function(){return k(i,t,h,c,l)})})).then(function(t){return"function"==typeof e.onrendered&&(w("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas"),e.onrendered(t)),t})}o.CanvasRenderer=d,o.NodeContainer=r,o.log=w,o.utils=i;var a="undefined"==typeof document||"function"!=typeof Object.create||"function"!=typeof document.createElement("canvas").getContext?function(){return Promise.reject("No canvas support")}:o;function k(n,r,i,t,e){var o,a,s=r.contentWindow,h=new p(s.document),c=new g(i,h),l=b(n),u="view"===i.type?t:(o=s.document,Math.max(Math.max(o.body.scrollWidth,o.documentElement.scrollWidth),Math.max(o.body.offsetWidth,o.documentElement.offsetWidth),Math.max(o.body.clientWidth,o.documentElement.clientWidth))),f="view"===i.type?e:(a=s.document,Math.max(Math.max(a.body.scrollHeight,a.documentElement.scrollHeight),Math.max(a.body.offsetHeight,a.documentElement.offsetHeight),Math.max(a.body.clientHeight,a.documentElement.clientHeight))),d=new i.renderer(u,f,c,i,document);return new m(n,d,h,c,i).ready.then(function(){var t,e;return w("Finished rendering"),t="view"===i.type?_(d.canvas,{width:d.canvas.width,height:d.canvas.height,top:0,left:0,x:0,y:0}):n===s.document.body||n===s.document.documentElement||null!=i.canvas?d.canvas:_(d.canvas,{width:null!=i.width?i.width:l.width,height:null!=i.height?i.height:l.height,top:l.top,left:l.left,x:0,y:0}),e=r,i.removeContainer&&(e.parentNode.removeChild(e),w("Cleaned up container")),t})}function _(t,e){var n=document.createElement("canvas"),r=Math.min(t.width-1,Math.max(0,e.left)),i=Math.min(t.width,Math.max(1,e.left+e.width)),o=Math.min(t.height-1,Math.max(0,e.top)),a=Math.min(t.height,Math.max(1,e.top+e.height));n.width=e.width,n.height=e.height;var s=i-r,h=a-o;return w("Cropping canvas at:","left:",e.left,"top:",e.top,"width:",s,"height:",h),w("Resulting crop with width",e.width,"and height",e.height,"with x",r,"and y",o),n.getContext("2d").drawImage(t,r,o,s,h,e.x,e.y,s,h),n}e.exports=a},{"./clone":2,"./imageloader":11,"./log":13,"./nodecontainer":14,"./nodeparser":15,"./proxy":16,"./renderers/canvas":20,"./support":22,"./utils":26}],5:[function(t,e,n){var r=t("./log"),i=t("./utils").smallImage;e.exports=function t(e){if(this.src=e,r("DummyImageContainer for",e),!this.promise||!this.image){r("Initiating DummyImageContainer"),t.prototype.image=new Image;var n=this.image;t.prototype.promise=new Promise(function(t,e){n.onload=t,n.onerror=e,n.src=i(),!0===n.complete&&t(n)})}}},{"./log":13,"./utils":26}],6:[function(t,e,n){var h=t("./utils").smallImage;e.exports=function(t,e){var n,r,i=document.createElement("div"),o=document.createElement("img"),a=document.createElement("span"),s="Hidden Text";i.style.visibility="hidden",i.style.fontFamily=t,i.style.fontSize=e,i.style.margin=0,i.style.padding=0,document.body.appendChild(i),o.src=h(),o.width=1,o.height=1,o.style.margin=0,o.style.padding=0,o.style.verticalAlign="baseline",a.style.fontFamily=t,a.style.fontSize=e,a.style.margin=0,a.style.padding=0,a.appendChild(document.createTextNode(s)),i.appendChild(a),i.appendChild(o),n=o.offsetTop-a.offsetTop+1,i.removeChild(a),i.appendChild(document.createTextNode(s)),i.style.lineHeight="normal",o.style.verticalAlign="super",r=o.offsetTop-i.offsetTop+1,document.body.removeChild(i),this.baseline=n,this.lineWidth=1,this.middle=r}},{"./utils":26}],7:[function(t,e,n){var r=t("./font");function i(){this.data={}}i.prototype.getMetrics=function(t,e){return void 0===this.data[t+"-"+e]&&(this.data[t+"-"+e]=new r(t,e)),this.data[t+"-"+e]},e.exports=i},{"./font":6}],8:[function(o,t,e){var a=o("./utils").getBounds,i=o("./proxy").loadUrlDocument;function n(e,t,n){this.image=null,this.src=e;var r=this,i=a(e);this.promise=(t?new Promise(function(t){"about:blank"===e.contentWindow.document.URL||null==e.contentWindow.document.documentElement?e.contentWindow.onload=e.onload=function(){t(e)}:t(e)}):this.proxyLoad(n.proxy,i,n)).then(function(t){return o("./core")(t.contentWindow.document.documentElement,{type:"view",width:t.width,height:t.height,proxy:n.proxy,javascriptEnabled:n.javascriptEnabled,removeContainer:n.removeContainer,allowTaint:n.allowTaint,imageTimeout:n.imageTimeout/2})}).then(function(t){return r.image=t})}n.prototype.proxyLoad=function(t,e,n){var r=this.src;return i(r.src,t,r.ownerDocument,e.width,e.height,n)},t.exports=n},{"./core":4,"./proxy":16,"./utils":26}],9:[function(t,e,n){function r(t){this.src=t.value,this.colorStops=[],this.type=null,this.x0=.5,this.y0=.5,this.x1=.5,this.y1=.5,this.promise=Promise.resolve(!0)}r.TYPES={LINEAR:1,RADIAL:2},r.REGEXP_COLORSTOP=/^\s*(rgba?\(\s*\d{1,3},\s*\d{1,3},\s*\d{1,3}(?:,\s*[0-9\.]+)?\s*\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\s+(\d{1,3}(?:\.\d+)?)(%|px)?)?(?:\s|$)/i,e.exports=r},{}],10:[function(t,e,n){e.exports=function(n,r){this.src=n,this.image=new Image;var i=this;this.tainted=null,this.promise=new Promise(function(t,e){i.image.onload=t,i.image.onerror=e,r&&(i.image.crossOrigin="anonymous"),i.image.src=n,!0===i.image.complete&&t(i.image)})}},{}],11:[function(t,e,n){var o=t("./log"),r=t("./imagecontainer"),i=t("./dummyimagecontainer"),a=t("./proxyimagecontainer"),s=t("./framecontainer"),h=t("./svgcontainer"),c=t("./svgnodecontainer"),l=t("./lineargradientcontainer"),u=t("./webkitgradientcontainer"),f=t("./utils").bind;function d(t,e){this.link=null,this.options=t,this.support=e,this.origin=this.getOrigin(window.location.href)}d.prototype.findImages=function(t){var e=[];return t.reduce(function(t,e){switch(e.node.nodeName){case"IMG":return t.concat([{args:[e.node.src],method:"url"}]);case"svg":case"IFRAME":return t.concat([{args:[e.node],method:e.node.nodeName}])}return t},[]).forEach(this.addImage(e,this.loadImage),this),e},d.prototype.findBackgroundImage=function(t,e){return e.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(t,this.loadImage),this),t},d.prototype.addImage=function(n,r){return function(e){e.args.forEach(function(t){this.imageExists(n,t)||(n.splice(0,0,r.call(this,e)),o("Added image #"+n.length,"string"==typeof t?t.substring(0,100):t))},this)}},d.prototype.hasImageBackground=function(t){return"none"!==t.method},d.prototype.loadImage=function(t){if("url"===t.method){var e=t.args[0];return!this.isSVG(e)||this.support.svg||this.options.allowTaint?e.match(/data:image\/.*;base64,/i)?new r(e.replace(/url\(['"]{0,}|['"]{0,}\)$/gi,""),!1):this.isSameOrigin(e)||!0===this.options.allowTaint||this.isSVG(e)?new r(e,!1):this.support.cors&&!this.options.allowTaint&&this.options.useCORS?new r(e,!0):this.options.proxy?new a(e,this.options.proxy):new i(e):new h(e)}return"linear-gradient"===t.method?new l(t):"gradient"===t.method?new u(t):"svg"===t.method?new c(t.args[0],this.support.svg):"IFRAME"===t.method?new s(t.args[0],this.isSameOrigin(t.args[0].src),this.options):new i(t)},d.prototype.isSVG=function(t){return"svg"===t.substring(t.length-3).toLowerCase()||h.prototype.isInline(t)},d.prototype.imageExists=function(t,e){return t.some(function(t){return t.src===e})},d.prototype.isSameOrigin=function(t){return this.getOrigin(t)===this.origin},d.prototype.getOrigin=function(t){var e=this.link||(this.link=document.createElement("a"));return e.href=t,e.href=e.href,e.protocol+e.hostname+e.port},d.prototype.getPromise=function(e){return this.timeout(e,this.options.imageTimeout).catch(function(){return new i(e.src).promise.then(function(t){e.image=t})})},d.prototype.get=function(e){var n=null;return this.images.some(function(t){return(n=t).src===e})?n:null},d.prototype.fetch=function(t){return this.images=t.reduce(f(this.findBackgroundImage,this),this.findImages(t)),this.images.forEach(function(e,n){e.promise.then(function(){o("Succesfully loaded image #"+(n+1),e)},function(t){o("Failed loading image #"+(n+1),e,t)})}),this.ready=Promise.all(this.images.map(this.getPromise,this)),o("Finished searching images"),this},d.prototype.timeout=function(n,r){var i,t=Promise.race([n.promise,new Promise(function(t,e){i=setTimeout(function(){o("Timed out loading image",n),e(n)},r)})]).then(function(t){return clearTimeout(i),t});return t.catch(function(){clearTimeout(i)}),t},e.exports=d},{"./dummyimagecontainer":5,"./framecontainer":8,"./imagecontainer":10,"./lineargradientcontainer":12,"./log":13,"./proxyimagecontainer":17,"./svgcontainer":23,"./svgnodecontainer":24,"./utils":26,"./webkitgradientcontainer":27}],12:[function(t,e,n){var i=t("./gradientcontainer"),o=t("./color");function r(t){i.apply(this,arguments),this.type=i.TYPES.LINEAR;var e=r.REGEXP_DIRECTION.test(t.args[0])||!i.REGEXP_COLORSTOP.test(t.args[0]);e?t.args[0].split(/\s+/).reverse().forEach(function(t,e){switch(t){case"left":this.x0=0,this.x1=1;break;case"top":this.y0=0,this.y1=1;break;case"right":this.x0=1,this.x1=0;break;case"bottom":this.y0=1,this.y1=0;break;case"to":var n=this.y0,r=this.x0;this.y0=this.y1,this.x0=this.x1,this.x1=r,this.y1=n;break;case"center":break;default:var i=.01*parseFloat(t,10);if(isNaN(i))break;0===e?(this.y0=i,this.y1=1-this.y0):(this.x0=i,this.x1=1-this.x0)}},this):(this.y0=0,this.y1=1),this.colorStops=t.args.slice(e?1:0).map(function(t){var e=t.match(i.REGEXP_COLORSTOP),n=+e[2],r=0===n?"%":e[3];return{color:new o(e[1]),stop:"%"===r?n/100:null}}),null===this.colorStops[0].stop&&(this.colorStops[0].stop=0),null===this.colorStops[this.colorStops.length-1].stop&&(this.colorStops[this.colorStops.length-1].stop=1),this.colorStops.forEach(function(n,r){null===n.stop&&this.colorStops.slice(r).some(function(t,e){return null!==t.stop&&(n.stop=(t.stop-this.colorStops[r-1].stop)/(e+1)+this.colorStops[r-1].stop,!0)},this)},this)}r.prototype=Object.create(i.prototype),r.REGEXP_DIRECTION=/^\s*(?:to|left|right|top|bottom|center|\d{1,3}(?:\.\d+)?%?)(?:\s|$)/i,e.exports=r},{"./color":3,"./gradientcontainer":9}],13:[function(t,e,n){var r=function(){r.options.logging&&window.console&&window.console.log&&Function.prototype.bind.call(window.console.log,window.console).apply(window.console,[Date.now()-r.options.start+"ms","html2canvas:"].concat([].slice.call(arguments,0)))};r.options={logging:!1},e.exports=r},{}],14:[function(t,e,n){var o=t("./color"),r=t("./utils"),i=r.getBounds,a=r.parseBackgrounds,s=r.offsetBounds;function h(t,e){this.node=t,this.parent=e,this.stack=null,this.bounds=null,this.borders=null,this.clip=[],this.backgroundClip=[],this.offsetBounds=null,this.visible=null,this.computedStyles=null,this.colors={},this.styles={},this.backgroundImages=null,this.transformData=null,this.transformMatrix=null,this.isPseudoElement=!1,this.opacity=null}function c(t){return-1!==t.toString().indexOf("%")}function l(t){return t.replace("px","")}function u(t){return parseFloat(t)}h.prototype.cloneTo=function(t){t.visible=this.visible,t.borders=this.borders,t.bounds=this.bounds,t.clip=this.clip,t.backgroundClip=this.backgroundClip,t.computedStyles=this.computedStyles,t.styles=this.styles,t.backgroundImages=this.backgroundImages,t.opacity=this.opacity},h.prototype.getOpacity=function(){return null===this.opacity?this.opacity=this.cssFloat("opacity"):this.opacity},h.prototype.assignStack=function(t){(this.stack=t).children.push(this)},h.prototype.isElementVisible=function(){return this.node.nodeType===Node.TEXT_NODE?this.parent.visible:"none"!==this.css("display")&&"hidden"!==this.css("visibility")&&!this.node.hasAttribute("data-html2canvas-ignore")&&("INPUT"!==this.node.nodeName||"hidden"!==this.node.getAttribute("type"))},h.prototype.css=function(t){return this.computedStyles||(this.computedStyles=this.isPseudoElement?this.parent.computedStyle(this.before?":before":":after"):this.computedStyle(null)),this.styles[t]||(this.styles[t]=this.computedStyles[t])},h.prototype.prefixedCss=function(e){var n=this.css(e);return void 0===n&&["webkit","moz","ms","o"].some(function(t){return void 0!==(n=this.css(t+e.substr(0,1).toUpperCase()+e.substr(1)))},this),void 0===n?null:n},h.prototype.computedStyle=function(t){return this.node.ownerDocument.defaultView.getComputedStyle(this.node,t)},h.prototype.cssInt=function(t){var e=parseInt(this.css(t),10);return isNaN(e)?0:e},h.prototype.color=function(t){return this.colors[t]||(this.colors[t]=new o(this.css(t)))},h.prototype.cssFloat=function(t){var e=parseFloat(this.css(t));return isNaN(e)?0:e},h.prototype.fontWeight=function(){var t=this.css("fontWeight");switch(parseInt(t,10)){case 401:t="bold";break;case 400:t="normal"}return t},h.prototype.parseClip=function(){var t=this.css("clip").match(this.CLIP);return t?{top:parseInt(t[1],10),right:parseInt(t[2],10),bottom:parseInt(t[3],10),left:parseInt(t[4],10)}:null},h.prototype.parseBackgroundImages=function(){return this.backgroundImages||(this.backgroundImages=a(this.css("backgroundImage")))},h.prototype.cssList=function(t,e){var n=(this.css(t)||"").split(",");return 1===(n=(n=n[e||0]||n[0]||"auto").trim().split(" ")).length&&(n=[n[0],c(n[0])?"auto":n[0]]),n},h.prototype.parseBackgroundSize=function(t,e,n){var r,i,o=this.cssList("backgroundSize",n);if(c(o[0]))r=t.width*parseFloat(o[0])/100;else{if(/contain|cover/.test(o[0])){var a=t.width/t.height,s=e.width/e.height;return a<s^"contain"===o[0]?{width:t.height*s,height:t.height}:{width:t.width,height:t.width/s}}r=parseInt(o[0],10)}return i="auto"===o[0]&&"auto"===o[1]?e.height:"auto"===o[1]?r/e.width*e.height:c(o[1])?t.height*parseFloat(o[1])/100:parseInt(o[1],10),"auto"===o[0]&&(r=i/e.height*e.width),{width:r,height:i}},h.prototype.parseBackgroundPosition=function(t,e,n,r){var i,o,a=this.cssList("backgroundPosition",n);return i=c(a[0])?(t.width-(r||e).width)*(parseFloat(a[0])/100):parseInt(a[0],10),o="auto"===a[1]?i/e.width*e.height:c(a[1])?(t.height-(r||e).height)*parseFloat(a[1])/100:parseInt(a[1],10),"auto"===a[0]&&(i=o/e.height*e.width),{left:i,top:o}},h.prototype.parseBackgroundRepeat=function(t){return this.cssList("backgroundRepeat",t)[0]},h.prototype.parseTextShadows=function(){var t=this.css("textShadow"),e=[];if(t&&"none"!==t)for(var n=t.match(this.TEXT_SHADOW_PROPERTY),r=0;n&&r<n.length;r++){var i=n[r].match(this.TEXT_SHADOW_VALUES);e.push({color:new o(i[0]),offsetX:i[1]?parseFloat(i[1].replace("px","")):0,offsetY:i[2]?parseFloat(i[2].replace("px","")):0,blur:i[3]?i[3].replace("px",""):0})}return e},h.prototype.parseTransform=function(){if(!this.transformData)if(this.hasTransform()){var t=this.parseBounds(),e=this.prefixedCss("transformOrigin").split(" ").map(l).map(u);e[0]+=t.left,e[1]+=t.top,this.transformData={origin:e,matrix:this.parseTransformMatrix()}}else this.transformData={origin:[0,0],matrix:[1,0,0,1,0,0]};return this.transformData},h.prototype.parseTransformMatrix=function(){if(!this.transformMatrix){var t=this.prefixedCss("transform"),e=t?function(t){{if(t&&"matrix"===t[1])return t[2].split(",").map(function(t){return parseFloat(t.trim())});if(t&&"matrix3d"===t[1]){var e=t[2].split(",").map(function(t){return parseFloat(t.trim())});return[e[0],e[1],e[4],e[5],e[12],e[13]]}}}(t.match(this.MATRIX_PROPERTY)):null;this.transformMatrix=e||[1,0,0,1,0,0]}return this.transformMatrix},h.prototype.parseBounds=function(){return this.bounds||(this.bounds=this.hasTransform()?s(this.node):i(this.node))},h.prototype.hasTransform=function(){return"1,0,0,1,0,0"!==this.parseTransformMatrix().join(",")||this.parent&&this.parent.hasTransform()},h.prototype.getValue=function(){var t,e,n=this.node.value||"";return"SELECT"===this.node.tagName?(t=this.node,n=(e=t.options[t.selectedIndex||0])&&e.text||""):"password"===this.node.type&&(n=Array(n.length+1).join("")),0===n.length?this.node.placeholder||"":n},h.prototype.MATRIX_PROPERTY=/(matrix|matrix3d)\((.+)\)/,h.prototype.TEXT_SHADOW_PROPERTY=/((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g,h.prototype.TEXT_SHADOW_VALUES=/(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g,h.prototype.CLIP=/^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/,e.exports=h},{"./color":3,"./utils":26}],15:[function(t,e,n){var s=t("./log"),h=t("punycode"),c=t("./nodecontainer"),f=t("./textcontainer"),d=t("./pseudoelementcontainer"),l=t("./fontmetrics"),u=t("./color"),p=t("./stackingcontext"),r=t("./utils"),g=r.bind,a=r.getBounds,m=r.parseBackgrounds,w=r.offsetBounds;function i(t,e,n,r,i){s("Starting NodeParser"),this.renderer=e,this.options=i,this.range=null,this.support=n,this.renderQueue=[],this.stack=new p(!0,1,t.ownerDocument,null);var o=new c(t,null);if(i.background&&e.rectangle(0,0,e.width,e.height,new u(i.background)),t===t.ownerDocument.documentElement){var a=new c(o.color("backgroundColor").isTransparent()?t.ownerDocument.body:t.ownerDocument.documentElement,null);e.rectangle(0,0,e.width,e.height,a.color("backgroundColor"))}o.visibile=o.isElementVisible(),this.createPseudoHideStyles(t.ownerDocument),this.disableAnimations(t.ownerDocument),this.nodes=L([o].concat(this.getChildren(o)).filter(function(t){return t.visible=t.isElementVisible()}).map(this.getPseudoElements,this)),this.fontMetrics=new l,s("Fetched nodes, total:",this.nodes.length),s("Calculate overflow clips"),this.calculateOverflowClips(),s("Start fetching images"),this.images=r.fetch(this.nodes.filter(j)),this.ready=this.images.ready.then(g(function(){return s("Images loaded, starting parsing"),s("Creating stacking contexts"),this.createStackingContexts(),s("Sorting stacking contexts"),this.sortStackingContexts(this.stack),this.parse(this.stack),s("Render queue created with "+this.renderQueue.length+" items"),new Promise(g(function(t){i.async?"function"==typeof i.async?i.async.call(this,this.renderQueue,t):0<this.renderQueue.length?(this.renderIndex=0,this.asyncRenderer(this.renderQueue,t)):t():(this.renderQueue.forEach(this.paint,this),t())},this))},this))}function o(t){return t.parent&&t.parent.clip.length}function y(){}i.prototype.calculateOverflowClips=function(){this.nodes.forEach(function(t){if(j(t)){D(t)&&t.appendToDOM(),t.borders=this.parseBorders(t);var e="hidden"===t.css("overflow")?[t.borders.clip]:[],n=t.parseClip();n&&-1!==["absolute","fixed"].indexOf(t.css("position"))&&e.push([["rect",t.bounds.left+n.left,t.bounds.top+n.top,n.right-n.left,n.bottom-n.top]]),t.clip=o(t)?t.parent.clip.concat(e):e,t.backgroundClip="hidden"!==t.css("overflow")?t.clip.concat([t.borders.clip]):t.clip,D(t)&&t.cleanDOM()}else M(t)&&(t.clip=o(t)?t.parent.clip:[]);D(t)||(t.bounds=null)},this)},i.prototype.asyncRenderer=function(t,e,n){n=n||Date.now(),this.paint(t[this.renderIndex++]),t.length===this.renderIndex?e():n+20>Date.now()?this.asyncRenderer(t,e,n):setTimeout(g(function(){this.asyncRenderer(t,e)},this),0)},i.prototype.createPseudoHideStyles=function(t){this.createStyles(t,"."+d.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE+':before { content: "" !important; display: none !important; }.'+d.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER+':after { content: "" !important; display: none !important; }')},i.prototype.disableAnimations=function(t){this.createStyles(t,"* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}")},i.prototype.createStyles=function(t,e){var n=t.createElement("style");n.innerHTML=e,t.body.appendChild(n)},i.prototype.getPseudoElements=function(t){var e=[[t]];if(t.node.nodeType===Node.ELEMENT_NODE){var n=this.getPseudoElement(t,":before"),r=this.getPseudoElement(t,":after");n&&e.push(n),r&&e.push(r)}return L(e)},i.prototype.getPseudoElement=function(t,e){var n=t.computedStyle(e);if(!n||!n.content||"none"===n.content||"-moz-alt-content"===n.content||"none"===n.display)return null;for(var r,i,o=(r=n.content,(i=r.substr(0,1))===r.substr(r.length-1)&&i.match(/'|"/)?r.substr(1,r.length-2):r),a="url"===o.substr(0,3),s=document.createElement(a?"img":"html2canvaspseudoelement"),h=new d(s,t,e),c=n.length-1;0<=c;c--){var l=n.item(c).replace(/(\-[a-z])/g,function(t){return t.toUpperCase().replace("-","")});s.style[l]=n[l]}if(s.className=d.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE+" "+d.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER,a)return s.src=m(o)[0].args[0],[h];var u=document.createTextNode(o);return s.appendChild(u),[h,new f(u,h)]},i.prototype.getChildren=function(n){return L([].filter.call(n.node.childNodes,q).map(function(t){var e=[t.nodeType===Node.TEXT_NODE?new f(t,n):new c(t,n)].filter(z);return t.nodeType===Node.ELEMENT_NODE&&e.length&&"TEXTAREA"!==t.tagName?e[0].isElementVisible()?e.concat(this.getChildren(e[0])):[]:e},this))},i.prototype.newStackingContext=function(t,e){var n=new p(e,t.getOpacity(),t.node,t.parent);t.cloneTo(n),(e?n.getParentStack(this):n.parent.stack).contexts.push(n),t.stack=n},i.prototype.createStackingContexts=function(){this.nodes.forEach(function(t){var e,n;j(t)&&(this.isRootElement(t)||t.getOpacity()<1||(n=(e=t).css("position"),"auto"!==(-1!==["absolute","relative","fixed"].indexOf(n)?e.css("zIndex"):"auto"))||this.isBodyWithTransparentRoot(t)||t.hasTransform())?this.newStackingContext(t,!0):j(t)&&(O(t)&&T(t)||-1!==["inline-block","inline-table"].indexOf(t.css("display"))||B(t))?this.newStackingContext(t,!1):t.assignStack(t.parent.stack)},this)},i.prototype.isBodyWithTransparentRoot=function(t){return"BODY"===t.node.nodeName&&t.parent.color("backgroundColor").isTransparent()},i.prototype.isRootElement=function(t){return null===t.parent},i.prototype.sortStackingContexts=function(t){var n;t.contexts.sort((n=t.contexts.slice(0),function(t,e){return t.cssInt("zIndex")+n.indexOf(t)/n.length-(e.cssInt("zIndex")+n.indexOf(e)/n.length)})),t.contexts.forEach(this.sortStackingContexts,this)},i.prototype.parseTextBounds=function(a){return function(t,e,n){if("none"!==a.parent.css("textDecoration").substr(0,4)||0!==t.trim().length){if(this.support.rangeBounds&&!a.parent.hasTransform()){var r=n.slice(0,e).join("").length;return this.getRangeBounds(a.node,r,t.length)}if(a.node&&"string"==typeof a.node.data){var i=a.node.splitText(t.length),o=this.getWrapperBounds(a.node,a.parent.hasTransform());return a.node=i,o}}else this.support.rangeBounds&&!a.parent.hasTransform()||(a.node=a.node.splitText(t.length));return{}}},i.prototype.getWrapperBounds=function(t,e){var n=t.ownerDocument.createElement("html2canvaswrapper"),r=t.parentNode,i=t.cloneNode(!0);n.appendChild(t.cloneNode(!0)),r.replaceChild(n,t);var o=e?w(n):a(n);return r.replaceChild(i,n),o},i.prototype.getRangeBounds=function(t,e,n){var r=this.range||(this.range=t.ownerDocument.createRange());return r.setStart(t,e),r.setEnd(t,e+n),r.getBoundingClientRect()},i.prototype.parse=function(t){var e=t.contexts.filter(I),n=t.children.filter(j),r=n.filter(R(B)),i=r.filter(R(O)).filter(R(F)),o=n.filter(R(O)).filter(B),a=r.filter(R(O)).filter(F),s=t.contexts.concat(r.filter(O)).filter(T),h=t.children.filter(M).filter(E),c=t.contexts.filter(C);e.concat(i).concat(o).concat(a).concat(s).concat(h).concat(c).forEach(function(t){this.renderQueue.push(t),P(t)&&(this.parse(t),this.renderQueue.push(new y))},this)},i.prototype.paint=function(t){try{t instanceof y?this.renderer.ctx.restore():M(t)?(D(t.parent)&&t.parent.appendToDOM(),this.paintText(t),D(t.parent)&&t.parent.cleanDOM()):this.paintNode(t)}catch(t){if(s(t),this.options.strict)throw t}},i.prototype.paintNode=function(t){P(t)&&(this.renderer.setOpacity(t.opacity),this.renderer.ctx.save(),t.hasTransform()&&this.renderer.setTransform(t.parseTransform())),"INPUT"===t.node.nodeName&&"checkbox"===t.node.type?this.paintCheckbox(t):"INPUT"===t.node.nodeName&&"radio"===t.node.type?this.paintRadio(t):this.paintElement(t)},i.prototype.paintElement=function(n){var r=n.parseBounds();this.renderer.clip(n.backgroundClip,function(){this.renderer.renderBackground(n,r,n.borders.borders.map(N))},this),this.renderer.clip(n.clip,function(){this.renderer.renderBorders(n.borders.borders)},this),this.renderer.clip(n.backgroundClip,function(){switch(n.node.nodeName){case"svg":case"IFRAME":var t=this.images.get(n.node);t?this.renderer.renderImage(n,r,n.borders,t):s("Error loading <"+n.node.nodeName+">",n.node);break;case"IMG":var e=this.images.get(n.node.src);e?this.renderer.renderImage(n,r,n.borders,e):s("Error loading <img>",n.node.src);break;case"CANVAS":this.renderer.renderImage(n,r,n.borders,{image:n.node});break;case"SELECT":case"INPUT":case"TEXTAREA":this.paintFormValue(n)}},this)},i.prototype.paintCheckbox=function(t){var e=t.parseBounds(),n=Math.min(e.width,e.height),r={width:n-1,height:n-1,top:e.top,left:e.left},i=[3,3],o=[i,i,i,i],a=[1,1,1,1].map(function(t){return{color:new u("#A5A5A5"),width:t}}),s=S(r,o,a);this.renderer.clip(t.backgroundClip,function(){this.renderer.rectangle(r.left+1,r.top+1,r.width-2,r.height-2,new u("#DEDEDE")),this.renderer.renderBorders(b(a,r,s,o)),t.node.checked&&(this.renderer.font(new u("#424242"),"normal","normal","bold",n-3+"px","arial"),this.renderer.text("",r.left+n/6,r.top+n-1))},this)},i.prototype.paintRadio=function(t){var e=t.parseBounds(),n=Math.min(e.width,e.height)-2;this.renderer.clip(t.backgroundClip,function(){this.renderer.circleStroke(e.left+1,e.top+1,n,new u("#DEDEDE"),1,new u("#A5A5A5")),t.node.checked&&this.renderer.circle(Math.ceil(e.left+n/4)+1,Math.ceil(e.top+n/4)+1,Math.floor(n/2),new u("#424242"))},this)},i.prototype.paintFormValue=function(e){var t=e.getValue();if(0<t.length){var n=e.node.ownerDocument,r=n.createElement("html2canvaswrapper");["lineHeight","textAlign","fontFamily","fontWeight","fontSize","color","paddingLeft","paddingTop","paddingRight","paddingBottom","width","height","borderLeftStyle","borderTopStyle","borderLeftWidth","borderTopWidth","boxSizing","whiteSpace","wordWrap"].forEach(function(t){try{r.style[t]=e.css(t)}catch(t){s("html2canvas: Parse: Exception caught in renderFormValue: "+t.message)}});var i=e.parseBounds();r.style.position="fixed",r.style.left=i.left+"px",r.style.top=i.top+"px",r.textContent=t,n.body.appendChild(r),this.paintText(new f(r.firstChild,e)),n.body.removeChild(r)}},i.prototype.paintText=function(n){n.applyTextTransform();var t,e=h.ucs2.decode(n.node.data),r=this.options.letterRendering&&!/^(normal|none|0px)$/.test(n.parent.css("letterSpacing"))||(t=n.node.data,/[^\u0000-\u00ff]/.test(t))?e.map(function(t){return h.ucs2.encode([t])}):function(t){var e,n=[],r=0,i=!1;for(;t.length;)o=t[r],-1!==[32,13,10,9,45].indexOf(o)===i?((e=t.splice(0,r)).length&&n.push(h.ucs2.encode(e)),i=!i,r=0):r++,r>=t.length&&(e=t.splice(0,r)).length&&n.push(h.ucs2.encode(e));var o;return n}(e),i=n.parent.fontWeight(),o=n.parent.css("fontSize"),a=n.parent.css("fontFamily"),s=n.parent.parseTextShadows();this.renderer.font(n.parent.color("color"),n.parent.css("fontStyle"),n.parent.css("fontVariant"),i,o,a),s.length?this.renderer.fontShadow(s[0].color,s[0].offsetX,s[0].offsetY,s[0].blur):this.renderer.clearShadow(),this.renderer.clip(n.parent.clip,function(){r.map(this.parseTextBounds(n),this).forEach(function(t,e){t&&!1===/^\s*$/.test(r[e])&&(this.renderer.text(r[e],t.left,t.bottom),this.renderTextDecoration(n.parent,t,this.fontMetrics.getMetrics(a,o)))},this)},this)},i.prototype.renderTextDecoration=function(t,e,n){switch(t.css("textDecoration").split(" ")[0]){case"underline":this.renderer.rectangle(e.left,Math.round(e.top+n.baseline+n.lineWidth),e.width,1,t.color("color"));break;case"overline":this.renderer.rectangle(e.left,Math.round(e.top),e.width,1,t.color("color"));break;case"line-through":this.renderer.rectangle(e.left,Math.ceil(e.top+n.middle+n.lineWidth),e.width,1,t.color("color"))}};var v={inset:[["darken",.6],["darken",.1],["darken",.1],["darken",.6]]};function b(a,s,h,c){return a.map(function(t,e){if(0<t.width){var n=s.left,r=s.top,i=s.width,o=s.height-a[2].width;switch(e){case 0:o=a[0].width,t.args=_({c1:[n,r],c2:[n+i,r],c3:[n+i-a[1].width,r+o],c4:[n+a[3].width,r+o]},c[0],c[1],h.topLeftOuter,h.topLeftInner,h.topRightOuter,h.topRightInner);break;case 1:n=s.left+s.width-a[1].width,i=a[1].width,t.args=_({c1:[n+i,r],c2:[n+i,r+o+a[2].width],c3:[n,r+o],c4:[n,r+a[0].width]},c[1],c[2],h.topRightOuter,h.topRightInner,h.bottomRightOuter,h.bottomRightInner);break;case 2:r=r+s.height-a[2].width,o=a[2].width,t.args=_({c1:[n+i,r+o],c2:[n,r+o],c3:[n+a[3].width,r],c4:[n+i-a[3].width,r]},c[2],c[3],h.bottomRightOuter,h.bottomRightInner,h.bottomLeftOuter,h.bottomLeftInner);break;case 3:i=a[3].width,t.args=_({c1:[n,r+o+a[2].width],c2:[n,r],c3:[n+i,r+a[0].width],c4:[n+i,r+o]},c[3],c[0],h.bottomLeftOuter,h.bottomLeftInner,h.topLeftOuter,h.topLeftInner)}}return t})}function x(t,e,n,r){var i=(Math.sqrt(2)-1)/3*4,o=n*i,a=r*i,s=t+n,h=e+r;return{topLeft:k({x:t,y:h},{x:t,y:h-a},{x:s-o,y:e},{x:s,y:e}),topRight:k({x:t,y:e},{x:t+o,y:e},{x:s,y:h-a},{x:s,y:h}),bottomRight:k({x:s,y:e},{x:s,y:e+a},{x:t+o,y:h},{x:t,y:h}),bottomLeft:k({x:s,y:h},{x:s-o,y:h},{x:t,y:e+a},{x:t,y:e})}}function S(t,e,n){var r=t.left,i=t.top,o=t.width,a=t.height,s=e[0][0]<o/2?e[0][0]:o/2,h=e[0][1]<a/2?e[0][1]:a/2,c=e[1][0]<o/2?e[1][0]:o/2,l=e[1][1]<a/2?e[1][1]:a/2,u=e[2][0]<o/2?e[2][0]:o/2,f=e[2][1]<a/2?e[2][1]:a/2,d=e[3][0]<o/2?e[3][0]:o/2,p=e[3][1]<a/2?e[3][1]:a/2,g=o-c,m=a-f,w=o-u,y=a-p;return{topLeftOuter:x(r,i,s,h).topLeft.subdivide(.5),topLeftInner:x(r+n[3].width,i+n[0].width,Math.max(0,s-n[3].width),Math.max(0,h-n[0].width)).topLeft.subdivide(.5),topRightOuter:x(r+g,i,c,l).topRight.subdivide(.5),topRightInner:x(r+Math.min(g,o+n[3].width),i+n[0].width,g>o+n[3].width?0:c-n[3].width,l-n[0].width).topRight.subdivide(.5),bottomRightOuter:x(r+w,i+m,u,f).bottomRight.subdivide(.5),bottomRightInner:x(r+Math.min(w,o-n[3].width),i+Math.min(m,a+n[0].width),Math.max(0,u-n[1].width),f-n[2].width).bottomRight.subdivide(.5),bottomLeftOuter:x(r,i+y,d,p).bottomLeft.subdivide(.5),bottomLeftInner:x(r+n[3].width,i+y,Math.max(0,d-n[3].width),p-n[2].width).bottomLeft.subdivide(.5)}}function k(s,h,c,l){var u=function(t,e,n){return{x:t.x+(e.x-t.x)*n,y:t.y+(e.y-t.y)*n}};return{start:s,startControl:h,endControl:c,end:l,subdivide:function(t){var e=u(s,h,t),n=u(h,c,t),r=u(c,l,t),i=u(e,n,t),o=u(n,r,t),a=u(i,o,t);return[k(s,e,i,a),k(a,o,r,l)]},curveTo:function(t){t.push(["bezierCurve",h.x,h.y,c.x,c.y,l.x,l.y])},curveToReversed:function(t){t.push(["bezierCurve",c.x,c.y,h.x,h.y,s.x,s.y])}}}function _(t,e,n,r,i,o,a){var s=[];return 0<e[0]||0<e[1]?(s.push(["line",r[1].start.x,r[1].start.y]),r[1].curveTo(s)):s.push(["line",t.c1[0],t.c1[1]]),0<n[0]||0<n[1]?(s.push(["line",o[0].start.x,o[0].start.y]),o[0].curveTo(s),s.push(["line",a[0].end.x,a[0].end.y]),a[0].curveToReversed(s)):(s.push(["line",t.c2[0],t.c2[1]]),s.push(["line",t.c3[0],t.c3[1]])),0<e[0]||0<e[1]?(s.push(["line",i[1].end.x,i[1].end.y]),i[1].curveToReversed(s)):s.push(["line",t.c4[0],t.c4[1]]),s}function A(t,e,n,r,i,o,a){0<e[0]||0<e[1]?(t.push(["line",r[0].start.x,r[0].start.y]),r[0].curveTo(t),r[1].curveTo(t)):t.push(["line",o,a]),(0<n[0]||0<n[1])&&t.push(["line",i[0].start.x,i[0].start.y])}function I(t){return t.cssInt("zIndex")<0}function C(t){return 0<t.cssInt("zIndex")}function T(t){return 0===t.cssInt("zIndex")}function F(t){return-1!==["inline","inline-block","inline-table"].indexOf(t.css("display"))}function P(t){return t instanceof p}function E(t){return 0<t.node.data.trim().length}function q(t){return t.nodeType===Node.TEXT_NODE||t.nodeType===Node.ELEMENT_NODE}function O(t){return"static"!==t.css("position")}function B(t){return"none"!==t.css("float")}function R(t){var e=this;return function(){return!t.apply(e,arguments)}}function j(t){return t.node.nodeType===Node.ELEMENT_NODE}function D(t){return!0===t.isPseudoElement}function M(t){return t.node.nodeType===Node.TEXT_NODE}function U(t){return parseInt(t,10)}function N(t){return t.width}function z(t){return t.node.nodeType!==Node.ELEMENT_NODE||-1===["SCRIPT","HEAD","TITLE","OBJECT","BR","OPTION"].indexOf(t.node.nodeName)}function L(t){return[].concat.apply([],t)}i.prototype.parseBorders=function(o){var r,t=o.parseBounds(),e=(r=o,["TopLeft","TopRight","BottomRight","BottomLeft"].map(function(t){var e=r.css("border"+t+"Radius"),n=e.split(" ");return n.length<=1&&(n[1]=n[0]),n.map(U)})),n=["Top","Right","Bottom","Left"].map(function(t,e){var n=o.css("border"+t+"Style"),r=o.color("border"+t+"Color");"inset"===n&&r.isBlack()&&(r=new u([255,255,255,r.a]));var i=v[n]?v[n][e]:null;return{width:o.cssInt("border"+t+"Width"),color:i?r[i[0]](i[1]):r,args:null}}),i=S(t,e,n);return{clip:this.parseBackgroundClip(o,i,n,e,t),borders:b(n,t,i,e)}},i.prototype.parseBackgroundClip=function(t,e,n,r,i){var o=[];switch(t.css("backgroundClip")){case"content-box":case"padding-box":A(o,r[0],r[1],e.topLeftInner,e.topRightInner,i.left+n[3].width,i.top+n[0].width),A(o,r[1],r[2],e.topRightInner,e.bottomRightInner,i.left+i.width-n[1].width,i.top+n[0].width),A(o,r[2],r[3],e.bottomRightInner,e.bottomLeftInner,i.left+i.width-n[1].width,i.top+i.height-n[2].width),A(o,r[3],r[0],e.bottomLeftInner,e.topLeftInner,i.left+n[3].width,i.top+i.height-n[2].width);break;default:A(o,r[0],r[1],e.topLeftOuter,e.topRightOuter,i.left,i.top),A(o,r[1],r[2],e.topRightOuter,e.bottomRightOuter,i.left+i.width,i.top),A(o,r[2],r[3],e.bottomRightOuter,e.bottomLeftOuter,i.left+i.width,i.top+i.height),A(o,r[3],r[0],e.bottomLeftOuter,e.topLeftOuter,i.left,i.top+i.height)}return o},e.exports=i},{"./color":3,"./fontmetrics":7,"./log":13,"./nodecontainer":14,"./pseudoelementcontainer":18,"./stackingcontext":21,"./textcontainer":25,"./utils":26,punycode:1}],16:[function(t,e,n){var a=t("./xhr"),r=t("./utils"),s=t("./log"),h=t("./clone"),c=r.decode64;function l(t,e,n){var r="withCredentials"in new XMLHttpRequest;if(!e)return Promise.reject("No proxy configured");var i=f(r),o=d(e,t,i);return r?a(o):u(n,o,i).then(function(t){return c(t.content)})}var i=0;function u(i,o,a){return new Promise(function(e,n){var t=i.createElement("script"),r=function(){delete window.html2canvas.proxy[a],i.body.removeChild(t)};window.html2canvas.proxy[a]=function(t){r(),e(t)},t.src=o,t.onerror=function(t){r(),n(t)},i.body.appendChild(t)})}function f(t){return t?"":"html2canvas_"+Date.now()+"_"+ ++i+"_"+Math.round(1e5*Math.random())}function d(t,e,n){return t+"?url="+encodeURIComponent(e)+(n.length?"&callback=html2canvas.proxy."+n:"")}n.Proxy=l,n.ProxyURL=function(t,e,n){var r="crossOrigin"in new Image,i=f(r),o=d(e,t,i);return r?Promise.resolve(o):u(n,o,i).then(function(t){return"data:"+t.type+";base64,"+t.content})},n.loadUrlDocument=function(t,e,n,r,i,o){return new l(t,e,window.document).then((a=t,function(e){var n,t=new DOMParser;try{n=t.parseFromString(e,"text/html")}catch(t){s("DOMParser not supported, falling back to createHTMLDocument"),n=document.implementation.createHTMLDocument("");try{n.open(),n.write(e),n.close()}catch(t){s("createHTMLDocument write not supported, falling back to document.body.innerHTML"),n.body.innerHTML=e}}var r=n.querySelector("base");if(!r||!r.href.host){var i=n.createElement("base");i.href=a,n.head.insertBefore(i,n.head.firstChild)}return n})).then(function(t){return h(t,n,r,i,o,0,0)});var a}},{"./clone":2,"./log":13,"./utils":26,"./xhr":28}],17:[function(t,e,n){var o=t("./proxy").ProxyURL;e.exports=function(n,r){var t=document.createElement("a");t.href=n,n=t.href,this.src=n,this.image=new Image;var i=this;this.promise=new Promise(function(t,e){i.image.crossOrigin="Anonymous",i.image.onload=t,i.image.onerror=e,new o(n,r,document).then(function(t){i.image.src=t}).catch(e)})}},{"./proxy":16}],18:[function(t,e,n){var r=t("./nodecontainer");function i(t,e,n){r.call(this,t,e),this.isPseudoElement=!0,this.before=":before"===n}i.prototype.cloneTo=function(t){i.prototype.cloneTo.call(this,t),t.isPseudoElement=!0,t.before=this.before},(i.prototype=Object.create(r.prototype)).appendToDOM=function(){this.before?this.parent.node.insertBefore(this.node,this.parent.node.firstChild):this.parent.node.appendChild(this.node),this.parent.node.className+=" "+this.getHideClass()},i.prototype.cleanDOM=function(){this.node.parentNode.removeChild(this.node),this.parent.node.className=this.parent.node.className.replace(this.getHideClass(),"")},i.prototype.getHideClass=function(){return this["PSEUDO_HIDE_ELEMENT_CLASS_"+(this.before?"BEFORE":"AFTER")]},i.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE="___html2canvas___pseudoelement_before",i.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER="___html2canvas___pseudoelement_after",e.exports=i},{"./nodecontainer":14}],19:[function(t,e,n){var h=t("./log");function r(t,e,n,r,i){this.width=t,this.height=e,this.images=n,this.options=r,this.document=i}r.prototype.renderImage=function(t,e,n,r){var i=t.cssInt("paddingLeft"),o=t.cssInt("paddingTop"),a=t.cssInt("paddingRight"),s=t.cssInt("paddingBottom"),h=n.borders,c=e.width-(h[1].width+h[3].width+i+a),l=e.height-(h[0].width+h[2].width+o+s);this.drawImage(r,0,0,r.image.width||c,r.image.height||l,e.left+i+h[3].width,e.top+o+h[0].width,c,l)},r.prototype.renderBackground=function(t,e,n){0<e.height&&0<e.width&&(this.renderBackgroundColor(t,e),this.renderBackgroundImage(t,e,n))},r.prototype.renderBackgroundColor=function(t,e){var n=t.color("backgroundColor");n.isTransparent()||this.rectangle(e.left,e.top,e.width,e.height,n)},r.prototype.renderBorders=function(t){t.forEach(this.renderBorder,this)},r.prototype.renderBorder=function(t){t.color.isTransparent()||null===t.args||this.drawShape(t.args,t.color)},r.prototype.renderBackgroundImage=function(o,a,s){o.parseBackgroundImages().reverse().forEach(function(t,e,n){switch(t.method){case"url":var r=this.images.get(t.args[0]);r?this.renderBackgroundRepeating(o,a,r,n.length-(e+1),s):h("Error loading background-image",t.args[0]);break;case"linear-gradient":case"gradient":var i=this.images.get(t.value);i?this.renderBackgroundGradient(i,a,s):h("Error loading background-image",t.args[0]);break;case"none":break;default:h("Unknown background-image type",t.args[0])}},this)},r.prototype.renderBackgroundRepeating=function(t,e,n,r,i){var o=t.parseBackgroundSize(e,n.image,r),a=t.parseBackgroundPosition(e,n.image,r,o);switch(t.parseBackgroundRepeat(r)){case"repeat-x":case"repeat no-repeat":this.backgroundRepeatShape(n,a,o,e,e.left+i[3],e.top+a.top+i[0],99999,o.height,i);break;case"repeat-y":case"no-repeat repeat":this.backgroundRepeatShape(n,a,o,e,e.left+a.left+i[3],e.top+i[0],o.width,99999,i);break;case"no-repeat":this.backgroundRepeatShape(n,a,o,e,e.left+a.left+i[3],e.top+a.top+i[0],o.width,o.height,i);break;default:this.renderBackgroundRepeat(n,a,o,{top:e.top,left:e.left},i[3],i[0])}},e.exports=r},{"./log":13}],20:[function(t,e,n){var r=t("../renderer"),i=t("../lineargradientcontainer"),o=t("../log");function a(t,e){r.apply(this,arguments),this.canvas=this.options.canvas||this.document.createElement("canvas"),this.options.canvas||(this.canvas.width=t,this.canvas.height=e),this.ctx=this.canvas.getContext("2d"),this.taintCtx=this.document.createElement("canvas").getContext("2d"),this.ctx.textBaseline="bottom",this.variables={},o("Initialized CanvasRenderer with size",t,"x",e)}function s(t){return 0<t.length}(a.prototype=Object.create(r.prototype)).setFillStyle=function(t){return this.ctx.fillStyle="object"==typeof t&&t.isColor?t.toString():t,this.ctx},a.prototype.rectangle=function(t,e,n,r,i){this.setFillStyle(i).fillRect(t,e,n,r)},a.prototype.circle=function(t,e,n,r){this.setFillStyle(r),this.ctx.beginPath(),this.ctx.arc(t+n/2,e+n/2,n/2,0,2*Math.PI,!0),this.ctx.closePath(),this.ctx.fill()},a.prototype.circleStroke=function(t,e,n,r,i,o){this.circle(t,e,n,r),this.ctx.strokeStyle=o.toString(),this.ctx.stroke()},a.prototype.drawShape=function(t,e){this.shape(t),this.setFillStyle(e).fill()},a.prototype.taints=function(e){if(null===e.tainted){this.taintCtx.drawImage(e.image,0,0);try{this.taintCtx.getImageData(0,0,1,1),e.tainted=!1}catch(t){this.taintCtx=document.createElement("canvas").getContext("2d"),e.tainted=!0}}return e.tainted},a.prototype.drawImage=function(t,e,n,r,i,o,a,s,h){this.taints(t)&&!this.options.allowTaint||this.ctx.drawImage(t.image,e,n,r,i,o,a,s,h)},a.prototype.clip=function(t,e,n){this.ctx.save(),t.filter(s).forEach(function(t){this.shape(t).clip()},this),e.call(n),this.ctx.restore()},a.prototype.shape=function(t){return this.ctx.beginPath(),t.forEach(function(t,e){"rect"===t[0]?this.ctx.rect.apply(this.ctx,t.slice(1)):this.ctx[0===e?"moveTo":t[0]+"To"].apply(this.ctx,t.slice(1))},this),this.ctx.closePath(),this.ctx},a.prototype.font=function(t,e,n,r,i,o){this.setFillStyle(t).font=[e,n,r,i,o].join(" ").split(",")[0]},a.prototype.fontShadow=function(t,e,n,r){this.setVariable("shadowColor",t.toString()).setVariable("shadowOffsetY",e).setVariable("shadowOffsetX",n).setVariable("shadowBlur",r)},a.prototype.clearShadow=function(){this.setVariable("shadowColor","rgba(0,0,0,0)")},a.prototype.setOpacity=function(t){this.ctx.globalAlpha=t},a.prototype.setTransform=function(t){this.ctx.translate(t.origin[0],t.origin[1]),this.ctx.transform.apply(this.ctx,t.matrix),this.ctx.translate(-t.origin[0],-t.origin[1])},a.prototype.setVariable=function(t,e){return this.variables[t]!==e&&(this.variables[t]=this.ctx[t]=e),this},a.prototype.text=function(t,e,n){this.ctx.fillText(t,e,n)},a.prototype.backgroundRepeatShape=function(t,e,n,r,i,o,a,s,h){var c=[["line",Math.round(i),Math.round(o)],["line",Math.round(i+a),Math.round(o)],["line",Math.round(i+a),Math.round(s+o)],["line",Math.round(i),Math.round(s+o)]];this.clip([c],function(){this.renderBackgroundRepeat(t,e,n,r,h[3],h[0])},this)},a.prototype.renderBackgroundRepeat=function(t,e,n,r,i,o){var a=Math.round(r.left+e.left+i),s=Math.round(r.top+e.top+o);this.setFillStyle(this.ctx.createPattern(this.resizeImage(t,n),"repeat")),this.ctx.translate(a,s),this.ctx.fill(),this.ctx.translate(-a,-s)},a.prototype.renderBackgroundGradient=function(t,e){if(t instanceof i){var n=this.ctx.createLinearGradient(e.left+e.width*t.x0,e.top+e.height*t.y0,e.left+e.width*t.x1,e.top+e.height*t.y1);t.colorStops.forEach(function(t){n.addColorStop(t.stop,t.color.toString())}),this.rectangle(e.left,e.top,e.width,e.height,n)}},a.prototype.resizeImage=function(t,e){var n=t.image;if(n.width===e.width&&n.height===e.height)return n;var r=document.createElement("canvas");return r.width=e.width,r.height=e.height,r.getContext("2d").drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),r},e.exports=a},{"../lineargradientcontainer":12,"../log":13,"../renderer":19}],21:[function(t,e,n){var i=t("./nodecontainer");function r(t,e,n,r){i.call(this,n,r),this.ownStacking=t,this.contexts=[],this.children=[],this.opacity=(this.parent?this.parent.stack.opacity:1)*e}(r.prototype=Object.create(i.prototype)).getParentStack=function(t){var e=this.parent?this.parent.stack:null;return e?e.ownStacking?e:e.getParentStack(t):t.stack},e.exports=r},{"./nodecontainer":14}],22:[function(t,e,n){function r(t){this.rangeBounds=this.testRangeBounds(t),this.cors=this.testCORS(),this.svg=this.testSVG()}r.prototype.testRangeBounds=function(t){var e,n,r=!1;return t.createRange&&(e=t.createRange()).getBoundingClientRect&&((n=t.createElement("boundtest")).style.height="123px",n.style.display="block",t.body.appendChild(n),e.selectNode(n),123===e.getBoundingClientRect().height&&(r=!0),t.body.removeChild(n)),r},r.prototype.testCORS=function(){return void 0!==(new Image).crossOrigin},r.prototype.testSVG=function(){var t=new Image,e=document.createElement("canvas"),n=e.getContext("2d");t.src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";try{n.drawImage(t,0,0),e.toDataURL()}catch(t){return!1}return!0},e.exports=r},{}],23:[function(t,e,n){var r=t("./xhr"),i=t("./utils").decode64;function o(t){this.src=t,this.image=null;var n=this;this.promise=this.hasFabric().then(function(){return n.isInline(t)?Promise.resolve(n.inlineFormatting(t)):r(t)}).then(function(e){return new Promise(function(t){window.html2canvas.svg.fabric.loadSVGFromString(e,n.createCanvas.call(n,t))})})}o.prototype.hasFabric=function(){return window.html2canvas.svg&&window.html2canvas.svg.fabric?Promise.resolve():Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg"))},o.prototype.inlineFormatting=function(t){return/^data:image\/svg\+xml;base64,/.test(t)?this.decode64(this.removeContentType(t)):this.removeContentType(t)},o.prototype.removeContentType=function(t){return t.replace(/^data:image\/svg\+xml(;base64)?,/,"")},o.prototype.isInline=function(t){return/^data:image\/svg\+xml/i.test(t)},o.prototype.createCanvas=function(r){var i=this;return function(t,e){var n=new window.html2canvas.svg.fabric.StaticCanvas("c");i.image=n.lowerCanvasEl,n.setWidth(e.width).setHeight(e.height).add(window.html2canvas.svg.fabric.util.groupSVGElements(t,e)).renderAll(),r(n.lowerCanvasEl)}},o.prototype.decode64=function(t){return"function"==typeof window.atob?window.atob(t):i(t)},e.exports=o},{"./utils":26,"./xhr":28}],24:[function(t,e,n){var r=t("./svgcontainer");function i(n,t){this.src=n,this.image=null;var r=this;this.promise=t?new Promise(function(t,e){r.image=new Image,r.image.onload=t,r.image.onerror=e,r.image.src="data:image/svg+xml,"+(new XMLSerializer).serializeToString(n),!0===r.image.complete&&t(r.image)}):this.hasFabric().then(function(){return new Promise(function(t){window.html2canvas.svg.fabric.parseSVGDocument(n,r.createCanvas.call(r,t))})})}i.prototype=Object.create(r.prototype),e.exports=i},{"./svgcontainer":23}],25:[function(t,e,n){var r=t("./nodecontainer");function i(t,e){r.call(this,t,e)}function o(t,e,n){if(0<t.length)return e+n.toUpperCase()}(i.prototype=Object.create(r.prototype)).applyTextTransform=function(){this.node.data=this.transform(this.parent.css("textTransform"))},i.prototype.transform=function(t){var e=this.node.data;switch(t){case"lowercase":return e.toLowerCase();case"capitalize":return e.replace(/(^|\s|:|-|\(|\))([a-z])/g,o);case"uppercase":return e.toUpperCase();default:return e}},e.exports=i},{"./nodecontainer":14}],26:[function(t,e,n){n.smallImage=function(){return"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"},n.bind=function(t,e){return function(){return t.apply(e,arguments)}},
/*
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */
n.decode64=function(t){var e,n,r,i,o,a,s,h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",c=t.length,l="";for(e=0;e<c;e+=4)o=h.indexOf(t[e])<<2|(n=h.indexOf(t[e+1]))>>4,a=(15&n)<<4|(r=h.indexOf(t[e+2]))>>2,s=(3&r)<<6|(i=h.indexOf(t[e+3])),l+=64===r?String.fromCharCode(o):64===i||-1===i?String.fromCharCode(o,a):String.fromCharCode(o,a,s);return l},n.getBounds=function(t){if(t.getBoundingClientRect){var e=t.getBoundingClientRect(),n=null==t.offsetWidth?e.width:t.offsetWidth;return{top:e.top,bottom:e.bottom||e.top+e.height,right:e.left+n,left:e.left,width:n,height:null==t.offsetHeight?e.height:t.offsetHeight}}return{}},n.offsetBounds=function(t){var e=t.offsetParent?n.offsetBounds(t.offsetParent):{top:0,left:0};return{top:t.offsetTop+e.top,bottom:t.offsetTop+t.offsetHeight+e.top,right:t.offsetLeft+e.left+t.offsetWidth,left:t.offsetLeft+e.left,width:t.offsetWidth,height:t.offsetHeight}},n.parseBackgrounds=function(t){var e,n,r,i,o,a,s,h=[],c=0,l=0,u=function(){e&&('"'===n.substr(0,1)&&(n=n.substr(1,n.length-2)),n&&s.push(n),"-"===e.substr(0,1)&&0<(i=e.indexOf("-",1)+1)&&(r=e.substr(0,i),e=e.substr(i)),h.push({prefix:r,method:e.toLowerCase(),value:o,args:s,image:null})),s=[],e=r=n=o=""};return s=[],e=r=n=o="",t.split("").forEach(function(t){if(!(0===c&&-1<" \r\n\t".indexOf(t))){switch(t){case'"':a?a===t&&(a=null):a=t;break;case"(":if(a)break;if(0===c)return c=1,void(o+=t);l++;break;case")":if(a)break;if(1===c){if(0===l)return c=0,o+=t,void u();l--}break;case",":if(a)break;if(0===c)return void u();if(1===c&&0===l&&!e.match(/^url$/i))return s.push(n),n="",void(o+=t)}o+=t,0===c?e+=t:n+=t}}),u(),h}},{}],27:[function(t,e,n){var r=t("./gradientcontainer");function i(t){r.apply(this,arguments),this.type="linear"===t.args[0]?r.TYPES.LINEAR:r.TYPES.RADIAL}i.prototype=Object.create(r.prototype),e.exports=i},{"./gradientcontainer":9}],28:[function(t,e,n){e.exports=function(r){return new Promise(function(t,e){var n=new XMLHttpRequest;n.open("GET",r),n.onload=function(){200===n.status?t(n.responseText):e(new Error(n.statusText))},n.onerror=function(){e(new Error("Network Error"))},n.send()})}},{}]},{},[4])(4)}),function(t){var n="+".charCodeAt(0),r="/".charCodeAt(0),i="0".charCodeAt(0),o="a".charCodeAt(0),a="A".charCodeAt(0),s="-".charCodeAt(0),h="_".charCodeAt(0),l=function(t){var e=t.charCodeAt(0);return e===n||e===s?62:e===r||e===h?63:e<i?-1:e<i+10?e-i+26+26:e<a+26?e-a:e<o+26?e-o+26:void 0};t.API.TTFFont=function(){function i(t,e,n){var r;if(this.rawData=t,r=this.contents=new X(t),this.contents.pos=4,"ttcf"===r.readString(4)){if(!e)throw new Error("Must specify a font name for TTC files.");throw new Error("Font "+e+" not found in TTC file.")}r.pos=0,this.parse(),this.subset=new T(this),this.registerTTF()}return i.open=function(t,e,n,r){return new i(function(t){var e,n,r,i,o,a;if(0<t.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var s=t.length;o="="===t.charAt(s-2)?2:"="===t.charAt(s-1)?1:0,a=new Uint8Array(3*t.length/4-o),r=0<o?t.length-4:t.length;var h=0;function c(t){a[h++]=t}for(n=e=0;e<r;e+=4,n+=3)c((16711680&(i=l(t.charAt(e))<<18|l(t.charAt(e+1))<<12|l(t.charAt(e+2))<<6|l(t.charAt(e+3))))>>16),c((65280&i)>>8),c(255&i);return 2===o?c(255&(i=l(t.charAt(e))<<2|l(t.charAt(e+1))>>4)):1===o&&(c((i=l(t.charAt(e))<<10|l(t.charAt(e+1))<<4|l(t.charAt(e+2))>>2)>>8&255),c(255&i)),a}(n),e,r)},i.prototype.parse=function(){return this.directory=new e(this.contents),this.head=new d(this),this.name=new b(this),this.cmap=new m(this),this.hhea=new g(this),this.maxp=new x(this),this.hmtx=new S(this),this.post=new y(this),this.os2=new w(this),this.loca=new C(this),this.glyf=new _(this),this.ascender=this.os2.exists&&this.os2.ascender||this.hhea.ascender,this.decender=this.os2.exists&&this.os2.decender||this.hhea.decender,this.lineGap=this.os2.exists&&this.os2.lineGap||this.hhea.lineGap,this.bbox=[this.head.xMin,this.head.yMin,this.head.xMax,this.head.yMax]},i.prototype.registerTTF=function(){var i,t,e,n,r;if(this.scaleFactor=1e3/this.head.unitsPerEm,this.bbox=function(){var t,e,n,r;for(r=[],t=0,e=(n=this.bbox).length;t<e;t++)i=n[t],r.push(Math.round(i*this.scaleFactor));return r}.call(this),this.stemV=0,this.post.exists?(e=255&(n=this.post.italic_angle),!0&(t=n>>16)&&(t=-(1+(65535^t))),this.italicAngle=+(t+"."+e)):this.italicAngle=0,this.ascender=Math.round(this.ascender*this.scaleFactor),this.decender=Math.round(this.decender*this.scaleFactor),this.lineGap=Math.round(this.lineGap*this.scaleFactor),this.capHeight=this.os2.exists&&this.os2.capHeight||this.ascender,this.xHeight=this.os2.exists&&this.os2.xHeight||0,this.familyClass=(this.os2.exists&&this.os2.familyClass||0)>>8,this.isSerif=1===(r=this.familyClass)||2===r||3===r||4===r||5===r||7===r,this.isScript=10===this.familyClass,this.flags=0,this.post.isFixedPitch&&(this.flags|=1),this.isSerif&&(this.flags|=2),this.isScript&&(this.flags|=8),0!==this.italicAngle&&(this.flags|=64),this.flags|=32,!this.cmap.unicode)throw new Error("No unicode cmap for font")},i.prototype.characterToGlyph=function(t){var e;return(null!=(e=this.cmap.unicode)?e.codeMap[t]:void 0)||0},i.prototype.widthOfGlyph=function(t){var e;return e=1e3/this.head.unitsPerEm,this.hmtx.forGlyph(t).advance*e},i.prototype.widthOfString=function(t,e,n){var r,i,o,a,s;for(i=a=o=0,s=(t=""+t).length;0<=s?a<s:s<a;i=0<=s?++a:--a)r=t.charCodeAt(i),o+=this.widthOfGlyph(this.characterToGlyph(r))+n*(1e3/e)||0;return o*(e/1e3)},i.prototype.lineHeight=function(t,e){var n;return null==e&&(e=!1),n=e?this.lineGap:0,(this.ascender+n-this.decender)/1e3*t},i}();var c,X=function(){function t(t){this.data=null!=t?t:[],this.pos=0,this.length=this.data.length}return t.prototype.readByte=function(){return this.data[this.pos++]},t.prototype.writeByte=function(t){return this.data[this.pos++]=t},t.prototype.readUInt32=function(){return 16777216*this.readByte()+(this.readByte()<<16)+(this.readByte()<<8)+this.readByte()},t.prototype.writeUInt32=function(t){return this.writeByte(t>>>24&255),this.writeByte(t>>16&255),this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt32=function(){var t;return 2147483648<=(t=this.readUInt32())?t-4294967296:t},t.prototype.writeInt32=function(t){return t<0&&(t+=4294967296),this.writeUInt32(t)},t.prototype.readUInt16=function(){return this.readByte()<<8|this.readByte()},t.prototype.writeUInt16=function(t){return this.writeByte(t>>8&255),this.writeByte(255&t)},t.prototype.readInt16=function(){var t;return 32768<=(t=this.readUInt16())?t-65536:t},t.prototype.writeInt16=function(t){return t<0&&(t+=65536),this.writeUInt16(t)},t.prototype.readString=function(t){var e,n,r;for(n=[],e=r=0;0<=t?r<t:t<r;e=0<=t?++r:--r)n[e]=String.fromCharCode(this.readByte());return n.join("")},t.prototype.writeString=function(t){var e,n,r,i;for(i=[],e=n=0,r=t.length;0<=r?n<r:r<n;e=0<=r?++n:--n)i.push(this.writeByte(t.charCodeAt(e)));return i},t.prototype.readShort=function(){return this.readInt16()},t.prototype.writeShort=function(t){return this.writeInt16(t)},t.prototype.readLongLong=function(){var t,e,n,r,i,o,a,s;return t=this.readByte(),e=this.readByte(),n=this.readByte(),r=this.readByte(),i=this.readByte(),o=this.readByte(),a=this.readByte(),s=this.readByte(),128&t?-1*(72057594037927940*(255^t)+281474976710656*(255^e)+1099511627776*(255^n)+4294967296*(255^r)+16777216*(255^i)+65536*(255^o)+256*(255^a)+(255^s)+1):72057594037927940*t+281474976710656*e+1099511627776*n+4294967296*r+16777216*i+65536*o+256*a+s},t.prototype.readInt=function(){return this.readInt32()},t.prototype.writeInt=function(t){return this.writeInt32(t)},t.prototype.read=function(t){var e,n;for(e=[],n=0;0<=t?n<t:t<n;0<=t?++n:--n)e.push(this.readByte());return e},t.prototype.write=function(t){var e,n,r,i;for(i=[],n=0,r=t.length;n<r;n++)e=t[n],i.push(this.writeByte(e));return i},t}(),e=function(){var p;function t(t){var e,n,r;for(this.scalarType=t.readInt(),this.tableCount=t.readShort(),this.searchRange=t.readShort(),this.entrySelector=t.readShort(),this.rangeShift=t.readShort(),this.tables={},n=0,r=this.tableCount;0<=r?n<r:r<n;0<=r?++n:--n)e={tag:t.readString(4),checksum:t.readInt(),offset:t.readInt(),length:t.readInt()},this.tables[e.tag]=e}return t.prototype.encode=function(t){var e,n,r,i,o,a,s,h,c,l,u,f,d;for(d in u=Object.keys(t).length,a=Math.log(2),c=16*Math.floor(Math.log(u)/a),i=Math.floor(c/a),h=16*u-c,(n=new X).writeInt(this.scalarType),n.writeShort(u),n.writeShort(c),n.writeShort(i),n.writeShort(h),r=16*u,s=n.pos+r,o=null,f=[],t)for(l=t[d],n.writeString(d),n.writeInt(p(l)),n.writeInt(s),n.writeInt(l.length),f=f.concat(l),"head"===d&&(o=s),s+=l.length;s%4;)f.push(0),s++;return n.write(f),e=2981146554-p(n.data),n.pos=o+8,n.writeUInt32(e),n.data},p=function(t){var e,n,r,i;for(t=k.call(t);t.length%4;)t.push(0);for(n=new X(t),r=e=0,i=t.length;r<i;r+=4)e+=n.readUInt32();return 4294967295&e},t}(),u={}.hasOwnProperty,f=function(t,e){for(var n in e)u.call(e,n)&&(t[n]=e[n]);function r(){this.constructor=t}return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t};c=function(){function t(t){var e;this.file=t,e=this.file.directory.tables[this.tag],this.exists=!!e,e&&(this.offset=e.offset,this.length=e.length,this.parse(this.file.contents))}return t.prototype.parse=function(){},t.prototype.encode=function(){},t.prototype.raw=function(){return this.exists?(this.file.contents.pos=this.offset,this.file.contents.read(this.length)):null},t}();var d=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="head",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.revision=t.readInt(),this.checkSumAdjustment=t.readInt(),this.magicNumber=t.readInt(),this.flags=t.readShort(),this.unitsPerEm=t.readShort(),this.created=t.readLongLong(),this.modified=t.readLongLong(),this.xMin=t.readShort(),this.yMin=t.readShort(),this.xMax=t.readShort(),this.yMax=t.readShort(),this.macStyle=t.readShort(),this.lowestRecPPEM=t.readShort(),this.fontDirectionHint=t.readShort(),this.indexToLocFormat=t.readShort(),this.glyphDataFormat=t.readShort()},e}(),p=function(){function t(n,t){var e,r,i,o,a,s,h,c,l,u,f,d,p,g,m,w,y,v;switch(this.platformID=n.readUInt16(),this.encodingID=n.readShort(),this.offset=t+n.readInt(),l=n.pos,n.pos=this.offset,this.format=n.readUInt16(),this.length=n.readUInt16(),this.language=n.readUInt16(),this.isUnicode=3===this.platformID&&1===this.encodingID&&4===this.format||0===this.platformID&&4===this.format,this.codeMap={},this.format){case 0:for(s=m=0;m<256;s=++m)this.codeMap[s]=n.readByte();break;case 4:for(f=n.readUInt16(),u=f/2,n.pos+=6,i=function(){var t,e;for(e=[],s=t=0;0<=u?t<u:u<t;s=0<=u?++t:--t)e.push(n.readUInt16());return e}(),n.pos+=2,p=function(){var t,e;for(e=[],s=t=0;0<=u?t<u:u<t;s=0<=u?++t:--t)e.push(n.readUInt16());return e}(),h=function(){var t,e;for(e=[],s=t=0;0<=u?t<u:u<t;s=0<=u?++t:--t)e.push(n.readUInt16());return e}(),c=function(){var t,e;for(e=[],s=t=0;0<=u?t<u:u<t;s=0<=u?++t:--t)e.push(n.readUInt16());return e}(),r=(this.length-n.pos+this.offset)/2,a=function(){var t,e;for(e=[],s=t=0;0<=r?t<r:r<t;s=0<=r?++t:--t)e.push(n.readUInt16());return e}(),s=w=0,v=i.length;w<v;s=++w)for(g=i[s],e=y=d=p[s];d<=g?y<=g:g<=y;e=d<=g?++y:--y)0===c[s]?o=e+h[s]:0!==(o=a[c[s]/2+(e-d)-(u-s)]||0)&&(o+=h[s]),this.codeMap[e]=65535&o}n.pos=l}return t.encode=function(t,e){var n,r,i,o,a,s,h,c,l,u,f,d,p,g,m,w,y,v,b,x,S,k,_,A,I,C,T,F,P,E,q,O,B,R,j,D,M,U,N,z,L,H,W,G,V,Y;switch(F=new X,o=Object.keys(t).sort(function(t,e){return t-e}),e){case"macroman":for(p=0,g=function(){var t,e;for(e=[],d=t=0;t<256;d=++t)e.push(0);return e}(),w={0:0},i={},P=0,B=o.length;P<B;P++)null==w[W=t[r=o[P]]]&&(w[W]=++p),i[r]={old:t[r],new:w[t[r]]},g[r]=w[t[r]];return F.writeUInt16(1),F.writeUInt16(0),F.writeUInt32(12),F.writeUInt16(0),F.writeUInt16(262),F.writeUInt16(0),F.write(g),{charMap:i,subtable:F.data,maxGlyphID:p+1};case"unicode":for(C=[],l=[],w={},n={},m=h=null,E=y=0,R=o.length;E<R;E++)null==w[b=t[r=o[E]]]&&(w[b]=++y),n[r]={old:b,new:w[b]},a=w[b]-r,null!=m&&a===h||(m&&l.push(m),C.push(r),h=a),m=r;for(m&&l.push(m),l.push(65535),C.push(65535),A=2*(_=C.length),k=2*Math.pow(Math.log(_)/Math.LN2,2),u=Math.log(k/2)/Math.LN2,S=2*_-k,s=[],x=[],f=[],d=q=0,j=C.length;q<j;d=++q){if(I=C[d],c=l[d],65535===I){s.push(0),x.push(0);break}if(32768<=I-(T=n[I].new))for(s.push(0),x.push(2*(f.length+_-d)),r=O=I;I<=c?O<=c:c<=O;r=I<=c?++O:--O)f.push(n[r].new);else s.push(T-I),x.push(0)}for(F.writeUInt16(3),F.writeUInt16(1),F.writeUInt32(12),F.writeUInt16(4),F.writeUInt16(16+8*_+2*f.length),F.writeUInt16(0),F.writeUInt16(A),F.writeUInt16(k),F.writeUInt16(u),F.writeUInt16(S),L=0,D=l.length;L<D;L++)r=l[L],F.writeUInt16(r);for(F.writeUInt16(0),H=0,M=C.length;H<M;H++)r=C[H],F.writeUInt16(r);for(G=0,U=s.length;G<U;G++)a=s[G],F.writeUInt16(a);for(V=0,N=x.length;V<N;V++)v=x[V],F.writeUInt16(v);for(Y=0,z=f.length;Y<z;Y++)p=f[Y],F.writeUInt16(p);return{charMap:n,subtable:F.data,maxGlyphID:y+1}}},t}(),m=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="cmap",e.prototype.parse=function(t){var e,n,r;for(t.pos=this.offset,this.version=t.readUInt16(),n=t.readUInt16(),this.tables=[],this.unicode=null,r=0;0<=n?r<n:n<r;0<=n?++r:--r)e=new p(t,this.offset),this.tables.push(e),e.isUnicode&&null==this.unicode&&(this.unicode=e);return!0},e.encode=function(t,e){var n,r;return null==e&&(e="macroman"),n=p.encode(t,e),(r=new X).writeUInt16(0),r.writeUInt16(1),n.table=r.data.concat(n.subtable),n},e}(),g=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="hhea",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.ascender=t.readShort(),this.decender=t.readShort(),this.lineGap=t.readShort(),this.advanceWidthMax=t.readShort(),this.minLeftSideBearing=t.readShort(),this.minRightSideBearing=t.readShort(),this.xMaxExtent=t.readShort(),this.caretSlopeRise=t.readShort(),this.caretSlopeRun=t.readShort(),this.caretOffset=t.readShort(),t.pos+=8,this.metricDataFormat=t.readShort(),this.numberOfMetrics=t.readUInt16()},e}(),w=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="OS/2",e.prototype.parse=function(n){if(n.pos=this.offset,this.version=n.readUInt16(),this.averageCharWidth=n.readShort(),this.weightClass=n.readUInt16(),this.widthClass=n.readUInt16(),this.type=n.readShort(),this.ySubscriptXSize=n.readShort(),this.ySubscriptYSize=n.readShort(),this.ySubscriptXOffset=n.readShort(),this.ySubscriptYOffset=n.readShort(),this.ySuperscriptXSize=n.readShort(),this.ySuperscriptYSize=n.readShort(),this.ySuperscriptXOffset=n.readShort(),this.ySuperscriptYOffset=n.readShort(),this.yStrikeoutSize=n.readShort(),this.yStrikeoutPosition=n.readShort(),this.familyClass=n.readShort(),this.panose=function(){var t,e;for(e=[],t=0;t<10;++t)e.push(n.readByte());return e}(),this.charRange=function(){var t,e;for(e=[],t=0;t<4;++t)e.push(n.readInt());return e}(),this.vendorID=n.readString(4),this.selection=n.readShort(),this.firstCharIndex=n.readShort(),this.lastCharIndex=n.readShort(),0<this.version&&(this.ascent=n.readShort(),this.descent=n.readShort(),this.lineGap=n.readShort(),this.winAscent=n.readShort(),this.winDescent=n.readShort(),this.codePageRange=function(){var t,e;for(e=[],t=0;t<2;++t)e.push(n.readInt());return e}(),1<this.version))return this.xHeight=n.readShort(),this.capHeight=n.readShort(),this.defaultChar=n.readShort(),this.breakChar=n.readShort(),this.maxContext=n.readShort()},e}(),y=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="post",e.prototype.parse=function(r){var t,e,n,i;switch(r.pos=this.offset,this.format=r.readInt(),this.italicAngle=r.readInt(),this.underlinePosition=r.readShort(),this.underlineThickness=r.readShort(),this.isFixedPitch=r.readInt(),this.minMemType42=r.readInt(),this.maxMemType42=r.readInt(),this.minMemType1=r.readInt(),this.maxMemType1=r.readInt(),this.format){case 65536:break;case 131072:for(e=r.readUInt16(),this.glyphNameIndex=[],n=0;0<=e?n<e:e<n;0<=e?++n:--n)this.glyphNameIndex.push(r.readUInt16());for(this.names=[],i=[];r.pos<this.offset+this.length;)t=r.readByte(),i.push(this.names.push(r.readString(t)));return i;case 151552:return e=r.readUInt16(),this.offsets=r.read(e);case 196608:break;case 262144:return this.map=function(){var t,e,n;for(n=[],t=0,e=this.file.maxp.numGlyphs;0<=e?t<e:e<t;0<=e?++t:--t)n.push(r.readUInt32());return n}.call(this)}},e}(),v=function(t,e){this.raw=t,this.length=t.length,this.platformID=e.platformID,this.encodingID=e.encodingID,this.languageID=e.languageID},b=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="name",e.prototype.parse=function(t){var e,n,r,i,o,a,s,h,c,l,u,f;for(t.pos=this.offset,t.readShort(),e=t.readShort(),a=t.readShort(),n=[],i=c=0;0<=e?c<e:e<c;i=0<=e?++c:--c)n.push({platformID:t.readShort(),encodingID:t.readShort(),languageID:t.readShort(),nameID:t.readShort(),length:t.readShort(),offset:this.offset+a+t.readShort()});for(s={},i=l=0,u=n.length;l<u;i=++l)r=n[i],t.pos=r.offset,h=t.readString(r.length),o=new v(h,r),null==s[f=r.nameID]&&(s[f]=[]),s[r.nameID].push(o);return this.strings=s,this.copyright=s[0],this.fontFamily=s[1],this.fontSubfamily=s[2],this.uniqueSubfamily=s[3],this.fontName=s[4],this.version=s[5],this.postscriptName=s[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g,""),this.trademark=s[7],this.manufacturer=s[8],this.designer=s[9],this.description=s[10],this.vendorUrl=s[11],this.designerUrl=s[12],this.license=s[13],this.licenseUrl=s[14],this.preferredFamily=s[15],this.preferredSubfamily=s[17],this.compatibleFull=s[18],this.sampleText=s[19]},e}(),x=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="maxp",e.prototype.parse=function(t){return t.pos=this.offset,this.version=t.readInt(),this.numGlyphs=t.readUInt16(),this.maxPoints=t.readUInt16(),this.maxContours=t.readUInt16(),this.maxCompositePoints=t.readUInt16(),this.maxComponentContours=t.readUInt16(),this.maxZones=t.readUInt16(),this.maxTwilightPoints=t.readUInt16(),this.maxStorage=t.readUInt16(),this.maxFunctionDefs=t.readUInt16(),this.maxInstructionDefs=t.readUInt16(),this.maxStackElements=t.readUInt16(),this.maxSizeOfInstructions=t.readUInt16(),this.maxComponentElements=t.readUInt16(),this.maxComponentDepth=t.readUInt16()},e}(),S=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="hmtx",e.prototype.parse=function(n){var t,r,i,e,o,a,s;for(n.pos=this.offset,this.metrics=[],e=0,a=this.file.hhea.numberOfMetrics;0<=a?e<a:a<e;0<=a?++e:--e)this.metrics.push({advance:n.readUInt16(),lsb:n.readInt16()});for(r=this.file.maxp.numGlyphs-this.file.hhea.numberOfMetrics,this.leftSideBearings=function(){var t,e;for(e=[],t=0;0<=r?t<r:r<t;0<=r?++t:--t)e.push(n.readInt16());return e}(),this.widths=function(){var t,e,n,r;for(r=[],t=0,e=(n=this.metrics).length;t<e;t++)i=n[t],r.push(i.advance);return r}.call(this),t=this.widths[this.widths.length-1],s=[],o=0;0<=r?o<r:r<o;0<=r?++o:--o)s.push(this.widths.push(t));return s},e.prototype.forGlyph=function(t){return t in this.metrics?this.metrics[t]:{advance:this.metrics[this.metrics.length-1].advance,lsb:this.leftSideBearings[t-this.metrics.length]}},e}(),k=[].slice,_=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="glyf",e.prototype.parse=function(t){return this.cache={}},e.prototype.glyphFor=function(t){var e,n,r,i,o,a,s,h,c,l;return(t=t)in this.cache?this.cache[t]:(i=this.file.loca,e=this.file.contents,n=i.indexOf(t),0===(r=i.lengthOf(t))?this.cache[t]=null:(e.pos=this.offset+n,o=(a=new X(e.read(r))).readShort(),h=a.readShort(),l=a.readShort(),s=a.readShort(),c=a.readShort(),this.cache[t]=-1===o?new I(a,h,l,s,c):new A(a,o,h,l,s,c),this.cache[t]))},e.prototype.encode=function(t,e,n){var r,i,o,a,s;for(o=[],i=[],a=0,s=e.length;a<s;a++)r=t[e[a]],i.push(o.length),r&&(o=o.concat(r.encode(n)));return i.push(o.length),{table:o,offsets:i}},e}(),A=function(){function t(t,e,n,r,i,o){this.raw=t,this.numberOfContours=e,this.xMin=n,this.yMin=r,this.xMax=i,this.yMax=o,this.compound=!1}return t.prototype.encode=function(){return this.raw.data},t}(),I=function(){function t(t,e,n,r,i){var o,a;for(this.raw=t,this.xMin=e,this.yMin=n,this.xMax=r,this.yMax=i,this.compound=!0,this.glyphIDs=[],this.glyphOffsets=[],o=this.raw;a=o.readShort(),this.glyphOffsets.push(o.pos),this.glyphIDs.push(o.readShort()),32&a;)o.pos+=1&a?4:2,128&a?o.pos+=8:64&a?o.pos+=4:8&a&&(o.pos+=2)}return 1,8,32,64,128,t.prototype.encode=function(t){var e,n,r,i,o;for(n=new X(k.call(this.raw.data)),e=r=0,i=(o=this.glyphIDs).length;r<i;e=++r)o[e],n.pos=this.glyphOffsets[e];return n.data},t}(),C=function(t){function e(){return e.__super__.constructor.apply(this,arguments)}return f(e,c),e.prototype.tag="loca",e.prototype.parse=function(r){var t;return r.pos=this.offset,t=this.file.head.indexToLocFormat,this.offsets=0===t?function(){var t,e,n;for(n=[],t=0,e=this.length;t<e;t+=2)n.push(2*r.readUInt16());return n}.call(this):function(){var t,e,n;for(n=[],t=0,e=this.length;t<e;t+=4)n.push(r.readUInt32());return n}.call(this)},e.prototype.indexOf=function(t){return this.offsets[t]},e.prototype.lengthOf=function(t){return this.offsets[t+1]-this.offsets[t]},e.prototype.encode=function(t,e){for(var n=new Uint32Array(this.offsets.length),r=0,i=0,o=0;o<n.length;++o)if(n[o]=r,i<e.length&&e[i]==o){++i,n[o]=r;var a=this.offsets[o],s=this.offsets[o+1]-a;0<s&&(r+=s)}for(var h=new Array(4*n.length),c=0;c<n.length;++c)h[4*c+3]=255&n[c],h[4*c+2]=(65280&n[c])>>8,h[4*c+1]=(16711680&n[c])>>16,h[4*c]=(4278190080&n[c])>>24;return h},e}(),T=function(){function t(t){this.font=t,this.subset={},this.unicodes={},this.next=33}return t.prototype.generateCmap=function(){var t,e,n,r,i;for(e in r=this.font.cmap.tables[0].codeMap,t={},i=this.subset)n=i[e],t[e]=r[n];return t},t.prototype.glyphsFor=function(t){var e,n,r,i,o,a,s;for(r={},o=0,a=t.length;o<a;o++)r[i=t[o]]=this.font.glyf.glyphFor(i);for(i in e=[],r)(null!=(n=r[i])?n.compound:void 0)&&e.push.apply(e,n.glyphIDs);if(0<e.length)for(i in s=this.glyphsFor(e))n=s[i],r[i]=n;return r},t.prototype.encode=function(t){var e,n,r,i,o,a,s,h,c,l,u,f,d,p,g;for(n in e=m.encode(this.generateCmap(),"unicode"),i=this.glyphsFor(t),u={0:0},g=e.charMap)u[(a=g[n]).old]=a.new;for(f in l=e.maxGlyphID,i)f in u||(u[f]=l++);return h=function(t){var e,n;for(e in n={},t)n[t[e]]=e;return n}(u),c=Object.keys(h).sort(function(t,e){return t-e}),d=function(){var t,e,n;for(n=[],t=0,e=c.length;t<e;t++)o=c[t],n.push(h[o]);return n}(),r=this.font.glyf.encode(i,d,u),s=this.font.loca.encode(r.offsets,d),p={cmap:this.font.cmap.raw(),glyf:r.table,loca:s,hmtx:this.font.hmtx.raw(),hhea:this.font.hhea.raw(),maxp:this.font.maxp.raw(),post:this.font.post.raw(),name:this.font.name.raw(),head:this.font.head.raw()},this.font.os2.exists&&(p["OS/2"]=this.font.os2.raw()),this.font.directory.encode(p)},t}();t.API.PDFObject=function(){var o;function a(){}return o=function(t,e){return(Array(e+1).join("0")+t).slice(-e)},a.convert=function(r){var i,t,e,n;if(Array.isArray(r))return"["+function(){var t,e,n;for(n=[],t=0,e=r.length;t<e;t++)i=r[t],n.push(a.convert(i));return n}().join(" ")+"]";if("string"==typeof r)return"/"+r;if(null!=r?r.isString:void 0)return"("+r+")";if(r instanceof Date)return"(D:"+o(r.getUTCFullYear(),4)+o(r.getUTCMonth(),2)+o(r.getUTCDate(),2)+o(r.getUTCHours(),2)+o(r.getUTCMinutes(),2)+o(r.getUTCSeconds(),2)+"Z)";if("[object Object]"==={}.toString.call(r)){for(t in e=["<<"],r)n=r[t],e.push("/"+t+" "+a.convert(n));return e.push(">>"),e.join("\n")}return""+r},a}()}($),
/*
  # PNG.js
  # Copyright (c) 2011 Devon Govett
  # MIT LICENSE
  # 
  # 
  */
pt="undefined"!=typeof self&&self||"undefined"!=typeof window&&window||"undefined"!=typeof global&&global||Function('return typeof this === "object" && this.content')()||Function("return this")(),gt=function(){var c,n,r;function i(t){var e,n,r,i,o,a,s,h,c,l,u,f,d,p;for(this.data=t,this.pos=8,this.palette=[],this.imgData=[],this.transparency={},this.animation=null,this.text={},a=null;;){switch(e=this.readUInt32(),c=function(){var t,e;for(e=[],t=0;t<4;++t)e.push(String.fromCharCode(this.data[this.pos++]));return e}.call(this).join("")){case"IHDR":this.width=this.readUInt32(),this.height=this.readUInt32(),this.bits=this.data[this.pos++],this.colorType=this.data[this.pos++],this.compressionMethod=this.data[this.pos++],this.filterMethod=this.data[this.pos++],this.interlaceMethod=this.data[this.pos++];break;case"acTL":this.animation={numFrames:this.readUInt32(),numPlays:this.readUInt32()||1/0,frames:[]};break;case"PLTE":this.palette=this.read(e);break;case"fcTL":a&&this.animation.frames.push(a),this.pos+=4,a={width:this.readUInt32(),height:this.readUInt32(),xOffset:this.readUInt32(),yOffset:this.readUInt32()},o=this.readUInt16(),i=this.readUInt16()||100,a.delay=1e3*o/i,a.disposeOp=this.data[this.pos++],a.blendOp=this.data[this.pos++],a.data=[];break;case"IDAT":case"fdAT":for("fdAT"===c&&(this.pos+=4,e-=4),t=(null!=a?a.data:void 0)||this.imgData,f=0;0<=e?f<e:e<f;0<=e?++f:--f)t.push(this.data[this.pos++]);break;case"tRNS":switch(this.transparency={},this.colorType){case 3:if(r=this.palette.length/3,this.transparency.indexed=this.read(e),this.transparency.indexed.length>r)throw new Error("More transparent colors than palette size");if(0<(l=r-this.transparency.indexed.length))for(d=0;0<=l?d<l:l<d;0<=l?++d:--d)this.transparency.indexed.push(255);break;case 0:this.transparency.grayscale=this.read(e)[0];break;case 2:this.transparency.rgb=this.read(e)}break;case"tEXt":s=(u=this.read(e)).indexOf(0),h=String.fromCharCode.apply(String,u.slice(0,s)),this.text[h]=String.fromCharCode.apply(String,u.slice(s+1));break;case"IEND":return a&&this.animation.frames.push(a),this.colors=function(){switch(this.colorType){case 0:case 3:case 4:return 1;case 2:case 6:return 3}}.call(this),this.hasAlphaChannel=4===(p=this.colorType)||6===p,n=this.colors+(this.hasAlphaChannel?1:0),this.pixelBitlength=this.bits*n,this.colorSpace=function(){switch(this.colors){case 1:return"DeviceGray";case 3:return"DeviceRGB"}}.call(this),void(this.imgData=new Uint8Array(this.imgData));default:this.pos+=e}if(this.pos+=4,this.pos>this.data.length)throw new Error("Incomplete or corrupt PNG file")}}i.load=function(t,e,n){var r;return"function"==typeof e&&(n=e),(r=new XMLHttpRequest).open("GET",t,!0),r.responseType="arraybuffer",r.onload=function(){var t;return t=new i(new Uint8Array(r.response||r.mozResponseArrayBuffer)),"function"==typeof(null!=e?e.getContext:void 0)&&t.render(e),"function"==typeof n?n(t):void 0},r.send(null)},i.prototype.read=function(t){var e,n;for(n=[],e=0;0<=t?e<t:t<e;0<=t?++e:--e)n.push(this.data[this.pos++]);return n},i.prototype.readUInt32=function(){return this.data[this.pos++]<<24|this.data[this.pos++]<<16|this.data[this.pos++]<<8|this.data[this.pos++]},i.prototype.readUInt16=function(){return this.data[this.pos++]<<8|this.data[this.pos++]},i.prototype.decodePixels=function(E){var q=this.pixelBitlength/8,O=new Uint8Array(this.width*this.height*q),B=0,R=this;if(null==E&&(E=this.imgData),0===E.length)return new Uint8Array(0);function t(t,e,n,r){var i,o,a,s,h,c,l,u,f,d,p,g,m,w,y,v,b,x,S,k,_,A=Math.ceil((R.width-t)/n),I=Math.ceil((R.height-e)/r),C=R.width==A&&R.height==I;for(w=q*A,g=C?O:new Uint8Array(w*I),c=E.length,o=m=0;m<I&&B<c;){switch(E[B++]){case 0:for(s=b=0;b<w;s=b+=1)g[o++]=E[B++];break;case 1:for(s=x=0;x<w;s=x+=1)i=E[B++],h=s<q?0:g[o-q],g[o++]=(i+h)%256;break;case 2:for(s=S=0;S<w;s=S+=1)i=E[B++],a=(s-s%q)/q,y=m&&g[(m-1)*w+a*q+s%q],g[o++]=(y+i)%256;break;case 3:for(s=k=0;k<w;s=k+=1)i=E[B++],a=(s-s%q)/q,h=s<q?0:g[o-q],y=m&&g[(m-1)*w+a*q+s%q],g[o++]=(i+Math.floor((h+y)/2))%256;break;case 4:for(s=_=0;_<w;s=_+=1)i=E[B++],a=(s-s%q)/q,h=s<q?0:g[o-q],0===m?y=v=0:(y=g[(m-1)*w+a*q+s%q],v=a&&g[(m-1)*w+(a-1)*q+s%q]),l=h+y-v,u=Math.abs(l-h),d=Math.abs(l-y),p=Math.abs(l-v),f=u<=d&&u<=p?h:d<=p?y:v,g[o++]=(i+f)%256;break;default:throw new Error("Invalid filter algorithm: "+E[B-1])}if(!C){var T=((e+m*r)*R.width+t)*q,F=m*w;for(s=0;s<A;s+=1){for(var P=0;P<q;P+=1)O[T++]=g[F++];T+=(n-1)*q}}m++}}return E=(E=new kt(E)).getBytes(),1==R.interlaceMethod?(t(0,0,8,8),t(4,0,8,8),t(0,4,4,8),t(2,0,4,4),t(0,2,2,4),t(1,0,2,2),t(0,1,1,2)):t(0,0,1,1),O},i.prototype.decodePalette=function(){var t,e,n,r,i,o,a,s,h;for(n=this.palette,o=this.transparency.indexed||[],i=new Uint8Array((o.length||0)+n.length),r=0,n.length,e=a=t=0,s=n.length;a<s;e=a+=3)i[r++]=n[e],i[r++]=n[e+1],i[r++]=n[e+2],i[r++]=null!=(h=o[t++])?h:255;return i},i.prototype.copyToImageData=function(t,e){var n,r,i,o,a,s,h,c,l,u,f;if(r=this.colors,l=null,n=this.hasAlphaChannel,this.palette.length&&(l=null!=(f=this._decodedPalette)?f:this._decodedPalette=this.decodePalette(),r=4,n=!0),c=(i=t.data||t).length,a=l||e,o=s=0,1===r)for(;o<c;)h=l?4*e[o/4]:s,u=a[h++],i[o++]=u,i[o++]=u,i[o++]=u,i[o++]=n?a[h++]:255,s=h;else for(;o<c;)h=l?4*e[o/4]:s,i[o++]=a[h++],i[o++]=a[h++],i[o++]=a[h++],i[o++]=n?a[h++]:255,s=h},i.prototype.decode=function(){var t;return t=new Uint8Array(this.width*this.height*4),this.copyToImageData(t,this.decodePixels()),t};try{n=pt.document.createElement("canvas"),r=n.getContext("2d")}catch(t){return-1}return c=function(t){var e;return r.width=t.width,r.height=t.height,r.clearRect(0,0,t.width,t.height),r.putImageData(t,0,0),(e=new Image).src=n.toDataURL(),e},i.prototype.decodeFrames=function(t){var e,n,r,i,o,a,s,h;if(this.animation){for(h=[],n=o=0,a=(s=this.animation.frames).length;o<a;n=++o)e=s[n],r=t.createImageData(e.width,e.height),i=this.decodePixels(new Uint8Array(e.data)),this.copyToImageData(r,i),e.imageData=r,h.push(e.image=c(r));return h}},i.prototype.renderFrame=function(t,e){var n,r,i;return n=(r=this.animation.frames)[e],i=r[e-1],0===e&&t.clearRect(0,0,this.width,this.height),1===(null!=i?i.disposeOp:void 0)?t.clearRect(i.xOffset,i.yOffset,i.width,i.height):2===(null!=i?i.disposeOp:void 0)&&t.putImageData(i.imageData,i.xOffset,i.yOffset),0===n.blendOp&&t.clearRect(n.xOffset,n.yOffset,n.width,n.height),t.drawImage(n.image,n.xOffset,n.yOffset)},i.prototype.animate=function(n){var r,i,o,a,s,t,h=this;return i=0,t=this.animation,a=t.numFrames,o=t.frames,s=t.numPlays,(r=function(){var t,e;if(t=i++%a,e=o[t],h.renderFrame(n,t),1<a&&i/a<s)return h.animation._timeout=setTimeout(r,e.delay)})()},i.prototype.stopAnimation=function(){var t;return clearTimeout(null!=(t=this.animation)?t._timeout:void 0)},i.prototype.render=function(t){var e,n;return t._png&&t._png.stopAnimation(),t._png=this,t.width=this.width,t.height=this.height,e=t.getContext("2d"),this.animation?(this.decodeFrames(e),this.animate(e)):(n=e.createImageData(this.width,this.height),this.copyToImageData(n,this.decodePixels()),e.putImageData(n,0,0))},i}(),pt.PNG=gt;
/*
   * Extracted from pdf.js
   * https://github.com/andreasgal/pdf.js
   *
   * Copyright (c) 2011 Mozilla Foundation
   *
   * Contributors: Andreas Gal <gal@mozilla.com>
   *               Chris G Jones <cjones@mozilla.com>
   *               Shaon Barman <shaon.barman@gmail.com>
   *               Vivien Nicolas <21@vingtetun.org>
   *               Justin D'Arcangelo <justindarc@gmail.com>
   *               Yury Delendik
   *
   * 
   */
var St=function(){function t(){this.pos=0,this.bufferLength=0,this.eof=!1,this.buffer=null}return t.prototype={ensureBuffer:function(t){var e=this.buffer,n=e?e.byteLength:0;if(t<n)return e;for(var r=512;r<t;)r<<=1;for(var i=new Uint8Array(r),o=0;o<n;++o)i[o]=e[o];return this.buffer=i},getByte:function(){for(var t=this.pos;this.bufferLength<=t;){if(this.eof)return null;this.readBlock()}return this.buffer[this.pos++]},getBytes:function(t){var e=this.pos;if(t){this.ensureBuffer(e+t);for(var n=e+t;!this.eof&&this.bufferLength<n;)this.readBlock();var r=this.bufferLength;r<n&&(n=r)}else{for(;!this.eof;)this.readBlock();n=this.bufferLength}return this.pos=n,this.buffer.subarray(e,n)},lookChar:function(){for(var t=this.pos;this.bufferLength<=t;){if(this.eof)return null;this.readBlock()}return String.fromCharCode(this.buffer[this.pos])},getChar:function(){for(var t=this.pos;this.bufferLength<=t;){if(this.eof)return null;this.readBlock()}return String.fromCharCode(this.buffer[this.pos++])},makeSubStream:function(t,e,n){for(var r=t+e;this.bufferLength<=r&&!this.eof;)this.readBlock();return new Stream(this.buffer,t,e,n)},skip:function(t){t||(t=1),this.pos+=t},reset:function(){this.pos=0}},t}(),kt=function(){if("undefined"!=typeof Uint32Array){var F=new Uint32Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),P=new Uint32Array([3,4,5,6,7,8,9,10,65547,65549,65551,65553,131091,131095,131099,131103,196643,196651,196659,196667,262211,262227,262243,262259,327811,327843,327875,327907,258,258,258]),E=new Uint32Array([1,2,3,4,65541,65543,131081,131085,196625,196633,262177,262193,327745,327777,393345,393409,459009,459137,524801,525057,590849,591361,657409,658433,724993,727041,794625,798721,868353,876545]),q=[new Uint32Array([459008,524368,524304,524568,459024,524400,524336,590016,459016,524384,524320,589984,524288,524416,524352,590048,459012,524376,524312,589968,459028,524408,524344,590032,459020,524392,524328,59e4,524296,524424,524360,590064,459010,524372,524308,524572,459026,524404,524340,590024,459018,524388,524324,589992,524292,524420,524356,590056,459014,524380,524316,589976,459030,524412,524348,590040,459022,524396,524332,590008,524300,524428,524364,590072,459009,524370,524306,524570,459025,524402,524338,590020,459017,524386,524322,589988,524290,524418,524354,590052,459013,524378,524314,589972,459029,524410,524346,590036,459021,524394,524330,590004,524298,524426,524362,590068,459011,524374,524310,524574,459027,524406,524342,590028,459019,524390,524326,589996,524294,524422,524358,590060,459015,524382,524318,589980,459031,524414,524350,590044,459023,524398,524334,590012,524302,524430,524366,590076,459008,524369,524305,524569,459024,524401,524337,590018,459016,524385,524321,589986,524289,524417,524353,590050,459012,524377,524313,589970,459028,524409,524345,590034,459020,524393,524329,590002,524297,524425,524361,590066,459010,524373,524309,524573,459026,524405,524341,590026,459018,524389,524325,589994,524293,524421,524357,590058,459014,524381,524317,589978,459030,524413,524349,590042,459022,524397,524333,590010,524301,524429,524365,590074,459009,524371,524307,524571,459025,524403,524339,590022,459017,524387,524323,589990,524291,524419,524355,590054,459013,524379,524315,589974,459029,524411,524347,590038,459021,524395,524331,590006,524299,524427,524363,590070,459011,524375,524311,524575,459027,524407,524343,590030,459019,524391,524327,589998,524295,524423,524359,590062,459015,524383,524319,589982,459031,524415,524351,590046,459023,524399,524335,590014,524303,524431,524367,590078,459008,524368,524304,524568,459024,524400,524336,590017,459016,524384,524320,589985,524288,524416,524352,590049,459012,524376,524312,589969,459028,524408,524344,590033,459020,524392,524328,590001,524296,524424,524360,590065,459010,524372,524308,524572,459026,524404,524340,590025,459018,524388,524324,589993,524292,524420,524356,590057,459014,524380,524316,589977,459030,524412,524348,590041,459022,524396,524332,590009,524300,524428,524364,590073,459009,524370,524306,524570,459025,524402,524338,590021,459017,524386,524322,589989,524290,524418,524354,590053,459013,524378,524314,589973,459029,524410,524346,590037,459021,524394,524330,590005,524298,524426,524362,590069,459011,524374,524310,524574,459027,524406,524342,590029,459019,524390,524326,589997,524294,524422,524358,590061,459015,524382,524318,589981,459031,524414,524350,590045,459023,524398,524334,590013,524302,524430,524366,590077,459008,524369,524305,524569,459024,524401,524337,590019,459016,524385,524321,589987,524289,524417,524353,590051,459012,524377,524313,589971,459028,524409,524345,590035,459020,524393,524329,590003,524297,524425,524361,590067,459010,524373,524309,524573,459026,524405,524341,590027,459018,524389,524325,589995,524293,524421,524357,590059,459014,524381,524317,589979,459030,524413,524349,590043,459022,524397,524333,590011,524301,524429,524365,590075,459009,524371,524307,524571,459025,524403,524339,590023,459017,524387,524323,589991,524291,524419,524355,590055,459013,524379,524315,589975,459029,524411,524347,590039,459021,524395,524331,590007,524299,524427,524363,590071,459011,524375,524311,524575,459027,524407,524343,590031,459019,524391,524327,589999,524295,524423,524359,590063,459015,524383,524319,589983,459031,524415,524351,590047,459023,524399,524335,590015,524303,524431,524367,590079]),9],O=[new Uint32Array([327680,327696,327688,327704,327684,327700,327692,327708,327682,327698,327690,327706,327686,327702,327694,0,327681,327697,327689,327705,327685,327701,327693,327709,327683,327699,327691,327707,327687,327703,327695,0]),5];return(t.prototype=Object.create(St.prototype)).getBits=function(t){for(var e,n=this.codeSize,r=this.codeBuf,i=this.bytes,o=this.bytesPos;n<t;)void 0===(e=i[o++])&&B("Bad encoding in flate stream"),r|=e<<n,n+=8;return e=r&(1<<t)-1,this.codeBuf=r>>t,this.codeSize=n-=t,this.bytesPos=o,e},t.prototype.getCode=function(t){for(var e=t[0],n=t[1],r=this.codeSize,i=this.codeBuf,o=this.bytes,a=this.bytesPos;r<n;){var s;void 0===(s=o[a++])&&B("Bad encoding in flate stream"),i|=s<<r,r+=8}var h=e[i&(1<<n)-1],c=h>>16,l=65535&h;return(0==r||r<c||0==c)&&B("Bad encoding in flate stream"),this.codeBuf=i>>c,this.codeSize=r-c,this.bytesPos=a,l},t.prototype.generateHuffmanTable=function(t){for(var e=t.length,n=0,r=0;r<e;++r)t[r]>n&&(n=t[r]);for(var i=1<<n,o=new Uint32Array(i),a=1,s=0,h=2;a<=n;++a,s<<=1,h<<=1)for(var c=0;c<e;++c)if(t[c]==a){var l=0,u=s;for(r=0;r<a;++r)l=l<<1|1&u,u>>=1;for(r=l;r<i;r+=h)o[r]=a<<16|c;++s}return[o,n]},t.prototype.readBlock=function(){function t(t,e,n,r,i){for(var o=t.getBits(n)+r;0<o--;)e[h++]=i}var e=this.getBits(3);if(1&e&&(this.eof=!0),0!=(e>>=1)){var n,r;if(1==e)n=q,r=O;else if(2==e){for(var i=this.getBits(5)+257,o=this.getBits(5)+1,a=this.getBits(4)+4,s=Array(F.length),h=0;h<a;)s[F[h++]]=this.getBits(3);for(var c=this.generateHuffmanTable(s),l=0,u=(h=0,i+o),f=new Array(u);h<u;){var d=this.getCode(c);16==d?t(this,f,2,3,l):17==d?t(this,f,3,3,l=0):18==d?t(this,f,7,11,l=0):f[h++]=l=d}n=this.generateHuffmanTable(f.slice(0,i)),r=this.generateHuffmanTable(f.slice(i,u))}else B("Unknown block type in flate stream");for(var p=(I=this.buffer)?I.length:0,g=this.bufferLength;;){var m=this.getCode(n);if(m<256)p<=g+1&&(p=(I=this.ensureBuffer(g+1)).length),I[g++]=m;else{if(256==m)return void(this.bufferLength=g);var w=(m=P[m-=257])>>16;0<w&&(w=this.getBits(w));l=(65535&m)+w;m=this.getCode(r),0<(w=(m=E[m])>>16)&&(w=this.getBits(w));var y=(65535&m)+w;p<=g+l&&(p=(I=this.ensureBuffer(g+l)).length);for(var v=0;v<l;++v,++g)I[g]=I[g-y]}}}else{var b,x=this.bytes,S=this.bytesPos;void 0===(b=x[S++])&&B("Bad block header in flate stream");var k=b;void 0===(b=x[S++])&&B("Bad block header in flate stream"),k|=b<<8,void 0===(b=x[S++])&&B("Bad block header in flate stream");var _=b;void 0===(b=x[S++])&&B("Bad block header in flate stream"),(_|=b<<8)!=(65535&~k)&&B("Bad uncompressed block length in flate stream"),this.codeBuf=0,this.codeSize=0;var A=this.bufferLength,I=this.ensureBuffer(A+k),C=A+k;this.bufferLength=C;for(var T=A;T<C;++T){if(void 0===(b=x[S++])){this.eof=!0;break}I[T]=b}this.bytesPos=S}},t}function B(t){throw new Error(t)}function t(t){var e=0,n=t[e++],r=t[e++];-1!=n&&-1!=r||B("Invalid header in flate stream"),8!=(15&n)&&B("Unknown compression method in flate stream"),((n<<8)+r)%31!=0&&B("Bad FCHECK in flate stream"),32&r&&B("FDICT bit set in flate stream"),this.bytes=t,this.bytesPos=2,this.codeSize=0,this.codeBuf=0,St.call(this)}}();return function(t){if("object"!=typeof t.console){t.console={};for(var e,n,r=t.console,i=function(){},o=["memory"],a="assert,clear,count,debug,dir,dirxml,error,exception,group,groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn".split(",");e=o.pop();)r[e]||(r[e]={});for(;n=a.pop();)r[n]||(r[n]=i)}var s,h,c,l,u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";void 0===t.btoa&&(t.btoa=function(t){var e,n,r,i,o,a=0,s=0,h="",c=[];if(!t)return t;for(;e=(o=t.charCodeAt(a++)<<16|t.charCodeAt(a++)<<8|t.charCodeAt(a++))>>18&63,n=o>>12&63,r=o>>6&63,i=63&o,c[s++]=u.charAt(e)+u.charAt(n)+u.charAt(r)+u.charAt(i),a<t.length;);h=c.join("");var l=t.length%3;return(l?h.slice(0,l-3):h)+"===".slice(l||3)}),void 0===t.atob&&(t.atob=function(t){var e,n,r,i,o,a,s=0,h=0,c=[];if(!t)return t;for(t+="";e=(a=u.indexOf(t.charAt(s++))<<18|u.indexOf(t.charAt(s++))<<12|(i=u.indexOf(t.charAt(s++)))<<6|(o=u.indexOf(t.charAt(s++))))>>16&255,n=a>>8&255,r=255&a,c[h++]=64==i?String.fromCharCode(e):64==o?String.fromCharCode(e,n):String.fromCharCode(e,n,r),s<t.length;);return c.join("")}),Array.prototype.map||(Array.prototype.map=function(t){if(null==this||"function"!=typeof t)throw new TypeError;for(var e=Object(this),n=e.length>>>0,r=new Array(n),i=1<arguments.length?arguments[1]:void 0,o=0;o<n;o++)o in e&&(r[o]=t.call(i,e[o],o,e));return r}),Array.isArray||(Array.isArray=function(t){return"[object Array]"===Object.prototype.toString.call(t)}),Array.prototype.forEach||(Array.prototype.forEach=function(t,e){if(null==this||"function"!=typeof t)throw new TypeError;for(var n=Object(this),r=n.length>>>0,i=0;i<r;i++)i in n&&t.call(e,n[i],i,n)}),Object.keys||(Object.keys=(s=Object.prototype.hasOwnProperty,h=!{toString:null}.propertyIsEnumerable("toString"),l=(c=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"]).length,function(t){if("object"!=typeof t&&("function"!=typeof t||null===t))throw new TypeError;var e,n,r=[];for(e in t)s.call(t,e)&&r.push(e);if(h)for(n=0;n<l;n++)s.call(t,c[n])&&r.push(c[n]);return r})),"function"!=typeof Object.assign&&(Object.assign=function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");t=Object(t);for(var e=1;e<arguments.length;e++){var n=arguments[e];if(null!=n)for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}),String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")}),String.prototype.trimLeft||(String.prototype.trimLeft=function(){return this.replace(/^\s+/g,"")}),String.prototype.trimRight||(String.prototype.trimRight=function(){return this.replace(/\s+$/g,"")})}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||"undefined"!=typeof global&&global||Function('return typeof this === "object" && this.content')()||Function("return this")()),$});
},{"process":"g5I+"}],"Qq+a":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var PATH = exports.PATH = {
  VECTOR: 0,
  BEZIER_CURVE: 1,
  CIRCLE: 2
};
},{}],"IvPj":[function(require,module,exports) {
'use strict'; // http://dev.w3.org/csswg/css-color/

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var HEX3 = /^#([a-f0-9]{3})$/i;

var hex3 = function hex3(value) {
  var match = value.match(HEX3);

  if (match) {
    return [parseInt(match[1][0] + match[1][0], 16), parseInt(match[1][1] + match[1][1], 16), parseInt(match[1][2] + match[1][2], 16), null];
  }

  return false;
};

var HEX6 = /^#([a-f0-9]{6})$/i;

var hex6 = function hex6(value) {
  var match = value.match(HEX6);

  if (match) {
    return [parseInt(match[1].substring(0, 2), 16), parseInt(match[1].substring(2, 4), 16), parseInt(match[1].substring(4, 6), 16), null];
  }

  return false;
};

var RGB = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;

var rgb = function rgb(value) {
  var match = value.match(RGB);

  if (match) {
    return [Number(match[1]), Number(match[2]), Number(match[3]), null];
  }

  return false;
};

var RGBA = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;

var rgba = function rgba(value) {
  var match = value.match(RGBA);

  if (match && match.length > 4) {
    return [Number(match[1]), Number(match[2]), Number(match[3]), Number(match[4])];
  }

  return false;
};

var fromArray = function fromArray(array) {
  return [Math.min(array[0], 255), Math.min(array[1], 255), Math.min(array[2], 255), array.length > 3 ? array[3] : null];
};

var namedColor = function namedColor(name) {
  var color = NAMED_COLORS[name.toLowerCase()];
  return color ? color : false;
};

var Color = function () {
  function Color(value) {
    _classCallCheck(this, Color);

    var _ref = Array.isArray(value) ? fromArray(value) : hex3(value) || rgb(value) || rgba(value) || namedColor(value) || hex6(value) || [0, 0, 0, null],
        _ref2 = _slicedToArray(_ref, 4),
        r = _ref2[0],
        g = _ref2[1],
        b = _ref2[2],
        a = _ref2[3];

    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }

  _createClass(Color, [{
    key: 'isTransparent',
    value: function isTransparent() {
      return this.a === 0;
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.a !== null && this.a !== 1 ? 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')' : 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    }
  }]);

  return Color;
}();

exports.default = Color;
var NAMED_COLORS = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, null],
  antiquewhite: [250, 235, 215, null],
  aqua: [0, 255, 255, null],
  aquamarine: [127, 255, 212, null],
  azure: [240, 255, 255, null],
  beige: [245, 245, 220, null],
  bisque: [255, 228, 196, null],
  black: [0, 0, 0, null],
  blanchedalmond: [255, 235, 205, null],
  blue: [0, 0, 255, null],
  blueviolet: [138, 43, 226, null],
  brown: [165, 42, 42, null],
  burlywood: [222, 184, 135, null],
  cadetblue: [95, 158, 160, null],
  chartreuse: [127, 255, 0, null],
  chocolate: [210, 105, 30, null],
  coral: [255, 127, 80, null],
  cornflowerblue: [100, 149, 237, null],
  cornsilk: [255, 248, 220, null],
  crimson: [220, 20, 60, null],
  cyan: [0, 255, 255, null],
  darkblue: [0, 0, 139, null],
  darkcyan: [0, 139, 139, null],
  darkgoldenrod: [184, 134, 11, null],
  darkgray: [169, 169, 169, null],
  darkgreen: [0, 100, 0, null],
  darkgrey: [169, 169, 169, null],
  darkkhaki: [189, 183, 107, null],
  darkmagenta: [139, 0, 139, null],
  darkolivegreen: [85, 107, 47, null],
  darkorange: [255, 140, 0, null],
  darkorchid: [153, 50, 204, null],
  darkred: [139, 0, 0, null],
  darksalmon: [233, 150, 122, null],
  darkseagreen: [143, 188, 143, null],
  darkslateblue: [72, 61, 139, null],
  darkslategray: [47, 79, 79, null],
  darkslategrey: [47, 79, 79, null],
  darkturquoise: [0, 206, 209, null],
  darkviolet: [148, 0, 211, null],
  deeppink: [255, 20, 147, null],
  deepskyblue: [0, 191, 255, null],
  dimgray: [105, 105, 105, null],
  dimgrey: [105, 105, 105, null],
  dodgerblue: [30, 144, 255, null],
  firebrick: [178, 34, 34, null],
  floralwhite: [255, 250, 240, null],
  forestgreen: [34, 139, 34, null],
  fuchsia: [255, 0, 255, null],
  gainsboro: [220, 220, 220, null],
  ghostwhite: [248, 248, 255, null],
  gold: [255, 215, 0, null],
  goldenrod: [218, 165, 32, null],
  gray: [128, 128, 128, null],
  green: [0, 128, 0, null],
  greenyellow: [173, 255, 47, null],
  grey: [128, 128, 128, null],
  honeydew: [240, 255, 240, null],
  hotpink: [255, 105, 180, null],
  indianred: [205, 92, 92, null],
  indigo: [75, 0, 130, null],
  ivory: [255, 255, 240, null],
  khaki: [240, 230, 140, null],
  lavender: [230, 230, 250, null],
  lavenderblush: [255, 240, 245, null],
  lawngreen: [124, 252, 0, null],
  lemonchiffon: [255, 250, 205, null],
  lightblue: [173, 216, 230, null],
  lightcoral: [240, 128, 128, null],
  lightcyan: [224, 255, 255, null],
  lightgoldenrodyellow: [250, 250, 210, null],
  lightgray: [211, 211, 211, null],
  lightgreen: [144, 238, 144, null],
  lightgrey: [211, 211, 211, null],
  lightpink: [255, 182, 193, null],
  lightsalmon: [255, 160, 122, null],
  lightseagreen: [32, 178, 170, null],
  lightskyblue: [135, 206, 250, null],
  lightslategray: [119, 136, 153, null],
  lightslategrey: [119, 136, 153, null],
  lightsteelblue: [176, 196, 222, null],
  lightyellow: [255, 255, 224, null],
  lime: [0, 255, 0, null],
  limegreen: [50, 205, 50, null],
  linen: [250, 240, 230, null],
  magenta: [255, 0, 255, null],
  maroon: [128, 0, 0, null],
  mediumaquamarine: [102, 205, 170, null],
  mediumblue: [0, 0, 205, null],
  mediumorchid: [186, 85, 211, null],
  mediumpurple: [147, 112, 219, null],
  mediumseagreen: [60, 179, 113, null],
  mediumslateblue: [123, 104, 238, null],
  mediumspringgreen: [0, 250, 154, null],
  mediumturquoise: [72, 209, 204, null],
  mediumvioletred: [199, 21, 133, null],
  midnightblue: [25, 25, 112, null],
  mintcream: [245, 255, 250, null],
  mistyrose: [255, 228, 225, null],
  moccasin: [255, 228, 181, null],
  navajowhite: [255, 222, 173, null],
  navy: [0, 0, 128, null],
  oldlace: [253, 245, 230, null],
  olive: [128, 128, 0, null],
  olivedrab: [107, 142, 35, null],
  orange: [255, 165, 0, null],
  orangered: [255, 69, 0, null],
  orchid: [218, 112, 214, null],
  palegoldenrod: [238, 232, 170, null],
  palegreen: [152, 251, 152, null],
  paleturquoise: [175, 238, 238, null],
  palevioletred: [219, 112, 147, null],
  papayawhip: [255, 239, 213, null],
  peachpuff: [255, 218, 185, null],
  peru: [205, 133, 63, null],
  pink: [255, 192, 203, null],
  plum: [221, 160, 221, null],
  powderblue: [176, 224, 230, null],
  purple: [128, 0, 128, null],
  rebeccapurple: [102, 51, 153, null],
  red: [255, 0, 0, null],
  rosybrown: [188, 143, 143, null],
  royalblue: [65, 105, 225, null],
  saddlebrown: [139, 69, 19, null],
  salmon: [250, 128, 114, null],
  sandybrown: [244, 164, 96, null],
  seagreen: [46, 139, 87, null],
  seashell: [255, 245, 238, null],
  sienna: [160, 82, 45, null],
  silver: [192, 192, 192, null],
  skyblue: [135, 206, 235, null],
  slateblue: [106, 90, 205, null],
  slategray: [112, 128, 144, null],
  slategrey: [112, 128, 144, null],
  snow: [255, 250, 250, null],
  springgreen: [0, 255, 127, null],
  steelblue: [70, 130, 180, null],
  tan: [210, 180, 140, null],
  teal: [0, 128, 128, null],
  thistle: [216, 191, 216, null],
  tomato: [255, 99, 71, null],
  turquoise: [64, 224, 208, null],
  violet: [238, 130, 238, null],
  wheat: [245, 222, 179, null],
  white: [255, 255, 255, null],
  whitesmoke: [245, 245, 245, null],
  yellow: [255, 255, 0, null],
  yellowgreen: [154, 205, 50, null]
};
var TRANSPARENT = exports.TRANSPARENT = new Color([0, 0, 0, 0]);
},{}],"37pw":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTextDecoration = exports.TEXT_DECORATION_LINE = exports.TEXT_DECORATION = exports.TEXT_DECORATION_STYLE = undefined;

var _Color = require('../Color');

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var TEXT_DECORATION_STYLE = exports.TEXT_DECORATION_STYLE = {
  SOLID: 0,
  DOUBLE: 1,
  DOTTED: 2,
  DASHED: 3,
  WAVY: 4
};
var TEXT_DECORATION = exports.TEXT_DECORATION = {
  NONE: null
};
var TEXT_DECORATION_LINE = exports.TEXT_DECORATION_LINE = {
  UNDERLINE: 1,
  OVERLINE: 2,
  LINE_THROUGH: 3,
  BLINK: 4
};

var parseLine = function parseLine(line) {
  switch (line) {
    case 'underline':
      return TEXT_DECORATION_LINE.UNDERLINE;

    case 'overline':
      return TEXT_DECORATION_LINE.OVERLINE;

    case 'line-through':
      return TEXT_DECORATION_LINE.LINE_THROUGH;
  }

  return TEXT_DECORATION_LINE.BLINK;
};

var parseTextDecorationLine = function parseTextDecorationLine(line) {
  if (line === 'none') {
    return null;
  }

  return line.split(' ').map(parseLine);
};

var parseTextDecorationStyle = function parseTextDecorationStyle(style) {
  switch (style) {
    case 'double':
      return TEXT_DECORATION_STYLE.DOUBLE;

    case 'dotted':
      return TEXT_DECORATION_STYLE.DOTTED;

    case 'dashed':
      return TEXT_DECORATION_STYLE.DASHED;

    case 'wavy':
      return TEXT_DECORATION_STYLE.WAVY;
  }

  return TEXT_DECORATION_STYLE.SOLID;
};

var parseTextDecoration = exports.parseTextDecoration = function parseTextDecoration(style) {
  var textDecorationLine = parseTextDecorationLine(style.textDecorationLine ? style.textDecorationLine : style.textDecoration);

  if (textDecorationLine === null) {
    return TEXT_DECORATION.NONE;
  }

  var textDecorationColor = style.textDecorationColor ? new _Color2.default(style.textDecorationColor) : null;
  var textDecorationStyle = parseTextDecorationStyle(style.textDecorationStyle);
  return {
    textDecorationLine: textDecorationLine,
    textDecorationColor: textDecorationColor,
    textDecorationStyle: textDecorationStyle
  };
};
},{"../Color":"IvPj"}],"R8cr":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Path = require('../drawing/Path');

var _textDecoration = require('../parsing/textDecoration');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var addColorStops = function addColorStops(gradient, canvasGradient) {
  var maxStop = Math.max.apply(null, gradient.colorStops.map(function (colorStop) {
    return colorStop.stop;
  }));
  var f = 1 / Math.max(1, maxStop);
  gradient.colorStops.forEach(function (colorStop) {
    canvasGradient.addColorStop(f * colorStop.stop, colorStop.color.toString());
  });
};

var CanvasRenderer = function () {
  function CanvasRenderer(canvas) {
    _classCallCheck(this, CanvasRenderer);

    this.canvas = canvas ? canvas : document.createElement('canvas');
  }

  _createClass(CanvasRenderer, [{
    key: 'render',
    value: function render(options) {
      this.ctx = this.canvas.getContext('2d');
      this.options = options;
      this.canvas.width = Math.floor(options.width * options.scale);
      this.canvas.height = Math.floor(options.height * options.scale);
      this.canvas.style.width = options.width + 'px';
      this.canvas.style.height = options.height + 'px';
      this.ctx.scale(this.options.scale, this.options.scale);
      this.ctx.translate(-options.x, -options.y);
      this.ctx.textBaseline = 'bottom';
      options.logger.log('Canvas renderer initialized (' + options.width + 'x' + options.height + ' at ' + options.x + ',' + options.y + ') with scale ' + this.options.scale);
    }
  }, {
    key: 'clip',
    value: function clip(clipPaths, callback) {
      var _this = this;

      if (clipPaths.length) {
        this.ctx.save();
        clipPaths.forEach(function (path) {
          _this.path(path);

          _this.ctx.clip();
        });
      }

      callback();

      if (clipPaths.length) {
        this.ctx.restore();
      }
    }
  }, {
    key: 'drawImage',
    value: function drawImage(image, source, destination) {
      this.ctx.drawImage(image, source.left, source.top, source.width, source.height, destination.left, destination.top, destination.width, destination.height);
    }
  }, {
    key: 'drawShape',
    value: function drawShape(path, color) {
      this.path(path);
      this.ctx.fillStyle = color.toString();
      this.ctx.fill();
    }
  }, {
    key: 'fill',
    value: function fill(color) {
      this.ctx.fillStyle = color.toString();
      this.ctx.fill();
    }
  }, {
    key: 'getTarget',
    value: function getTarget() {
      this.canvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
      return Promise.resolve(this.canvas);
    }
  }, {
    key: 'path',
    value: function path(_path) {
      var _this2 = this;

      this.ctx.beginPath();

      if (Array.isArray(_path)) {
        _path.forEach(function (point, index) {
          var start = point.type === _Path.PATH.VECTOR ? point : point.start;

          if (index === 0) {
            _this2.ctx.moveTo(start.x, start.y);
          } else {
            _this2.ctx.lineTo(start.x, start.y);
          }

          if (point.type === _Path.PATH.BEZIER_CURVE) {
            _this2.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
          }
        });
      } else {
        this.ctx.arc(_path.x + _path.radius, _path.y + _path.radius, _path.radius, 0, Math.PI * 2, true);
      }

      this.ctx.closePath();
    }
  }, {
    key: 'rectangle',
    value: function rectangle(x, y, width, height, color) {
      this.ctx.fillStyle = color.toString();
      this.ctx.fillRect(x, y, width, height);
    }
  }, {
    key: 'renderLinearGradient',
    value: function renderLinearGradient(bounds, gradient) {
      var linearGradient = this.ctx.createLinearGradient(bounds.left + gradient.direction.x1, bounds.top + gradient.direction.y1, bounds.left + gradient.direction.x0, bounds.top + gradient.direction.y0);
      addColorStops(gradient, linearGradient);
      this.ctx.fillStyle = linearGradient;
      this.ctx.fillRect(bounds.left, bounds.top, bounds.width, bounds.height);
    }
  }, {
    key: 'renderRadialGradient',
    value: function renderRadialGradient(bounds, gradient) {
      var _this3 = this;

      var x = bounds.left + gradient.center.x;
      var y = bounds.top + gradient.center.y;
      var radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, gradient.radius.x);

      if (!radialGradient) {
        return;
      }

      addColorStops(gradient, radialGradient);
      this.ctx.fillStyle = radialGradient;

      if (gradient.radius.x !== gradient.radius.y) {
        // transforms for elliptical radial gradient
        var midX = bounds.left + 0.5 * bounds.width;
        var midY = bounds.top + 0.5 * bounds.height;
        var f = gradient.radius.y / gradient.radius.x;
        var invF = 1 / f;
        this.transform(midX, midY, [1, 0, 0, f, 0, 0], function () {
          return _this3.ctx.fillRect(bounds.left, invF * (bounds.top - midY) + midY, bounds.width, bounds.height * invF);
        });
      } else {
        this.ctx.fillRect(bounds.left, bounds.top, bounds.width, bounds.height);
      }
    }
  }, {
    key: 'renderRepeat',
    value: function renderRepeat(path, image, imageSize, offsetX, offsetY) {
      this.path(path);
      this.ctx.fillStyle = this.ctx.createPattern(this.resizeImage(image, imageSize), 'repeat');
      this.ctx.translate(offsetX, offsetY);
      this.ctx.fill();
      this.ctx.translate(-offsetX, -offsetY);
    }
  }, {
    key: 'renderTextNode',
    value: function renderTextNode(textBounds, color, font, textDecoration, textShadows) {
      var _this4 = this;

      this.ctx.font = [font.fontStyle, font.fontVariant, font.fontWeight, font.fontSize, font.fontFamily].join(' ');
      textBounds.forEach(function (text) {
        _this4.ctx.fillStyle = color.toString();

        if (textShadows && text.text.trim().length) {
          textShadows.slice(0).reverse().forEach(function (textShadow) {
            _this4.ctx.shadowColor = textShadow.color.toString();
            _this4.ctx.shadowOffsetX = textShadow.offsetX * _this4.options.scale;
            _this4.ctx.shadowOffsetY = textShadow.offsetY * _this4.options.scale;
            _this4.ctx.shadowBlur = textShadow.blur;

            _this4.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
          });
        } else {
          _this4.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
        }

        if (textDecoration !== null) {
          var textDecorationColor = textDecoration.textDecorationColor || color;
          textDecoration.textDecorationLine.forEach(function (textDecorationLine) {
            switch (textDecorationLine) {
              case _textDecoration.TEXT_DECORATION_LINE.UNDERLINE:
                // Draws a line at the baseline of the font
                // TODO As some browsers display the line as more than 1px if the font-size is big,
                // need to take that into account both in position and size
                var _options$fontMetrics$ = _this4.options.fontMetrics.getMetrics(font),
                    baseline = _options$fontMetrics$.baseline;

                _this4.rectangle(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1, textDecorationColor);

                break;

              case _textDecoration.TEXT_DECORATION_LINE.OVERLINE:
                _this4.rectangle(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1, textDecorationColor);

                break;

              case _textDecoration.TEXT_DECORATION_LINE.LINE_THROUGH:
                // TODO try and find exact position for line-through
                var _options$fontMetrics$2 = _this4.options.fontMetrics.getMetrics(font),
                    middle = _options$fontMetrics$2.middle;

                _this4.rectangle(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1, textDecorationColor);

                break;
            }
          });
        }
      });
    }
  }, {
    key: 'resizeImage',
    value: function resizeImage(image, size) {
      if (image.width === size.width && image.height === size.height) {
        return image;
      }

      var canvas = this.canvas.ownerDocument.createElement('canvas');
      canvas.width = size.width;
      canvas.height = size.height;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);
      return canvas;
    }
  }, {
    key: 'setOpacity',
    value: function setOpacity(opacity) {
      this.ctx.globalAlpha = opacity;
    }
  }, {
    key: 'transform',
    value: function transform(offsetX, offsetY, matrix, callback) {
      this.ctx.save();
      this.ctx.translate(offsetX, offsetY);
      this.ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      this.ctx.translate(-offsetX, -offsetY);
      callback();
      this.ctx.restore();
    }
  }]);

  return CanvasRenderer;
}();

exports.default = CanvasRenderer;
},{"../drawing/Path":"Qq+a","../parsing/textDecoration":"37pw"}],"aleJ":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Logger = function () {
  function Logger(enabled, id, start) {
    _classCallCheck(this, Logger);

    this.enabled = typeof window !== 'undefined' && enabled;
    this.start = start ? start : Date.now();
    this.id = id;
  }

  _createClass(Logger, [{
    key: 'child',
    value: function child(id) {
      return new Logger(this.enabled, id, this.start);
    } // eslint-disable-next-line flowtype/no-weak-types

  }, {
    key: 'log',
    value: function log() {
      if (this.enabled && window.console && window.console.log) {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        Function.prototype.bind.call(window.console.log, window.console).apply(window.console, [Date.now() - this.start + 'ms', this.id ? 'html2canvas (' + this.id + '):' : 'html2canvas:'].concat([].slice.call(args, 0)));
      }
    } // eslint-disable-next-line flowtype/no-weak-types

  }, {
    key: 'error',
    value: function error() {
      if (this.enabled && window.console && window.console.error) {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        Function.prototype.bind.call(window.console.error, window.console).apply(window.console, [Date.now() - this.start + 'ms', this.id ? 'html2canvas (' + this.id + '):' : 'html2canvas:'].concat([].slice.call(args, 0)));
      }
    }
  }]);

  return Logger;
}();

exports.default = Logger;
},{}],"RUru":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var contains = exports.contains = function contains(bit, value) {
  return (bit & value) !== 0;
};

var distance = exports.distance = function distance(a, b) {
  return Math.sqrt(a * a + b * b);
};

var copyCSSStyles = exports.copyCSSStyles = function copyCSSStyles(style, target) {
  // Edge does not provide value for cssText
  for (var i = style.length - 1; i >= 0; i--) {
    var property = style.item(i); // Safari shows pseudoelements if content is set

    if (property !== 'content') {
      target.style.setProperty(property, style.getPropertyValue(property));
    }
  }

  return target;
};

var SMALL_IMAGE = exports.SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
},{}],"21CJ":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateLengthFromValueWithUnit = exports.LENGTH_TYPE = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _NodeContainer = require('./NodeContainer');

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var LENGTH_WITH_UNIT = /([\d.]+)(px|r?em|%)/i;
var LENGTH_TYPE = exports.LENGTH_TYPE = {
  PX: 0,
  PERCENTAGE: 1
};

var Length = function () {
  function Length(value) {
    _classCallCheck(this, Length);

    this.type = value.substr(value.length - 1) === '%' ? LENGTH_TYPE.PERCENTAGE : LENGTH_TYPE.PX;
    var parsedValue = parseFloat(value);

    if ("production" !== 'production' && isNaN(parsedValue)) {
      console.error('Invalid value given for Length: "' + value + '"');
    }

    this.value = isNaN(parsedValue) ? 0 : parsedValue;
  }

  _createClass(Length, [{
    key: 'isPercentage',
    value: function isPercentage() {
      return this.type === LENGTH_TYPE.PERCENTAGE;
    }
  }, {
    key: 'getAbsoluteValue',
    value: function getAbsoluteValue(parentLength) {
      return this.isPercentage() ? parentLength * (this.value / 100) : this.value;
    }
  }], [{
    key: 'create',
    value: function create(v) {
      return new Length(v);
    }
  }]);

  return Length;
}();

exports.default = Length;

var getRootFontSize = function getRootFontSize(container) {
  var parent = container.parent;
  return parent ? getRootFontSize(parent) : parseFloat(container.style.font.fontSize);
};

var calculateLengthFromValueWithUnit = exports.calculateLengthFromValueWithUnit = function calculateLengthFromValueWithUnit(container, value, unit) {
  switch (unit) {
    case 'px':
    case '%':
      return new Length(value + unit);

    case 'em':
    case 'rem':
      var length = new Length(value);
      length.value *= unit === 'em' ? parseFloat(container.style.font.fontSize) : getRootFontSize(container);
      return length;

    default:
      // TODO: handle correctly if unknown unit is used
      return new Length('0');
  }
};
},{"./NodeContainer":"aCnv"}],"IKoY":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Size = function Size(width, height) {
  _classCallCheck(this, Size);

  this.width = width;
  this.height = height;
};

exports.default = Size;
},{}],"FP3Z":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Path = require('./Path');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Vector = function Vector(x, y) {
  _classCallCheck(this, Vector);

  this.type = _Path.PATH.VECTOR;
  this.x = x;
  this.y = y;

  if ("production" !== 'production') {
    if (isNaN(x)) {
      console.error('Invalid x value given for Vector');
    }

    if (isNaN(y)) {
      console.error('Invalid y value given for Vector');
    }
  }
};

exports.default = Vector;
},{"./Path":"Qq+a"}],"GBGN":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Path = require('./Path');

var _Vector = require('./Vector');

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var lerp = function lerp(a, b, t) {
  return new _Vector2.default(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
};

var BezierCurve = function () {
  function BezierCurve(start, startControl, endControl, end) {
    _classCallCheck(this, BezierCurve);

    this.type = _Path.PATH.BEZIER_CURVE;
    this.start = start;
    this.startControl = startControl;
    this.endControl = endControl;
    this.end = end;
  }

  _createClass(BezierCurve, [{
    key: 'subdivide',
    value: function subdivide(t, firstHalf) {
      var ab = lerp(this.start, this.startControl, t);
      var bc = lerp(this.startControl, this.endControl, t);
      var cd = lerp(this.endControl, this.end, t);
      var abbc = lerp(ab, bc, t);
      var bccd = lerp(bc, cd, t);
      var dest = lerp(abbc, bccd, t);
      return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
    }
  }, {
    key: 'reverse',
    value: function reverse() {
      return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
    }
  }]);

  return BezierCurve;
}();

exports.default = BezierCurve;
},{"./Path":"Qq+a","./Vector":"FP3Z"}],"0S3x":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseBoundCurves = exports.calculatePaddingBoxPath = exports.calculateBorderBoxPath = exports.parsePathForBorder = exports.parseDocumentSize = exports.calculateContentBox = exports.calculatePaddingBox = exports.parseBounds = exports.Bounds = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Vector = require('./drawing/Vector');

var _Vector2 = _interopRequireDefault(_Vector);

var _BezierCurve = require('./drawing/BezierCurve');

var _BezierCurve2 = _interopRequireDefault(_BezierCurve);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;
var H = 0;
var V = 1;

var Bounds = exports.Bounds = function () {
  function Bounds(x, y, w, h) {
    _classCallCheck(this, Bounds);

    this.left = x;
    this.top = y;
    this.width = w;
    this.height = h;
  }

  _createClass(Bounds, null, [{
    key: 'fromClientRect',
    value: function fromClientRect(clientRect, scrollX, scrollY) {
      return new Bounds(clientRect.left + scrollX, clientRect.top + scrollY, clientRect.width, clientRect.height);
    }
  }]);

  return Bounds;
}();

var parseBounds = exports.parseBounds = function parseBounds(node, scrollX, scrollY) {
  return Bounds.fromClientRect(node.getBoundingClientRect(), scrollX, scrollY);
};

var calculatePaddingBox = exports.calculatePaddingBox = function calculatePaddingBox(bounds, borders) {
  return new Bounds(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth, bounds.width - (borders[RIGHT].borderWidth + borders[LEFT].borderWidth), bounds.height - (borders[TOP].borderWidth + borders[BOTTOM].borderWidth));
};

var calculateContentBox = exports.calculateContentBox = function calculateContentBox(bounds, padding, borders) {
  // TODO support percentage paddings
  var paddingTop = padding[TOP].value;
  var paddingRight = padding[RIGHT].value;
  var paddingBottom = padding[BOTTOM].value;
  var paddingLeft = padding[LEFT].value;
  return new Bounds(bounds.left + paddingLeft + borders[LEFT].borderWidth, bounds.top + paddingTop + borders[TOP].borderWidth, bounds.width - (borders[RIGHT].borderWidth + borders[LEFT].borderWidth + paddingLeft + paddingRight), bounds.height - (borders[TOP].borderWidth + borders[BOTTOM].borderWidth + paddingTop + paddingBottom));
};

var parseDocumentSize = exports.parseDocumentSize = function parseDocumentSize(document) {
  var body = document.body;
  var documentElement = document.documentElement;

  if (!body || !documentElement) {
    throw new Error("production" !== 'production' ? 'Unable to get document size' : '');
  }

  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width, height);
};

var parsePathForBorder = exports.parsePathForBorder = function parsePathForBorder(curves, borderSide) {
  switch (borderSide) {
    case TOP:
      return createPathFromCurves(curves.topLeftOuter, curves.topLeftInner, curves.topRightOuter, curves.topRightInner);

    case RIGHT:
      return createPathFromCurves(curves.topRightOuter, curves.topRightInner, curves.bottomRightOuter, curves.bottomRightInner);

    case BOTTOM:
      return createPathFromCurves(curves.bottomRightOuter, curves.bottomRightInner, curves.bottomLeftOuter, curves.bottomLeftInner);

    case LEFT:
    default:
      return createPathFromCurves(curves.bottomLeftOuter, curves.bottomLeftInner, curves.topLeftOuter, curves.topLeftInner);
  }
};

var createPathFromCurves = function createPathFromCurves(outer1, inner1, outer2, inner2) {
  var path = [];

  if (outer1 instanceof _BezierCurve2.default) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }

  if (outer2 instanceof _BezierCurve2.default) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }

  if (inner2 instanceof _BezierCurve2.default) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }

  if (inner1 instanceof _BezierCurve2.default) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }

  return path;
};

var calculateBorderBoxPath = exports.calculateBorderBoxPath = function calculateBorderBoxPath(curves) {
  return [curves.topLeftOuter, curves.topRightOuter, curves.bottomRightOuter, curves.bottomLeftOuter];
};

var calculatePaddingBoxPath = exports.calculatePaddingBoxPath = function calculatePaddingBoxPath(curves) {
  return [curves.topLeftInner, curves.topRightInner, curves.bottomRightInner, curves.bottomLeftInner];
};

var parseBoundCurves = exports.parseBoundCurves = function parseBoundCurves(bounds, borders, borderRadius) {
  var tlh = borderRadius[CORNER.TOP_LEFT][H].getAbsoluteValue(bounds.width);
  var tlv = borderRadius[CORNER.TOP_LEFT][V].getAbsoluteValue(bounds.height);
  var trh = borderRadius[CORNER.TOP_RIGHT][H].getAbsoluteValue(bounds.width);
  var trv = borderRadius[CORNER.TOP_RIGHT][V].getAbsoluteValue(bounds.height);
  var brh = borderRadius[CORNER.BOTTOM_RIGHT][H].getAbsoluteValue(bounds.width);
  var brv = borderRadius[CORNER.BOTTOM_RIGHT][V].getAbsoluteValue(bounds.height);
  var blh = borderRadius[CORNER.BOTTOM_LEFT][H].getAbsoluteValue(bounds.width);
  var blv = borderRadius[CORNER.BOTTOM_LEFT][V].getAbsoluteValue(bounds.height);
  var factors = [];
  factors.push((tlh + trh) / bounds.width);
  factors.push((blh + brh) / bounds.width);
  factors.push((tlv + blv) / bounds.height);
  factors.push((trv + brv) / bounds.height);
  var maxFactor = Math.max.apply(Math, factors);

  if (maxFactor > 1) {
    tlh /= maxFactor;
    tlv /= maxFactor;
    trh /= maxFactor;
    trv /= maxFactor;
    brh /= maxFactor;
    brv /= maxFactor;
    blh /= maxFactor;
    blv /= maxFactor;
  }

  var topWidth = bounds.width - trh;
  var rightHeight = bounds.height - brv;
  var bottomWidth = bounds.width - brh;
  var leftHeight = bounds.height - blv;
  return {
    topLeftOuter: tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new _Vector2.default(bounds.left, bounds.top),
    topLeftInner: tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth, Math.max(0, tlh - borders[LEFT].borderWidth), Math.max(0, tlv - borders[TOP].borderWidth), CORNER.TOP_LEFT) : new _Vector2.default(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth),
    topRightOuter: trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new _Vector2.default(bounds.left + bounds.width, bounds.top),
    topRightInner: trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borders[LEFT].borderWidth), bounds.top + borders[TOP].borderWidth, topWidth > bounds.width + borders[LEFT].borderWidth ? 0 : trh - borders[LEFT].borderWidth, trv - borders[TOP].borderWidth, CORNER.TOP_RIGHT) : new _Vector2.default(bounds.left + bounds.width - borders[RIGHT].borderWidth, bounds.top + borders[TOP].borderWidth),
    bottomRightOuter: brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new _Vector2.default(bounds.left + bounds.width, bounds.top + bounds.height),
    bottomRightInner: brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borders[LEFT].borderWidth), bounds.top + Math.min(rightHeight, bounds.height + borders[TOP].borderWidth), Math.max(0, brh - borders[RIGHT].borderWidth), brv - borders[BOTTOM].borderWidth, CORNER.BOTTOM_RIGHT) : new _Vector2.default(bounds.left + bounds.width - borders[RIGHT].borderWidth, bounds.top + bounds.height - borders[BOTTOM].borderWidth),
    bottomLeftOuter: blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new _Vector2.default(bounds.left, bounds.top + bounds.height),
    bottomLeftInner: blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borders[LEFT].borderWidth, bounds.top + leftHeight, Math.max(0, blh - borders[LEFT].borderWidth), blv - borders[BOTTOM].borderWidth, CORNER.BOTTOM_LEFT) : new _Vector2.default(bounds.left + borders[LEFT].borderWidth, bounds.top + bounds.height - borders[BOTTOM].borderWidth)
  };
};

var CORNER = {
  TOP_LEFT: 0,
  TOP_RIGHT: 1,
  BOTTOM_RIGHT: 2,
  BOTTOM_LEFT: 3
};

var getCurvePoints = function getCurvePoints(x, y, r1, r2, position) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa; // control point offset horizontal

  var oy = r2 * kappa; // control point offset vertical

  var xm = x + r1; // x-middle

  var ym = y + r2; // y-middle

  switch (position) {
    case CORNER.TOP_LEFT:
      return new _BezierCurve2.default(new _Vector2.default(x, ym), new _Vector2.default(x, ym - oy), new _Vector2.default(xm - ox, y), new _Vector2.default(xm, y));

    case CORNER.TOP_RIGHT:
      return new _BezierCurve2.default(new _Vector2.default(x, y), new _Vector2.default(x + ox, y), new _Vector2.default(xm, ym - oy), new _Vector2.default(xm, ym));

    case CORNER.BOTTOM_RIGHT:
      return new _BezierCurve2.default(new _Vector2.default(xm, y), new _Vector2.default(xm, y + oy), new _Vector2.default(x + ox, ym), new _Vector2.default(x, ym));

    case CORNER.BOTTOM_LEFT:
    default:
      return new _BezierCurve2.default(new _Vector2.default(xm, ym), new _Vector2.default(xm - ox, ym), new _Vector2.default(x, y + oy), new _Vector2.default(x, y));
  }
};
},{"./drawing/Vector":"FP3Z","./drawing/BezierCurve":"GBGN"}],"xKfD":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePadding = exports.PADDING_SIDES = undefined;

var _Length = require('../Length');

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var PADDING_SIDES = exports.PADDING_SIDES = {
  TOP: 0,
  RIGHT: 1,
  BOTTOM: 2,
  LEFT: 3
};
var SIDES = ['top', 'right', 'bottom', 'left'];

var parsePadding = exports.parsePadding = function parsePadding(style) {
  return SIDES.map(function (side) {
    return new _Length2.default(style.getPropertyValue('padding-' + side));
  });
};
},{"../Length":"21CJ"}],"mnnN":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseBackgroundImage = exports.parseBackground = exports.calculateBackgroundRepeatPath = exports.calculateBackgroundPosition = exports.calculateBackgroungPositioningArea = exports.calculateBackgroungPaintingArea = exports.calculateGradientBackgroundSize = exports.calculateBackgroundSize = exports.BACKGROUND_ORIGIN = exports.BACKGROUND_CLIP = exports.BACKGROUND_SIZE = exports.BACKGROUND_REPEAT = undefined;

var _Color = require('../Color');

var _Color2 = _interopRequireDefault(_Color);

var _Length = require('../Length');

var _Length2 = _interopRequireDefault(_Length);

var _Size = require('../drawing/Size');

var _Size2 = _interopRequireDefault(_Size);

var _Vector = require('../drawing/Vector');

var _Vector2 = _interopRequireDefault(_Vector);

var _Bounds = require('../Bounds');

var _padding = require('./padding');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var BACKGROUND_REPEAT = exports.BACKGROUND_REPEAT = {
  REPEAT: 0,
  NO_REPEAT: 1,
  REPEAT_X: 2,
  REPEAT_Y: 3
};
var BACKGROUND_SIZE = exports.BACKGROUND_SIZE = {
  AUTO: 0,
  CONTAIN: 1,
  COVER: 2,
  LENGTH: 3
};
var BACKGROUND_CLIP = exports.BACKGROUND_CLIP = {
  BORDER_BOX: 0,
  PADDING_BOX: 1,
  CONTENT_BOX: 2
};
var BACKGROUND_ORIGIN = exports.BACKGROUND_ORIGIN = BACKGROUND_CLIP;
var AUTO = 'auto';

var BackgroundSize = function BackgroundSize(size) {
  _classCallCheck(this, BackgroundSize);

  switch (size) {
    case 'contain':
      this.size = BACKGROUND_SIZE.CONTAIN;
      break;

    case 'cover':
      this.size = BACKGROUND_SIZE.COVER;
      break;

    case 'auto':
      this.size = BACKGROUND_SIZE.AUTO;
      break;

    default:
      this.value = new _Length2.default(size);
  }
};

var calculateBackgroundSize = exports.calculateBackgroundSize = function calculateBackgroundSize(backgroundImage, image, bounds) {
  var width = 0;
  var height = 0;
  var size = backgroundImage.size;

  if (size[0].size === BACKGROUND_SIZE.CONTAIN || size[0].size === BACKGROUND_SIZE.COVER) {
    var targetRatio = bounds.width / bounds.height;
    var currentRatio = image.width / image.height;
    return targetRatio < currentRatio !== (size[0].size === BACKGROUND_SIZE.COVER) ? new _Size2.default(bounds.width, bounds.width / currentRatio) : new _Size2.default(bounds.height * currentRatio, bounds.height);
  }

  if (size[0].value) {
    width = size[0].value.getAbsoluteValue(bounds.width);
  }

  if (size[0].size === BACKGROUND_SIZE.AUTO && size[1].size === BACKGROUND_SIZE.AUTO) {
    height = image.height;
  } else if (size[1].size === BACKGROUND_SIZE.AUTO) {
    height = width / image.width * image.height;
  } else if (size[1].value) {
    height = size[1].value.getAbsoluteValue(bounds.height);
  }

  if (size[0].size === BACKGROUND_SIZE.AUTO) {
    width = height / image.height * image.width;
  }

  return new _Size2.default(width, height);
};

var calculateGradientBackgroundSize = exports.calculateGradientBackgroundSize = function calculateGradientBackgroundSize(backgroundImage, bounds) {
  var size = backgroundImage.size;
  var width = size[0].value ? size[0].value.getAbsoluteValue(bounds.width) : bounds.width;
  var height = size[1].value ? size[1].value.getAbsoluteValue(bounds.height) : size[0].value ? width : bounds.height;
  return new _Size2.default(width, height);
};

var AUTO_SIZE = new BackgroundSize(AUTO);

var calculateBackgroungPaintingArea = exports.calculateBackgroungPaintingArea = function calculateBackgroungPaintingArea(curves, clip) {
  switch (clip) {
    case BACKGROUND_CLIP.BORDER_BOX:
      return (0, _Bounds.calculateBorderBoxPath)(curves);

    case BACKGROUND_CLIP.PADDING_BOX:
    default:
      return (0, _Bounds.calculatePaddingBoxPath)(curves);
  }
};

var calculateBackgroungPositioningArea = exports.calculateBackgroungPositioningArea = function calculateBackgroungPositioningArea(backgroundOrigin, bounds, padding, border) {
  var paddingBox = (0, _Bounds.calculatePaddingBox)(bounds, border);

  switch (backgroundOrigin) {
    case BACKGROUND_ORIGIN.BORDER_BOX:
      return bounds;

    case BACKGROUND_ORIGIN.CONTENT_BOX:
      var paddingLeft = padding[_padding.PADDING_SIDES.LEFT].getAbsoluteValue(bounds.width);

      var paddingRight = padding[_padding.PADDING_SIDES.RIGHT].getAbsoluteValue(bounds.width);

      var paddingTop = padding[_padding.PADDING_SIDES.TOP].getAbsoluteValue(bounds.width);

      var paddingBottom = padding[_padding.PADDING_SIDES.BOTTOM].getAbsoluteValue(bounds.width);

      return new _Bounds.Bounds(paddingBox.left + paddingLeft, paddingBox.top + paddingTop, paddingBox.width - paddingLeft - paddingRight, paddingBox.height - paddingTop - paddingBottom);

    case BACKGROUND_ORIGIN.PADDING_BOX:
    default:
      return paddingBox;
  }
};

var calculateBackgroundPosition = exports.calculateBackgroundPosition = function calculateBackgroundPosition(position, size, bounds) {
  return new _Vector2.default(position[0].getAbsoluteValue(bounds.width - size.width), position[1].getAbsoluteValue(bounds.height - size.height));
};

var calculateBackgroundRepeatPath = exports.calculateBackgroundRepeatPath = function calculateBackgroundRepeatPath(background, position, size, backgroundPositioningArea, bounds) {
  var repeat = background.repeat;

  switch (repeat) {
    case BACKGROUND_REPEAT.REPEAT_X:
      return [new _Vector2.default(Math.round(bounds.left), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(size.height + backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(bounds.left), Math.round(size.height + backgroundPositioningArea.top + position.y))];

    case BACKGROUND_REPEAT.REPEAT_Y:
      return [new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(bounds.top)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(bounds.top)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(bounds.height + bounds.top)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(bounds.height + bounds.top))];

    case BACKGROUND_REPEAT.NO_REPEAT:
      return [new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(backgroundPositioningArea.top + position.y + size.height)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y + size.height))];

    default:
      return [new _Vector2.default(Math.round(bounds.left), Math.round(bounds.top)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(bounds.top)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(bounds.height + bounds.top)), new _Vector2.default(Math.round(bounds.left), Math.round(bounds.height + bounds.top))];
  }
};

var parseBackground = exports.parseBackground = function parseBackground(style, resourceLoader) {
  return {
    backgroundColor: new _Color2.default(style.backgroundColor),
    backgroundImage: parseBackgroundImages(style, resourceLoader),
    backgroundClip: parseBackgroundClip(style.backgroundClip),
    backgroundOrigin: parseBackgroundOrigin(style.backgroundOrigin)
  };
};

var parseBackgroundClip = function parseBackgroundClip(backgroundClip) {
  switch (backgroundClip) {
    case 'padding-box':
      return BACKGROUND_CLIP.PADDING_BOX;

    case 'content-box':
      return BACKGROUND_CLIP.CONTENT_BOX;
  }

  return BACKGROUND_CLIP.BORDER_BOX;
};

var parseBackgroundOrigin = function parseBackgroundOrigin(backgroundOrigin) {
  switch (backgroundOrigin) {
    case 'padding-box':
      return BACKGROUND_ORIGIN.PADDING_BOX;

    case 'content-box':
      return BACKGROUND_ORIGIN.CONTENT_BOX;
  }

  return BACKGROUND_ORIGIN.BORDER_BOX;
};

var parseBackgroundRepeat = function parseBackgroundRepeat(backgroundRepeat) {
  switch (backgroundRepeat.trim()) {
    case 'no-repeat':
      return BACKGROUND_REPEAT.NO_REPEAT;

    case 'repeat-x':
    case 'repeat no-repeat':
      return BACKGROUND_REPEAT.REPEAT_X;

    case 'repeat-y':
    case 'no-repeat repeat':
      return BACKGROUND_REPEAT.REPEAT_Y;

    case 'repeat':
      return BACKGROUND_REPEAT.REPEAT;
  }

  if ("production" !== 'production') {
    console.error('Invalid background-repeat value "' + backgroundRepeat + '"');
  }

  return BACKGROUND_REPEAT.REPEAT;
};

var parseBackgroundImages = function parseBackgroundImages(style, resourceLoader) {
  var sources = parseBackgroundImage(style.backgroundImage).map(function (backgroundImage) {
    if (backgroundImage.method === 'url') {
      var key = resourceLoader.loadImage(backgroundImage.args[0]);
      backgroundImage.args = key ? [key] : [];
    }

    return backgroundImage;
  });
  var positions = style.backgroundPosition.split(',');
  var repeats = style.backgroundRepeat.split(',');
  var sizes = style.backgroundSize.split(',');
  return sources.map(function (source, index) {
    var size = (sizes[index] || AUTO).trim().split(' ').map(parseBackgroundSize);
    var position = (positions[index] || AUTO).trim().split(' ').map(parseBackgoundPosition);
    return {
      source: source,
      repeat: parseBackgroundRepeat(typeof repeats[index] === 'string' ? repeats[index] : repeats[0]),
      size: size.length < 2 ? [size[0], AUTO_SIZE] : [size[0], size[1]],
      position: position.length < 2 ? [position[0], position[0]] : [position[0], position[1]]
    };
  });
};

var parseBackgroundSize = function parseBackgroundSize(size) {
  return size === 'auto' ? AUTO_SIZE : new BackgroundSize(size);
};

var parseBackgoundPosition = function parseBackgoundPosition(position) {
  switch (position) {
    case 'bottom':
    case 'right':
      return new _Length2.default('100%');

    case 'left':
    case 'top':
      return new _Length2.default('0%');

    case 'auto':
      return new _Length2.default('0');
  }

  return new _Length2.default(position);
};

var parseBackgroundImage = exports.parseBackgroundImage = function parseBackgroundImage(image) {
  var whitespace = /^\s$/;
  var results = [];
  var args = [];
  var method = '';
  var quote = null;
  var definition = '';
  var mode = 0;
  var numParen = 0;

  var appendResult = function appendResult() {
    var prefix = '';

    if (method) {
      if (definition.substr(0, 1) === '"') {
        definition = definition.substr(1, definition.length - 2);
      }

      if (definition) {
        args.push(definition.trim());
      }

      var prefix_i = method.indexOf('-', 1) + 1;

      if (method.substr(0, 1) === '-' && prefix_i > 0) {
        prefix = method.substr(0, prefix_i).toLowerCase();
        method = method.substr(prefix_i);
      }

      method = method.toLowerCase();

      if (method !== 'none') {
        results.push({
          prefix: prefix,
          method: method,
          args: args
        });
      }
    }

    args = [];
    method = definition = '';
  };

  image.split('').forEach(function (c) {
    if (mode === 0 && whitespace.test(c)) {
      return;
    }

    switch (c) {
      case '"':
        if (!quote) {
          quote = c;
        } else if (quote === c) {
          quote = null;
        }

        break;

      case '(':
        if (quote) {
          break;
        } else if (mode === 0) {
          mode = 1;
          return;
        } else {
          numParen++;
        }

        break;

      case ')':
        if (quote) {
          break;
        } else if (mode === 1) {
          if (numParen === 0) {
            mode = 0;
            appendResult();
            return;
          } else {
            numParen--;
          }
        }

        break;

      case ',':
        if (quote) {
          break;
        } else if (mode === 0) {
          appendResult();
          return;
        } else if (mode === 1) {
          if (numParen === 0 && !method.match(/^url$/i)) {
            args.push(definition.trim());
            definition = '';
            return;
          }
        }

        break;
    }

    if (mode === 0) {
      method += c;
    } else {
      definition += c;
    }
  });
  appendResult();
  return results;
};
},{"../Color":"IvPj","../Length":"21CJ","../drawing/Size":"IKoY","../drawing/Vector":"FP3Z","../Bounds":"0S3x","./padding":"xKfD"}],"DyH5":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseBorder = exports.BORDER_SIDES = exports.BORDER_STYLE = undefined;

var _Color = require('../Color');

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var BORDER_STYLE = exports.BORDER_STYLE = {
  NONE: 0,
  SOLID: 1
};
var BORDER_SIDES = exports.BORDER_SIDES = {
  TOP: 0,
  RIGHT: 1,
  BOTTOM: 2,
  LEFT: 3
};
var SIDES = Object.keys(BORDER_SIDES).map(function (s) {
  return s.toLowerCase();
});

var parseBorderStyle = function parseBorderStyle(style) {
  switch (style) {
    case 'none':
      return BORDER_STYLE.NONE;
  }

  return BORDER_STYLE.SOLID;
};

var parseBorder = exports.parseBorder = function parseBorder(style) {
  return SIDES.map(function (side) {
    var borderColor = new _Color2.default(style.getPropertyValue('border-' + side + '-color'));
    var borderStyle = parseBorderStyle(style.getPropertyValue('border-' + side + '-style'));
    var borderWidth = parseFloat(style.getPropertyValue('border-' + side + '-width'));
    return {
      borderColor: borderColor,
      borderStyle: borderStyle,
      borderWidth: isNaN(borderWidth) ? 0 : borderWidth
    };
  });
};
},{"../Color":"IvPj"}],"RaWo":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseBorderRadius = undefined;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _Length = require('../Length');

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var SIDES = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];

var parseBorderRadius = exports.parseBorderRadius = function parseBorderRadius(style) {
  return SIDES.map(function (side) {
    var value = style.getPropertyValue('border-' + side + '-radius');

    var _value$split$map = value.split(' ').map(_Length2.default.create),
        _value$split$map2 = _slicedToArray(_value$split$map, 2),
        horizontal = _value$split$map2[0],
        vertical = _value$split$map2[1];

    return typeof vertical === 'undefined' ? [horizontal, horizontal] : [horizontal, vertical];
  });
};
},{"../Length":"21CJ"}],"LzdE":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var DISPLAY = exports.DISPLAY = {
  NONE: 1 << 0,
  BLOCK: 1 << 1,
  INLINE: 1 << 2,
  RUN_IN: 1 << 3,
  FLOW: 1 << 4,
  FLOW_ROOT: 1 << 5,
  TABLE: 1 << 6,
  FLEX: 1 << 7,
  GRID: 1 << 8,
  RUBY: 1 << 9,
  SUBGRID: 1 << 10,
  LIST_ITEM: 1 << 11,
  TABLE_ROW_GROUP: 1 << 12,
  TABLE_HEADER_GROUP: 1 << 13,
  TABLE_FOOTER_GROUP: 1 << 14,
  TABLE_ROW: 1 << 15,
  TABLE_CELL: 1 << 16,
  TABLE_COLUMN_GROUP: 1 << 17,
  TABLE_COLUMN: 1 << 18,
  TABLE_CAPTION: 1 << 19,
  RUBY_BASE: 1 << 20,
  RUBY_TEXT: 1 << 21,
  RUBY_BASE_CONTAINER: 1 << 22,
  RUBY_TEXT_CONTAINER: 1 << 23,
  CONTENTS: 1 << 24,
  INLINE_BLOCK: 1 << 25,
  INLINE_LIST_ITEM: 1 << 26,
  INLINE_TABLE: 1 << 27,
  INLINE_FLEX: 1 << 28,
  INLINE_GRID: 1 << 29
};

var parseDisplayValue = function parseDisplayValue(display) {
  switch (display) {
    case 'block':
      return DISPLAY.BLOCK;

    case 'inline':
      return DISPLAY.INLINE;

    case 'run-in':
      return DISPLAY.RUN_IN;

    case 'flow':
      return DISPLAY.FLOW;

    case 'flow-root':
      return DISPLAY.FLOW_ROOT;

    case 'table':
      return DISPLAY.TABLE;

    case 'flex':
      return DISPLAY.FLEX;

    case 'grid':
      return DISPLAY.GRID;

    case 'ruby':
      return DISPLAY.RUBY;

    case 'subgrid':
      return DISPLAY.SUBGRID;

    case 'list-item':
      return DISPLAY.LIST_ITEM;

    case 'table-row-group':
      return DISPLAY.TABLE_ROW_GROUP;

    case 'table-header-group':
      return DISPLAY.TABLE_HEADER_GROUP;

    case 'table-footer-group':
      return DISPLAY.TABLE_FOOTER_GROUP;

    case 'table-row':
      return DISPLAY.TABLE_ROW;

    case 'table-cell':
      return DISPLAY.TABLE_CELL;

    case 'table-column-group':
      return DISPLAY.TABLE_COLUMN_GROUP;

    case 'table-column':
      return DISPLAY.TABLE_COLUMN;

    case 'table-caption':
      return DISPLAY.TABLE_CAPTION;

    case 'ruby-base':
      return DISPLAY.RUBY_BASE;

    case 'ruby-text':
      return DISPLAY.RUBY_TEXT;

    case 'ruby-base-container':
      return DISPLAY.RUBY_BASE_CONTAINER;

    case 'ruby-text-container':
      return DISPLAY.RUBY_TEXT_CONTAINER;

    case 'contents':
      return DISPLAY.CONTENTS;

    case 'inline-block':
      return DISPLAY.INLINE_BLOCK;

    case 'inline-list-item':
      return DISPLAY.INLINE_LIST_ITEM;

    case 'inline-table':
      return DISPLAY.INLINE_TABLE;

    case 'inline-flex':
      return DISPLAY.INLINE_FLEX;

    case 'inline-grid':
      return DISPLAY.INLINE_GRID;
  }

  return DISPLAY.NONE;
};

var setDisplayBit = function setDisplayBit(bit, display) {
  return bit | parseDisplayValue(display);
};

var parseDisplay = exports.parseDisplay = function parseDisplay(display) {
  return display.split(' ').reduce(setDisplayBit, 0);
};
},{}],"sC4M":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var FLOAT = exports.FLOAT = {
  NONE: 0,
  LEFT: 1,
  RIGHT: 2,
  INLINE_START: 3,
  INLINE_END: 4
};

var parseCSSFloat = exports.parseCSSFloat = function parseCSSFloat(float) {
  switch (float) {
    case 'left':
      return FLOAT.LEFT;

    case 'right':
      return FLOAT.RIGHT;

    case 'inline-start':
      return FLOAT.INLINE_START;

    case 'inline-end':
      return FLOAT.INLINE_END;
  }

  return FLOAT.NONE;
};
},{}],"OsIM":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parseFontWeight = function parseFontWeight(weight) {
  switch (weight) {
    case 'normal':
      return 400;

    case 'bold':
      return 700;
  }

  var value = parseInt(weight, 10);
  return isNaN(value) ? 400 : value;
};

var parseFont = exports.parseFont = function parseFont(style) {
  var fontFamily = style.fontFamily;
  var fontSize = style.fontSize;
  var fontStyle = style.fontStyle;
  var fontVariant = style.fontVariant;
  var fontWeight = parseFontWeight(style.fontWeight);
  return {
    fontFamily: fontFamily,
    fontSize: fontSize,
    fontStyle: fontStyle,
    fontVariant: fontVariant,
    fontWeight: fontWeight
  };
};
},{}],"gatk":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parseLetterSpacing = exports.parseLetterSpacing = function parseLetterSpacing(letterSpacing) {
  if (letterSpacing === 'normal') {
    return 0;
  }

  var value = parseFloat(letterSpacing);
  return isNaN(value) ? 0 : value;
};
},{}],"dXkp":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var LINE_BREAK = exports.LINE_BREAK = {
  NORMAL: 'normal',
  STRICT: 'strict'
};

var parseLineBreak = exports.parseLineBreak = function parseLineBreak(wordBreak) {
  switch (wordBreak) {
    case 'strict':
      return LINE_BREAK.STRICT;

    case 'normal':
    default:
      return LINE_BREAK.NORMAL;
  }
};
},{}],"9MRV":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseListStyle = exports.parseListStyleType = exports.LIST_STYLE_TYPE = exports.LIST_STYLE_POSITION = undefined;

var _background = require('./background');

var LIST_STYLE_POSITION = exports.LIST_STYLE_POSITION = {
  INSIDE: 0,
  OUTSIDE: 1
};
var LIST_STYLE_TYPE = exports.LIST_STYLE_TYPE = {
  NONE: -1,
  DISC: 0,
  CIRCLE: 1,
  SQUARE: 2,
  DECIMAL: 3,
  CJK_DECIMAL: 4,
  DECIMAL_LEADING_ZERO: 5,
  LOWER_ROMAN: 6,
  UPPER_ROMAN: 7,
  LOWER_GREEK: 8,
  LOWER_ALPHA: 9,
  UPPER_ALPHA: 10,
  ARABIC_INDIC: 11,
  ARMENIAN: 12,
  BENGALI: 13,
  CAMBODIAN: 14,
  CJK_EARTHLY_BRANCH: 15,
  CJK_HEAVENLY_STEM: 16,
  CJK_IDEOGRAPHIC: 17,
  DEVANAGARI: 18,
  ETHIOPIC_NUMERIC: 19,
  GEORGIAN: 20,
  GUJARATI: 21,
  GURMUKHI: 22,
  HEBREW: 22,
  HIRAGANA: 23,
  HIRAGANA_IROHA: 24,
  JAPANESE_FORMAL: 25,
  JAPANESE_INFORMAL: 26,
  KANNADA: 27,
  KATAKANA: 28,
  KATAKANA_IROHA: 29,
  KHMER: 30,
  KOREAN_HANGUL_FORMAL: 31,
  KOREAN_HANJA_FORMAL: 32,
  KOREAN_HANJA_INFORMAL: 33,
  LAO: 34,
  LOWER_ARMENIAN: 35,
  MALAYALAM: 36,
  MONGOLIAN: 37,
  MYANMAR: 38,
  ORIYA: 39,
  PERSIAN: 40,
  SIMP_CHINESE_FORMAL: 41,
  SIMP_CHINESE_INFORMAL: 42,
  TAMIL: 43,
  TELUGU: 44,
  THAI: 45,
  TIBETAN: 46,
  TRAD_CHINESE_FORMAL: 47,
  TRAD_CHINESE_INFORMAL: 48,
  UPPER_ARMENIAN: 49,
  DISCLOSURE_OPEN: 50,
  DISCLOSURE_CLOSED: 51
};

var parseListStyleType = exports.parseListStyleType = function parseListStyleType(type) {
  switch (type) {
    case 'disc':
      return LIST_STYLE_TYPE.DISC;

    case 'circle':
      return LIST_STYLE_TYPE.CIRCLE;

    case 'square':
      return LIST_STYLE_TYPE.SQUARE;

    case 'decimal':
      return LIST_STYLE_TYPE.DECIMAL;

    case 'cjk-decimal':
      return LIST_STYLE_TYPE.CJK_DECIMAL;

    case 'decimal-leading-zero':
      return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;

    case 'lower-roman':
      return LIST_STYLE_TYPE.LOWER_ROMAN;

    case 'upper-roman':
      return LIST_STYLE_TYPE.UPPER_ROMAN;

    case 'lower-greek':
      return LIST_STYLE_TYPE.LOWER_GREEK;

    case 'lower-alpha':
      return LIST_STYLE_TYPE.LOWER_ALPHA;

    case 'upper-alpha':
      return LIST_STYLE_TYPE.UPPER_ALPHA;

    case 'arabic-indic':
      return LIST_STYLE_TYPE.ARABIC_INDIC;

    case 'armenian':
      return LIST_STYLE_TYPE.ARMENIAN;

    case 'bengali':
      return LIST_STYLE_TYPE.BENGALI;

    case 'cambodian':
      return LIST_STYLE_TYPE.CAMBODIAN;

    case 'cjk-earthly-branch':
      return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;

    case 'cjk-heavenly-stem':
      return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;

    case 'cjk-ideographic':
      return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;

    case 'devanagari':
      return LIST_STYLE_TYPE.DEVANAGARI;

    case 'ethiopic-numeric':
      return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;

    case 'georgian':
      return LIST_STYLE_TYPE.GEORGIAN;

    case 'gujarati':
      return LIST_STYLE_TYPE.GUJARATI;

    case 'gurmukhi':
      return LIST_STYLE_TYPE.GURMUKHI;

    case 'hebrew':
      return LIST_STYLE_TYPE.HEBREW;

    case 'hiragana':
      return LIST_STYLE_TYPE.HIRAGANA;

    case 'hiragana-iroha':
      return LIST_STYLE_TYPE.HIRAGANA_IROHA;

    case 'japanese-formal':
      return LIST_STYLE_TYPE.JAPANESE_FORMAL;

    case 'japanese-informal':
      return LIST_STYLE_TYPE.JAPANESE_INFORMAL;

    case 'kannada':
      return LIST_STYLE_TYPE.KANNADA;

    case 'katakana':
      return LIST_STYLE_TYPE.KATAKANA;

    case 'katakana-iroha':
      return LIST_STYLE_TYPE.KATAKANA_IROHA;

    case 'khmer':
      return LIST_STYLE_TYPE.KHMER;

    case 'korean-hangul-formal':
      return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;

    case 'korean-hanja-formal':
      return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;

    case 'korean-hanja-informal':
      return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;

    case 'lao':
      return LIST_STYLE_TYPE.LAO;

    case 'lower-armenian':
      return LIST_STYLE_TYPE.LOWER_ARMENIAN;

    case 'malayalam':
      return LIST_STYLE_TYPE.MALAYALAM;

    case 'mongolian':
      return LIST_STYLE_TYPE.MONGOLIAN;

    case 'myanmar':
      return LIST_STYLE_TYPE.MYANMAR;

    case 'oriya':
      return LIST_STYLE_TYPE.ORIYA;

    case 'persian':
      return LIST_STYLE_TYPE.PERSIAN;

    case 'simp-chinese-formal':
      return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;

    case 'simp-chinese-informal':
      return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;

    case 'tamil':
      return LIST_STYLE_TYPE.TAMIL;

    case 'telugu':
      return LIST_STYLE_TYPE.TELUGU;

    case 'thai':
      return LIST_STYLE_TYPE.THAI;

    case 'tibetan':
      return LIST_STYLE_TYPE.TIBETAN;

    case 'trad-chinese-formal':
      return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;

    case 'trad-chinese-informal':
      return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;

    case 'upper-armenian':
      return LIST_STYLE_TYPE.UPPER_ARMENIAN;

    case 'disclosure-open':
      return LIST_STYLE_TYPE.DISCLOSURE_OPEN;

    case 'disclosure-closed':
      return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;

    case 'none':
    default:
      return LIST_STYLE_TYPE.NONE;
  }
};

var parseListStyle = exports.parseListStyle = function parseListStyle(style) {
  var listStyleImage = (0, _background.parseBackgroundImage)(style.getPropertyValue('list-style-image'));
  return {
    listStyleType: parseListStyleType(style.getPropertyValue('list-style-type')),
    listStyleImage: listStyleImage.length ? listStyleImage[0] : null,
    listStylePosition: parseListStylePosition(style.getPropertyValue('list-style-position'))
  };
};

var parseListStylePosition = function parseListStylePosition(position) {
  switch (position) {
    case 'inside':
      return LIST_STYLE_POSITION.INSIDE;

    case 'outside':
    default:
      return LIST_STYLE_POSITION.OUTSIDE;
  }
};
},{"./background":"mnnN"}],"E76M":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMargin = undefined;

var _Length = require('../Length');

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var SIDES = ['top', 'right', 'bottom', 'left'];

var parseMargin = exports.parseMargin = function parseMargin(style) {
  return SIDES.map(function (side) {
    return new _Length2.default(style.getPropertyValue('margin-' + side));
  });
};
},{"../Length":"21CJ"}],"mAuW":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var OVERFLOW = exports.OVERFLOW = {
  VISIBLE: 0,
  HIDDEN: 1,
  SCROLL: 2,
  AUTO: 3
};

var parseOverflow = exports.parseOverflow = function parseOverflow(overflow) {
  switch (overflow) {
    case 'hidden':
      return OVERFLOW.HIDDEN;

    case 'scroll':
      return OVERFLOW.SCROLL;

    case 'auto':
      return OVERFLOW.AUTO;

    case 'visible':
    default:
      return OVERFLOW.VISIBLE;
  }
};
},{}],"5D+K":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var OVERFLOW_WRAP = exports.OVERFLOW_WRAP = {
  NORMAL: 0,
  BREAK_WORD: 1
};

var parseOverflowWrap = exports.parseOverflowWrap = function parseOverflowWrap(overflow) {
  switch (overflow) {
    case 'break-word':
      return OVERFLOW_WRAP.BREAK_WORD;

    case 'normal':
    default:
      return OVERFLOW_WRAP.NORMAL;
  }
};
},{}],"JuyM":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var POSITION = exports.POSITION = {
  STATIC: 0,
  RELATIVE: 1,
  ABSOLUTE: 2,
  FIXED: 3,
  STICKY: 4
};

var parsePosition = exports.parsePosition = function parsePosition(position) {
  switch (position) {
    case 'relative':
      return POSITION.RELATIVE;

    case 'absolute':
      return POSITION.ABSOLUTE;

    case 'fixed':
      return POSITION.FIXED;

    case 'sticky':
      return POSITION.STICKY;
  }

  return POSITION.STATIC;
};
},{}],"O3Tr":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTextShadow = undefined;

var _Color = require('../Color');

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var NUMBER = /^([+-]|\d|\.)$/i;

var parseTextShadow = exports.parseTextShadow = function parseTextShadow(textShadow) {
  if (textShadow === 'none' || typeof textShadow !== 'string') {
    return null;
  }

  var currentValue = '';
  var isLength = false;
  var values = [];
  var shadows = [];
  var numParens = 0;
  var color = null;

  var appendValue = function appendValue() {
    if (currentValue.length) {
      if (isLength) {
        values.push(parseFloat(currentValue));
      } else {
        color = new _Color2.default(currentValue);
      }
    }

    isLength = false;
    currentValue = '';
  };

  var appendShadow = function appendShadow() {
    if (values.length && color !== null) {
      shadows.push({
        color: color,
        offsetX: values[0] || 0,
        offsetY: values[1] || 0,
        blur: values[2] || 0
      });
    }

    values.splice(0, values.length);
    color = null;
  };

  for (var i = 0; i < textShadow.length; i++) {
    var c = textShadow[i];

    switch (c) {
      case '(':
        currentValue += c;
        numParens++;
        break;

      case ')':
        currentValue += c;
        numParens--;
        break;

      case ',':
        if (numParens === 0) {
          appendValue();
          appendShadow();
        } else {
          currentValue += c;
        }

        break;

      case ' ':
        if (numParens === 0) {
          appendValue();
        } else {
          currentValue += c;
        }

        break;

      default:
        if (currentValue.length === 0 && NUMBER.test(c)) {
          isLength = true;
        }

        currentValue += c;
    }
  }

  appendValue();
  appendShadow();

  if (shadows.length === 0) {
    return null;
  }

  return shadows;
};
},{"../Color":"IvPj"}],"Qy+a":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var TEXT_TRANSFORM = exports.TEXT_TRANSFORM = {
  NONE: 0,
  LOWERCASE: 1,
  UPPERCASE: 2,
  CAPITALIZE: 3
};

var parseTextTransform = exports.parseTextTransform = function parseTextTransform(textTransform) {
  switch (textTransform) {
    case 'uppercase':
      return TEXT_TRANSFORM.UPPERCASE;

    case 'lowercase':
      return TEXT_TRANSFORM.LOWERCASE;

    case 'capitalize':
      return TEXT_TRANSFORM.CAPITALIZE;
  }

  return TEXT_TRANSFORM.NONE;
};
},{}],"gqmU":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTransform = undefined;

var _Length = require('../Length');

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var toFloat = function toFloat(s) {
  return parseFloat(s.trim());
};

var MATRIX = /(matrix|matrix3d)\((.+)\)/;

var parseTransform = exports.parseTransform = function parseTransform(style) {
  var transform = parseTransformMatrix(style.transform || style.webkitTransform || style.mozTransform || // $FlowFixMe
  style.msTransform || // $FlowFixMe
  style.oTransform);

  if (transform === null) {
    return null;
  }

  return {
    transform: transform,
    transformOrigin: parseTransformOrigin(style.transformOrigin || style.webkitTransformOrigin || style.mozTransformOrigin || // $FlowFixMe
    style.msTransformOrigin || // $FlowFixMe
    style.oTransformOrigin)
  };
}; // $FlowFixMe


var parseTransformOrigin = function parseTransformOrigin(origin) {
  if (typeof origin !== 'string') {
    var v = new _Length2.default('0');
    return [v, v];
  }

  var values = origin.split(' ').map(_Length2.default.create);
  return [values[0], values[1]];
}; // $FlowFixMe


var parseTransformMatrix = function parseTransformMatrix(transform) {
  if (transform === 'none' || typeof transform !== 'string') {
    return null;
  }

  var match = transform.match(MATRIX);

  if (match) {
    if (match[1] === 'matrix') {
      var matrix = match[2].split(',').map(toFloat);
      return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
    } else {
      var matrix3d = match[2].split(',').map(toFloat);
      return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];
    }
  }

  return null;
};
},{"../Length":"21CJ"}],"yETD":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var VISIBILITY = exports.VISIBILITY = {
  VISIBLE: 0,
  HIDDEN: 1,
  COLLAPSE: 2
};

var parseVisibility = exports.parseVisibility = function parseVisibility(visibility) {
  switch (visibility) {
    case 'hidden':
      return VISIBILITY.HIDDEN;

    case 'collapse':
      return VISIBILITY.COLLAPSE;

    case 'visible':
    default:
      return VISIBILITY.VISIBLE;
  }
};
},{}],"O7NJ":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var WORD_BREAK = exports.WORD_BREAK = {
  NORMAL: 'normal',
  BREAK_ALL: 'break-all',
  KEEP_ALL: 'keep-all'
};

var parseWordBreak = exports.parseWordBreak = function parseWordBreak(wordBreak) {
  switch (wordBreak) {
    case 'break-all':
      return WORD_BREAK.BREAK_ALL;

    case 'keep-all':
      return WORD_BREAK.KEEP_ALL;

    case 'normal':
    default:
      return WORD_BREAK.NORMAL;
  }
};
},{}],"jGiM":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var parseZIndex = exports.parseZIndex = function parseZIndex(zIndex) {
  var auto = zIndex === 'auto';
  return {
    auto: auto,
    order: auto ? 0 : parseInt(zIndex, 10)
  };
};
},{}],"a32l":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ForeignObjectRenderer = function () {
  function ForeignObjectRenderer(element) {
    _classCallCheck(this, ForeignObjectRenderer);

    this.element = element;
  }

  _createClass(ForeignObjectRenderer, [{
    key: 'render',
    value: function render(options) {
      var _this = this;

      this.options = options;
      this.canvas = document.createElement('canvas');
      this.ctx = this.canvas.getContext('2d');
      this.canvas.width = Math.floor(options.width) * options.scale;
      this.canvas.height = Math.floor(options.height) * options.scale;
      this.canvas.style.width = options.width + 'px';
      this.canvas.style.height = options.height + 'px';
      options.logger.log('ForeignObject renderer initialized (' + options.width + 'x' + options.height + ' at ' + options.x + ',' + options.y + ') with scale ' + options.scale);
      var svg = createForeignObjectSVG(Math.max(options.windowWidth, options.width) * options.scale, Math.max(options.windowHeight, options.height) * options.scale, options.scrollX * options.scale, options.scrollY * options.scale, this.element);
      return loadSerializedSVG(svg).then(function (img) {
        if (options.backgroundColor) {
          _this.ctx.fillStyle = options.backgroundColor.toString();

          _this.ctx.fillRect(0, 0, options.width * options.scale, options.height * options.scale);
        }

        _this.ctx.drawImage(img, -options.x * options.scale, -options.y * options.scale);

        return _this.canvas;
      });
    }
  }]);

  return ForeignObjectRenderer;
}();

exports.default = ForeignObjectRenderer;

var createForeignObjectSVG = exports.createForeignObjectSVG = function createForeignObjectSVG(width, height, x, y, node) {
  var xmlns = 'http://www.w3.org/2000/svg';
  var svg = document.createElementNS(xmlns, 'svg');
  var foreignObject = document.createElementNS(xmlns, 'foreignObject');
  svg.setAttributeNS(null, 'width', width);
  svg.setAttributeNS(null, 'height', height);
  foreignObject.setAttributeNS(null, 'width', '100%');
  foreignObject.setAttributeNS(null, 'height', '100%');
  foreignObject.setAttributeNS(null, 'x', x);
  foreignObject.setAttributeNS(null, 'y', y);
  foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svg;
};

var loadSerializedSVG = exports.loadSerializedSVG = function loadSerializedSVG(svg) {
  return new Promise(function (resolve, reject) {
    var img = new Image();

    img.onload = function () {
      return resolve(img);
    };

    img.onerror = reject;
    img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
},{}],"iLjs":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ForeignObjectRenderer = require('./renderer/ForeignObjectRenderer');

var testRangeBounds = function testRangeBounds(document) {
  var TEST_HEIGHT = 123;

  if (document.createRange) {
    var range = document.createRange();

    if (range.getBoundingClientRect) {
      var testElement = document.createElement('boundtest');
      testElement.style.height = TEST_HEIGHT + 'px';
      testElement.style.display = 'block';
      document.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document.body.removeChild(testElement);

      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }

  return false;
}; // iOS 10.3 taints canvas with base64 images unless crossOrigin = 'anonymous'


var testBase64 = function testBase64(document, src) {
  var img = new Image();
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  return new Promise(function (resolve) {
    // Single pixel base64 image renders fine on iOS 10.3???
    img.src = src;

    var onload = function onload() {
      try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
      } catch (e) {
        return resolve(false);
      }

      return resolve(true);
    };

    img.onload = onload;

    img.onerror = function () {
      return resolve(false);
    };

    if (img.complete === true) {
      setTimeout(function () {
        onload();
      }, 500);
    }
  });
};

var testCORS = function testCORS() {
  return typeof new Image().crossOrigin !== 'undefined';
};

var testResponseType = function testResponseType() {
  return typeof new XMLHttpRequest().responseType === 'string';
};

var testSVG = function testSVG(document) {
  var img = new Image();
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  img.src = 'data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\'></svg>';

  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e) {
    return false;
  }

  return true;
};

var isGreenPixel = function isGreenPixel(data) {
  return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};

var testForeignObject = function testForeignObject(document) {
  var canvas = document.createElement('canvas');
  var size = 100;
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgb(0, 255, 0)';
  ctx.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg = (0, _ForeignObjectRenderer.createForeignObjectSVG)(size, size, 0, 0, img);
  ctx.fillStyle = 'red';
  ctx.fillRect(0, 0, size, size);
  return (0, _ForeignObjectRenderer.loadSerializedSVG)(svg).then(function (img) {
    ctx.drawImage(img, 0, 0);
    var data = ctx.getImageData(0, 0, size, size).data;
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, size, size);
    var node = document.createElement('div');
    node.style.backgroundImage = 'url(' + greenImageSrc + ')';
    node.style.height = size + 'px'; // Firefox 55 does not render inline <img /> tags

    return isGreenPixel(data) ? (0, _ForeignObjectRenderer.loadSerializedSVG)((0, _ForeignObjectRenderer.createForeignObjectSVG)(size, size, 0, 0, node)) : Promise.reject(false);
  }).then(function (img) {
    ctx.drawImage(img, 0, 0); // Edge does not render background-images

    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  }).catch(function (e) {
    return false;
  });
};

var FEATURES = {
  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_RANGE_BOUNDS() {
    'use strict';

    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', {
      value: value
    });
    return value;
  },

  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_SVG_DRAWING() {
    'use strict';

    var value = testSVG(document);
    Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', {
      value: value
    });
    return value;
  },

  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_BASE64_DRAWING() {
    'use strict';

    return function (src) {
      var _value = testBase64(document, src);

      Object.defineProperty(FEATURES, 'SUPPORT_BASE64_DRAWING', {
        value: function value() {
          return _value;
        }
      });
      return _value;
    };
  },

  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    'use strict';

    var value = typeof Array.from === 'function' && typeof window.fetch === 'function' ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', {
      value: value
    });
    return value;
  },

  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_CORS_IMAGES() {
    'use strict';

    var value = testCORS();
    Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', {
      value: value
    });
    return value;
  },

  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_RESPONSE_TYPE() {
    'use strict';

    var value = testResponseType();
    Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', {
      value: value
    });
    return value;
  },

  // $FlowFixMe - get/set properties not yet supported
  get SUPPORT_CORS_XHR() {
    'use strict';

    var value = 'withCredentials' in new XMLHttpRequest();
    Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', {
      value: value
    });
    return value;
  }

};
exports.default = FEATURES;
},{"./renderer/ForeignObjectRenderer":"a32l"}],"G1YA":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var toCodePoints = exports.toCodePoints = function toCodePoints(str) {
    var codePoints = [];
    var i = 0;
    var length = str.length;
    while (i < length) {
        var value = str.charCodeAt(i++);
        if (value >= 0xd800 && value <= 0xdbff && i < length) {
            var extra = str.charCodeAt(i++);
            if ((extra & 0xfc00) === 0xdc00) {
                codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
            } else {
                codePoints.push(value);
                i--;
            }
        } else {
            codePoints.push(value);
        }
    }
    return codePoints;
};

var fromCodePoint = exports.fromCodePoint = function fromCodePoint() {
    if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, arguments);
    }

    var length = arguments.length;
    if (!length) {
        return '';
    }

    var codeUnits = [];

    var index = -1;
    var result = '';
    while (++index < length) {
        var codePoint = arguments.length <= index ? undefined : arguments[index];
        if (codePoint <= 0xffff) {
            codeUnits.push(codePoint);
        } else {
            codePoint -= 0x10000;
            codeUnits.push((codePoint >> 10) + 0xd800, codePoint % 0x400 + 0xdc00);
        }
        if (index + 1 === length || codeUnits.length > 0x4000) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
        }
    }
    return result;
};

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}

var decode = exports.decode = function decode(base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i = void 0,
        p = 0,
        encoded1 = void 0,
        encoded2 = void 0,
        encoded3 = void 0,
        encoded4 = void 0;

    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint8Array.prototype.slice !== 'undefined' ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
    var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];

        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return buffer;
};

var polyUint16Array = exports.polyUint16Array = function polyUint16Array(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var _i = 0; _i < length; _i += 2) {
        bytes.push(buffer[_i + 1] << 8 | buffer[_i]);
    }
    return bytes;
};

var polyUint32Array = exports.polyUint32Array = function polyUint32Array(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var _i2 = 0; _i2 < length; _i2 += 4) {
        bytes.push(buffer[_i2 + 3] << 24 | buffer[_i2 + 2] << 16 | buffer[_i2 + 1] << 8 | buffer[_i2]);
    }
    return bytes;
};
},{}],"cyO+":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Trie = exports.createTrieFromBase64 = exports.UTRIE2_INDEX_2_MASK = exports.UTRIE2_INDEX_2_BLOCK_LENGTH = exports.UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = exports.UTRIE2_INDEX_1_OFFSET = exports.UTRIE2_UTF8_2B_INDEX_2_LENGTH = exports.UTRIE2_UTF8_2B_INDEX_2_OFFSET = exports.UTRIE2_INDEX_2_BMP_LENGTH = exports.UTRIE2_LSCP_INDEX_2_LENGTH = exports.UTRIE2_DATA_MASK = exports.UTRIE2_DATA_BLOCK_LENGTH = exports.UTRIE2_LSCP_INDEX_2_OFFSET = exports.UTRIE2_SHIFT_1_2 = exports.UTRIE2_INDEX_SHIFT = exports.UTRIE2_SHIFT_1 = exports.UTRIE2_SHIFT_2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = require('./Util');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Shift size for getting the index-2 table offset. */
var UTRIE2_SHIFT_2 = exports.UTRIE2_SHIFT_2 = 5;

/** Shift size for getting the index-1 table offset. */
var UTRIE2_SHIFT_1 = exports.UTRIE2_SHIFT_1 = 6 + 5;

/**
 * Shift size for shifting left the index array values.
 * Increases possible data size with 16-bit index values at the cost
 * of compactability.
 * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
 */
var UTRIE2_INDEX_SHIFT = exports.UTRIE2_INDEX_SHIFT = 2;

/**
 * Difference between the two shift sizes,
 * for getting an index-1 offset from an index-2 offset. 6=11-5
 */
var UTRIE2_SHIFT_1_2 = exports.UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;

/**
 * The part of the index-2 table for U+D800..U+DBFF stores values for
 * lead surrogate code _units_ not code _points_.
 * Values for lead surrogate code _points_ are indexed with this portion of the table.
 * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
 */
var UTRIE2_LSCP_INDEX_2_OFFSET = exports.UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;

/** Number of entries in a data block. 32=0x20 */
var UTRIE2_DATA_BLOCK_LENGTH = exports.UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
/** Mask for getting the lower bits for the in-data-block offset. */
var UTRIE2_DATA_MASK = exports.UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;

var UTRIE2_LSCP_INDEX_2_LENGTH = exports.UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
/** Count the lengths of both BMP pieces. 2080=0x820 */
var UTRIE2_INDEX_2_BMP_LENGTH = exports.UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
/**
 * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
 * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
 */
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = exports.UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = exports.UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
/**
 * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
 * Variable length, for code points up to highStart, where the last single-value range starts.
 * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
 * (For 0x100000 supplementary code points U+10000..U+10ffff.)
 *
 * The part of the index-2 table for supplementary code points starts
 * after this index-1 table.
 *
 * Both the index-1 table and the following part of the index-2 table
 * are omitted completely if there is only BMP data.
 */
var UTRIE2_INDEX_1_OFFSET = exports.UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;

/**
 * Number of index-1 entries for the BMP. 32=0x20
 * This part of the index-1 table is omitted from the serialized form.
 */
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = exports.UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;

/** Number of entries in an index-2 block. 64=0x40 */
var UTRIE2_INDEX_2_BLOCK_LENGTH = exports.UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
/** Mask for getting the lower bits for the in-index-2-block offset. */
var UTRIE2_INDEX_2_MASK = exports.UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;

var createTrieFromBase64 = exports.createTrieFromBase64 = function createTrieFromBase64(base64) {
    var buffer = (0, _Util.decode)(base64);
    var view32 = Array.isArray(buffer) ? (0, _Util.polyUint32Array)(buffer) : new Uint32Array(buffer);
    var view16 = Array.isArray(buffer) ? (0, _Util.polyUint16Array)(buffer) : new Uint16Array(buffer);
    var headerLength = 24;

    var index = view16.slice(headerLength / 2, view32[4] / 2);
    var data = view32[5] === 2 ? view16.slice((headerLength + view32[4]) / 2) : view32.slice(Math.ceil((headerLength + view32[4]) / 4));

    return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
};

var Trie = exports.Trie = function () {
    function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
        _classCallCheck(this, Trie);

        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index;
        this.data = data;
    }

    /**
     * Get the value for a code point as stored in the Trie.
     *
     * @param codePoint the code point
     * @return the value
     */


    _createClass(Trie, [{
        key: 'get',
        value: function get(codePoint) {
            var ix = void 0;
            if (codePoint >= 0) {
                if (codePoint < 0x0d800 || codePoint > 0x0dbff && codePoint <= 0x0ffff) {
                    // Ordinary BMP code point, excluding leading surrogates.
                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                    // 16 bit data is stored in the index array itself.
                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }

                if (codePoint <= 0xffff) {
                    // Lead Surrogate Code Point.  A Separate index section is stored for
                    // lead surrogate code units and code points.
                    //   The main index has the code unit data.
                    //   For this function, we need the code point data.
                    // Note: this expression could be refactored for slightly improved efficiency, but
                    //       surrogate code points will be so rare in practice that it's not worth it.
                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 0xd800 >> UTRIE2_SHIFT_2)];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }

                if (codePoint < this.highStart) {
                    // Supplemental code point, use two-level lookup.
                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                    ix = this.index[ix];
                    ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                    ix = this.index[ix];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }
                if (codePoint <= 0x10ffff) {
                    return this.data[this.highValueIndex];
                }
            }

            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
            return this.errorValue;
        }
    }]);

    return Trie;
}();
},{"./Util":"G1YA"}],"8QNX":[function(require,module,exports) {
'use strict';

module.exports = 'KwAAAAAAAAAACA4AIDoAAPAfAAACAAAAAAAIABAAGABAAEgAUABYAF4AZgBeAGYAYABoAHAAeABeAGYAfACEAIAAiACQAJgAoACoAK0AtQC9AMUAXgBmAF4AZgBeAGYAzQDVAF4AZgDRANkA3gDmAOwA9AD8AAQBDAEUARoBIgGAAIgAJwEvATcBPwFFAU0BTAFUAVwBZAFsAXMBewGDATAAiwGTAZsBogGkAawBtAG8AcIBygHSAdoB4AHoAfAB+AH+AQYCDgIWAv4BHgImAi4CNgI+AkUCTQJTAlsCYwJrAnECeQKBAk0CiQKRApkCoQKoArACuALAAsQCzAIwANQC3ALkAjAA7AL0AvwCAQMJAxADGAMwACADJgMuAzYDPgOAAEYDSgNSA1IDUgNaA1oDYANiA2IDgACAAGoDgAByA3YDfgOAAIQDgACKA5IDmgOAAIAAogOqA4AAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAK8DtwOAAIAAvwPHA88D1wPfAyAD5wPsA/QD/AOAAIAABAQMBBIEgAAWBB4EJgQuBDMEIAM7BEEEXgBJBCADUQRZBGEEaQQwADAAcQQ+AXkEgQSJBJEEgACYBIAAoASoBK8EtwQwAL8ExQSAAIAAgACAAIAAgACgAM0EXgBeAF4AXgBeAF4AXgBeANUEXgDZBOEEXgDpBPEE+QQBBQkFEQUZBSEFKQUxBTUFPQVFBUwFVAVcBV4AYwVeAGsFcwV7BYMFiwWSBV4AmgWgBacFXgBeAF4AXgBeAKsFXgCyBbEFugW7BcIFwgXIBcIFwgXQBdQF3AXkBesF8wX7BQMGCwYTBhsGIwYrBjMGOwZeAD8GRwZNBl4AVAZbBl4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAGMGXgBqBnEGXgBeAF4AXgBeAF4AXgBeAF4AXgB5BoAG4wSGBo4GkwaAAIADHgR5AF4AXgBeAJsGgABGA4AAowarBrMGswagALsGwwbLBjAA0wbaBtoG3QbaBtoG2gbaBtoG2gblBusG8wb7BgMHCwcTBxsHCwcjBysHMAc1BzUHOgdCB9oGSgdSB1oHYAfaBloHaAfaBlIH2gbaBtoG2gbaBtoG2gbaBjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHbQdeAF4ANQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQd1B30HNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B4MH2gaKB68EgACAAIAAgACAAIAAgACAAI8HlwdeAJ8HpweAAIAArwe3B14AXgC/B8UHygcwANAH2AfgB4AA6AfwBz4B+AcACFwBCAgPCBcIogEYAR8IJwiAAC8INwg/CCADRwhPCFcIXwhnCEoDGgSAAIAAgABvCHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIhAiLCI4IMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAANQc1BzUHNQc1BzUHNQc1BzUHNQc1B54INQc1B6II2gaqCLIIugiAAIAAvgjGCIAAgACAAIAAgACAAIAAgACAAIAAywiHAYAA0wiAANkI3QjlCO0I9Aj8CIAAgACAAAIJCgkSCRoJIgknCTYHLwk3CZYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiAAIAAAAFAAXgBeAGAAcABeAHwAQACQAKAArQC9AJ4AXgBeAE0A3gBRAN4A7AD8AMwBGgEAAKcBNwEFAUwBXAF4QkhCmEKnArcCgAHHAsABz4LAAcABwAHAAd+C6ABoAG+C/4LAAcABwAHAAc+DF4MAAcAB54M3gweDV4Nng3eDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEeDqABVg6WDqABoQ6gAaABoAHXDvcONw/3DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DncPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB7cPPwlGCU4JMACAAIAAgABWCV4JYQmAAGkJcAl4CXwJgAkwADAAMAAwAIgJgACLCZMJgACZCZ8JowmrCYAAswkwAF4AXgB8AIAAuwkABMMJyQmAAM4JgADVCTAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAqwYWBNkIMAAwADAAMADdCeAJ6AnuCR4E9gkwAP4JBQoNCjAAMACAABUK0wiAAB0KJAosCjQKgAAwADwKQwqAAEsKvQmdCVMKWwowADAAgACAALcEMACAAGMKgABrCjAAMAAwADAAMAAwADAAMAAwADAAMAAeBDAAMAAwADAAMAAwADAAMAAwADAAMAAwAIkEPQFzCnoKiQSCCooKkAqJBJgKoAqkCokEGAGsCrQKvArBCjAAMADJCtEKFQHZCuEK/gHpCvEKMAAwADAAMACAAIwE+QowAIAAPwEBCzAAMAAwADAAMACAAAkLEQswAIAAPwEZCyELgAAOCCkLMAAxCzkLMAAwADAAMAAwADAAXgBeAEELMAAwADAAMAAwADAAMAAwAEkLTQtVC4AAXAtkC4AAiQkwADAAMAAwADAAMAAwADAAbAtxC3kLgAuFC4sLMAAwAJMLlwufCzAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAApwswADAAMACAAIAAgACvC4AAgACAAIAAgACAALcLMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAvwuAAMcLgACAAIAAgACAAIAAyguAAIAAgACAAIAA0QswADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAANkLgACAAIAA4AswADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACJCR4E6AswADAAhwHwC4AA+AsADAgMEAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACAAIAAGAwdDCUMMAAwAC0MNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQw1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHPQwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADUHNQc1BzUHNQc1BzUHNQc2BzAAMAA5DDUHNQc1BzUHNQc1BzUHNQc1BzUHNQdFDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAATQxSDFoMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAF4AXgBeAF4AXgBeAF4AYgxeAGoMXgBxDHkMfwxeAIUMXgBeAI0MMAAwADAAMAAwAF4AXgCVDJ0MMAAwADAAMABeAF4ApQxeAKsMswy7DF4Awgy9DMoMXgBeAF4AXgBeAF4AXgBeAF4AXgDRDNkMeQBqCeAM3Ax8AOYM7Az0DPgMXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgCgAAANoAAHDQ4NFg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAeDSYNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAC4NMABeAF4ANg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAD4NRg1ODVYNXg1mDTAAbQ0wADAAMAAwADAAMAAwADAA2gbaBtoG2gbaBtoG2gbaBnUNeg3CBYANwgWFDdoGjA3aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gaUDZwNpA2oDdoG2gawDbcNvw3HDdoG2gbPDdYN3A3fDeYN2gbsDfMN2gbaBvoN/g3aBgYODg7aBl4AXgBeABYOXgBeACUG2gYeDl4AJA5eACwO2w3aBtoGMQ45DtoG2gbaBtoGQQ7aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B1EO2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQdZDjUHNQc1BzUHNQc1B2EONQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHaA41BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B3AO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B2EO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBkkOeA6gAKAAoAAwADAAMAAwAKAAoACgAKAAoACgAKAAgA4wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAD//wQABAAEAAQABAAEAAQABAAEAA0AAwABAAEAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAKABMAFwAeABsAGgAeABcAFgASAB4AGwAYAA8AGAAcAEsASwBLAEsASwBLAEsASwBLAEsAGAAYAB4AHgAeABMAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAFgAbABIAHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYADQARAB4ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkAFgAaABsAGwAbAB4AHQAdAB4ATwAXAB4ADQAeAB4AGgAbAE8ATwAOAFAAHQAdAB0ATwBPABcATwBPAE8AFgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwArAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAAQABAANAA0ASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAUAArACsAKwArACsAKwArACsABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAGgAaAFAAUABQAFAAUABMAB4AGwBQAB4AKwArACsABAAEAAQAKwBQAFAAUABQAFAAUAArACsAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUAArAFAAUAArACsABAArAAQABAAEAAQABAArACsAKwArAAQABAArACsABAAEAAQAKwArACsABAArACsAKwArACsAKwArAFAAUABQAFAAKwBQACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwAEAAQAUABQAFAABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQAKwArAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeABsAKwArACsAKwArACsAKwBQAAQABAAEAAQABAAEACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAKwArACsAKwArACsAKwArAAQABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwAEAFAAKwBQAFAAUABQAFAAUAArACsAKwBQAFAAUAArAFAAUABQAFAAKwArACsAUABQACsAUAArAFAAUAArACsAKwBQAFAAKwArACsAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQAKwArACsABAAEAAQAKwAEAAQABAAEACsAKwBQACsAKwArACsAKwArAAQAKwArACsAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAB4AHgAeAB4AHgAeABsAHgArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArAFAAUABQACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAB4AUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArACsAKwArACsAKwArAFAAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwArAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAKwBcAFwAKwBcACsAKwBcACsAKwArACsAKwArAFwAXABcAFwAKwBcAFwAXABcAFwAXABcACsAXABcAFwAKwBcACsAXAArACsAXABcACsAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgArACoAKgBcACsAKwBcAFwAXABcAFwAKwBcACsAKgAqACoAKgAqACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAFwAXABcAFwAUAAOAA4ADgAOAB4ADgAOAAkADgAOAA0ACQATABMAEwATABMACQAeABMAHgAeAB4ABAAEAB4AHgAeAB4AHgAeAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUAANAAQAHgAEAB4ABAAWABEAFgARAAQABABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAAQABAAEAAQABAANAAQABABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsADQANAB4AHgAeAB4AHgAeAAQAHgAeAB4AHgAeAB4AKwAeAB4ADgAOAA0ADgAeAB4AHgAeAB4ACQAJACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgAeAB4AHgBcAFwAXABcAFwAXAAqACoAKgAqAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAKgAqACoAKgAqACoAKgBcAFwAXAAqACoAKgAqAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAXAAqAEsASwBLAEsASwBLAEsASwBLAEsAKgAqACoAKgAqACoAUABQAFAAUABQAFAAKwBQACsAKwArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQACsAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwAEAAQABAAeAA0AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAEQArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAADQANAA0AUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAA0ADQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoADQANABUAXAANAB4ADQAbAFwAKgArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAB4AHgATABMADQANAA4AHgATABMAHgAEAAQABAAJACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAUABQAFAAUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwAeACsAKwArABMAEwBLAEsASwBLAEsASwBLAEsASwBLAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwBcAFwAXABcAFwAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcACsAKwArACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwAeAB4AXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsABABLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKgAqACoAKgAqACoAKgBcACoAKgAqACoAKgAqACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAUABQAFAAUABQAFAAUAArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4ADQANAA0ADQAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAHgAeAB4AHgBQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwANAA0ADQANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwBQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsABAAEAAQAHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAABABQAFAAUABQAAQABAAEAFAAUAAEAAQABAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAKwBQACsAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAKwArAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAKwAeAB4AHgAeAB4AHgAeAA4AHgArAA0ADQANAA0ADQANAA0ACQANAA0ADQAIAAQACwAEAAQADQAJAA0ADQAMAB0AHQAeABcAFwAWABcAFwAXABYAFwAdAB0AHgAeABQAFAAUAA0AAQABAAQABAAEAAQABAAJABoAGgAaABoAGgAaABoAGgAeABcAFwAdABUAFQAeAB4AHgAeAB4AHgAYABYAEQAVABUAFQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgANAB4ADQANAA0ADQAeAA0ADQANAAcAHgAeAB4AHgArAAQABAAEAAQABAAEAAQABAAEAAQAUABQACsAKwBPAFAAUABQAFAAUAAeAB4AHgAWABEATwBQAE8ATwBPAE8AUABQAFAAUABQAB4AHgAeABYAEQArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGgAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgBQABoAHgAdAB4AUAAeABoAHgAeAB4AHgAeAB4AHgAeAB4ATwAeAFAAGwAeAB4AUABQAFAAUABQAB4AHgAeAB0AHQAeAFAAHgBQAB4AUAAeAFAATwBQAFAAHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AUABQAFAAUABPAE8AUABQAFAAUABQAE8AUABQAE8AUABPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAE8ATwBPAE8ATwBPAE8ATwBPAE8AUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAATwAeAB4AKwArACsAKwAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB0AHQAeAB4AHgAdAB0AHgAeAB0AHgAeAB4AHQAeAB0AGwAbAB4AHQAeAB4AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB0AHgAdAB4AHQAdAB0AHQAdAB0AHgAdAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAdAB0AHQAdAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAlACUAHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB0AHQAeAB4AHgAeAB0AHQAdAB4AHgAdAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB0AHQAeAB4AHQAeAB4AHgAeAB0AHQAeAB4AHgAeACUAJQAdAB0AJQAeACUAJQAlACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHQAdAB0AHgAdACUAHQAdAB4AHQAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHQAdAB0AHQAlAB4AJQAlACUAHQAlACUAHQAdAB0AJQAlAB0AHQAlAB0AHQAlACUAJQAeAB0AHgAeAB4AHgAdAB0AJQAdAB0AHQAdAB0AHQAlACUAJQAlACUAHQAlACUAIAAlAB0AHQAlACUAJQAlACUAJQAlACUAHgAeAB4AJQAlACAAIAAgACAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeABcAFwAXABcAFwAXAB4AEwATACUAHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACUAJQBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwArACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAE8ATwBPAE8ATwBPAE8ATwAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeACsAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUAArACsAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQBQAFAAUABQACsAKwArACsAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAABAAEAAQAKwAEAAQAKwArACsAKwArAAQABAAEAAQAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsABAAEAAQAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsADQANAA0ADQANAA0ADQANAB4AKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAUABQAFAAUABQAA0ADQANAA0ADQANABQAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwANAA0ADQANAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAeAAQABAAEAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLACsADQArAB4AKwArAAQABAAEAAQAUABQAB4AUAArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwAEAAQABAAEAAQABAAEAAQABAAOAA0ADQATABMAHgAeAB4ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0AUABQAFAAUAAEAAQAKwArAAQADQANAB4AUAArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXABcAA0ADQANACoASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUAArACsAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANACsADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEcARwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwAeAAQABAANAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAEAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUAArACsAUAArACsAUABQACsAKwBQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAeAB4ADQANAA0ADQAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAArAAQABAArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAEAAQABAAEAAQABAAEACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAFgAWAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAKwBQACsAKwArACsAKwArAFAAKwArACsAKwBQACsAUAArAFAAKwBQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQACsAUAArAFAAKwBQACsAUABQACsAUAArACsAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAUABQAFAAUAArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUAArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAlACUAJQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeACUAJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeACUAJQAlACUAJQAeACUAJQAlACUAJQAgACAAIAAlACUAIAAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIQAhACEAIQAhACUAJQAgACAAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAIAAlACUAJQAlACAAJQAgACAAIAAgACAAIAAgACAAIAAlACUAJQAgACUAJQAlACUAIAAgACAAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeACUAHgAlAB4AJQAlACUAJQAlACAAJQAlACUAJQAeACUAHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAIAAgACAAIAAgAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFwAXABcAFQAVABUAHgAeAB4AHgAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAlACAAIAAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsA';
},{}],"WYqB":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineBreaker = exports.inlineBreakOpportunities = exports.lineBreakAtIndex = exports.codePointsToCharacterClasses = exports.UnicodeTrie = exports.BREAK_ALLOWED = exports.BREAK_NOT_ALLOWED = exports.BREAK_MANDATORY = exports.classes = exports.LETTER_NUMBER_MODIFIER = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _Trie = require('./Trie');

var _linebreakTrie = require('./linebreak-trie');

var _linebreakTrie2 = _interopRequireDefault(_linebreakTrie);

var _Util = require('./Util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LETTER_NUMBER_MODIFIER = exports.LETTER_NUMBER_MODIFIER = 50;

// Non-tailorable Line Breaking Classes
var BK = 1; //  Cause a line break (after)
var CR = 2; //  Cause a line break (after), except between CR and LF
var LF = 3; //  Cause a line break (after)
var CM = 4; //  Prohibit a line break between the character and the preceding character
var NL = 5; //  Cause a line break (after)
var SG = 6; //  Do not occur in well-formed text
var WJ = 7; //  Prohibit line breaks before and after
var ZW = 8; //  Provide a break opportunity
var GL = 9; //  Prohibit line breaks before and after
var SP = 10; // Enable indirect line breaks
var ZWJ = 11; // Prohibit line breaks within joiner sequences
// Break Opportunities
var B2 = 12; //  Provide a line break opportunity before and after the character
var BA = 13; //  Generally provide a line break opportunity after the character
var BB = 14; //  Generally provide a line break opportunity before the character
var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
var CB = 16; //   Provide a line break opportunity contingent on additional information
// Characters Prohibiting Certain Breaks
var CL = 17; //  Prohibit line breaks before
var CP = 18; //  Prohibit line breaks before
var EX = 19; //  Prohibit line breaks before
var IN = 20; //  Allow only indirect line breaks between pairs
var NS = 21; //  Allow only indirect line breaks before
var OP = 22; //  Prohibit line breaks after
var QU = 23; //  Act like they are both opening and closing
// Numeric Context
var IS = 24; //  Prevent breaks after any and before numeric
var NU = 25; //  Form numeric expressions for line breaking purposes
var PO = 26; //  Do not break following a numeric expression
var PR = 27; //  Do not break in front of a numeric expression
var SY = 28; //  Prevent a break before; and allow a break after
// Other Characters
var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
var EB = 32; //  Do not break from following Emoji Modifier
var EM = 33; //  Do not break from preceding Emoji Base
var H2 = 34; //  Form Korean syllable blocks
var H3 = 35; //  Form Korean syllable blocks
var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
var ID = 37; //  Break before or after; except in some numeric context
var JL = 38; //  Form Korean syllable blocks
var JV = 39; //  Form Korean syllable blocks
var JT = 40; //  Form Korean syllable blocks
var RI = 41; //  Keep pairs together. For pairs; break before and after other classes
var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions

var classes = exports.classes = {
    BK: BK,
    CR: CR,
    LF: LF,
    CM: CM,
    NL: NL,
    SG: SG,
    WJ: WJ,
    ZW: ZW,
    GL: GL,
    SP: SP,
    ZWJ: ZWJ,
    B2: B2,
    BA: BA,
    BB: BB,
    HY: HY,
    CB: CB,
    CL: CL,
    CP: CP,
    EX: EX,
    IN: IN,
    NS: NS,
    OP: OP,
    QU: QU,
    IS: IS,
    NU: NU,
    PO: PO,
    PR: PR,
    SY: SY,
    AI: AI,
    AL: AL,
    CJ: CJ,
    EB: EB,
    EM: EM,
    H2: H2,
    H3: H3,
    HL: HL,
    ID: ID,
    JL: JL,
    JV: JV,
    JT: JT,
    RI: RI,
    SA: SA,
    XX: XX
};

var BREAK_MANDATORY = exports.BREAK_MANDATORY = '!';
var BREAK_NOT_ALLOWED = exports.BREAK_NOT_ALLOWED = '';
var BREAK_ALLOWED = exports.BREAK_ALLOWED = '';
var UnicodeTrie = exports.UnicodeTrie = (0, _Trie.createTrieFromBase64)(_linebreakTrie2.default);

var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR, LF, NL];
var SPACE = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];

var codePointsToCharacterClasses = exports.codePointsToCharacterClasses = function codePointsToCharacterClasses(codePoints) {
    var lineBreak = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'strict';

    var types = [];
    var indicies = [];
    var categories = [];
    codePoints.forEach(function (codePoint, index) {
        var classType = UnicodeTrie.get(codePoint);
        if (classType > LETTER_NUMBER_MODIFIER) {
            categories.push(true);
            classType -= LETTER_NUMBER_MODIFIER;
        } else {
            categories.push(false);
        }

        if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
            // U+2010,  U+2013,  U+301C,  U+30A0
            if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                indicies.push(index);
                return types.push(CB);
            }
        }

        if (classType === CM || classType === ZWJ) {
            // LB10 Treat any remaining combining mark or ZWJ as AL.
            if (index === 0) {
                indicies.push(index);
                return types.push(AL);
            }

            // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
            // the base character in all of the following rules. Treat ZWJ as if it were CM.
            var prev = types[index - 1];
            if (LINE_BREAKS.indexOf(prev) === -1) {
                indicies.push(indicies[index - 1]);
                return types.push(prev);
            }
            indicies.push(index);
            return types.push(AL);
        }

        indicies.push(index);

        if (classType === CJ) {
            return types.push(lineBreak === 'strict' ? NS : ID);
        }

        if (classType === SA) {
            return types.push(AL);
        }

        if (classType === AI) {
            return types.push(AL);
        }

        // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
        // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
        // to take into account the actual line breaking properties for these characters.
        if (classType === XX) {
            if (codePoint >= 0x20000 && codePoint <= 0x2fffd || codePoint >= 0x30000 && codePoint <= 0x3fffd) {
                return types.push(ID);
            } else {
                return types.push(AL);
            }
        }

        types.push(classType);
    });

    return [indicies, types, categories];
};

var isAdjacentWithSpaceIgnored = function isAdjacentWithSpaceIgnored(a, b, currentIndex, classTypes) {
    var current = classTypes[currentIndex];
    if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
        var i = currentIndex;
        while (i <= classTypes.length) {
            i++;
            var next = classTypes[i];

            if (next === b) {
                return true;
            }

            if (next !== SP) {
                break;
            }
        }
    }

    if (current === SP) {
        var _i = currentIndex;

        while (_i > 0) {
            _i--;
            var prev = classTypes[_i];

            if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                var n = currentIndex;
                while (n <= classTypes.length) {
                    n++;
                    var _next = classTypes[n];

                    if (_next === b) {
                        return true;
                    }

                    if (_next !== SP) {
                        break;
                    }
                }
            }

            if (prev !== SP) {
                break;
            }
        }
    }
    return false;
};

var previousNonSpaceClassType = function previousNonSpaceClassType(currentIndex, classTypes) {
    var i = currentIndex;
    while (i >= 0) {
        var type = classTypes[i];
        if (type === SP) {
            i--;
        } else {
            return type;
        }
    }
    return 0;
};

var _lineBreakAtIndex = function _lineBreakAtIndex(codePoints, classTypes, indicies, index, forbiddenBreaks) {
    if (indicies[index] === 0) {
        return BREAK_NOT_ALLOWED;
    }

    var currentIndex = index - 1;
    if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
        return BREAK_NOT_ALLOWED;
    }

    var beforeIndex = currentIndex - 1;
    var afterIndex = currentIndex + 1;
    var current = classTypes[currentIndex];

    // LB4 Always break after hard line breaks.
    // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
    var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
    var next = classTypes[afterIndex];

    if (current === CR && next === LF) {
        return BREAK_NOT_ALLOWED;
    }

    if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
        return BREAK_MANDATORY;
    }

    // LB6 Do not break before hard line breaks.
    if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB7 Do not break before spaces or zero width space.
    if (SPACE.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
    if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
        return BREAK_ALLOWED;
    }

    // LB8a Do not break between a zero width joiner and an ideograph, emoji base or emoji modifier.
    if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ && (next === ID || next === EB || next === EM)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB11 Do not break before or after Word joiner and related characters.
    if (current === WJ || next === WJ) {
        return BREAK_NOT_ALLOWED;
    }

    // LB12 Do not break after NBSP and related characters.
    if (current === GL) {
        return BREAK_NOT_ALLOWED;
    }

    // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
    if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
        return BREAK_NOT_ALLOWED;
    }

    // LB13 Do not break before ] or ! or ; or /, even after spaces.
    if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB14 Do not break after [, even after spaces.
    if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
        return BREAK_NOT_ALLOWED;
    }

    // LB15 Do not break within [, even with intervening spaces.
    if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
    if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB17 Do not break within , even with intervening spaces.
    if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB18 Break after spaces.
    if (current === SP) {
        return BREAK_ALLOWED;
    }

    // LB19 Do not break before or after quotation marks, such as   .
    if (current === QU || next === QU) {
        return BREAK_NOT_ALLOWED;
    }

    // LB20 Break before and after unresolved CB.
    if (next === CB || current === CB) {
        return BREAK_ALLOWED;
    }

    // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
    if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
        return BREAK_NOT_ALLOWED;
    }

    // LB21a Don't break after Hebrew + Hyphen.
    if (before === HL && HYPHEN.indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB21b Dont break between Solidus and Hebrew letters.
    if (current === SY && next === HL) {
        return BREAK_NOT_ALLOWED;
    }

    // LB22 Do not break between two ellipses, or between letters, numbers or exclamations and ellipsis.
    if (next === IN && ALPHABETICS.concat(IN, EX, NU, ID, EB, EM).indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB23 Do not break between digits and letters.
    if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
        return BREAK_NOT_ALLOWED;
    }

    // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
    if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
        return BREAK_NOT_ALLOWED;
    }

    // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
    if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB25 Do not break between the following pairs of classes relevant to numbers:
    if (
    // (PR | PO)  ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) ||
    // ( OP | HY )  NU
    [OP, HY].indexOf(current) !== -1 && next === NU ||
    // NU 	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // NU (NU | SY | IS)*  (NU | SY | IS | CL | CP)
    if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
        var prevIndex = currentIndex;
        while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
                return BREAK_NOT_ALLOWED;
            } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
            } else {
                break;
            }
        }
    }

    // NU (NU | SY | IS)* (CL | CP)?  (PO | PR))
    if ([PR, PO].indexOf(next) !== -1) {
        var _prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
        while (_prevIndex >= 0) {
            var _type = classTypes[_prevIndex];
            if (_type === NU) {
                return BREAK_NOT_ALLOWED;
            } else if ([SY, IS].indexOf(_type) !== -1) {
                _prevIndex--;
            } else {
                break;
            }
        }
    }

    // LB26 Do not break a Korean syllable.
    if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
        return BREAK_NOT_ALLOWED;
    }

    // LB27 Treat a Korean Syllable Block the same as ID.
    if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
        return BREAK_NOT_ALLOWED;
    }

    // LB28 Do not break between alphabetics (at).
    if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB29 Do not break between numeric punctuation and alphabetics (e.g.).
    if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
    if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
        return BREAK_NOT_ALLOWED;
    }

    // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
    // indicators preceding the position of the break.
    if (current === RI && next === RI) {
        var i = indicies[currentIndex];
        var count = 1;
        while (i > 0) {
            i--;
            if (classTypes[i] === RI) {
                count++;
            } else {
                break;
            }
        }
        if (count % 2 !== 0) {
            return BREAK_NOT_ALLOWED;
        }
    }

    // LB30b Do not break between an emoji base and an emoji modifier.
    if (current === EB && next === EM) {
        return BREAK_NOT_ALLOWED;
    }

    return BREAK_ALLOWED;
};

var lineBreakAtIndex = exports.lineBreakAtIndex = function lineBreakAtIndex(codePoints, index) {
    // LB2 Never break at the start of text.
    if (index === 0) {
        return BREAK_NOT_ALLOWED;
    }

    // LB3 Always break at the end of text.
    if (index >= codePoints.length) {
        return BREAK_MANDATORY;
    }

    var _codePointsToCharacte = codePointsToCharacterClasses(codePoints),
        _codePointsToCharacte2 = _slicedToArray(_codePointsToCharacte, 2),
        indicies = _codePointsToCharacte2[0],
        classTypes = _codePointsToCharacte2[1];

    return _lineBreakAtIndex(codePoints, classTypes, indicies, index);
};

var cssFormattedClasses = function cssFormattedClasses(codePoints, options) {
    if (!options) {
        options = { lineBreak: 'normal', wordBreak: 'normal' };
    }

    var _codePointsToCharacte3 = codePointsToCharacterClasses(codePoints, options.lineBreak),
        _codePointsToCharacte4 = _slicedToArray(_codePointsToCharacte3, 3),
        indicies = _codePointsToCharacte4[0],
        classTypes = _codePointsToCharacte4[1],
        isLetterNumber = _codePointsToCharacte4[2];

    if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
        classTypes = classTypes.map(function (type) {
            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
        });
    }

    var forbiddenBreakpoints = options.wordBreak === 'keep-all' ? isLetterNumber.map(function (isLetterNumber, i) {
        return isLetterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
    }) : null;

    return [indicies, classTypes, forbiddenBreakpoints];
};

var inlineBreakOpportunities = exports.inlineBreakOpportunities = function inlineBreakOpportunities(str, options) {
    var codePoints = (0, _Util.toCodePoints)(str);
    var output = BREAK_NOT_ALLOWED;

    var _cssFormattedClasses = cssFormattedClasses(codePoints, options),
        _cssFormattedClasses2 = _slicedToArray(_cssFormattedClasses, 3),
        indicies = _cssFormattedClasses2[0],
        classTypes = _cssFormattedClasses2[1],
        forbiddenBreakpoints = _cssFormattedClasses2[2];

    codePoints.forEach(function (codePoint, i) {
        output += (0, _Util.fromCodePoint)(codePoint) + (i >= codePoints.length - 1 ? BREAK_MANDATORY : _lineBreakAtIndex(codePoints, classTypes, indicies, i + 1, forbiddenBreakpoints));
    });

    return output;
};

var Break = function () {
    function Break(codePoints, lineBreak, start, end) {
        _classCallCheck(this, Break);

        this._codePoints = codePoints;
        this.required = lineBreak === BREAK_MANDATORY;
        this.start = start;
        this.end = end;
    }

    _createClass(Break, [{
        key: 'slice',
        value: function slice() {
            return _Util.fromCodePoint.apply(undefined, _toConsumableArray(this._codePoints.slice(this.start, this.end)));
        }
    }]);

    return Break;
}();

var LineBreaker = exports.LineBreaker = function LineBreaker(str, options) {
    var codePoints = (0, _Util.toCodePoints)(str);

    var _cssFormattedClasses3 = cssFormattedClasses(codePoints, options),
        _cssFormattedClasses4 = _slicedToArray(_cssFormattedClasses3, 3),
        indicies = _cssFormattedClasses4[0],
        classTypes = _cssFormattedClasses4[1],
        forbiddenBreakpoints = _cssFormattedClasses4[2];

    var length = codePoints.length;
    var lastEnd = 0;
    var nextIndex = 0;

    return {
        next: function next() {
            if (nextIndex >= length) {
                return { done: true };
            }
            var lineBreak = BREAK_NOT_ALLOWED;
            while (nextIndex < length && (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED) {}

            if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {
                var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                lastEnd = nextIndex;
                return { value: value, done: false };
            }

            return { done: true };
        }
    };
};
},{"./Trie":"cyO+","./linebreak-trie":"8QNX","./Util":"G1YA"}],"eYU0":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Util = require('./Util');

Object.defineProperty(exports, 'toCodePoints', {
  enumerable: true,
  get: function get() {
    return _Util.toCodePoints;
  }
});
Object.defineProperty(exports, 'fromCodePoint', {
  enumerable: true,
  get: function get() {
    return _Util.fromCodePoint;
  }
});

var _LineBreak = require('./LineBreak');

Object.defineProperty(exports, 'LineBreaker', {
  enumerable: true,
  get: function get() {
    return _LineBreak.LineBreaker;
  }
});
},{"./Util":"G1YA","./LineBreak":"WYqB"}],"YXY6":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.breakWords = exports.fromCodePoint = exports.toCodePoints = undefined;

var _cssLineBreak = require('css-line-break');

Object.defineProperty(exports, 'toCodePoints', {
  enumerable: true,
  get: function get() {
    return _cssLineBreak.toCodePoints;
  }
});
Object.defineProperty(exports, 'fromCodePoint', {
  enumerable: true,
  get: function get() {
    return _cssLineBreak.fromCodePoint;
  }
});

var _NodeContainer = require('./NodeContainer');

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _overflowWrap = require('./parsing/overflowWrap');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var breakWords = exports.breakWords = function breakWords(str, parent) {
  var breaker = (0, _cssLineBreak.LineBreaker)(str, {
    lineBreak: parent.style.lineBreak,
    wordBreak: parent.style.overflowWrap === _overflowWrap.OVERFLOW_WRAP.BREAK_WORD ? 'break-word' : parent.style.wordBreak
  });
  var words = [];
  var bk = void 0;

  while (!(bk = breaker.next()).done) {
    words.push(bk.value.slice());
  }

  return words;
};
},{"css-line-break":"eYU0","./NodeContainer":"aCnv","./parsing/overflowWrap":"5D+K"}],"hsrb":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTextBounds = exports.TextBounds = undefined;

var _Bounds = require('./Bounds');

var _textDecoration = require('./parsing/textDecoration');

var _Feature = require('./Feature');

var _Feature2 = _interopRequireDefault(_Feature);

var _Unicode = require('./Unicode');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var TextBounds = exports.TextBounds = function TextBounds(text, bounds) {
  _classCallCheck(this, TextBounds);

  this.text = text;
  this.bounds = bounds;
};

var parseTextBounds = exports.parseTextBounds = function parseTextBounds(value, parent, node) {
  var letterRendering = parent.style.letterSpacing !== 0;
  var textList = letterRendering ? (0, _Unicode.toCodePoints)(value).map(function (i) {
    return (0, _Unicode.fromCodePoint)(i);
  }) : (0, _Unicode.breakWords)(value, parent);
  var length = textList.length;
  var defaultView = node.parentNode ? node.parentNode.ownerDocument.defaultView : null;
  var scrollX = defaultView ? defaultView.pageXOffset : 0;
  var scrollY = defaultView ? defaultView.pageYOffset : 0;
  var textBounds = [];
  var offset = 0;

  for (var i = 0; i < length; i++) {
    var text = textList[i];

    if (parent.style.textDecoration !== _textDecoration.TEXT_DECORATION.NONE || text.trim().length > 0) {
      if (_Feature2.default.SUPPORT_RANGE_BOUNDS) {
        textBounds.push(new TextBounds(text, getRangeBounds(node, offset, text.length, scrollX, scrollY)));
      } else {
        var replacementNode = node.splitText(text.length);
        textBounds.push(new TextBounds(text, getWrapperBounds(node, scrollX, scrollY)));
        node = replacementNode;
      }
    } else if (!_Feature2.default.SUPPORT_RANGE_BOUNDS) {
      node = node.splitText(text.length);
    }

    offset += text.length;
  }

  return textBounds;
};

var getWrapperBounds = function getWrapperBounds(node, scrollX, scrollY) {
  var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
  wrapper.appendChild(node.cloneNode(true));
  var parentNode = node.parentNode;

  if (parentNode) {
    parentNode.replaceChild(wrapper, node);
    var bounds = (0, _Bounds.parseBounds)(wrapper, scrollX, scrollY);

    if (wrapper.firstChild) {
      parentNode.replaceChild(wrapper.firstChild, wrapper);
    }

    return bounds;
  }

  return new _Bounds.Bounds(0, 0, 0, 0);
};

var getRangeBounds = function getRangeBounds(node, offset, length, scrollX, scrollY) {
  var range = node.ownerDocument.createRange();
  range.setStart(node, offset);
  range.setEnd(node, offset + length);
  return _Bounds.Bounds.fromClientRect(range.getBoundingClientRect(), scrollX, scrollY);
};
},{"./Bounds":"0S3x","./parsing/textDecoration":"37pw","./Feature":"iLjs","./Unicode":"YXY6"}],"0xF8":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _textTransform = require('./parsing/textTransform');

var _TextBounds = require('./TextBounds');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var TextContainer = function () {
  function TextContainer(text, parent, bounds) {
    _classCallCheck(this, TextContainer);

    this.text = text;
    this.parent = parent;
    this.bounds = bounds;
  }

  _createClass(TextContainer, null, [{
    key: 'fromTextNode',
    value: function fromTextNode(node, parent) {
      var text = transform(node.data, parent.style.textTransform);
      return new TextContainer(text, parent, (0, _TextBounds.parseTextBounds)(text, parent, node));
    }
  }]);

  return TextContainer;
}();

exports.default = TextContainer;
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;

var transform = function transform(text, _transform) {
  switch (_transform) {
    case _textTransform.TEXT_TRANSFORM.LOWERCASE:
      return text.toLowerCase();

    case _textTransform.TEXT_TRANSFORM.CAPITALIZE:
      return text.replace(CAPITALIZE, capitalize);

    case _textTransform.TEXT_TRANSFORM.UPPERCASE:
      return text.toUpperCase();

    default:
      return text;
  }
};

function capitalize(m, p1, p2) {
  if (m.length > 0) {
    return p1 + p2.toUpperCase();
  }

  return m;
}
},{"./parsing/textTransform":"Qy+a","./TextBounds":"hsrb"}],"PBaV":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Path = require('./Path');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Circle = function Circle(x, y, radius) {
  _classCallCheck(this, Circle);

  this.type = _Path.PATH.CIRCLE;
  this.x = x;
  this.y = y;
  this.radius = radius;

  if ("production" !== 'production') {
    if (isNaN(x)) {
      console.error('Invalid x value given for Circle');
    }

    if (isNaN(y)) {
      console.error('Invalid y value given for Circle');
    }

    if (isNaN(radius)) {
      console.error('Invalid radius value given for Circle');
    }
  }
};

exports.default = Circle;
},{"./Path":"Qq+a"}],"akgg":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reformatInputBounds = exports.inlineSelectElement = exports.inlineTextAreaElement = exports.inlineInputElement = exports.getInputBorderRadius = exports.INPUT_BACKGROUND = exports.INPUT_BORDERS = exports.INPUT_COLOR = undefined;

var _TextContainer = require('./TextContainer');

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _background = require('./parsing/background');

var _border = require('./parsing/border');

var _Circle = require('./drawing/Circle');

var _Circle2 = _interopRequireDefault(_Circle);

var _Vector = require('./drawing/Vector');

var _Vector2 = _interopRequireDefault(_Vector);

var _Color = require('./Color');

var _Color2 = _interopRequireDefault(_Color);

var _Length = require('./Length');

var _Length2 = _interopRequireDefault(_Length);

var _Bounds = require('./Bounds');

var _TextBounds = require('./TextBounds');

var _Util = require('./Util');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var INPUT_COLOR = exports.INPUT_COLOR = new _Color2.default([42, 42, 42]);
var INPUT_BORDER_COLOR = new _Color2.default([165, 165, 165]);
var INPUT_BACKGROUND_COLOR = new _Color2.default([222, 222, 222]);
var INPUT_BORDER = {
  borderWidth: 1,
  borderColor: INPUT_BORDER_COLOR,
  borderStyle: _border.BORDER_STYLE.SOLID
};
var INPUT_BORDERS = exports.INPUT_BORDERS = [INPUT_BORDER, INPUT_BORDER, INPUT_BORDER, INPUT_BORDER];
var INPUT_BACKGROUND = exports.INPUT_BACKGROUND = {
  backgroundColor: INPUT_BACKGROUND_COLOR,
  backgroundImage: [],
  backgroundClip: _background.BACKGROUND_CLIP.PADDING_BOX,
  backgroundOrigin: _background.BACKGROUND_ORIGIN.PADDING_BOX
};
var RADIO_BORDER_RADIUS = new _Length2.default('50%');
var RADIO_BORDER_RADIUS_TUPLE = [RADIO_BORDER_RADIUS, RADIO_BORDER_RADIUS];
var INPUT_RADIO_BORDER_RADIUS = [RADIO_BORDER_RADIUS_TUPLE, RADIO_BORDER_RADIUS_TUPLE, RADIO_BORDER_RADIUS_TUPLE, RADIO_BORDER_RADIUS_TUPLE];
var CHECKBOX_BORDER_RADIUS = new _Length2.default('3px');
var CHECKBOX_BORDER_RADIUS_TUPLE = [CHECKBOX_BORDER_RADIUS, CHECKBOX_BORDER_RADIUS];
var INPUT_CHECKBOX_BORDER_RADIUS = [CHECKBOX_BORDER_RADIUS_TUPLE, CHECKBOX_BORDER_RADIUS_TUPLE, CHECKBOX_BORDER_RADIUS_TUPLE, CHECKBOX_BORDER_RADIUS_TUPLE];

var getInputBorderRadius = exports.getInputBorderRadius = function getInputBorderRadius(node) {
  return node.type === 'radio' ? INPUT_RADIO_BORDER_RADIUS : INPUT_CHECKBOX_BORDER_RADIUS;
};

var inlineInputElement = exports.inlineInputElement = function inlineInputElement(node, container) {
  if (node.type === 'radio' || node.type === 'checkbox') {
    if (node.checked) {
      var size = Math.min(container.bounds.width, container.bounds.height);
      container.childNodes.push(node.type === 'checkbox' ? [new _Vector2.default(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79), new _Vector2.default(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549), new _Vector2.default(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071), new _Vector2.default(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649), new _Vector2.default(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23), new _Vector2.default(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085), new _Vector2.default(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)] : new _Circle2.default(container.bounds.left + size / 4, container.bounds.top + size / 4, size / 4));
    }
  } else {
    inlineFormElement(getInputValue(node), node, container, false);
  }
};

var inlineTextAreaElement = exports.inlineTextAreaElement = function inlineTextAreaElement(node, container) {
  inlineFormElement(node.value, node, container, true);
};

var inlineSelectElement = exports.inlineSelectElement = function inlineSelectElement(node, container) {
  var option = node.options[node.selectedIndex || 0];
  inlineFormElement(option ? option.text || '' : '', node, container, false);
};

var reformatInputBounds = exports.reformatInputBounds = function reformatInputBounds(bounds) {
  if (bounds.width > bounds.height) {
    bounds.left += (bounds.width - bounds.height) / 2;
    bounds.width = bounds.height;
  } else if (bounds.width < bounds.height) {
    bounds.top += (bounds.height - bounds.width) / 2;
    bounds.height = bounds.width;
  }

  return bounds;
};

var inlineFormElement = function inlineFormElement(value, node, container, allowLinebreak) {
  var body = node.ownerDocument.body;

  if (value.length > 0 && body) {
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    (0, _Util.copyCSSStyles)(node.ownerDocument.defaultView.getComputedStyle(node, null), wrapper);
    wrapper.style.position = 'absolute';
    wrapper.style.left = container.bounds.left + 'px';
    wrapper.style.top = container.bounds.top + 'px';

    if (!allowLinebreak) {
      wrapper.style.whiteSpace = 'nowrap';
    }

    var text = node.ownerDocument.createTextNode(value);
    wrapper.appendChild(text);
    body.appendChild(wrapper);
    container.childNodes.push(_TextContainer2.default.fromTextNode(text, container));
    body.removeChild(wrapper);
  }
};

var getInputValue = function getInputValue(node) {
  var value = node.type === 'password' ? new Array(node.value.length + 1).join("\u2022") : node.value;
  return value.length === 0 ? node.placeholder || '' : value;
};
},{"./TextContainer":"0xF8","./parsing/background":"mnnN","./parsing/border":"DyH5","./drawing/Circle":"PBaV","./drawing/Vector":"FP3Z","./Color":"IvPj","./Length":"21CJ","./Bounds":"0S3x","./TextBounds":"hsrb","./Util":"RUru"}],"+cR8":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCounterText = exports.inlineListItemElement = exports.getListOwner = undefined;

var _Util = require('./Util');

var _NodeContainer = require('./NodeContainer');

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _TextContainer = require('./TextContainer');

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _listStyle = require('./parsing/listStyle');

var _Unicode = require('./Unicode');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
} // Margin between the enumeration and the list item content


var MARGIN_RIGHT = 7;
var ancestorTypes = ['OL', 'UL', 'MENU'];

var getListOwner = exports.getListOwner = function getListOwner(container) {
  var parent = container.parent;

  if (!parent) {
    return null;
  }

  do {
    var isAncestor = ancestorTypes.indexOf(parent.tagName) !== -1;

    if (isAncestor) {
      return parent;
    }

    parent = parent.parent;
  } while (parent);

  return container.parent;
};

var inlineListItemElement = exports.inlineListItemElement = function inlineListItemElement(node, container, resourceLoader) {
  var listStyle = container.style.listStyle;

  if (!listStyle) {
    return;
  }

  var style = node.ownerDocument.defaultView.getComputedStyle(node, null);
  var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
  (0, _Util.copyCSSStyles)(style, wrapper);
  wrapper.style.position = 'absolute';
  wrapper.style.bottom = 'auto';
  wrapper.style.display = 'block';
  wrapper.style.letterSpacing = 'normal';

  switch (listStyle.listStylePosition) {
    case _listStyle.LIST_STYLE_POSITION.OUTSIDE:
      wrapper.style.left = 'auto';
      wrapper.style.right = node.ownerDocument.defaultView.innerWidth - container.bounds.left - container.style.margin[1].getAbsoluteValue(container.bounds.width) + MARGIN_RIGHT + 'px';
      wrapper.style.textAlign = 'right';
      break;

    case _listStyle.LIST_STYLE_POSITION.INSIDE:
      wrapper.style.left = container.bounds.left - container.style.margin[3].getAbsoluteValue(container.bounds.width) + 'px';
      wrapper.style.right = 'auto';
      wrapper.style.textAlign = 'left';
      break;
  }

  var text = void 0;
  var MARGIN_TOP = container.style.margin[0].getAbsoluteValue(container.bounds.width);
  var styleImage = listStyle.listStyleImage;

  if (styleImage) {
    if (styleImage.method === 'url') {
      var image = node.ownerDocument.createElement('img');
      image.src = styleImage.args[0];
      wrapper.style.top = container.bounds.top - MARGIN_TOP + 'px';
      wrapper.style.width = 'auto';
      wrapper.style.height = 'auto';
      wrapper.appendChild(image);
    } else {
      var size = parseFloat(container.style.font.fontSize) * 0.5;
      wrapper.style.top = container.bounds.top - MARGIN_TOP + container.bounds.height - 1.5 * size + 'px';
      wrapper.style.width = size + 'px';
      wrapper.style.height = size + 'px';
      wrapper.style.backgroundImage = style.listStyleImage;
    }
  } else if (typeof container.listIndex === 'number') {
    text = node.ownerDocument.createTextNode(createCounterText(container.listIndex, listStyle.listStyleType, true));
    wrapper.appendChild(text);
    wrapper.style.top = container.bounds.top - MARGIN_TOP + 'px';
  } // $FlowFixMe


  var body = node.ownerDocument.body;
  body.appendChild(wrapper);

  if (text) {
    container.childNodes.push(_TextContainer2.default.fromTextNode(text, container));
    body.removeChild(wrapper);
  } else {
    // $FlowFixMe
    container.childNodes.push(new _NodeContainer2.default(wrapper, container, resourceLoader, 0));
  }
};

var ROMAN_UPPER = {
  integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
};
var ARMENIAN = {
  integers: [9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
  values: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
};
var HEBREW = {
  integers: [10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
  values: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
};
var GEORGIAN = {
  integers: [10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
  values: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
};

var createAdditiveCounter = function createAdditiveCounter(value, min, max, symbols, fallback, suffix) {
  if (value < min || value > max) {
    return createCounterText(value, fallback, suffix.length > 0);
  }

  return symbols.integers.reduce(function (string, integer, index) {
    while (value >= integer) {
      value -= integer;
      string += symbols.values[index];
    }

    return string;
  }, '') + suffix;
};

var createCounterStyleWithSymbolResolver = function createCounterStyleWithSymbolResolver(value, codePointRangeLength, isNumeric, resolver) {
  var string = '';

  do {
    if (!isNumeric) {
      value--;
    }

    string = resolver(value) + string;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);

  return string;
};

var createCounterStyleFromRange = function createCounterStyleFromRange(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? '-' : '') + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
    return (0, _Unicode.fromCodePoint)(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};

var createCounterStyleFromSymbols = function createCounterStyleFromSymbols(value, symbols) {
  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '. ';
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};

var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;

var createCJKCounter = function createCJKCounter(value, numbers, multipliers, negativeSign, suffix, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, _listStyle.LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
  }

  var tmp = Math.abs(value);
  var string = suffix;

  if (tmp === 0) {
    return numbers[0] + string;
  }

  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;

    if (coefficient === 0 && (0, _Util.contains)(flags, CJK_ZEROS) && string !== '') {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && (0, _Util.contains)(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && (0, _Util.contains)(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && (0, _Util.contains)(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }

    tmp = Math.floor(tmp / 10);
  }

  return (value < 0 ? negativeSign : '') + string;
};

var CHINESE_INFORMAL_MULTIPLIERS = '';
var CHINESE_FORMAL_MULTIPLIERS = '';
var JAPANESE_NEGATIVE = '';
var KOREAN_NEGATIVE = ' ';

var createCounterText = exports.createCounterText = function createCounterText(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? '. ' : '';
  var cjkSuffix = appendSuffix ? '' : '';
  var koreanSuffix = appendSuffix ? ', ' : '';

  switch (type) {
    case _listStyle.LIST_STYLE_TYPE.DISC:
      return '';

    case _listStyle.LIST_STYLE_TYPE.CIRCLE:
      return '';

    case _listStyle.LIST_STYLE_TYPE.SQUARE:
      return '';

    case _listStyle.LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string.length < 4 ? '0' + string : string;

    case _listStyle.LIST_STYLE_TYPE.CJK_DECIMAL:
      return createCounterStyleFromSymbols(value, '', cjkSuffix);

    case _listStyle.LIST_STYLE_TYPE.LOWER_ROMAN:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();

    case _listStyle.LIST_STYLE_TYPE.UPPER_ROMAN:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.LOWER_GREEK:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.LOWER_ALPHA:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.UPPER_ALPHA:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.ARABIC_INDIC:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.ARMENIAN:
    case _listStyle.LIST_STYLE_TYPE.UPPER_ARMENIAN:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.LOWER_ARMENIAN:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();

    case _listStyle.LIST_STYLE_TYPE.BENGALI:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.CAMBODIAN:
    case _listStyle.LIST_STYLE_TYPE.KHMER:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
      return createCounterStyleFromSymbols(value, '', cjkSuffix);

    case _listStyle.LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
      return createCounterStyleFromSymbols(value, '', cjkSuffix);

    case _listStyle.LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
    case _listStyle.LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
      return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
      return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
      return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
      return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.JAPANESE_INFORMAL:
      return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, 0);

    case _listStyle.LIST_STYLE_TYPE.JAPANESE_FORMAL:
      return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
      return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
      return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, 0);

    case _listStyle.LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
      return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);

    case _listStyle.LIST_STYLE_TYPE.DEVANAGARI:
      return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.GEORGIAN:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.GUJARATI:
      return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.GURMUKHI:
      return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.HEBREW:
      return createAdditiveCounter(value, 1, 10999, HEBREW, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.HIRAGANA:
      return createCounterStyleFromSymbols(value, '');

    case _listStyle.LIST_STYLE_TYPE.HIRAGANA_IROHA:
      return createCounterStyleFromSymbols(value, '');

    case _listStyle.LIST_STYLE_TYPE.KANNADA:
      return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.KATAKANA:
      return createCounterStyleFromSymbols(value, '', cjkSuffix);

    case _listStyle.LIST_STYLE_TYPE.KATAKANA_IROHA:
      return createCounterStyleFromSymbols(value, '', cjkSuffix);

    case _listStyle.LIST_STYLE_TYPE.LAO:
      return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.MONGOLIAN:
      return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.MYANMAR:
      return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.ORIYA:
      return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.PERSIAN:
      return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.TAMIL:
      return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.TELUGU:
      return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.THAI:
      return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.TIBETAN:
      return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);

    case _listStyle.LIST_STYLE_TYPE.DECIMAL:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
},{"./Util":"RUru","./NodeContainer":"aCnv","./TextContainer":"0xF8","./parsing/listStyle":"9MRV","./Unicode":"YXY6"}],"aCnv":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Color = require('./Color');

var _Color2 = _interopRequireDefault(_Color);

var _Util = require('./Util');

var _background = require('./parsing/background');

var _border = require('./parsing/border');

var _borderRadius = require('./parsing/borderRadius');

var _display = require('./parsing/display');

var _float = require('./parsing/float');

var _font = require('./parsing/font');

var _letterSpacing = require('./parsing/letterSpacing');

var _lineBreak = require('./parsing/lineBreak');

var _listStyle = require('./parsing/listStyle');

var _margin = require('./parsing/margin');

var _overflow = require('./parsing/overflow');

var _overflowWrap = require('./parsing/overflowWrap');

var _padding = require('./parsing/padding');

var _position = require('./parsing/position');

var _textDecoration = require('./parsing/textDecoration');

var _textShadow = require('./parsing/textShadow');

var _textTransform = require('./parsing/textTransform');

var _transform = require('./parsing/transform');

var _visibility = require('./parsing/visibility');

var _wordBreak = require('./parsing/word-break');

var _zIndex = require('./parsing/zIndex');

var _Bounds = require('./Bounds');

var _Input = require('./Input');

var _ListItem = require('./ListItem');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];

var NodeContainer = function () {
  function NodeContainer(node, parent, resourceLoader, index) {
    var _this = this;

    _classCallCheck(this, NodeContainer);

    this.parent = parent;
    this.tagName = node.tagName;
    this.index = index;
    this.childNodes = [];
    this.listItems = [];

    if (typeof node.start === 'number') {
      this.listStart = node.start;
    }

    var defaultView = node.ownerDocument.defaultView;
    var scrollX = defaultView.pageXOffset;
    var scrollY = defaultView.pageYOffset;
    var style = defaultView.getComputedStyle(node, null);
    var display = (0, _display.parseDisplay)(style.display);
    var IS_INPUT = node.type === 'radio' || node.type === 'checkbox';
    var position = (0, _position.parsePosition)(style.position);
    this.style = {
      background: IS_INPUT ? _Input.INPUT_BACKGROUND : (0, _background.parseBackground)(style, resourceLoader),
      border: IS_INPUT ? _Input.INPUT_BORDERS : (0, _border.parseBorder)(style),
      borderRadius: (node instanceof defaultView.HTMLInputElement || node instanceof HTMLInputElement) && IS_INPUT ? (0, _Input.getInputBorderRadius)(node) : (0, _borderRadius.parseBorderRadius)(style),
      color: IS_INPUT ? _Input.INPUT_COLOR : new _Color2.default(style.color),
      display: display,
      float: (0, _float.parseCSSFloat)(style.float),
      font: (0, _font.parseFont)(style),
      letterSpacing: (0, _letterSpacing.parseLetterSpacing)(style.letterSpacing),
      listStyle: display === _display.DISPLAY.LIST_ITEM ? (0, _listStyle.parseListStyle)(style) : null,
      lineBreak: (0, _lineBreak.parseLineBreak)(style.lineBreak),
      margin: (0, _margin.parseMargin)(style),
      opacity: parseFloat(style.opacity),
      overflow: INPUT_TAGS.indexOf(node.tagName) === -1 ? (0, _overflow.parseOverflow)(style.overflow) : _overflow.OVERFLOW.HIDDEN,
      overflowWrap: (0, _overflowWrap.parseOverflowWrap)(style.overflowWrap ? style.overflowWrap : style.wordWrap),
      padding: (0, _padding.parsePadding)(style),
      position: position,
      textDecoration: (0, _textDecoration.parseTextDecoration)(style),
      textShadow: (0, _textShadow.parseTextShadow)(style.textShadow),
      textTransform: (0, _textTransform.parseTextTransform)(style.textTransform),
      transform: (0, _transform.parseTransform)(style),
      visibility: (0, _visibility.parseVisibility)(style.visibility),
      wordBreak: (0, _wordBreak.parseWordBreak)(style.wordBreak),
      zIndex: (0, _zIndex.parseZIndex)(position !== _position.POSITION.STATIC ? style.zIndex : 'auto')
    };

    if (this.isTransformed()) {
      // getBoundingClientRect provides values post-transform, we want them without the transformation
      node.style.transform = 'matrix(1,0,0,1,0,0)';
    }

    if (display === _display.DISPLAY.LIST_ITEM) {
      var listOwner = (0, _ListItem.getListOwner)(this);

      if (listOwner) {
        var listIndex = listOwner.listItems.length;
        listOwner.listItems.push(this);
        this.listIndex = node.hasAttribute('value') && typeof node.value === 'number' ? node.value : listIndex === 0 ? typeof listOwner.listStart === 'number' ? listOwner.listStart : 1 : listOwner.listItems[listIndex - 1].listIndex + 1;
      }
    } // TODO move bound retrieval for all nodes to a later stage?


    if (node.tagName === 'IMG') {
      node.addEventListener('load', function () {
        _this.bounds = (0, _Bounds.parseBounds)(node, scrollX, scrollY);
        _this.curvedBounds = (0, _Bounds.parseBoundCurves)(_this.bounds, _this.style.border, _this.style.borderRadius);
      });
    }

    this.image = getImage(node, resourceLoader);
    this.bounds = IS_INPUT ? (0, _Input.reformatInputBounds)((0, _Bounds.parseBounds)(node, scrollX, scrollY)) : (0, _Bounds.parseBounds)(node, scrollX, scrollY);
    this.curvedBounds = (0, _Bounds.parseBoundCurves)(this.bounds, this.style.border, this.style.borderRadius);

    if ("production" !== 'production') {
      this.name = '' + node.tagName.toLowerCase() + (node.id ? '#' + node.id : '') + node.className.toString().split(' ').map(function (s) {
        return s.length ? '.' + s : '';
      }).join('');
    }
  }

  _createClass(NodeContainer, [{
    key: 'getClipPaths',
    value: function getClipPaths() {
      var parentClips = this.parent ? this.parent.getClipPaths() : [];
      var isClipped = this.style.overflow !== _overflow.OVERFLOW.VISIBLE;
      return isClipped ? parentClips.concat([(0, _Bounds.calculatePaddingBoxPath)(this.curvedBounds)]) : parentClips;
    }
  }, {
    key: 'isInFlow',
    value: function isInFlow() {
      return this.isRootElement() && !this.isFloating() && !this.isAbsolutelyPositioned();
    }
  }, {
    key: 'isVisible',
    value: function isVisible() {
      return !(0, _Util.contains)(this.style.display, _display.DISPLAY.NONE) && this.style.opacity > 0 && this.style.visibility === _visibility.VISIBILITY.VISIBLE;
    }
  }, {
    key: 'isAbsolutelyPositioned',
    value: function isAbsolutelyPositioned() {
      return this.style.position !== _position.POSITION.STATIC && this.style.position !== _position.POSITION.RELATIVE;
    }
  }, {
    key: 'isPositioned',
    value: function isPositioned() {
      return this.style.position !== _position.POSITION.STATIC;
    }
  }, {
    key: 'isFloating',
    value: function isFloating() {
      return this.style.float !== _float.FLOAT.NONE;
    }
  }, {
    key: 'isRootElement',
    value: function isRootElement() {
      return this.parent === null;
    }
  }, {
    key: 'isTransformed',
    value: function isTransformed() {
      return this.style.transform !== null;
    }
  }, {
    key: 'isPositionedWithZIndex',
    value: function isPositionedWithZIndex() {
      return this.isPositioned() && !this.style.zIndex.auto;
    }
  }, {
    key: 'isInlineLevel',
    value: function isInlineLevel() {
      return (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_BLOCK) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_FLEX) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_GRID) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_LIST_ITEM) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_TABLE);
    }
  }, {
    key: 'isInlineBlockOrInlineTable',
    value: function isInlineBlockOrInlineTable() {
      return (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_BLOCK) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_TABLE);
    }
  }]);

  return NodeContainer;
}();

exports.default = NodeContainer;

var getImage = function getImage(node, resourceLoader) {
  if (node instanceof node.ownerDocument.defaultView.SVGSVGElement || node instanceof SVGSVGElement) {
    var s = new XMLSerializer();
    return resourceLoader.loadImage('data:image/svg+xml,' + encodeURIComponent(s.serializeToString(node)));
  }

  switch (node.tagName) {
    case 'IMG':
      // $FlowFixMe
      var img = node;
      return resourceLoader.loadImage(img.currentSrc || img.src);

    case 'CANVAS':
      // $FlowFixMe
      var canvas = node;
      return resourceLoader.loadCanvas(canvas);

    case 'IFRAME':
      var iframeKey = node.getAttribute('data-html2canvas-internal-iframe-key');

      if (iframeKey) {
        return iframeKey;
      }

      break;
  }

  return null;
};
},{"./Color":"IvPj","./Util":"RUru","./parsing/background":"mnnN","./parsing/border":"DyH5","./parsing/borderRadius":"RaWo","./parsing/display":"LzdE","./parsing/float":"sC4M","./parsing/font":"OsIM","./parsing/letterSpacing":"gatk","./parsing/lineBreak":"dXkp","./parsing/listStyle":"9MRV","./parsing/margin":"E76M","./parsing/overflow":"mAuW","./parsing/overflowWrap":"5D+K","./parsing/padding":"xKfD","./parsing/position":"JuyM","./parsing/textDecoration":"37pw","./parsing/textShadow":"O3Tr","./parsing/textTransform":"Qy+a","./parsing/transform":"gqmU","./parsing/visibility":"yETD","./parsing/word-break":"O7NJ","./parsing/zIndex":"jGiM","./Bounds":"0S3x","./Input":"akgg","./ListItem":"+cR8"}],"plqL":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _NodeContainer = require('./NodeContainer');

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _position = require('./parsing/position');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var StackingContext = function () {
  function StackingContext(container, parent, treatAsRealStackingContext) {
    _classCallCheck(this, StackingContext);

    this.container = container;
    this.parent = parent;
    this.contexts = [];
    this.children = [];
    this.treatAsRealStackingContext = treatAsRealStackingContext;
  }

  _createClass(StackingContext, [{
    key: 'getOpacity',
    value: function getOpacity() {
      return this.parent ? this.container.style.opacity * this.parent.getOpacity() : this.container.style.opacity;
    }
  }, {
    key: 'getRealParentStackingContext',
    value: function getRealParentStackingContext() {
      return !this.parent || this.treatAsRealStackingContext ? this : this.parent.getRealParentStackingContext();
    }
  }]);

  return StackingContext;
}();

exports.default = StackingContext;
},{"./NodeContainer":"aCnv","./parsing/position":"JuyM"}],"Ce85":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeParser = undefined;

var _StackingContext = require('./StackingContext');

var _StackingContext2 = _interopRequireDefault(_StackingContext);

var _NodeContainer = require('./NodeContainer');

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _TextContainer = require('./TextContainer');

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _Input = require('./Input');

var _ListItem = require('./ListItem');

var _listStyle = require('./parsing/listStyle');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var NodeParser = exports.NodeParser = function NodeParser(node, resourceLoader, logger) {
  if ("production" !== 'production') {
    logger.log('Starting node parsing');
  }

  var index = 0;
  var container = new _NodeContainer2.default(node, null, resourceLoader, index++);
  var stack = new _StackingContext2.default(container, null, true);
  parseNodeTree(node, container, stack, resourceLoader, index);

  if ("production" !== 'production') {
    logger.log('Finished parsing node tree');
  }

  return stack;
};

var IGNORED_NODE_NAMES = ['SCRIPT', 'HEAD', 'TITLE', 'OBJECT', 'BR', 'OPTION'];

var parseNodeTree = function parseNodeTree(node, parent, stack, resourceLoader, index) {
  if ("production" !== 'production' && index > 50000) {
    throw new Error('Recursion error while parsing node tree');
  }

  for (var childNode = node.firstChild, nextNode; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    var defaultView = childNode.ownerDocument.defaultView;

    if (childNode instanceof defaultView.Text || childNode instanceof Text || defaultView.parent && childNode instanceof defaultView.parent.Text) {
      if (childNode.data.trim().length > 0) {
        parent.childNodes.push(_TextContainer2.default.fromTextNode(childNode, parent));
      }
    } else if (childNode instanceof defaultView.HTMLElement || childNode instanceof HTMLElement || defaultView.parent && childNode instanceof defaultView.parent.HTMLElement) {
      if (IGNORED_NODE_NAMES.indexOf(childNode.nodeName) === -1) {
        var container = new _NodeContainer2.default(childNode, parent, resourceLoader, index++);

        if (container.isVisible()) {
          if (childNode.tagName === 'INPUT') {
            // $FlowFixMe
            (0, _Input.inlineInputElement)(childNode, container);
          } else if (childNode.tagName === 'TEXTAREA') {
            // $FlowFixMe
            (0, _Input.inlineTextAreaElement)(childNode, container);
          } else if (childNode.tagName === 'SELECT') {
            // $FlowFixMe
            (0, _Input.inlineSelectElement)(childNode, container);
          } else if (container.style.listStyle && container.style.listStyle.listStyleType !== _listStyle.LIST_STYLE_TYPE.NONE) {
            (0, _ListItem.inlineListItemElement)(childNode, container, resourceLoader);
          }

          var SHOULD_TRAVERSE_CHILDREN = childNode.tagName !== 'TEXTAREA';
          var treatAsRealStackingContext = createsRealStackingContext(container, childNode);

          if (treatAsRealStackingContext || createsStackingContext(container)) {
            // for treatAsRealStackingContext:false, any positioned descendants and descendants
            // which actually create a new stacking context should be considered part of the parent stacking context
            var parentStack = treatAsRealStackingContext || container.isPositioned() ? stack.getRealParentStackingContext() : stack;
            var childStack = new _StackingContext2.default(container, parentStack, treatAsRealStackingContext);
            parentStack.contexts.push(childStack);

            if (SHOULD_TRAVERSE_CHILDREN) {
              parseNodeTree(childNode, container, childStack, resourceLoader, index);
            }
          } else {
            stack.children.push(container);

            if (SHOULD_TRAVERSE_CHILDREN) {
              parseNodeTree(childNode, container, stack, resourceLoader, index);
            }
          }
        }
      }
    } else if (childNode instanceof defaultView.SVGSVGElement || childNode instanceof SVGSVGElement || defaultView.parent && childNode instanceof defaultView.parent.SVGSVGElement) {
      var _container = new _NodeContainer2.default(childNode, parent, resourceLoader, index++);

      var _treatAsRealStackingContext = createsRealStackingContext(_container, childNode);

      if (_treatAsRealStackingContext || createsStackingContext(_container)) {
        // for treatAsRealStackingContext:false, any positioned descendants and descendants
        // which actually create a new stacking context should be considered part of the parent stacking context
        var _parentStack = _treatAsRealStackingContext || _container.isPositioned() ? stack.getRealParentStackingContext() : stack;

        var _childStack = new _StackingContext2.default(_container, _parentStack, _treatAsRealStackingContext);

        _parentStack.contexts.push(_childStack);
      } else {
        stack.children.push(_container);
      }
    }
  }
};

var createsRealStackingContext = function createsRealStackingContext(container, node) {
  return container.isRootElement() || container.isPositionedWithZIndex() || container.style.opacity < 1 || container.isTransformed() || isBodyWithTransparentRoot(container, node);
};

var createsStackingContext = function createsStackingContext(container) {
  return container.isPositioned() || container.isFloating();
};

var isBodyWithTransparentRoot = function isBodyWithTransparentRoot(container, node) {
  return node.nodeName === 'BODY' && container.parent instanceof _NodeContainer2.default && container.parent.style.background.backgroundColor.isTransparent();
};
},{"./StackingContext":"plqL","./NodeContainer":"aCnv","./TextContainer":"0xF8","./Input":"akgg","./ListItem":"+cR8","./parsing/listStyle":"9MRV"}],"pRhb":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FontMetrics = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Util = require('./Util');

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var SAMPLE_TEXT = 'Hidden Text';

var FontMetrics = exports.FontMetrics = function () {
  function FontMetrics(document) {
    _classCallCheck(this, FontMetrics);

    this._data = {};
    this._document = document;
  }

  _createClass(FontMetrics, [{
    key: '_parseMetrics',
    value: function _parseMetrics(font) {
      var container = this._document.createElement('div');

      var img = this._document.createElement('img');

      var span = this._document.createElement('span');

      var body = this._document.body;

      if (!body) {
        throw new Error("production" !== 'production' ? 'No document found for font metrics' : '');
      }

      container.style.visibility = 'hidden';
      container.style.fontFamily = font.fontFamily;
      container.style.fontSize = font.fontSize;
      container.style.margin = '0';
      container.style.padding = '0';
      body.appendChild(container);
      img.src = _Util.SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = '0';
      img.style.padding = '0';
      img.style.verticalAlign = 'baseline';
      span.style.fontFamily = font.fontFamily;
      span.style.fontSize = font.fontSize;
      span.style.margin = '0';
      span.style.padding = '0';
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = 'normal';
      img.style.verticalAlign = 'super';
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return {
        baseline: baseline,
        middle: middle
      };
    }
  }, {
    key: 'getMetrics',
    value: function getMetrics(font) {
      var key = font.fontFamily + ' ' + font.fontSize;

      if (this._data[key] === undefined) {
        this._data[key] = this._parseMetrics(font);
      }

      return this._data[key];
    }
  }]);

  return FontMetrics;
}();
},{"./Util":"RUru"}],"aoYd":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var ANGLE = /([+-]?\d*\.?\d+)(deg|grad|rad|turn)/i;

var parseAngle = exports.parseAngle = function parseAngle(angle) {
  var match = angle.match(ANGLE);

  if (match) {
    var value = parseFloat(match[1]);

    switch (match[2].toLowerCase()) {
      case 'deg':
        return Math.PI * value / 180;

      case 'grad':
        return Math.PI / 200 * value;

      case 'rad':
        return value;

      case 'turn':
        return Math.PI * 2 * value;
    }
  }

  return null;
};
},{}],"YydK":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _NodeContainer = require('./NodeContainer');

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _Angle = require('./Angle');

var _Color = require('./Color');

var _Color2 = _interopRequireDefault(_Color);

var _Length = require('./Length');

var _Length2 = _interopRequireDefault(_Length);

var _Util = require('./Util');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;
var PERCENTAGE_ANGLES = /^([+-]?\d*\.?\d+)% ([+-]?\d*\.?\d+)%$/i;
var ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;
var FROM_TO_COLORSTOP = /^(from|to|color-stop)\((?:([\d.]+)(%)?,\s*)?(.+?)\)$/i;
var RADIAL_SHAPE_DEFINITION = /^\s*(circle|ellipse)?\s*((?:([\d.]+)(px|r?em|%)\s*(?:([\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\s*(?:at\s*(?:(left|center|right)|([\d.]+)(px|r?em|%))\s+(?:(top|center|bottom)|([\d.]+)(px|r?em|%)))?(?:\s|$)/i;
var GRADIENT_TYPE = exports.GRADIENT_TYPE = {
  LINEAR_GRADIENT: 0,
  RADIAL_GRADIENT: 1
};
var RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {
  CIRCLE: 0,
  ELLIPSE: 1
};
var LENGTH_FOR_POSITION = {
  left: new _Length2.default('0%'),
  top: new _Length2.default('0%'),
  center: new _Length2.default('50%'),
  right: new _Length2.default('100%'),
  bottom: new _Length2.default('100%')
};

var LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {
  _classCallCheck(this, LinearGradient);

  this.type = GRADIENT_TYPE.LINEAR_GRADIENT;
  this.colorStops = colorStops;
  this.direction = direction;
};

var RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {
  _classCallCheck(this, RadialGradient);

  this.type = GRADIENT_TYPE.RADIAL_GRADIENT;
  this.colorStops = colorStops;
  this.shape = shape;
  this.center = center;
  this.radius = radius;
};

var parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {
  var args = _ref.args,
      method = _ref.method,
      prefix = _ref.prefix;

  if (method === 'linear-gradient') {
    return parseLinearGradient(args, bounds, !!prefix);
  } else if (method === 'gradient' && args[0] === 'linear') {
    // TODO handle correct angle
    return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);
  } else if (method === 'radial-gradient') {
    return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);
  } else if (method === 'gradient' && args[0] === 'radial') {
    return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);
  }
};

var parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {
  var colorStops = [];

  for (var i = firstColorStopIndex; i < args.length; i++) {
    var value = args[i];
    var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);
    var lastSpaceIndex = value.lastIndexOf(' ');

    var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);

    var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;

    colorStops.push({
      color: _color,
      stop: _stop
    });
  }

  var absoluteValuedColorStops = colorStops.map(function (_ref2) {
    var color = _ref2.color,
        stop = _ref2.stop;
    var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;
    return {
      color: color,
      // $FlowFixMe
      stop: absoluteStop
    };
  });
  var previousColorStop = absoluteValuedColorStops[0].stop;

  for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {
    if (previousColorStop !== null) {
      var _stop2 = absoluteValuedColorStops[_i].stop;

      if (_stop2 === null) {
        var n = _i;

        while (absoluteValuedColorStops[n].stop === null) {
          n++;
        }

        var steps = n - _i + 1;
        var nextColorStep = absoluteValuedColorStops[n].stop;
        var stepSize = (nextColorStep - previousColorStop) / steps;

        for (; _i < n; _i++) {
          previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;
        }
      } else {
        previousColorStop = _stop2;
      }
    }
  }

  return absoluteValuedColorStops;
};

var parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {
  var angle = (0, _Angle.parseAngle)(args[0]);
  var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);
  var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);
  var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection( // if there is a prefix, the 0 angle points due East (instead of North per W3C)
  hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);
  var firstColorStopIndex = HAS_DIRECTION ? 1 : 0; // TODO: Fix some inaccuracy with color stops with px values

  var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);
  return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);
};

var parseRadialGradient = function parseRadialGradient(container, args, bounds) {
  var m = args[0].match(RADIAL_SHAPE_DEFINITION);
  var shape = m && (m[1] === 'circle' || // explicit shape specification
  m[3] !== undefined && m[5] === undefined) // only one radius coordinate
  ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;
  var radius = {};
  var center = {};

  if (m) {
    // Radius
    if (m[3] !== undefined) {
      radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);
    }

    if (m[5] !== undefined) {
      radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);
    } // Position


    if (m[7]) {
      center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];
    } else if (m[8] !== undefined) {
      center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);
    }

    if (m[10]) {
      center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];
    } else if (m[11] !== undefined) {
      center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);
    }
  }

  var gradientCenter = {
    x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),
    y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)
  };
  var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);
  return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);
};

var calculateGradientDirection = function calculateGradientDirection(radian, bounds) {
  var width = bounds.width;
  var height = bounds.height;
  var HALF_WIDTH = width * 0.5;
  var HALF_HEIGHT = height * 0.5;
  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var HALF_LINE_LENGTH = lineLength / 2;
  var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;
  var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;
  var x1 = width - x0;
  var y1 = height - y0;
  return {
    x0: x0,
    x1: x1,
    y0: y0,
    y1: y1
  };
};

var parseTopRight = function parseTopRight(bounds) {
  return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));
};

var parseSideOrCorner = function parseSideOrCorner(side, bounds) {
  switch (side) {
    case 'bottom':
    case 'to top':
      return calculateGradientDirection(0, bounds);

    case 'left':
    case 'to right':
      return calculateGradientDirection(Math.PI / 2, bounds);

    case 'right':
    case 'to left':
      return calculateGradientDirection(3 * Math.PI / 2, bounds);

    case 'top right':
    case 'right top':
    case 'to bottom left':
    case 'to left bottom':
      return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);

    case 'top left':
    case 'left top':
    case 'to bottom right':
    case 'to right bottom':
      return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);

    case 'bottom left':
    case 'left bottom':
    case 'to top right':
    case 'to right top':
      return calculateGradientDirection(parseTopRight(bounds), bounds);

    case 'bottom right':
    case 'right bottom':
    case 'to top left':
    case 'to left top':
      return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);

    case 'top':
    case 'to bottom':
    default:
      return calculateGradientDirection(Math.PI, bounds);
  }
};

var parsePercentageAngle = function parsePercentageAngle(angle, bounds) {
  var _angle$split$map = angle.split(' ').map(parseFloat),
      _angle$split$map2 = _slicedToArray(_angle$split$map, 2),
      left = _angle$split$map2[0],
      top = _angle$split$map2[1];

  var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);
  return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);
};

var findCorner = function findCorner(bounds, x, y, closest) {
  var corners = [{
    x: 0,
    y: 0
  }, {
    x: 0,
    y: bounds.height
  }, {
    x: bounds.width,
    y: 0
  }, {
    x: bounds.width,
    y: bounds.height
  }]; // $FlowFixMe

  return corners.reduce(function (stat, corner) {
    var d = (0, _Util.distance)(x - corner.x, y - corner.y);

    if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d
      };
    }

    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};

var calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {
  var x = center.x;
  var y = center.y;
  var rx = 0;
  var ry = 0;

  switch (extent) {
    case 'closest-side':
      // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradients center.
      // If the shape is an ellipse, it exactly meets the closest side in each dimension.
      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
        rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));
      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
        rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));
        ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));
      }

      break;

    case 'closest-corner':
      // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradients center.
      // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
        rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));
      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
        // Compute the ratio ry/rx (which is to be the same as for "closest-side")
        var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));
        var corner = findCorner(bounds, x, y, true);
        rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);
        ry = c * rx;
      }

      break;

    case 'farthest-side':
      // Same as closest-side, except the ending shape is sized based on the farthest side(s)
      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
        rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));
      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
        rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));
        ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));
      }

      break;

    case 'farthest-corner':
      // Same as closest-corner, except the ending shape is sized based on the farthest corner.
      // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
        rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));
      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
        // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
        var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));

        var _corner = findCorner(bounds, x, y, false);

        rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);
        ry = _c * rx;
      }

      break;

    default:
      // pixel or percentage values
      rx = radius.x || 0;
      ry = radius.y !== undefined ? radius.y : rx;
      break;
  }

  return {
    x: rx,
    y: ry
  };
};

var transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {
  var shape = '';
  var radius = '';
  var extent = '';
  var position = '';
  var idx = 0;
  var POSITION = /^(left|center|right|\d+(?:px|r?em|%)?)(?:\s+(top|center|bottom|\d+(?:px|r?em|%)?))?$/i;
  var SHAPE_AND_EXTENT = /^(circle|ellipse)?\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;
  var RADIUS = /^\d+(px|r?em|%)?(?:\s+\d+(px|r?em|%)?)?$/i;
  var matchStartPosition = args[idx].match(POSITION);

  if (matchStartPosition) {
    idx++;
  }

  var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);

  if (matchShapeExtent) {
    shape = matchShapeExtent[1] || '';
    extent = matchShapeExtent[2] || '';

    if (extent === 'contain') {
      extent = 'closest-side';
    } else if (extent === 'cover') {
      extent = 'farthest-corner';
    }

    idx++;
  }

  var matchStartRadius = args[idx].match(RADIUS);

  if (matchStartRadius) {
    idx++;
  }

  var matchEndPosition = args[idx].match(POSITION);

  if (matchEndPosition) {
    idx++;
  }

  var matchEndRadius = args[idx].match(RADIUS);

  if (matchEndRadius) {
    idx++;
  }

  var matchPosition = matchEndPosition || matchStartPosition;

  if (matchPosition && matchPosition[1]) {
    position = matchPosition[1] + (/^\d+$/.test(matchPosition[1]) ? 'px' : '');

    if (matchPosition[2]) {
      position += ' ' + matchPosition[2] + (/^\d+$/.test(matchPosition[2]) ? 'px' : '');
    }
  }

  var matchRadius = matchEndRadius || matchStartRadius;

  if (matchRadius) {
    radius = matchRadius[0];

    if (!matchRadius[1]) {
      radius += 'px';
    }
  }

  if (position && !shape && !radius && !extent) {
    radius = position;
    position = '';
  }

  if (position) {
    position = 'at ' + position;
  }

  return [[shape, extent, radius, position].filter(function (s) {
    return !!s;
  }).join(' ')].concat(args.slice(idx));
};

var transformObsoleteColorStops = function transformObsoleteColorStops(args) {
  return args.map(function (color) {
    return color.match(FROM_TO_COLORSTOP);
  }) // $FlowFixMe
  .map(function (v, index) {
    if (!v) {
      return args[index];
    }

    switch (v[1]) {
      case 'from':
        return v[4] + ' 0%';

      case 'to':
        return v[4] + ' 100%';

      case 'color-stop':
        if (v[3] === '%') {
          return v[4] + ' ' + v[2];
        }

        return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';
    }
  });
};
},{"./NodeContainer":"aCnv","./Angle":"aoYd","./Color":"IvPj","./Length":"21CJ","./Util":"RUru"}],"g+e5":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Bounds = require('./Bounds');

var _Font = require('./Font');

var _Gradient = require('./Gradient');

var _TextContainer = require('./TextContainer');

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _background = require('./parsing/background');

var _border = require('./parsing/border');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Renderer = function () {
  function Renderer(target, options) {
    _classCallCheck(this, Renderer);

    this.target = target;
    this.options = options;
    target.render(options);
  }

  _createClass(Renderer, [{
    key: 'renderNode',
    value: function renderNode(container) {
      if (container.isVisible()) {
        this.renderNodeBackgroundAndBorders(container);
        this.renderNodeContent(container);
      }
    }
  }, {
    key: 'renderNodeContent',
    value: function renderNodeContent(container) {
      var _this = this;

      var callback = function callback() {
        if (container.childNodes.length) {
          container.childNodes.forEach(function (child) {
            if (child instanceof _TextContainer2.default) {
              var style = child.parent.style;

              _this.target.renderTextNode(child.bounds, style.color, style.font, style.textDecoration, style.textShadow);
            } else {
              _this.target.drawShape(child, container.style.color);
            }
          });
        }

        if (container.image) {
          var _image = _this.options.imageStore.get(container.image);

          if (_image) {
            var contentBox = (0, _Bounds.calculateContentBox)(container.bounds, container.style.padding, container.style.border);

            var _width = typeof _image.width === 'number' && _image.width > 0 ? _image.width : contentBox.width;

            var _height = typeof _image.height === 'number' && _image.height > 0 ? _image.height : contentBox.height;

            if (_width > 0 && _height > 0) {
              _this.target.clip([(0, _Bounds.calculatePaddingBoxPath)(container.curvedBounds)], function () {
                _this.target.drawImage(_image, new _Bounds.Bounds(0, 0, _width, _height), contentBox);
              });
            }
          }
        }
      };

      var paths = container.getClipPaths();

      if (paths.length) {
        this.target.clip(paths, callback);
      } else {
        callback();
      }
    }
  }, {
    key: 'renderNodeBackgroundAndBorders',
    value: function renderNodeBackgroundAndBorders(container) {
      var _this2 = this;

      var HAS_BACKGROUND = !container.style.background.backgroundColor.isTransparent() || container.style.background.backgroundImage.length;
      var hasRenderableBorders = container.style.border.some(function (border) {
        return border.borderStyle !== _border.BORDER_STYLE.NONE && !border.borderColor.isTransparent();
      });

      var callback = function callback() {
        var backgroundPaintingArea = (0, _background.calculateBackgroungPaintingArea)(container.curvedBounds, container.style.background.backgroundClip);

        if (HAS_BACKGROUND) {
          _this2.target.clip([backgroundPaintingArea], function () {
            if (!container.style.background.backgroundColor.isTransparent()) {
              _this2.target.fill(container.style.background.backgroundColor);
            }

            _this2.renderBackgroundImage(container);
          });
        }

        container.style.border.forEach(function (border, side) {
          if (border.borderStyle !== _border.BORDER_STYLE.NONE && !border.borderColor.isTransparent()) {
            _this2.renderBorder(border, side, container.curvedBounds);
          }
        });
      };

      if (HAS_BACKGROUND || hasRenderableBorders) {
        var paths = container.parent ? container.parent.getClipPaths() : [];

        if (paths.length) {
          this.target.clip(paths, callback);
        } else {
          callback();
        }
      }
    }
  }, {
    key: 'renderBackgroundImage',
    value: function renderBackgroundImage(container) {
      var _this3 = this;

      container.style.background.backgroundImage.slice(0).reverse().forEach(function (backgroundImage) {
        if (backgroundImage.source.method === 'url' && backgroundImage.source.args.length) {
          _this3.renderBackgroundRepeat(container, backgroundImage);
        } else if (/gradient/i.test(backgroundImage.source.method)) {
          _this3.renderBackgroundGradient(container, backgroundImage);
        }
      });
    }
  }, {
    key: 'renderBackgroundRepeat',
    value: function renderBackgroundRepeat(container, background) {
      var image = this.options.imageStore.get(background.source.args[0]);

      if (image) {
        var backgroundPositioningArea = (0, _background.calculateBackgroungPositioningArea)(container.style.background.backgroundOrigin, container.bounds, container.style.padding, container.style.border);
        var backgroundImageSize = (0, _background.calculateBackgroundSize)(background, image, backgroundPositioningArea);
        var position = (0, _background.calculateBackgroundPosition)(background.position, backgroundImageSize, backgroundPositioningArea);

        var _path = (0, _background.calculateBackgroundRepeatPath)(background, position, backgroundImageSize, backgroundPositioningArea, container.bounds);

        var _offsetX = Math.round(backgroundPositioningArea.left + position.x);

        var _offsetY = Math.round(backgroundPositioningArea.top + position.y);

        this.target.renderRepeat(_path, image, backgroundImageSize, _offsetX, _offsetY);
      }
    }
  }, {
    key: 'renderBackgroundGradient',
    value: function renderBackgroundGradient(container, background) {
      var backgroundPositioningArea = (0, _background.calculateBackgroungPositioningArea)(container.style.background.backgroundOrigin, container.bounds, container.style.padding, container.style.border);
      var backgroundImageSize = (0, _background.calculateGradientBackgroundSize)(background, backgroundPositioningArea);
      var position = (0, _background.calculateBackgroundPosition)(background.position, backgroundImageSize, backgroundPositioningArea);
      var gradientBounds = new _Bounds.Bounds(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y), backgroundImageSize.width, backgroundImageSize.height);
      var gradient = (0, _Gradient.parseGradient)(container, background.source, gradientBounds);

      if (gradient) {
        switch (gradient.type) {
          case _Gradient.GRADIENT_TYPE.LINEAR_GRADIENT:
            // $FlowFixMe
            this.target.renderLinearGradient(gradientBounds, gradient);
            break;

          case _Gradient.GRADIENT_TYPE.RADIAL_GRADIENT:
            // $FlowFixMe
            this.target.renderRadialGradient(gradientBounds, gradient);
            break;
        }
      }
    }
  }, {
    key: 'renderBorder',
    value: function renderBorder(border, side, curvePoints) {
      this.target.drawShape((0, _Bounds.parsePathForBorder)(curvePoints, side), border.borderColor);
    }
  }, {
    key: 'renderStack',
    value: function renderStack(stack) {
      var _this4 = this;

      if (stack.container.isVisible()) {
        var _opacity = stack.getOpacity();

        if (_opacity !== this._opacity) {
          this.target.setOpacity(stack.getOpacity());
          this._opacity = _opacity;
        }

        var _transform = stack.container.style.transform;

        if (_transform !== null) {
          this.target.transform(stack.container.bounds.left + _transform.transformOrigin[0].value, stack.container.bounds.top + _transform.transformOrigin[1].value, _transform.transform, function () {
            return _this4.renderStackContent(stack);
          });
        } else {
          this.renderStackContent(stack);
        }
      }
    }
  }, {
    key: 'renderStackContent',
    value: function renderStackContent(stack) {
      var _splitStackingContext = splitStackingContexts(stack),
          _splitStackingContext2 = _slicedToArray(_splitStackingContext, 5),
          negativeZIndex = _splitStackingContext2[0],
          zeroOrAutoZIndexOrTransformedOrOpacity = _splitStackingContext2[1],
          positiveZIndex = _splitStackingContext2[2],
          nonPositionedFloats = _splitStackingContext2[3],
          nonPositionedInlineLevel = _splitStackingContext2[4];

      var _splitDescendants = splitDescendants(stack),
          _splitDescendants2 = _slicedToArray(_splitDescendants, 2),
          inlineLevel = _splitDescendants2[0],
          nonInlineLevel = _splitDescendants2[1]; // https://www.w3.org/TR/css-position-3/#painting-order
      // 1. the background and borders of the element forming the stacking context.


      this.renderNodeBackgroundAndBorders(stack.container); // 2. the child stacking contexts with negative stack levels (most negative first).

      negativeZIndex.sort(sortByZIndex).forEach(this.renderStack, this); // 3. For all its in-flow, non-positioned, block-level descendants in tree order:

      this.renderNodeContent(stack.container);
      nonInlineLevel.forEach(this.renderNode, this); // 4. All non-positioned floating descendants, in tree order. For each one of these,
      // treat the element as if it created a new stacking context, but any positioned descendants and descendants
      // which actually create a new stacking context should be considered part of the parent stacking context,
      // not this new one.

      nonPositionedFloats.forEach(this.renderStack, this); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.

      nonPositionedInlineLevel.forEach(this.renderStack, this);
      inlineLevel.forEach(this.renderNode, this); // 6. All positioned, opacity or transform descendants, in tree order that fall into the following categories:
      //  All positioned descendants with 'z-index: auto' or 'z-index: 0', in tree order.
      //  For those with 'z-index: auto', treat the element as if it created a new stacking context,
      //  but any positioned descendants and descendants which actually create a new stacking context should be
      //  considered part of the parent stacking context, not this new one. For those with 'z-index: 0',
      //  treat the stacking context generated atomically.
      //
      //  All opacity descendants with opacity less than 1
      //
      //  All transform descendants with transform other than none

      zeroOrAutoZIndexOrTransformedOrOpacity.forEach(this.renderStack, this); // 7. Stacking contexts formed by positioned descendants with z-indices greater than or equal to 1 in z-index
      // order (smallest first) then tree order.

      positiveZIndex.sort(sortByZIndex).forEach(this.renderStack, this);
    }
  }, {
    key: 'render',
    value: function render(stack) {
      var _this5 = this;

      if (this.options.backgroundColor) {
        this.target.rectangle(this.options.x, this.options.y, this.options.width, this.options.height, this.options.backgroundColor);
      }

      this.renderStack(stack);
      var target = this.target.getTarget();

      if ("production" !== 'production') {
        return target.then(function (output) {
          _this5.options.logger.log('Render completed');

          return output;
        });
      }

      return target;
    }
  }]);

  return Renderer;
}();

exports.default = Renderer;

var splitDescendants = function splitDescendants(stack) {
  var inlineLevel = [];
  var nonInlineLevel = [];
  var length = stack.children.length;

  for (var i = 0; i < length; i++) {
    var child = stack.children[i];

    if (child.isInlineLevel()) {
      inlineLevel.push(child);
    } else {
      nonInlineLevel.push(child);
    }
  }

  return [inlineLevel, nonInlineLevel];
};

var splitStackingContexts = function splitStackingContexts(stack) {
  var negativeZIndex = [];
  var zeroOrAutoZIndexOrTransformedOrOpacity = [];
  var positiveZIndex = [];
  var nonPositionedFloats = [];
  var nonPositionedInlineLevel = [];
  var length = stack.contexts.length;

  for (var i = 0; i < length; i++) {
    var child = stack.contexts[i];

    if (child.container.isPositioned() || child.container.style.opacity < 1 || child.container.isTransformed()) {
      if (child.container.style.zIndex.order < 0) {
        negativeZIndex.push(child);
      } else if (child.container.style.zIndex.order > 0) {
        positiveZIndex.push(child);
      } else {
        zeroOrAutoZIndexOrTransformedOrOpacity.push(child);
      }
    } else {
      if (child.container.isFloating()) {
        nonPositionedFloats.push(child);
      } else {
        nonPositionedInlineLevel.push(child);
      }
    }
  }

  return [negativeZIndex, zeroOrAutoZIndexOrTransformedOrOpacity, positiveZIndex, nonPositionedFloats, nonPositionedInlineLevel];
};

var sortByZIndex = function sortByZIndex(a, b) {
  if (a.container.style.zIndex.order > b.container.style.zIndex.order) {
    return 1;
  } else if (a.container.style.zIndex.order < b.container.style.zIndex.order) {
    return -1;
  }

  return a.container.index > b.container.index ? 1 : -1;
};
},{"./Bounds":"0S3x","./Font":"pRhb","./Gradient":"YydK","./TextContainer":"0xF8","./parsing/background":"mnnN","./parsing/border":"DyH5"}],"VB+h":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Proxy = undefined;

var _Feature = require('./Feature');

var _Feature2 = _interopRequireDefault(_Feature);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var Proxy = exports.Proxy = function Proxy(src, options) {
  if (!options.proxy) {
    return Promise.reject("production" !== 'production' ? 'No proxy defined' : null);
  }

  var proxy = options.proxy;
  return new Promise(function (resolve, reject) {
    var responseType = _Feature2.default.SUPPORT_CORS_XHR && _Feature2.default.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
    var xhr = _Feature2.default.SUPPORT_CORS_XHR ? new XMLHttpRequest() : new XDomainRequest();

    xhr.onload = function () {
      if (xhr instanceof XMLHttpRequest) {
        if (xhr.status === 200) {
          if (responseType === 'text') {
            resolve(xhr.response);
          } else {
            var reader = new FileReader(); // $FlowFixMe

            reader.addEventListener('load', function () {
              return resolve(reader.result);
            }, false); // $FlowFixMe

            reader.addEventListener('error', function (e) {
              return reject(e);
            }, false);
            reader.readAsDataURL(xhr.response);
          }
        } else {
          reject("production" !== 'production' ? 'Failed to proxy resource ' + src.substring(0, 256) + ' with status code ' + xhr.status : '');
        }
      } else {
        resolve(xhr.responseText);
      }
    };

    xhr.onerror = reject;
    xhr.open('GET', proxy + '?url=' + encodeURIComponent(src) + '&responseType=' + responseType);

    if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
      xhr.responseType = responseType;
    }

    if (options.imageTimeout) {
      var timeout = options.imageTimeout;
      xhr.timeout = timeout;

      xhr.ontimeout = function () {
        return reject("production" !== 'production' ? 'Timed out (' + timeout + 'ms) proxying ' + src.substring(0, 256) : '');
      };
    }

    xhr.send();
  });
};
},{"./Feature":"iLjs"}],"dNHt":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResourceStore = undefined;

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Feature = require('./Feature');

var _Feature2 = _interopRequireDefault(_Feature);

var _Proxy = require('./Proxy');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ResourceLoader = function () {
  function ResourceLoader(options, logger, window) {
    _classCallCheck(this, ResourceLoader);

    this.options = options;
    this._window = window;
    this.origin = this.getOrigin(window.location.href);
    this.cache = {};
    this.logger = logger;
    this._index = 0;
  }

  _createClass(ResourceLoader, [{
    key: 'loadImage',
    value: function loadImage(src) {
      var _this = this;

      if (this.hasResourceInCache(src)) {
        return src;
      }

      if (isBlobImage(src)) {
        this.cache[src] = _loadImage(src, this.options.imageTimeout || 0);
        return src;
      }

      if (!isSVG(src) || _Feature2.default.SUPPORT_SVG_DRAWING) {
        if (this.options.allowTaint === true || isInlineImage(src) || this.isSameOrigin(src)) {
          return this.addImage(src, src, false);
        } else if (!this.isSameOrigin(src)) {
          if (typeof this.options.proxy === 'string') {
            this.cache[src] = (0, _Proxy.Proxy)(src, this.options).then(function (src) {
              return _loadImage(src, _this.options.imageTimeout || 0);
            });
            return src;
          } else if (this.options.useCORS === true && _Feature2.default.SUPPORT_CORS_IMAGES) {
            return this.addImage(src, src, true);
          }
        }
      }
    }
  }, {
    key: 'inlineImage',
    value: function inlineImage(src) {
      var _this2 = this;

      if (isInlineImage(src)) {
        return _loadImage(src, this.options.imageTimeout || 0);
      }

      if (this.hasResourceInCache(src)) {
        return this.cache[src];
      }

      if (!this.isSameOrigin(src) && typeof this.options.proxy === 'string') {
        return this.cache[src] = (0, _Proxy.Proxy)(src, this.options).then(function (src) {
          return _loadImage(src, _this2.options.imageTimeout || 0);
        });
      }

      return this.xhrImage(src);
    }
  }, {
    key: 'xhrImage',
    value: function xhrImage(src) {
      var _this3 = this;

      this.cache[src] = new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();

        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            if (xhr.status !== 200) {
              reject('Failed to fetch image ' + src.substring(0, 256) + ' with status code ' + xhr.status);
            } else {
              var reader = new FileReader();
              reader.addEventListener('load', function () {
                // $FlowFixMe
                var result = reader.result;
                resolve(result);
              }, false);
              reader.addEventListener('error', function (e) {
                return reject(e);
              }, false);
              reader.readAsDataURL(xhr.response);
            }
          }
        };

        xhr.responseType = 'blob';

        if (_this3.options.imageTimeout) {
          var timeout = _this3.options.imageTimeout;
          xhr.timeout = timeout;

          xhr.ontimeout = function () {
            return reject("production" !== 'production' ? 'Timed out (' + timeout + 'ms) fetching ' + src.substring(0, 256) : '');
          };
        }

        xhr.open('GET', src, true);
        xhr.send();
      }).then(function (src) {
        return _loadImage(src, _this3.options.imageTimeout || 0);
      });
      return this.cache[src];
    }
  }, {
    key: 'loadCanvas',
    value: function loadCanvas(node) {
      var key = String(this._index++);
      this.cache[key] = Promise.resolve(node);
      return key;
    }
  }, {
    key: 'hasResourceInCache',
    value: function hasResourceInCache(key) {
      return typeof this.cache[key] !== 'undefined';
    }
  }, {
    key: 'addImage',
    value: function addImage(key, src, useCORS) {
      var _this4 = this;

      if ("production" !== 'production') {
        this.logger.log('Added image ' + key.substring(0, 256));
      }

      var imageLoadHandler = function imageLoadHandler(supportsDataImages) {
        return new Promise(function (resolve, reject) {
          var img = new Image();

          img.onload = function () {
            return resolve(img);
          }; //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous


          if (!supportsDataImages || useCORS) {
            img.crossOrigin = 'anonymous';
          }

          img.onerror = reject;
          img.src = src;

          if (img.complete === true) {
            // Inline XML images may fail to parse, throwing an Error later on
            setTimeout(function () {
              resolve(img);
            }, 500);
          }

          if (_this4.options.imageTimeout) {
            var timeout = _this4.options.imageTimeout;
            setTimeout(function () {
              return reject("production" !== 'production' ? 'Timed out (' + timeout + 'ms) fetching ' + src.substring(0, 256) : '');
            }, timeout);
          }
        });
      };

      this.cache[key] = isInlineBase64Image(src) && !isSVG(src) ? // $FlowFixMe
      _Feature2.default.SUPPORT_BASE64_DRAWING(src).then(imageLoadHandler) : imageLoadHandler(true);
      return key;
    }
  }, {
    key: 'isSameOrigin',
    value: function isSameOrigin(url) {
      return this.getOrigin(url) === this.origin;
    }
  }, {
    key: 'getOrigin',
    value: function getOrigin(url) {
      var link = this._link || (this._link = this._window.document.createElement('a'));

      link.href = url;
      link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/

      return link.protocol + link.hostname + link.port;
    }
  }, {
    key: 'ready',
    value: function ready() {
      var _this5 = this;

      var keys = Object.keys(this.cache);
      var values = keys.map(function (str) {
        return _this5.cache[str].catch(function (e) {
          if ("production" !== 'production') {
            _this5.logger.log('Unable to load image', e);
          }

          return null;
        });
      });
      return Promise.all(values).then(function (images) {
        if ("production" !== 'production') {
          _this5.logger.log('Finished loading ' + images.length + ' images', images);
        }

        return new ResourceStore(keys, images);
      });
    }
  }]);

  return ResourceLoader;
}();

exports.default = ResourceLoader;

var ResourceStore = exports.ResourceStore = function () {
  function ResourceStore(keys, resources) {
    _classCallCheck(this, ResourceStore);

    this._keys = keys;
    this._resources = resources;
  }

  _createClass(ResourceStore, [{
    key: 'get',
    value: function get(key) {
      var index = this._keys.indexOf(key);

      return index === -1 ? null : this._resources[index];
    }
  }]);

  return ResourceStore;
}();

var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;

var isInlineImage = function isInlineImage(src) {
  return INLINE_IMG.test(src);
};

var isInlineBase64Image = function isInlineBase64Image(src) {
  return INLINE_BASE64.test(src);
};

var isBlobImage = function isBlobImage(src) {
  return src.substr(0, 4) === 'blob';
};

var isSVG = function isSVG(src) {
  return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src);
};

var _loadImage = function _loadImage(src, timeout) {
  return new Promise(function (resolve, reject) {
    var img = new Image();

    img.onload = function () {
      return resolve(img);
    };

    img.onerror = reject;
    img.src = src;

    if (img.complete === true) {
      // Inline XML images may fail to parse, throwing an Error later on
      setTimeout(function () {
        resolve(img);
      }, 500);
    }

    if (timeout) {
      setTimeout(function () {
        return reject("production" !== 'production' ? 'Timed out (' + timeout + 'ms) loading image' : '');
      }, timeout);
    }
  });
};
},{"./Feature":"iLjs","./Proxy":"VB+h"}],"LdJ2":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseContent = exports.resolvePseudoContent = exports.popCounters = exports.parseCounterReset = exports.TOKEN_TYPE = exports.PSEUDO_CONTENT_ITEM_TYPE = undefined;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _ListItem = require('./ListItem');

var _listStyle = require('./parsing/listStyle');

var PSEUDO_CONTENT_ITEM_TYPE = exports.PSEUDO_CONTENT_ITEM_TYPE = {
  TEXT: 0,
  IMAGE: 1
};
var TOKEN_TYPE = exports.TOKEN_TYPE = {
  STRING: 0,
  ATTRIBUTE: 1,
  URL: 2,
  COUNTER: 3,
  COUNTERS: 4,
  OPENQUOTE: 5,
  CLOSEQUOTE: 6
};

var parseCounterReset = exports.parseCounterReset = function parseCounterReset(style, data) {
  if (!style || !style.counterReset || style.counterReset === 'none') {
    return [];
  }

  var counterNames = [];
  var counterResets = style.counterReset.split(/\s*,\s*/);
  var lenCounterResets = counterResets.length;

  for (var i = 0; i < lenCounterResets; i++) {
    var _counterResets$i$spli = counterResets[i].split(/\s+/),
        _counterResets$i$spli2 = _slicedToArray(_counterResets$i$spli, 2),
        counterName = _counterResets$i$spli2[0],
        initialValue = _counterResets$i$spli2[1];

    counterNames.push(counterName);
    var counter = data.counters[counterName];

    if (!counter) {
      counter = data.counters[counterName] = [];
    }

    counter.push(parseInt(initialValue || 0, 10));
  }

  return counterNames;
};

var popCounters = exports.popCounters = function popCounters(counterNames, data) {
  var lenCounters = counterNames.length;

  for (var i = 0; i < lenCounters; i++) {
    data.counters[counterNames[i]].pop();
  }
};

var resolvePseudoContent = exports.resolvePseudoContent = function resolvePseudoContent(node, style, data) {
  if (!style || !style.content || style.content === 'none' || style.content === '-moz-alt-content' || style.display === 'none') {
    return null;
  }

  var tokens = parseContent(style.content);
  var len = tokens.length;
  var contentItems = [];
  var s = ''; // increment the counter (if there is a "counter-increment" declaration)

  var counterIncrement = style.counterIncrement;

  if (counterIncrement && counterIncrement !== 'none') {
    var _counterIncrement$spl = counterIncrement.split(/\s+/),
        _counterIncrement$spl2 = _slicedToArray(_counterIncrement$spl, 2),
        counterName = _counterIncrement$spl2[0],
        incrementValue = _counterIncrement$spl2[1];

    var counter = data.counters[counterName];

    if (counter) {
      counter[counter.length - 1] += incrementValue === undefined ? 1 : parseInt(incrementValue, 10);
    }
  } // build the content string


  for (var i = 0; i < len; i++) {
    var token = tokens[i];

    switch (token.type) {
      case TOKEN_TYPE.STRING:
        s += token.value || '';
        break;

      case TOKEN_TYPE.ATTRIBUTE:
        if (node instanceof HTMLElement && token.value) {
          s += node.getAttribute(token.value) || '';
        }

        break;

      case TOKEN_TYPE.COUNTER:
        var _counter = data.counters[token.name || ''];

        if (_counter) {
          s += formatCounterValue([_counter[_counter.length - 1]], '', token.format);
        }

        break;

      case TOKEN_TYPE.COUNTERS:
        var _counters = data.counters[token.name || ''];

        if (_counters) {
          s += formatCounterValue(_counters, token.glue, token.format);
        }

        break;

      case TOKEN_TYPE.OPENQUOTE:
        s += getQuote(style, true, data.quoteDepth);
        data.quoteDepth++;
        break;

      case TOKEN_TYPE.CLOSEQUOTE:
        data.quoteDepth--;
        s += getQuote(style, false, data.quoteDepth);
        break;

      case TOKEN_TYPE.URL:
        if (s) {
          contentItems.push({
            type: PSEUDO_CONTENT_ITEM_TYPE.TEXT,
            value: s
          });
          s = '';
        }

        contentItems.push({
          type: PSEUDO_CONTENT_ITEM_TYPE.IMAGE,
          value: token.value || ''
        });
        break;
    }
  }

  if (s) {
    contentItems.push({
      type: PSEUDO_CONTENT_ITEM_TYPE.TEXT,
      value: s
    });
  }

  return contentItems;
};

var parseContent = exports.parseContent = function parseContent(content, cache) {
  if (cache && cache[content]) {
    return cache[content];
  }

  var tokens = [];
  var len = content.length;
  var isString = false;
  var isEscaped = false;
  var isFunction = false;
  var str = '';
  var functionName = '';
  var args = [];

  for (var i = 0; i < len; i++) {
    var c = content.charAt(i);

    switch (c) {
      case "'":
      case '"':
        if (isEscaped) {
          str += c;
        } else {
          isString = !isString;

          if (!isFunction && !isString) {
            tokens.push({
              type: TOKEN_TYPE.STRING,
              value: str
            });
            str = '';
          }
        }

        break;

      case '\\':
        if (isEscaped) {
          str += c;
          isEscaped = false;
        } else {
          isEscaped = true;
        }

        break;

      case '(':
        if (isString) {
          str += c;
        } else {
          isFunction = true;
          functionName = str;
          str = '';
          args = [];
        }

        break;

      case ')':
        if (isString) {
          str += c;
        } else if (isFunction) {
          if (str) {
            args.push(str);
          }

          switch (functionName) {
            case 'attr':
              if (args.length > 0) {
                tokens.push({
                  type: TOKEN_TYPE.ATTRIBUTE,
                  value: args[0]
                });
              }

              break;

            case 'counter':
              if (args.length > 0) {
                var counter = {
                  type: TOKEN_TYPE.COUNTER,
                  name: args[0]
                };

                if (args.length > 1) {
                  counter.format = args[1];
                }

                tokens.push(counter);
              }

              break;

            case 'counters':
              if (args.length > 0) {
                var _counters2 = {
                  type: TOKEN_TYPE.COUNTERS,
                  name: args[0]
                };

                if (args.length > 1) {
                  _counters2.glue = args[1];
                }

                if (args.length > 2) {
                  _counters2.format = args[2];
                }

                tokens.push(_counters2);
              }

              break;

            case 'url':
              if (args.length > 0) {
                tokens.push({
                  type: TOKEN_TYPE.URL,
                  value: args[0]
                });
              }

              break;
          }

          isFunction = false;
          str = '';
        }

        break;

      case ',':
        if (isString) {
          str += c;
        } else if (isFunction) {
          args.push(str);
          str = '';
        }

        break;

      case ' ':
      case '\t':
        if (isString) {
          str += c;
        } else if (str) {
          addOtherToken(tokens, str);
          str = '';
        }

        break;

      default:
        str += c;
    }

    if (c !== '\\') {
      isEscaped = false;
    }
  }

  if (str) {
    addOtherToken(tokens, str);
  }

  if (cache) {
    cache[content] = tokens;
  }

  return tokens;
};

var addOtherToken = function addOtherToken(tokens, identifier) {
  switch (identifier) {
    case 'open-quote':
      tokens.push({
        type: TOKEN_TYPE.OPENQUOTE
      });
      break;

    case 'close-quote':
      tokens.push({
        type: TOKEN_TYPE.CLOSEQUOTE
      });
      break;
  }
};

var getQuote = function getQuote(style, isOpening, quoteDepth) {
  var quotes = style.quotes ? style.quotes.split(/\s+/) : ["'\"'", "'\"'"];
  var idx = quoteDepth * 2;

  if (idx >= quotes.length) {
    idx = quotes.length - 2;
  }

  if (!isOpening) {
    ++idx;
  }

  return quotes[idx].replace(/^["']|["']$/g, '');
};

var formatCounterValue = function formatCounterValue(counter, glue, format) {
  var len = counter.length;
  var result = '';

  for (var i = 0; i < len; i++) {
    if (i > 0) {
      result += glue || '';
    }

    result += (0, _ListItem.createCounterText)(counter[i], (0, _listStyle.parseListStyleType)(format || 'decimal'), false);
  }

  return result;
};
},{"./ListItem":"+cR8","./parsing/listStyle":"9MRV"}],"h0Ii":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneWindow = exports.DocumentCloner = undefined;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _Bounds = require('./Bounds');

var _Proxy = require('./Proxy');

var _ResourceLoader = require('./ResourceLoader');

var _ResourceLoader2 = _interopRequireDefault(_ResourceLoader);

var _Util = require('./Util');

var _background = require('./parsing/background');

var _CanvasRenderer = require('./renderer/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _PseudoNodeContent = require('./PseudoNodeContent');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';

var DocumentCloner = exports.DocumentCloner = function () {
  function DocumentCloner(element, options, logger, copyInline, renderer) {
    _classCallCheck(this, DocumentCloner);

    this.referenceElement = element;
    this.scrolledElements = [];
    this.copyStyles = copyInline;
    this.inlineImages = copyInline;
    this.logger = logger;
    this.options = options;
    this.renderer = renderer;
    this.resourceLoader = new _ResourceLoader2.default(options, logger, window);
    this.pseudoContentData = {
      counters: {},
      quoteDepth: 0
    }; // $FlowFixMe

    this.documentElement = this.cloneNode(element.ownerDocument.documentElement);
  }

  _createClass(DocumentCloner, [{
    key: 'inlineAllImages',
    value: function inlineAllImages(node) {
      var _this = this;

      if (this.inlineImages && node) {
        var style = node.style;
        Promise.all((0, _background.parseBackgroundImage)(style.backgroundImage).map(function (backgroundImage) {
          if (backgroundImage.method === 'url') {
            return _this.resourceLoader.inlineImage(backgroundImage.args[0]).then(function (img) {
              return img && typeof img.src === 'string' ? 'url("' + img.src + '")' : 'none';
            }).catch(function (e) {
              if ("production" !== 'production') {
                _this.logger.log('Unable to load image', e);
              }
            });
          }

          return Promise.resolve('' + backgroundImage.prefix + backgroundImage.method + '(' + backgroundImage.args.join(',') + ')');
        })).then(function (backgroundImages) {
          if (backgroundImages.length > 1) {
            // TODO Multiple backgrounds somehow broken in Chrome
            style.backgroundColor = '';
          }

          style.backgroundImage = backgroundImages.join(',');
        });

        if (node instanceof HTMLImageElement) {
          this.resourceLoader.inlineImage(node.src).then(function (img) {
            if (img && node instanceof HTMLImageElement && node.parentNode) {
              var parentNode = node.parentNode;
              var clonedChild = (0, _Util.copyCSSStyles)(node.style, img.cloneNode(false));
              parentNode.replaceChild(clonedChild, node);
            }
          }).catch(function (e) {
            if ("production" !== 'production') {
              _this.logger.log('Unable to load image', e);
            }
          });
        }
      }
    }
  }, {
    key: 'inlineFonts',
    value: function inlineFonts(document) {
      var _this2 = this;

      return Promise.all(Array.from(document.styleSheets).map(function (sheet) {
        if (sheet.href) {
          return fetch(sheet.href).then(function (res) {
            return res.text();
          }).then(function (text) {
            return createStyleSheetFontsFromText(text, sheet.href);
          }).catch(function (e) {
            if ("production" !== 'production') {
              _this2.logger.log('Unable to load stylesheet', e);
            }

            return [];
          });
        }

        return getSheetFonts(sheet, document);
      })).then(function (fonts) {
        return fonts.reduce(function (acc, font) {
          return acc.concat(font);
        }, []);
      }).then(function (fonts) {
        return Promise.all(fonts.map(function (font) {
          return fetch(font.formats[0].src).then(function (response) {
            return response.blob();
          }).then(function (blob) {
            return new Promise(function (resolve, reject) {
              var reader = new FileReader();
              reader.onerror = reject;

              reader.onload = function () {
                // $FlowFixMe
                var result = reader.result;
                resolve(result);
              };

              reader.readAsDataURL(blob);
            });
          }).then(function (dataUri) {
            font.fontFace.setProperty('src', 'url("' + dataUri + '")');
            return '@font-face {' + font.fontFace.cssText + ' ';
          });
        }));
      }).then(function (fontCss) {
        var style = document.createElement('style');
        style.textContent = fontCss.join('\n');

        _this2.documentElement.appendChild(style);
      });
    }
  }, {
    key: 'createElementClone',
    value: function createElementClone(node) {
      var _this3 = this;

      if (this.copyStyles && node instanceof HTMLCanvasElement) {
        var img = node.ownerDocument.createElement('img');

        try {
          img.src = node.toDataURL();
          return img;
        } catch (e) {
          if ("production" !== 'production') {
            this.logger.log('Unable to clone canvas contents, canvas is tainted');
          }
        }
      }

      if (node instanceof HTMLIFrameElement) {
        var tempIframe = node.cloneNode(false);
        var iframeKey = generateIframeKey();
        tempIframe.setAttribute('data-html2canvas-internal-iframe-key', iframeKey);

        var _parseBounds = (0, _Bounds.parseBounds)(node, 0, 0),
            width = _parseBounds.width,
            height = _parseBounds.height;

        this.resourceLoader.cache[iframeKey] = getIframeDocumentElement(node, this.options).then(function (documentElement) {
          return _this3.renderer(documentElement, {
            async: _this3.options.async,
            allowTaint: _this3.options.allowTaint,
            backgroundColor: '#ffffff',
            canvas: null,
            imageTimeout: _this3.options.imageTimeout,
            logging: _this3.options.logging,
            proxy: _this3.options.proxy,
            removeContainer: _this3.options.removeContainer,
            scale: _this3.options.scale,
            foreignObjectRendering: _this3.options.foreignObjectRendering,
            useCORS: _this3.options.useCORS,
            target: new _CanvasRenderer2.default(),
            width: width,
            height: height,
            x: 0,
            y: 0,
            windowWidth: documentElement.ownerDocument.defaultView.innerWidth,
            windowHeight: documentElement.ownerDocument.defaultView.innerHeight,
            scrollX: documentElement.ownerDocument.defaultView.pageXOffset,
            scrollY: documentElement.ownerDocument.defaultView.pageYOffset
          }, _this3.logger.child(iframeKey));
        }).then(function (canvas) {
          return new Promise(function (resolve, reject) {
            var iframeCanvas = document.createElement('img');

            iframeCanvas.onload = function () {
              return resolve(canvas);
            };

            iframeCanvas.onerror = reject;
            iframeCanvas.src = canvas.toDataURL();

            if (tempIframe.parentNode) {
              tempIframe.parentNode.replaceChild((0, _Util.copyCSSStyles)(node.ownerDocument.defaultView.getComputedStyle(node), iframeCanvas), tempIframe);
            }
          });
        });
        return tempIframe;
      }

      if (node instanceof HTMLStyleElement && node.sheet && node.sheet.cssRules) {
        var css = [].slice.call(node.sheet.cssRules, 0).reduce(function (css, rule) {
          try {
            if (rule && rule.cssText) {
              return css + rule.cssText;
            }

            return css;
          } catch (err) {
            _this3.logger.log('Unable to access cssText property', rule.name);

            return css;
          }
        }, '');
        var style = node.cloneNode(false);
        style.textContent = css;
        return style;
      }

      return node.cloneNode(false);
    }
  }, {
    key: 'cloneNode',
    value: function cloneNode(node) {
      var clone = node.nodeType === Node.TEXT_NODE ? document.createTextNode(node.nodeValue) : this.createElementClone(node);
      var window = node.ownerDocument.defaultView;
      var style = node instanceof window.HTMLElement ? window.getComputedStyle(node) : null;
      var styleBefore = node instanceof window.HTMLElement ? window.getComputedStyle(node, ':before') : null;
      var styleAfter = node instanceof window.HTMLElement ? window.getComputedStyle(node, ':after') : null;

      if (this.referenceElement === node && clone instanceof window.HTMLElement) {
        this.clonedReferenceElement = clone;
      }

      if (clone instanceof window.HTMLBodyElement) {
        createPseudoHideStyles(clone);
      }

      var counters = (0, _PseudoNodeContent.parseCounterReset)(style, this.pseudoContentData);
      var contentBefore = (0, _PseudoNodeContent.resolvePseudoContent)(node, styleBefore, this.pseudoContentData);

      for (var child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType !== Node.ELEMENT_NODE || child.nodeName !== 'SCRIPT' && // $FlowFixMe
        !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== 'function' || // $FlowFixMe
        !this.options.ignoreElements(child))) {
          if (!this.copyStyles || child.nodeName !== 'STYLE') {
            clone.appendChild(this.cloneNode(child));
          }
        }
      }

      var contentAfter = (0, _PseudoNodeContent.resolvePseudoContent)(node, styleAfter, this.pseudoContentData);
      (0, _PseudoNodeContent.popCounters)(counters, this.pseudoContentData);

      if (node instanceof window.HTMLElement && clone instanceof window.HTMLElement) {
        if (styleBefore) {
          this.inlineAllImages(inlinePseudoElement(node, clone, styleBefore, contentBefore, PSEUDO_BEFORE));
        }

        if (styleAfter) {
          this.inlineAllImages(inlinePseudoElement(node, clone, styleAfter, contentAfter, PSEUDO_AFTER));
        }

        if (style && this.copyStyles && !(node instanceof HTMLIFrameElement)) {
          (0, _Util.copyCSSStyles)(style, clone);
        }

        this.inlineAllImages(clone);

        if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
          this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
        }

        switch (node.nodeName) {
          case 'CANVAS':
            if (!this.copyStyles) {
              cloneCanvasContents(node, clone);
            }

            break;

          case 'TEXTAREA':
          case 'SELECT':
            clone.value = node.value;
            break;
        }
      }

      return clone;
    }
  }]);

  return DocumentCloner;
}();

var getSheetFonts = function getSheetFonts(sheet, document) {
  // $FlowFixMe
  return (sheet.cssRules ? Array.from(sheet.cssRules) : []).filter(function (rule) {
    return rule.type === CSSRule.FONT_FACE_RULE;
  }).map(function (rule) {
    var src = (0, _background.parseBackgroundImage)(rule.style.getPropertyValue('src'));
    var formats = [];

    for (var i = 0; i < src.length; i++) {
      if (src[i].method === 'url' && src[i + 1] && src[i + 1].method === 'format') {
        var a = document.createElement('a');
        a.href = src[i].args[0];

        if (document.body) {
          document.body.appendChild(a);
        }

        var font = {
          src: a.href,
          format: src[i + 1].args[0]
        };
        formats.push(font);
      }
    }

    return {
      // TODO select correct format for browser),
      formats: formats.filter(function (font) {
        return /^woff/i.test(font.format);
      }),
      fontFace: rule.style
    };
  }).filter(function (font) {
    return font.formats.length;
  });
};

var createStyleSheetFontsFromText = function createStyleSheetFontsFromText(text, baseHref) {
  var doc = document.implementation.createHTMLDocument('');
  var base = document.createElement('base'); // $FlowFixMe

  base.href = baseHref;
  var style = document.createElement('style');
  style.textContent = text;

  if (doc.head) {
    doc.head.appendChild(base);
  }

  if (doc.body) {
    doc.body.appendChild(style);
  }

  return style.sheet ? getSheetFonts(style.sheet, doc) : [];
};

var restoreOwnerScroll = function restoreOwnerScroll(ownerDocument, x, y) {
  if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x, y);
  }
};

var cloneCanvasContents = function cloneCanvasContents(canvas, clonedCanvas) {
  try {
    if (clonedCanvas) {
      clonedCanvas.width = canvas.width;
      clonedCanvas.height = canvas.height;
      var ctx = canvas.getContext('2d');
      var clonedCtx = clonedCanvas.getContext('2d');

      if (ctx) {
        clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
      } else {
        clonedCtx.drawImage(canvas, 0, 0);
      }
    }
  } catch (e) {}
};

var inlinePseudoElement = function inlinePseudoElement(node, clone, style, contentItems, pseudoElt) {
  if (!style || !style.content || style.content === 'none' || style.content === '-moz-alt-content' || style.display === 'none') {
    return;
  }

  var anonymousReplacedElement = clone.ownerDocument.createElement('html2canvaspseudoelement');
  (0, _Util.copyCSSStyles)(style, anonymousReplacedElement);

  if (contentItems) {
    var len = contentItems.length;

    for (var i = 0; i < len; i++) {
      var item = contentItems[i];

      switch (item.type) {
        case _PseudoNodeContent.PSEUDO_CONTENT_ITEM_TYPE.IMAGE:
          var img = clone.ownerDocument.createElement('img');
          img.src = (0, _background.parseBackgroundImage)('url(' + item.value + ')')[0].args[0];
          img.style.opacity = '1';
          anonymousReplacedElement.appendChild(img);
          break;

        case _PseudoNodeContent.PSEUDO_CONTENT_ITEM_TYPE.TEXT:
          anonymousReplacedElement.appendChild(clone.ownerDocument.createTextNode(item.value));
          break;
      }
    }
  }

  anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ' ' + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
  clone.className += pseudoElt === PSEUDO_BEFORE ? ' ' + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : ' ' + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

  if (pseudoElt === PSEUDO_BEFORE) {
    clone.insertBefore(anonymousReplacedElement, clone.firstChild);
  } else {
    clone.appendChild(anonymousReplacedElement);
  }

  return anonymousReplacedElement;
};

var URL_REGEXP = /^url\((.+)\)$/i;
var PSEUDO_BEFORE = ':before';
var PSEUDO_AFTER = ':after';
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';

var createPseudoHideStyles = function createPseudoHideStyles(body) {
  createStyles(body, '.' + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + '\n         .' + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};

var createStyles = function createStyles(body, styles) {
  var style = body.ownerDocument.createElement('style');
  style.innerHTML = styles;
  body.appendChild(style);
};

var initNode = function initNode(_ref) {
  var _ref2 = _slicedToArray(_ref, 3),
      element = _ref2[0],
      x = _ref2[1],
      y = _ref2[2];

  element.scrollLeft = x;
  element.scrollTop = y;
};

var generateIframeKey = function generateIframeKey() {
  return Math.ceil(Date.now() + Math.random() * 10000000).toString(16);
};

var DATA_URI_REGEXP = /^data:text\/(.+);(base64)?,(.*)$/i;

var getIframeDocumentElement = function getIframeDocumentElement(node, options) {
  try {
    return Promise.resolve(node.contentWindow.document.documentElement);
  } catch (e) {
    return options.proxy ? (0, _Proxy.Proxy)(node.src, options).then(function (html) {
      var match = html.match(DATA_URI_REGEXP);

      if (!match) {
        return Promise.reject();
      }

      return match[2] === 'base64' ? window.atob(decodeURIComponent(match[3])) : decodeURIComponent(match[3]);
    }).then(function (html) {
      return createIframeContainer(node.ownerDocument, (0, _Bounds.parseBounds)(node, 0, 0)).then(function (cloneIframeContainer) {
        var cloneWindow = cloneIframeContainer.contentWindow;
        var documentClone = cloneWindow.document;
        documentClone.open();
        documentClone.write(html);
        var iframeLoad = iframeLoader(cloneIframeContainer).then(function () {
          return documentClone.documentElement;
        });
        documentClone.close();
        return iframeLoad;
      });
    }) : Promise.reject();
  }
};

var createIframeContainer = function createIframeContainer(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement('iframe');
  cloneIframeContainer.className = 'html2canvas-container';
  cloneIframeContainer.style.visibility = 'hidden';
  cloneIframeContainer.style.position = 'fixed';
  cloneIframeContainer.style.left = '-10000px';
  cloneIframeContainer.style.top = '0px';
  cloneIframeContainer.style.border = '0';
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it

  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');

  if (!ownerDocument.body) {
    return Promise.reject("production" !== 'production' ? 'Body element not found in Document that is getting rendered' : '');
  }

  ownerDocument.body.appendChild(cloneIframeContainer);
  return Promise.resolve(cloneIframeContainer);
};

var iframeLoader = function iframeLoader(cloneIframeContainer) {
  var cloneWindow = cloneIframeContainer.contentWindow;
  var documentClone = cloneWindow.document;
  return new Promise(function (resolve, reject) {
    cloneWindow.onload = cloneIframeContainer.onload = documentClone.onreadystatechange = function () {
      var interval = setInterval(function () {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
          clearInterval(interval);
          resolve(cloneIframeContainer);
        }
      }, 50);
    };
  });
};

var cloneWindow = exports.cloneWindow = function cloneWindow(ownerDocument, bounds, referenceElement, options, logger, renderer) {
  var cloner = new DocumentCloner(referenceElement, options, logger, false, renderer);
  var scrollX = ownerDocument.defaultView.pageXOffset;
  var scrollY = ownerDocument.defaultView.pageYOffset;
  return createIframeContainer(ownerDocument, bounds).then(function (cloneIframeContainer) {
    var cloneWindow = cloneIframeContainer.contentWindow;
    var documentClone = cloneWindow.document;
    /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
         if window url is about:blank, we can assign the url to current by writing onto the document
         */

    var iframeLoad = iframeLoader(cloneIframeContainer).then(function () {
      cloner.scrolledElements.forEach(initNode);
      cloneWindow.scrollTo(bounds.left, bounds.top);

      if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== bounds.top || cloneWindow.scrollX !== bounds.left)) {
        documentClone.documentElement.style.top = -bounds.top + 'px';
        documentClone.documentElement.style.left = -bounds.left + 'px';
        documentClone.documentElement.style.position = 'absolute';
      }

      var result = Promise.resolve([cloneIframeContainer, cloner.clonedReferenceElement, cloner.resourceLoader]);
      var onclone = options.onclone;
      return cloner.clonedReferenceElement instanceof cloneWindow.HTMLElement || cloner.clonedReferenceElement instanceof ownerDocument.defaultView.HTMLElement || cloner.clonedReferenceElement instanceof HTMLElement ? typeof onclone === 'function' ? Promise.resolve().then(function () {
        return onclone(documentClone);
      }).then(function () {
        return result;
      }) : result : Promise.reject("production" !== 'production' ? 'Error finding the ' + referenceElement.nodeName + ' in the cloned document' : '');
    });
    documentClone.open();
    documentClone.write(serializeDoctype(document.doctype) + '<html></html>'); // Chrome scrolls the parent document for some reason after the write to the cloned window???

    restoreOwnerScroll(referenceElement.ownerDocument, scrollX, scrollY);
    documentClone.replaceChild(documentClone.adoptNode(cloner.documentElement), documentClone.documentElement);
    documentClone.close();
    return iframeLoad;
  });
};

var serializeDoctype = function serializeDoctype(doctype) {
  var str = '';

  if (doctype) {
    str += '<!DOCTYPE ';

    if (doctype.name) {
      str += doctype.name;
    }

    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }

    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }

    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }

    str += '>';
  }

  return str;
};
},{"./Bounds":"0S3x","./Proxy":"VB+h","./ResourceLoader":"dNHt","./Util":"RUru","./parsing/background":"mnnN","./renderer/CanvasRenderer":"R8cr","./PseudoNodeContent":"LdJ2"}],"SvpN":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderElement = undefined;

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _NodeParser = require('./NodeParser');

var _Renderer = require('./Renderer');

var _Renderer2 = _interopRequireDefault(_Renderer);

var _ForeignObjectRenderer = require('./renderer/ForeignObjectRenderer');

var _ForeignObjectRenderer2 = _interopRequireDefault(_ForeignObjectRenderer);

var _Feature = require('./Feature');

var _Feature2 = _interopRequireDefault(_Feature);

var _Bounds = require('./Bounds');

var _Clone = require('./Clone');

var _Font = require('./Font');

var _Color = require('./Color');

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var renderElement = exports.renderElement = function renderElement(element, options, logger) {
  var ownerDocument = element.ownerDocument;
  var windowBounds = new _Bounds.Bounds(options.scrollX, options.scrollY, options.windowWidth, options.windowHeight); // http://www.w3.org/TR/css3-background/#special-backgrounds

  var documentBackgroundColor = ownerDocument.documentElement ? new _Color2.default(getComputedStyle(ownerDocument.documentElement).backgroundColor) : _Color.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? new _Color2.default(getComputedStyle(ownerDocument.body).backgroundColor) : _Color.TRANSPARENT;
  var backgroundColor = element === ownerDocument.documentElement ? documentBackgroundColor.isTransparent() ? bodyBackgroundColor.isTransparent() ? options.backgroundColor ? new _Color2.default(options.backgroundColor) : null : bodyBackgroundColor : documentBackgroundColor : options.backgroundColor ? new _Color2.default(options.backgroundColor) : null;
  return (options.foreignObjectRendering ? // $FlowFixMe
  _Feature2.default.SUPPORT_FOREIGNOBJECT_DRAWING : Promise.resolve(false)).then(function (supportForeignObject) {
    return supportForeignObject ? function (cloner) {
      if ("production" !== 'production') {
        logger.log('Document cloned, using foreignObject rendering');
      }

      return cloner.inlineFonts(ownerDocument).then(function () {
        return cloner.resourceLoader.ready();
      }).then(function () {
        var renderer = new _ForeignObjectRenderer2.default(cloner.documentElement);
        var defaultView = ownerDocument.defaultView;
        var scrollX = defaultView.pageXOffset;
        var scrollY = defaultView.pageYOffset;
        var isDocument = element.tagName === 'HTML' || element.tagName === 'BODY';

        var _ref = isDocument ? (0, _Bounds.parseDocumentSize)(ownerDocument) : (0, _Bounds.parseBounds)(element, scrollX, scrollY),
            width = _ref.width,
            height = _ref.height,
            left = _ref.left,
            top = _ref.top;

        return renderer.render({
          backgroundColor: backgroundColor,
          logger: logger,
          scale: options.scale,
          x: typeof options.x === 'number' ? options.x : left,
          y: typeof options.y === 'number' ? options.y : top,
          width: typeof options.width === 'number' ? options.width : Math.ceil(width),
          height: typeof options.height === 'number' ? options.height : Math.ceil(height),
          windowWidth: options.windowWidth,
          windowHeight: options.windowHeight,
          scrollX: options.scrollX,
          scrollY: options.scrollY
        });
      });
    }(new _Clone.DocumentCloner(element, options, logger, true, renderElement)) : (0, _Clone.cloneWindow)(ownerDocument, windowBounds, element, options, logger, renderElement).then(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 3),
          container = _ref3[0],
          clonedElement = _ref3[1],
          resourceLoader = _ref3[2];

      if ("production" !== 'production') {
        logger.log('Document cloned, using computed rendering');
      }

      var stack = (0, _NodeParser.NodeParser)(clonedElement, resourceLoader, logger);
      var clonedDocument = clonedElement.ownerDocument;

      if (backgroundColor === stack.container.style.background.backgroundColor) {
        stack.container.style.background.backgroundColor = _Color.TRANSPARENT;
      }

      return resourceLoader.ready().then(function (imageStore) {
        var fontMetrics = new _Font.FontMetrics(clonedDocument);

        if ("production" !== 'production') {
          logger.log('Starting renderer');
        }

        var defaultView = clonedDocument.defaultView;
        var scrollX = defaultView.pageXOffset;
        var scrollY = defaultView.pageYOffset;
        var isDocument = clonedElement.tagName === 'HTML' || clonedElement.tagName === 'BODY';

        var _ref4 = isDocument ? (0, _Bounds.parseDocumentSize)(ownerDocument) : (0, _Bounds.parseBounds)(clonedElement, scrollX, scrollY),
            width = _ref4.width,
            height = _ref4.height,
            left = _ref4.left,
            top = _ref4.top;

        var renderOptions = {
          backgroundColor: backgroundColor,
          fontMetrics: fontMetrics,
          imageStore: imageStore,
          logger: logger,
          scale: options.scale,
          x: typeof options.x === 'number' ? options.x : left,
          y: typeof options.y === 'number' ? options.y : top,
          width: typeof options.width === 'number' ? options.width : Math.ceil(width),
          height: typeof options.height === 'number' ? options.height : Math.ceil(height)
        };

        if (Array.isArray(options.target)) {
          return Promise.all(options.target.map(function (target) {
            var renderer = new _Renderer2.default(target, renderOptions);
            return renderer.render(stack);
          }));
        } else {
          var renderer = new _Renderer2.default(options.target, renderOptions);
          var canvas = renderer.render(stack);

          if (options.removeContainer === true) {
            if (container.parentNode) {
              container.parentNode.removeChild(container);
            } else if ("production" !== 'production') {
              logger.log('Cannot detach cloned iframe as it is not in the DOM anymore');
            }
          }

          return canvas;
        }
      });
    });
  });
};
},{"./Logger":"aleJ","./NodeParser":"Ce85","./Renderer":"g+e5","./renderer/ForeignObjectRenderer":"a32l","./Feature":"iLjs","./Bounds":"0S3x","./Clone":"h0Ii","./Font":"pRhb","./Color":"IvPj"}],"Tt9E":[function(require,module,exports) {
'use strict';

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _CanvasRenderer = require('./renderer/CanvasRenderer');

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _Logger = require('./Logger');

var _Logger2 = _interopRequireDefault(_Logger);

var _Window = require('./Window');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

var html2canvas = function html2canvas(element, conf) {
  var config = conf || {};
  var logger = new _Logger2.default(typeof config.logging === 'boolean' ? config.logging : true);
  logger.log('html2canvas ' + "$npm_package_version");

  if ("production" !== 'production' && typeof config.onrendered === 'function') {
    logger.error('onrendered option is deprecated, html2canvas returns a Promise with the canvas as the value');
  }

  var ownerDocument = element.ownerDocument;

  if (!ownerDocument) {
    return Promise.reject('Provided element is not within a Document');
  }

  var defaultView = ownerDocument.defaultView;
  var defaultOptions = {
    async: true,
    allowTaint: false,
    backgroundColor: '#ffffff',
    imageTimeout: 15000,
    logging: true,
    proxy: null,
    removeContainer: true,
    foreignObjectRendering: false,
    scale: defaultView.devicePixelRatio || 1,
    target: new _CanvasRenderer2.default(config.canvas),
    useCORS: false,
    windowWidth: defaultView.innerWidth,
    windowHeight: defaultView.innerHeight,
    scrollX: defaultView.pageXOffset,
    scrollY: defaultView.pageYOffset
  };
  var result = (0, _Window.renderElement)(element, _extends({}, defaultOptions, config), logger);

  if ("production" !== 'production') {
    return result.catch(function (e) {
      logger.error(e);
      throw e;
    });
  }

  return result;
};

html2canvas.CanvasRenderer = _CanvasRenderer2.default;
module.exports = html2canvas;
},{"./renderer/CanvasRenderer":"R8cr","./Logger":"aleJ","./Window":"SvpN"}],"km1w":[function(require,module,exports) {
var define;
var global = arguments[3];
/**
 * html2pdf.js v0.9.1
 * Copyright (c) 2018 Erik Koopmans
 * Released under the MIT License.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('es6-promise/auto'), require('jspdf'), require('html2canvas')) :
	typeof define === 'function' && define.amd ? define(['es6-promise/auto', 'jspdf', 'html2canvas'], factory) :
	(global.html2pdf = factory(null,global.jsPDF,global.html2canvas));
}(this, (function (auto,jsPDF,html2canvas) { 'use strict';

jsPDF = jsPDF && jsPDF.hasOwnProperty('default') ? jsPDF['default'] : jsPDF;
html2canvas = html2canvas && html2canvas.hasOwnProperty('default') ? html2canvas['default'] : html2canvas;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





















var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

// Determine the type of a variable/object.
var objType = function objType(obj) {
  var type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  if (type === 'undefined') return 'undefined';else if (type === 'string' || obj instanceof String) return 'string';else if (type === 'number' || obj instanceof Number) return 'number';else if (type === 'function' || obj instanceof Function) return 'function';else if (!!obj && obj.constructor === Array) return 'array';else if (obj && obj.nodeType === 1) return 'element';else if (type === 'object') return 'object';else return 'unknown';
};

// Create an HTML element with optional className, innerHTML, and style.
var createElement = function createElement(tagName, opt) {
  var el = document.createElement(tagName);
  if (opt.className) el.className = opt.className;
  if (opt.innerHTML) {
    el.innerHTML = opt.innerHTML;
    var scripts = el.getElementsByTagName('script');
    for (var i = scripts.length; i-- > 0; null) {
      scripts[i].parentNode.removeChild(scripts[i]);
    }
  }
  for (var key in opt.style) {
    el.style[key] = opt.style[key];
  }
  return el;
};

// Deep-clone a node and preserve contents/properties.
var cloneNode = function cloneNode(node, javascriptEnabled) {
  // Recursively clone the node.
  var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);
  for (var child = node.firstChild; child; child = child.nextSibling) {
    if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
      clone.appendChild(cloneNode(child, javascriptEnabled));
    }
  }

  if (node.nodeType === 1) {
    // Preserve contents/properties of special nodes.
    if (node.nodeName === 'CANVAS') {
      clone.width = node.width;
      clone.height = node.height;
      clone.getContext('2d').drawImage(node, 0, 0);
    } else if (node.nodeName === 'TEXTAREA' || node.nodeName === 'SELECT') {
      clone.value = node.value;
    }

    // Preserve the node's scroll position when it loads.
    clone.addEventListener('load', function () {
      clone.scrollTop = node.scrollTop;
      clone.scrollLeft = node.scrollLeft;
    }, true);
  }

  // Return the cloned node.
  return clone;
};

// Convert units from px using the conversion value 'k' from jsPDF.
var unitConvert = function unitConvert(obj, k) {
  if (objType(obj) === 'number') {
    return obj * 72 / 96 / k;
  } else {
    var newObj = {};
    for (var key in obj) {
      newObj[key] = obj[key] * 72 / 96 / k;
    }
    return newObj;
  }
};

// Convert units to px using the conversion value 'k' from jsPDF.
var toPx = function toPx(val, k) {
  return Math.floor(val * k / 72 * 96);
};

/* ----- CONSTRUCTOR ----- */

var Worker = function Worker(opt) {
  // Create the root parent for the proto chain, and the starting Worker.
  var root = _extends(Worker.convert(Promise.resolve()), JSON.parse(JSON.stringify(Worker.template)));
  var self = Worker.convert(Promise.resolve(), root);

  // Set progress, optional settings, and return.
  self = self.setProgress(1, Worker, 1, [Worker]);
  self = self.set(opt);
  return self;
};

// Boilerplate for subclassing Promise.
Worker.prototype = Object.create(Promise.prototype);
Worker.prototype.constructor = Worker;

// Converts/casts promises into Workers.
Worker.convert = function convert(promise, inherit) {
  // Uses prototypal inheritance to receive changes made to ancestors' properties.
  promise.__proto__ = inherit || Worker.prototype;
  return promise;
};

Worker.template = {
  prop: {
    src: null,
    container: null,
    overlay: null,
    canvas: null,
    img: null,
    pdf: null,
    pageSize: null
  },
  progress: {
    val: 0,
    state: null,
    n: 0,
    stack: []
  },
  opt: {
    filename: 'file.pdf',
    margin: [0, 0, 0, 0],
    image: { type: 'jpeg', quality: 0.95 },
    enableLinks: true,
    html2canvas: {},
    jsPDF: {}
  }
};

/* ----- FROM / TO ----- */

Worker.prototype.from = function from(src, type) {
  function getType(src) {
    switch (objType(src)) {
      case 'string':
        return 'string';
      case 'element':
        return src.nodeName.toLowerCase === 'canvas' ? 'canvas' : 'element';
      default:
        return 'unknown';
    }
  }

  return this.then(function from_main() {
    type = type || getType(src);
    switch (type) {
      case 'string':
        return this.set({ src: createElement('div', { innerHTML: src }) });
      case 'element':
        return this.set({ src: src });
      case 'canvas':
        return this.set({ canvas: src });
      case 'img':
        return this.set({ img: src });
      default:
        return this.error('Unknown source type.');
    }
  });
};

Worker.prototype.to = function to(target) {
  // Route the 'to' request to the appropriate method.
  switch (target) {
    case 'container':
      return this.toContainer();
    case 'canvas':
      return this.toCanvas();
    case 'img':
      return this.toImg();
    case 'pdf':
      return this.toPdf();
    default:
      return this.error('Invalid target.');
  }
};

Worker.prototype.toContainer = function toContainer() {
  // Set up function prerequisites.
  var prereqs = [function checkSrc() {
    return this.prop.src || this.error('Cannot duplicate - no source HTML.');
  }, function checkPageSize() {
    return this.prop.pageSize || this.setPageSize();
  }];

  return this.thenList(prereqs).then(function toContainer_main() {
    // Define the CSS styles for the container and its overlay parent.
    var overlayCSS = {
      position: 'fixed', overflow: 'hidden', zIndex: 1000,
      left: 0, right: 0, bottom: 0, top: 0,
      backgroundColor: 'rgba(0,0,0,0.8)'
    };
    var containerCSS = {
      position: 'absolute', width: this.prop.pageSize.inner.width + this.prop.pageSize.unit,
      left: 0, right: 0, top: 0, height: 'auto', margin: 'auto',
      backgroundColor: 'white'
    };

    // Set the overlay to hidden (could be changed in the future to provide a print preview).
    overlayCSS.opacity = 0;

    // Create and attach the elements.
    var source = cloneNode(this.prop.src, this.opt.html2canvas.javascriptEnabled);
    this.prop.overlay = createElement('div', { className: 'html2pdf__overlay', style: overlayCSS });
    this.prop.container = createElement('div', { className: 'html2pdf__container', style: containerCSS });
    this.prop.container.appendChild(source);
    this.prop.overlay.appendChild(this.prop.container);
    document.body.appendChild(this.prop.overlay);
  });
};

Worker.prototype.toCanvas = function toCanvas() {
  // Set up function prerequisites.
  var prereqs = [function checkContainer() {
    return document.body.contains(this.prop.container) || this.toContainer();
  }];

  // Fulfill prereqs then create the canvas.
  return this.thenList(prereqs).then(function toCanvas_main() {
    // Handle old-fashioned 'onrendered' argument.
    var options = _extends({}, this.opt.html2canvas);
    delete options.onrendered;

    return html2canvas(this.prop.container, options);
  }).then(function toCanvas_post(canvas) {
    // Handle old-fashioned 'onrendered' argument.
    var onRendered = this.opt.html2canvas.onrendered || function () {};
    onRendered(canvas);

    this.prop.canvas = canvas;
    document.body.removeChild(this.prop.overlay);
  });
};

Worker.prototype.toImg = function toImg() {
  // Set up function prerequisites.
  var prereqs = [function checkCanvas() {
    return this.prop.canvas || this.toCanvas();
  }];

  // Fulfill prereqs then create the image.
  return this.thenList(prereqs).then(function toImg_main() {
    var imgData = this.prop.canvas.toDataURL('image/' + this.opt.image.type, this.opt.image.quality);
    this.prop.img = document.createElement('img');
    this.prop.img.src = imgData;
  });
};

Worker.prototype.toPdf = function toPdf() {
  // Set up function prerequisites.
  var prereqs = [function checkCanvas() {
    return this.prop.canvas || this.toCanvas();
  }];

  // Fulfill prereqs then create the image.
  return this.thenList(prereqs).then(function toPdf_main() {
    // Create local copies of frequently used properties.
    var canvas = this.prop.canvas;
    var opt = this.opt;

    // Calculate the number of pages.
    var ctx = canvas.getContext('2d');
    var pxFullHeight = canvas.height;
    var pxPageHeight = Math.floor(canvas.width * this.prop.pageSize.inner.ratio);
    var nPages = Math.ceil(pxFullHeight / pxPageHeight);

    // Define pageHeight separately so it can be trimmed on the final page.
    var pageHeight = this.prop.pageSize.inner.height;

    // Create a one-page canvas to split up the full image.
    var pageCanvas = document.createElement('canvas');
    var pageCtx = pageCanvas.getContext('2d');
    pageCanvas.width = canvas.width;
    pageCanvas.height = pxPageHeight;

    // Initialize the PDF.
    this.prop.pdf = this.prop.pdf || new jsPDF(opt.jsPDF);

    for (var page = 0; page < nPages; page++) {
      // Trim the final page to reduce file size.
      if (page === nPages - 1) {
        pageCanvas.height = pxFullHeight % pxPageHeight;
        pageHeight = pageCanvas.height * this.prop.pageSize.inner.width / pageCanvas.width;
      }

      // Display the page.
      var w = pageCanvas.width;
      var h = pageCanvas.height;
      pageCtx.fillStyle = 'white';
      pageCtx.fillRect(0, 0, w, h);
      pageCtx.drawImage(canvas, 0, page * pxPageHeight, w, h, 0, 0, w, h);

      // Add the page to the PDF.
      if (page) this.prop.pdf.addPage();
      var imgData = pageCanvas.toDataURL('image/' + opt.image.type, opt.image.quality);
      this.prop.pdf.addImage(imgData, opt.image.type, opt.margin[1], opt.margin[0], this.prop.pageSize.inner.width, pageHeight);
    }
  });
};

/* ----- OUTPUT / SAVE ----- */

Worker.prototype.output = function output(type, options, src) {
  // Redirect requests to the correct function (outputPdf / outputImg).
  src = src || 'pdf';
  if (src.toLowerCase() === 'img' || src.toLowerCase() === 'image') {
    return this.outputImg(type, options);
  } else {
    return this.outputPdf(type, options);
  }
};

Worker.prototype.outputPdf = function outputPdf(type, options) {
  // Set up function prerequisites.
  var prereqs = [function checkPdf() {
    return this.prop.pdf || this.toPdf();
  }];

  // Fulfill prereqs then perform the appropriate output.
  return this.thenList(prereqs).then(function outputPdf_main() {
    /* Currently implemented output types:
     *    https://rawgit.com/MrRio/jsPDF/master/docs/jspdf.js.html#line992
     *  save(options), arraybuffer, blob, bloburi/bloburl,
     *  datauristring/dataurlstring, dataurlnewwindow, datauri/dataurl
     */
    return this.prop.pdf.output(type, options);
  });
};

Worker.prototype.outputImg = function outputImg(type, options) {
  // Set up function prerequisites.
  var prereqs = [function checkImg() {
    return this.prop.img || this.toImg();
  }];

  // Fulfill prereqs then perform the appropriate output.
  return this.thenList(prereqs).then(function outputImg_main() {
    switch (type) {
      case undefined:
      case 'img':
        return this.prop.img;
      case 'datauristring':
      case 'dataurlstring':
        return this.prop.img.src;
      case 'datauri':
      case 'dataurl':
        return document.location.href = this.prop.img.src;
      default:
        throw 'Image output type "' + type + '" is not supported.';
    }
  });
};

Worker.prototype.save = function save(filename) {
  // Set up function prerequisites.
  var prereqs = [function checkPdf() {
    return this.prop.pdf || this.toPdf();
  }];

  // Fulfill prereqs, update the filename (if provided), and save the PDF.
  return this.thenList(prereqs).set(filename ? { filename: filename } : null).then(function save_main() {
    this.prop.pdf.save(this.opt.filename);
  });
};

/* ----- SET / GET ----- */

Worker.prototype.set = function set$$1(opt) {
  // TODO: Implement ordered pairs?

  // Silently ignore invalid or empty input.
  if (objType(opt) !== 'object') {
    return this;
  }

  // Build an array of setter functions to queue.
  var fns = Object.keys(opt || {}).map(function (key) {
    if (key in Worker.template.prop) {
      // Set pre-defined properties.
      return function set_prop() {
        this.prop[key] = opt[key];
      };
    } else {
      switch (key) {
        case 'margin':
          return this.setMargin.bind(this, opt.margin);
        case 'jsPDF':
          return function set_jsPDF() {
            this.opt.jsPDF = opt.jsPDF;return this.setPageSize();
          };
        case 'pageSize':
          return this.setPageSize.bind(this, opt.pageSize);
        default:
          // Set any other properties in opt.
          return function set_opt() {
            this.opt[key] = opt[key];
          };
      }
    }
  }, this);

  // Set properties within the promise chain.
  return this.then(function set_main() {
    return this.thenList(fns);
  });
};

Worker.prototype.get = function get$$1(key, cbk) {
  return this.then(function get_main() {
    // Fetch the requested property, either as a predefined prop or in opt.
    var val = key in Worker.template.prop ? this.prop[key] : this.opt[key];
    return cbk ? cbk(val) : val;
  });
};

Worker.prototype.setMargin = function setMargin(margin) {
  return this.then(function setMargin_main() {
    // Parse the margin property: [top, left, bottom, right].
    switch (objType(margin)) {
      case 'number':
        margin = [margin, margin, margin, margin];
      case 'array':
        if (margin.length === 2) {
          margin = [margin[0], margin[1], margin[0], margin[1]];
        }
        if (margin.length === 4) {
          break;
        }
      default:
        return this.error('Invalid margin array.');
    }

    // Set the margin property, then update pageSize.
    this.opt.margin = margin;
  }).then(this.setPageSize);
};

Worker.prototype.setPageSize = function setPageSize(pageSize) {
  return this.then(function setPageSize_main() {
    // Retrieve page-size based on jsPDF settings, if not explicitly provided.
    pageSize = pageSize || jsPDF.getPageSize(this.opt.jsPDF);

    // Add 'inner' field if not present.
    if (!pageSize.hasOwnProperty('inner')) {
      pageSize.inner = {
        width: pageSize.width - this.opt.margin[1] - this.opt.margin[3],
        height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]
      };
      pageSize.inner.px = {
        width: toPx(pageSize.inner.width, pageSize.k),
        height: toPx(pageSize.inner.height, pageSize.k)
      };
      pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;
    }

    // Attach pageSize to this.
    this.prop.pageSize = pageSize;
  });
};

Worker.prototype.setProgress = function setProgress(val, state, n, stack) {
  // Immediately update all progress values.
  if (val != null) this.progress.val = val;
  if (state != null) this.progress.state = state;
  if (n != null) this.progress.n = n;
  if (stack != null) this.progress.stack = stack;
  this.progress.ratio = this.progress.val / this.progress.state;

  // Return this for command chaining.
  return this;
};

Worker.prototype.updateProgress = function updateProgress(val, state, n, stack) {
  // Immediately update all progress values, using setProgress.
  return this.setProgress(val ? this.progress.val + val : null, state ? state : null, n ? this.progress.n + n : null, stack ? this.progress.stack.concat(stack) : null);
};

/* ----- PROMISE MAPPING ----- */

Worker.prototype.then = function then(onFulfilled, onRejected) {
  // Wrap `this` for encapsulation.
  var self = this;

  return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled, onRejected) {
    // Update progress while queuing, calling, and resolving `then`.
    self.updateProgress(null, null, 1, [onFulfilled]);
    return Promise.prototype.then.call(this, function then_pre(val) {
      self.updateProgress(null, onFulfilled);
      return val;
    }).then(onFulfilled, onRejected).then(function then_post(val) {
      self.updateProgress(1);
      return val;
    });
  });
};

Worker.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {
  // Handle optional thenBase parameter.
  thenBase = thenBase || Promise.prototype.then;

  // Wrap `this` for encapsulation and bind it to the promise handlers.
  var self = this;
  if (onFulfilled) {
    onFulfilled = onFulfilled.bind(self);
  }
  if (onRejected) {
    onRejected = onRejected.bind(self);
  }

  // Cast self into a Promise to avoid polyfills recursively defining `then`.
  var isNative = Promise.toString().indexOf('[native code]') !== -1 && Promise.name === 'Promise';
  var selfPromise = isNative ? self : Worker.convert(_extends({}, self), Promise.prototype);

  // Return the promise, after casting it into a Worker and preserving props.
  var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);
  return Worker.convert(returnVal, self.__proto__);
};

Worker.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {
  // Call `then` and return a standard promise (exits the Worker chain).
  return Promise.prototype.then.call(this, onFulfilled, onRejected);
};

Worker.prototype.thenList = function thenList(fns) {
  // Queue a series of promise 'factories' into the promise chain.
  var self = this;
  fns.forEach(function thenList_forEach(fn) {
    self = self.thenCore(fn);
  });
  return self;
};

Worker.prototype['catch'] = function (onRejected) {
  // Bind `this` to the promise handler, call `catch`, and return a Worker.
  if (onRejected) {
    onRejected = onRejected.bind(this);
  }
  var returnVal = Promise.prototype['catch'].call(this, onRejected);
  return Worker.convert(returnVal, this);
};

Worker.prototype.catchExternal = function catchExternal(onRejected) {
  // Call `catch` and return a standard promise (exits the Worker chain).
  return Promise.prototype['catch'].call(this, onRejected);
};

Worker.prototype.error = function error(msg) {
  // Throw the error in the Promise chain.
  return this.then(function error_main() {
    throw new Error(msg);
  });
};

/* ----- ALIASES ----- */

Worker.prototype.using = Worker.prototype.set;
Worker.prototype.saveAs = Worker.prototype.save;
Worker.prototype.export = Worker.prototype.output;
Worker.prototype.run = Worker.prototype.then;

// Import dependencies.
// Get dimensions of a PDF page, as determined by jsPDF.
jsPDF.getPageSize = function (orientation, unit, format) {
  // Decode options object
  if ((typeof orientation === 'undefined' ? 'undefined' : _typeof(orientation)) === 'object') {
    var options = orientation;
    orientation = options.orientation;
    unit = options.unit || unit;
    format = options.format || format;
  }

  // Default options
  unit = unit || 'mm';
  format = format || 'a4';
  orientation = ('' + (orientation || 'P')).toLowerCase();
  var format_as_string = ('' + format).toLowerCase();

  // Size in pt of various paper formats
  var pageFormats = {
    'a0': [2383.94, 3370.39], 'a1': [1683.78, 2383.94],
    'a2': [1190.55, 1683.78], 'a3': [841.89, 1190.55],
    'a4': [595.28, 841.89], 'a5': [419.53, 595.28],
    'a6': [297.64, 419.53], 'a7': [209.76, 297.64],
    'a8': [147.40, 209.76], 'a9': [104.88, 147.40],
    'a10': [73.70, 104.88], 'b0': [2834.65, 4008.19],
    'b1': [2004.09, 2834.65], 'b2': [1417.32, 2004.09],
    'b3': [1000.63, 1417.32], 'b4': [708.66, 1000.63],
    'b5': [498.90, 708.66], 'b6': [354.33, 498.90],
    'b7': [249.45, 354.33], 'b8': [175.75, 249.45],
    'b9': [124.72, 175.75], 'b10': [87.87, 124.72],
    'c0': [2599.37, 3676.54], 'c1': [1836.85, 2599.37],
    'c2': [1298.27, 1836.85], 'c3': [918.43, 1298.27],
    'c4': [649.13, 918.43], 'c5': [459.21, 649.13],
    'c6': [323.15, 459.21], 'c7': [229.61, 323.15],
    'c8': [161.57, 229.61], 'c9': [113.39, 161.57],
    'c10': [79.37, 113.39], 'dl': [311.81, 623.62],
    'letter': [612, 792],
    'government-letter': [576, 756],
    'legal': [612, 1008],
    'junior-legal': [576, 360],
    'ledger': [1224, 792],
    'tabloid': [792, 1224],
    'credit-card': [153, 243]
  };

  // Unit conversion
  switch (unit) {
    case 'pt':
      var k = 1;break;
    case 'mm':
      var k = 72 / 25.4;break;
    case 'cm':
      var k = 72 / 2.54;break;
    case 'in':
      var k = 72;break;
    case 'px':
      var k = 72 / 96;break;
    case 'pc':
      var k = 12;break;
    case 'em':
      var k = 12;break;
    case 'ex':
      var k = 6;break;
    default:
      throw 'Invalid unit: ' + unit;
  }

  // Dimensions are stored as user units and converted to points on output
  if (pageFormats.hasOwnProperty(format_as_string)) {
    var pageHeight = pageFormats[format_as_string][1] / k;
    var pageWidth = pageFormats[format_as_string][0] / k;
  } else {
    try {
      var pageHeight = format[1];
      var pageWidth = format[0];
    } catch (err) {
      throw new Error('Invalid format: ' + format);
    }
  }

  // Handle page orientation
  if (orientation === 'p' || orientation === 'portrait') {
    orientation = 'p';
    if (pageWidth > pageHeight) {
      var tmp = pageWidth;
      pageWidth = pageHeight;
      pageHeight = tmp;
    }
  } else if (orientation === 'l' || orientation === 'landscape') {
    orientation = 'l';
    if (pageHeight > pageWidth) {
      var tmp = pageWidth;
      pageWidth = pageHeight;
      pageHeight = tmp;
    }
  } else {
    throw 'Invalid orientation: ' + orientation;
  }

  // Return information (k is the unit conversion ratio from pts)
  var info = { 'width': pageWidth, 'height': pageHeight, 'unit': unit, 'k': k };
  return info;
};

/* Pagebreak plugin:

    Adds page-break functionality to the html2pdf library. Page-breaks can be
    enabled by CSS styles, set on individual elements using selectors, or
    avoided from breaking inside all elements.

    Options on the `opt.pagebreak` object:

    mode:   String or array of strings: 'avoid-all', 'css', and/or 'legacy'
            Default: ['css', 'legacy']

    before: String or array of CSS selectors for which to add page-breaks
            before each element. Can be a specific element with an ID
            ('#myID'), all elements of a type (e.g. 'img'), all of a class
            ('.myClass'), or even '*' to match every element.

    after:  Like 'before', but adds a page-break immediately after the element.

    avoid:  Like 'before', but avoids page-breaks on these elements. You can
            enable this feature on every element using the 'avoid-all' mode.
*/

// Refs to original functions.
var orig = {
  toContainer: Worker.prototype.toContainer
};

// Add pagebreak default options to the Worker template.
Worker.template.opt.pagebreak = {
  mode: ['css', 'legacy'],
  before: [],
  after: [],
  avoid: []
};

Worker.prototype.toContainer = function toContainer() {
  return orig.toContainer.call(this).then(function toContainer_pagebreak() {
    // Setup root element and inner page height.
    var root = this.prop.container;
    var pxPageHeight = this.prop.pageSize.inner.px.height;

    // Check all requested modes.
    var modeSrc = [].concat(this.opt.pagebreak.mode);
    var mode = {
      avoidAll: modeSrc.indexOf('avoid-all') !== -1,
      css: modeSrc.indexOf('css') !== -1,
      legacy: modeSrc.indexOf('legacy') !== -1
    };

    // Get arrays of all explicitly requested elements.
    var select = {};
    var self = this;
    ['before', 'after', 'avoid'].forEach(function (key) {
      var all = mode.avoidAll && key === 'avoid';
      select[key] = all ? [] : [].concat(self.opt.pagebreak[key] || []);
      if (select[key].length > 0) {
        select[key] = Array.prototype.slice.call(root.querySelectorAll(select[key].join(', ')));
      }
    });

    // Get all legacy page-break elements.
    var legacyEls = root.querySelectorAll('.html2pdf__page-break');
    legacyEls = Array.prototype.slice.call(legacyEls);

    // Loop through all elements.
    var els = root.querySelectorAll('*');
    Array.prototype.forEach.call(els, function pagebreak_loop(el) {
      // Setup pagebreak rules based on legacy and avoidAll modes.
      var rules = {
        before: false,
        after: mode.legacy && legacyEls.indexOf(el) !== -1,
        avoid: mode.avoidAll
      };

      // Add rules for css mode.
      if (mode.css) {
        // TODO: Check if this is valid with iFrames.
        var style = window.getComputedStyle(el);
        // TODO: Handle 'left' and 'right' correctly.
        // TODO: Add support for 'avoid' on breakBefore/After.
        var breakOpt = ['always', 'page', 'left', 'right'];
        var avoidOpt = ['avoid', 'avoid-page'];
        rules = {
          before: rules.before || breakOpt.indexOf(style.breakBefore || style.pageBreakBefore) !== -1,
          after: rules.after || breakOpt.indexOf(style.breakAfter || style.pageBreakAfter) !== -1,
          avoid: rules.avoid || avoidOpt.indexOf(style.breakInside || style.pageBreakInside) !== -1
        };
      }

      // Add rules for explicit requests.
      Object.keys(rules).forEach(function (key) {
        rules[key] = rules[key] || select[key].indexOf(el) !== -1;
      });

      // Get element position on the screen.
      // TODO: Subtract the top of the container from clientRect.top/bottom?
      var clientRect = el.getBoundingClientRect();

      // Avoid: Check if a break happens mid-element.
      if (rules.avoid && !rules.before) {
        var startPage = Math.floor(clientRect.top / pxPageHeight);
        var endPage = Math.floor(clientRect.bottom / pxPageHeight);
        var nPages = Math.abs(clientRect.bottom - clientRect.top) / pxPageHeight;

        // Turn on rules.before if the el is broken and is at most one page long.
        if (endPage !== startPage && nPages <= 1) {
          rules.before = true;
        }
      }

      // Before: Create a padding div to push the element to the next page.
      if (rules.before) {
        var pad = createElement('div', { style: {
            display: 'block',
            height: pxPageHeight - clientRect.top % pxPageHeight + 'px'
          } });
        el.parentNode.insertBefore(pad, el);
      }

      // After: Create a padding div to fill the remaining page.
      if (rules.after) {
        var pad = createElement('div', { style: {
            display: 'block',
            height: pxPageHeight - clientRect.bottom % pxPageHeight + 'px'
          } });
        el.parentNode.insertBefore(pad, el.nextSibling);
      }
    });
  });
};

// Add hyperlink functionality to the PDF creation.

// Main link array, and refs to original functions.
var linkInfo = [];
var orig$1 = {
  toContainer: Worker.prototype.toContainer,
  toPdf: Worker.prototype.toPdf
};

Worker.prototype.toContainer = function toContainer() {
  return orig$1.toContainer.call(this).then(function toContainer_hyperlink() {
    // Retrieve hyperlink info if the option is enabled.
    if (this.opt.enableLinks) {
      // Find all anchor tags and get the container's bounds for reference.
      var container = this.prop.container;
      var links = container.querySelectorAll('a');
      var containerRect = unitConvert(container.getBoundingClientRect(), this.prop.pageSize.k);
      linkInfo = [];

      // Loop through each anchor tag.
      Array.prototype.forEach.call(links, function (link) {
        // Treat each client rect as a separate link (for text-wrapping).
        var clientRects = link.getClientRects();
        for (var i = 0; i < clientRects.length; i++) {
          var clientRect = unitConvert(clientRects[i], this.prop.pageSize.k);
          clientRect.left -= containerRect.left;
          clientRect.top -= containerRect.top;

          var page = Math.floor(clientRect.top / this.prop.pageSize.inner.height) + 1;
          var top = this.opt.margin[0] + clientRect.top % this.prop.pageSize.inner.height;
          var left = this.opt.margin[1] + clientRect.left;

          linkInfo.push({ page: page, top: top, left: left, clientRect: clientRect, link: link });
        }
      }, this);
    }
  });
};

Worker.prototype.toPdf = function toPdf() {
  return orig$1.toPdf.call(this).then(function toPdf_hyperlink() {
    // Add hyperlinks if the option is enabled.
    if (this.opt.enableLinks) {
      // Attach each anchor tag based on info from toContainer().
      linkInfo.forEach(function (l) {
        this.prop.pdf.setPage(l.page);
        this.prop.pdf.link(l.left, l.top, l.clientRect.width, l.clientRect.height, { url: l.link.href });
      }, this);

      // Reset the active page of the PDF to the final page.
      var nPages = this.prop.pdf.internal.getNumberOfPages();
      this.prop.pdf.setPage(nPages);
    }
  });
};

/**
 * Generate a PDF from an HTML element or string using html2canvas and jsPDF.
 *
 * @param {Element|string} source The source element or HTML string.
 * @param {Object=} opt An object of optional settings: 'margin', 'filename',
 *    'image' ('type' and 'quality'), and 'html2canvas' / 'jspdf', which are
 *    sent as settings to their corresponding functions.
 */
var html2pdf = function html2pdf(src, opt) {
  // Create a new worker with the given options.
  var worker = new html2pdf.Worker(opt);

  if (src) {
    // If src is specified, perform the traditional 'simple' operation.
    return worker.from(src).save();
  } else {
    // Otherwise, return the worker for new Promise-based operation.
    return worker;
  }
};
html2pdf.Worker = Worker;

return html2pdf;

})));

},{"es6-promise/auto":"kRE6","jspdf":"Up3p","html2canvas":"Tt9E"}],"Inql":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'HistoryTable',
  props: {
    searchToolSnapshot: {
      type: Array,
      required: true
    }
  }
};
exports.default = _default;
        var $83835d = exports.default || module.exports;
      
      if (typeof $83835d === 'function') {
        $83835d = $83835d.options;
      }
    
        /* template */
        Object.assign($83835d, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"history-table-export",staticStyle:{"width":"100%","font-size":"12px","padding":"12px 12px 0px 12px","display":"flex","flex-direction":"column"}},[_vm._m(0),_vm._v(" "),_c('div',{staticClass:"dt-body",staticStyle:{"display":"flex","flex-direction":"column","overflow":"auto","-webkit-overflow-scrolling":"touch","padding":"3px 4px 9px 4px"}},[_c('transition-group',{attrs:{"name":"list-element"}},_vm._l((_vm.searchToolSnapshot),function(entry){return _c('div',{key:entry.id,staticClass:"dt-row",staticStyle:{"display":"flex","border-radius":"3px","border-bottom":"solid 1px lightgray","background-color":"white","box-shadow":"0 3px 6px rgba(0, 0, 0, 0.16)","cursor":"pointer"}},[_c('div',{staticClass:"dt-cell id",staticStyle:{"display":"flex","flex":"0 0 40px","justify-content":"center","padding":"0","align-items":"center","height":"45px","font-weight":"600","border-right":"solid 1px lightgray"}},[_c('span',[_vm._v(_vm._s(entry.tool.id))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell name",staticStyle:{"display":"flex","justify-content":"flex-start","margin-left":"10px","align-items":"center","flex-direction":"row","height":"45px","font-weight":"600","flex":"0 0 calc(20% - 15px)"}},[_c('span',[_vm._v(_vm._s(((entry.tool.brand.name) + " " + (entry.tool.type.name))))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell name",staticStyle:{"display":"flex","justify-content":"flex-start","margin-left":"10px","align-items":"center","flex-direction":"row","height":"45px","font-weight":"600","flex":"0 0 calc(20% - 15px)"}},[_c('span',[_vm._v(_vm._s(entry.tool.owner.type === 'USER' ? ((entry.tool.owner.first_name) + " " + (entry.tool.owner.last_name)) : entry.tool.owner.name))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell name",staticStyle:{"display":"flex","justify-content":"flex-start","margin-left":"10px","align-items":"center","flex-direction":"row","height":"45px","font-weight":"600","flex":"0 0 calc(20% - 15px)"}},[_c('span',[_vm._v(_vm._s(entry.tool.status))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell date",staticStyle:{"display":"flex","justify-content":"center","align-items":"center","height":"45px","font-weight":"600","flex":"0 0 calc(20% - 15px)"}},[_c('span',[_vm._v(_vm._s(new Date(entry.metadata.timestamp).toLocaleDateString('en-US')))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell action",staticStyle:{"display":"flex","justify-content":"center","flex":"0 0 calc(20% - 15px)","align-items":"center","height":"45px","font-weight":"600"}},[_c('span',[_vm._v(_vm._s(entry.metadata.tool_action))])])])}))],1)])}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"dt-head",staticStyle:{"display":"flex","flex":"1 0 auto","border-radius":"3px","background-color":"#404040","font-size":"12px","max-height":"40px","height":"40px","align-items":"center","color":"#fff","text-align":"left","box-shadow":"0 3px 6px rgba(0, 0, 0, 0.16)","font-weight":"600"}},[_c('div',{staticClass:"dt-cell id",staticStyle:{"display":"flex","flex":"0 0 45px","justify-content":"center","padding":"0"}},[_c('span',[_vm._v("id")])]),_vm._v(" "),_c('div',{staticClass:"dt-cell tool",staticStyle:{"display":"flex","justify-content":"center","flex":"0 0 calc(20% - 15px)","margin-left":"10px"}},[_c('span',[_vm._v("tool")])]),_vm._v(" "),_c('div',{staticClass:"dt-cell tool",staticStyle:{"display":"flex","justify-content":"center","flex":"0 0 calc(20% - 15px)","margin-left":"10px"}},[_c('span',[_vm._v("assigned to")])]),_vm._v(" "),_c('div',{staticClass:"dt-cell tool",staticStyle:{"display":"flex","justify-content":"center","flex":"0 0 calc(20% - 15px)","margin-left":"10px"}},[_c('span',[_vm._v("status")])]),_vm._v(" "),_c('div',{staticClass:"dt-cell date",staticStyle:{"display":"flex","justify-content":"center","flex":"0 0 calc(20% - 15px)"}},[_c('span',[_vm._v("date")])]),_vm._v(" "),_c('div',{staticClass:"dt-cell action",staticStyle:{"display":"flex","justify-content":"center","flex":"0 0 calc(20% - 15px)"}},[_c('span',[_vm._v("action")])])])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"a4M8":[function(require,module,exports) {
var define;
;(function(root, factory) { // eslint-disable-line no-extra-semi
  var deepDiff = factory(root);
  // eslint-disable-next-line no-undef
  if (typeof define === 'function' && define.amd) {
      // AMD
      define('DeepDiff', function() { // eslint-disable-line no-undef
          return deepDiff;
      });
  } else if (typeof exports === 'object' || typeof navigator === 'object' && navigator.product.match(/ReactNative/i)) {
      // Node.js or ReactNative
      module.exports = deepDiff;
  } else {
      // Browser globals
      var _deepdiff = root.DeepDiff;
      deepDiff.noConflict = function() {
          if (root.DeepDiff === deepDiff) {
              root.DeepDiff = _deepdiff;
          }
          return deepDiff;
      };
      root.DeepDiff = deepDiff;
  }
}(this, function(root) {
  var validKinds = ['N', 'E', 'A', 'D'];

  // nodejs compatible on server side and in the browser.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }

  function Diff(kind, path) {
    Object.defineProperty(this, 'kind', {
      value: kind,
      enumerable: true
    });
    if (path && path.length) {
      Object.defineProperty(this, 'path', {
        value: path,
        enumerable: true
      });
    }
  }

  function DiffEdit(path, origin, value) {
    DiffEdit.super_.call(this, 'E', path);
    Object.defineProperty(this, 'lhs', {
      value: origin,
      enumerable: true
    });
    Object.defineProperty(this, 'rhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffEdit, Diff);

  function DiffNew(path, value) {
    DiffNew.super_.call(this, 'N', path);
    Object.defineProperty(this, 'rhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffNew, Diff);

  function DiffDeleted(path, value) {
    DiffDeleted.super_.call(this, 'D', path);
    Object.defineProperty(this, 'lhs', {
      value: value,
      enumerable: true
    });
  }
  inherits(DiffDeleted, Diff);

  function DiffArray(path, index, item) {
    DiffArray.super_.call(this, 'A', path);
    Object.defineProperty(this, 'index', {
      value: index,
      enumerable: true
    });
    Object.defineProperty(this, 'item', {
      value: item,
      enumerable: true
    });
  }
  inherits(DiffArray, Diff);

  function arrayRemove(arr, from, to) {
    var rest = arr.slice((to || from) + 1 || arr.length);
    arr.length = from < 0 ? arr.length + from : from;
    arr.push.apply(arr, rest);
    return arr;
  }

  function realTypeOf(subject) {
    var type = typeof subject;
    if (type !== 'object') {
      return type;
    }

    if (subject === Math) {
      return 'math';
    } else if (subject === null) {
      return 'null';
    } else if (Array.isArray(subject)) {
      return 'array';
    } else if (Object.prototype.toString.call(subject) === '[object Date]') {
      return 'date';
    } else if (typeof subject.toString === 'function' && /^\/.*\//.test(subject.toString())) {
      return 'regexp';
    }
    return 'object';
  }

  // http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/
  function hashThisString(string) {
    var hash = 0;
    if (string.length === 0) { return hash; }
    for (var i = 0; i < string.length; i++) {
      var char = string.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
  }

  // Gets a hash of the given object in an array order-independent fashion
  // also object key order independent (easier since they can be alphabetized)
  function getOrderIndependentHash(object) {
    var accum = 0;
    var type = realTypeOf(object);

    if (type === 'array') {
      object.forEach(function (item) {
        // Addition is commutative so this is order indep
        accum += getOrderIndependentHash(item);
      });

      var arrayString = '[type: array, hash: ' + accum + ']';
      return accum + hashThisString(arrayString);
    }

    if (type === 'object') {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          var keyValueString = '[ type: object, key: ' + key + ', value hash: ' + getOrderIndependentHash(object[key]) + ']';
          accum += hashThisString(keyValueString);
        }
      }

      return accum;
    }

    // Non object, non array...should be good?
    var stringToHash = '[ type: ' + type + ' ; value: ' + object + ']';
    return accum + hashThisString(stringToHash);
  }

  function deepDiff(lhs, rhs, changes, prefilter, path, key, stack, orderIndependent) {
    changes = changes || [];
    path = path || [];
    stack = stack || [];
    var currentPath = path.slice(0);
    if (typeof key !== 'undefined' && key !== null) {
      if (prefilter) {
        if (typeof (prefilter) === 'function' && prefilter(currentPath, key)) {
          return;
        } else if (typeof (prefilter) === 'object') {
          if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
            return;
          }
          if (prefilter.normalize) {
            var alt = prefilter.normalize(currentPath, key, lhs, rhs);
            if (alt) {
              lhs = alt[0];
              rhs = alt[1];
            }
          }
        }
      }
      currentPath.push(key);
    }

    // Use string comparison for regexes
    if (realTypeOf(lhs) === 'regexp' && realTypeOf(rhs) === 'regexp') {
      lhs = lhs.toString();
      rhs = rhs.toString();
    }

    var ltype = typeof lhs;
    var rtype = typeof rhs;
    var i, j, k, other;

    var ldefined = ltype !== 'undefined' ||
      (stack && (stack.length > 0) && stack[stack.length - 1].lhs &&
        Object.getOwnPropertyDescriptor(stack[stack.length - 1].lhs, key));
    var rdefined = rtype !== 'undefined' ||
      (stack && (stack.length > 0) && stack[stack.length - 1].rhs &&
        Object.getOwnPropertyDescriptor(stack[stack.length - 1].rhs, key));

    if (!ldefined && rdefined) {
      changes.push(new DiffNew(currentPath, rhs));
    } else if (!rdefined && ldefined) {
      changes.push(new DiffDeleted(currentPath, lhs));
    } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
      changes.push(new DiffEdit(currentPath, lhs, rhs));
    } else if (realTypeOf(lhs) === 'date' && (lhs - rhs) !== 0) {
      changes.push(new DiffEdit(currentPath, lhs, rhs));
    } else if (ltype === 'object' && lhs !== null && rhs !== null) {
      for (i = stack.length - 1; i > -1; --i) {
        if (stack[i].lhs === lhs) {
          other = true;
          break;
        }
      }
      if (!other) {
        stack.push({ lhs: lhs, rhs: rhs });
        if (Array.isArray(lhs)) {
          // If order doesn't matter, we need to sort our arrays
          if (orderIndependent) {
            lhs.sort(function (a, b) {
              return getOrderIndependentHash(a) - getOrderIndependentHash(b);
            });

            rhs.sort(function (a, b) {
              return getOrderIndependentHash(a) - getOrderIndependentHash(b);
            });
          }
          i = rhs.length - 1;
          j = lhs.length - 1;
          while (i > j) {
            changes.push(new DiffArray(currentPath, i, new DiffNew(undefined, rhs[i--])));
          }
          while (j > i) {
            changes.push(new DiffArray(currentPath, j, new DiffDeleted(undefined, lhs[j--])));
          }
          for (; i >= 0; --i) {
            deepDiff(lhs[i], rhs[i], changes, prefilter, currentPath, i, stack, orderIndependent);
          }
        } else {
          var akeys = Object.keys(lhs);
          var pkeys = Object.keys(rhs);
          for (i = 0; i < akeys.length; ++i) {
            k = akeys[i];
            other = pkeys.indexOf(k);
            if (other >= 0) {
              deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
              pkeys[other] = null;
            } else {
              deepDiff(lhs[k], undefined, changes, prefilter, currentPath, k, stack, orderIndependent);
            }
          }
          for (i = 0; i < pkeys.length; ++i) {
            k = pkeys[i];
            if (k) {
              deepDiff(undefined, rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
            }
          }
        }
        stack.length = stack.length - 1;
      } else if (lhs !== rhs) {
        // lhs is contains a cycle at this element and it differs from rhs
        changes.push(new DiffEdit(currentPath, lhs, rhs));
      }
    } else if (lhs !== rhs) {
      if (!(ltype === 'number' && isNaN(lhs) && isNaN(rhs))) {
        changes.push(new DiffEdit(currentPath, lhs, rhs));
      }
    }
  }

  function observableDiff(lhs, rhs, observer, prefilter, orderIndependent) {
    var changes = [];
    deepDiff(lhs, rhs, changes, prefilter, null, null, null, orderIndependent);
    if (observer) {
      for (var i = 0; i < changes.length; ++i) {
        observer(changes[i]);
      }
    }
    return changes;
  }

  function orderIndependentDeepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
    return deepDiff(lhs, rhs, changes, prefilter, path, key, stack, true);
  }

  function accumulateDiff(lhs, rhs, prefilter, accum) {
    var observer = (accum) ?
      function (difference) {
        if (difference) {
          accum.push(difference);
        }
      } : undefined;
    var changes = observableDiff(lhs, rhs, observer, prefilter);
    return (accum) ? accum : (changes.length) ? changes : undefined;
  }

  function accumulateOrderIndependentDiff(lhs, rhs, prefilter, accum) {
    var observer = (accum) ?
      function (difference) {
        if (difference) {
          accum.push(difference);
        }
      } : undefined;
    var changes = observableDiff(lhs, rhs, observer, prefilter, true);
    return (accum) ? accum : (changes.length) ? changes : undefined;
  }

  function applyArrayChange(arr, index, change) {
    if (change.path && change.path.length) {
      var it = arr[index],
        i, u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          applyArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          delete it[change.path[i]];
          break;
        case 'E':
        case 'N':
          it[change.path[i]] = change.rhs;
          break;
      }
    } else {
      switch (change.kind) {
        case 'A':
          applyArrayChange(arr[index], change.index, change.item);
          break;
        case 'D':
          arr = arrayRemove(arr, index);
          break;
        case 'E':
        case 'N':
          arr[index] = change.rhs;
          break;
      }
    }
    return arr;
  }

  function applyChange(target, source, change) {
    if (typeof change === 'undefined' && source && ~validKinds.indexOf(source.kind)) {
      change = source;
    }
    if (target && change && change.kind) {
      var it = target,
        i = -1,
        last = change.path ? change.path.length - 1 : 0;
      while (++i < last) {
        if (typeof it[change.path[i]] === 'undefined') {
          it[change.path[i]] = (typeof change.path[i + 1] !== 'undefined' && typeof change.path[i + 1] === 'number') ? [] : {};
        }
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          if (change.path && typeof it[change.path[i]] === 'undefined') {
            it[change.path[i]] = [];
          }
          applyArrayChange(change.path ? it[change.path[i]] : it, change.index, change.item);
          break;
        case 'D':
          delete it[change.path[i]];
          break;
        case 'E':
        case 'N':
          it[change.path[i]] = change.rhs;
          break;
      }
    }
  }

  function revertArrayChange(arr, index, change) {
    if (change.path && change.path.length) {
      // the structure of the object at the index has changed...
      var it = arr[index],
        i, u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          revertArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          it[change.path[i]] = change.lhs;
          break;
        case 'E':
          it[change.path[i]] = change.lhs;
          break;
        case 'N':
          delete it[change.path[i]];
          break;
      }
    } else {
      // the array item is different...
      switch (change.kind) {
        case 'A':
          revertArrayChange(arr[index], change.index, change.item);
          break;
        case 'D':
          arr[index] = change.lhs;
          break;
        case 'E':
          arr[index] = change.lhs;
          break;
        case 'N':
          arr = arrayRemove(arr, index);
          break;
      }
    }
    return arr;
  }

  function revertChange(target, source, change) {
    if (target && source && change && change.kind) {
      var it = target,
        i, u;
      u = change.path.length - 1;
      for (i = 0; i < u; i++) {
        if (typeof it[change.path[i]] === 'undefined') {
          it[change.path[i]] = {};
        }
        it = it[change.path[i]];
      }
      switch (change.kind) {
        case 'A':
          // Array was modified...
          // it will be an array...
          revertArrayChange(it[change.path[i]], change.index, change.item);
          break;
        case 'D':
          // Item was deleted...
          it[change.path[i]] = change.lhs;
          break;
        case 'E':
          // Item was edited...
          it[change.path[i]] = change.lhs;
          break;
        case 'N':
          // Item is new...
          delete it[change.path[i]];
          break;
      }
    }
  }

  function applyDiff(target, source, filter) {
    if (target && source) {
      var onChange = function (change) {
        if (!filter || filter(target, source, change)) {
          applyChange(target, source, change);
        }
      };
      observableDiff(target, source, onChange);
    }
  }

  Object.defineProperties(accumulateDiff, {

    diff: {
      value: accumulateDiff,
      enumerable: true
    },
    orderIndependentDiff: {
      value: accumulateOrderIndependentDiff,
      enumerable: true
    },
    observableDiff: {
      value: observableDiff,
      enumerable: true
    },
    orderIndependentObservableDiff: {
      value: orderIndependentDeepDiff,
      enumerable: true
    },
    orderIndepHash: {
      value: getOrderIndependentHash,
      enumerable: true
    },
    applyDiff: {
      value: applyDiff,
      enumerable: true
    },
    applyChange: {
      value: applyChange,
      enumerable: true
    },
    revertChange: {
      value: revertChange,
      enumerable: true
    },
    isConflict: {
      value: function () {
        return typeof $conflict !== 'undefined';
      },
      enumerable: true
    }
  });

  // hackish...
  accumulateDiff.DeepDiff = accumulateDiff;
  // ...but works with:
  // import DeepDiff from 'deep-diff'
  // import { DeepDiff } from 'deep-diff'
  // const DeepDiff = require('deep-diff');
  // const { DeepDiff } = require('deep-diff');

  if (root) {
    root.DeepDiff = accumulateDiff;
  }

  return accumulateDiff;
}));

},{}],"F5eQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _deepDiff = _interopRequireDefault(require("deep-diff"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          query getToolSnapshot($id: ID!) {\n            getToolSnapshot(tool_snapshot_id: $id) {\n              id\n              metadata {\n                action_note\n              }\n              tool {\n                id\n                status\n                photo\n                model_number\n                serial_number\n                brand {\n                  id\n                  name\n                }\n                type {\n                  id\n                  name\n                }\n                purchased_from {\n                  id\n                  name\n                }\n                owner {\n                  ... on Location {\n                    id\n                    name\n                    type\n                  }\n                  ... on User {\n                    id\n                    first_name\n                    last_name\n                    type\n                  }\n                }\n                date_purchased\n                price\n                year\n              }\n              metadata {\n                actor {\n                  id\n                  first_name\n                  last_name\n                }\n              }\n              previous_tool_snapshot {\n                tool {\n                  id\n                  status\n                  model_number\n                  serial_number\n                  brand {\n                    id\n                    name\n                  }\n                  type {\n                    id\n                    name\n                  }\n                  purchased_from {\n                    id\n                    name\n                  }\n                  owner {\n                    ... on Location {\n                      id\n                      name\n                      type\n                    }\n                    ... on User {\n                      id\n                      first_name\n                      last_name\n                      type\n                    }\n                  }\n                  date_purchased\n                  price\n                  year\n                }\n              }\n            }\n          }\n        "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'HistorySearchResult',
  props: {
    entry: {
      type: Object,
      required: true
    },
    selectTool: {
      type: Function,
      required: true
    },
    isDetailResult: {
      type: Boolean,
      required: true
    }
  },
  data: function data() {
    return {
      details: false,
      currentSnapshot: {},
      previousSnapshot: {},
      metadata: {},
      statusDiff: null,
      ownerDiff: null,
      diff: null
    };
  },
  computed: {
    diffMap: function diffMap() {
      var diffMap = {};
      return diffMap;
    },
    showingDetails: function showingDetails() {
      return this.details && this.$props.isDetailResult;
    },
    loadingDetail: function loadingDetail() {
      return this.currentSnapshot === null;
    },
    status: function status() {
      return this.statusDiff || this.$props.entry.tool.status;
    },
    owner: function owner() {
      return this.ownerDiff || this.ownerName;
    },
    actorName: function actorName() {
      if (this.currentSnapshot) {
        return '' || "".concat(this.metadata.actor.first_name, " ").concat(this.metadata.actor.last_name);
      }

      return '';
    },
    ownerName: function ownerName() {
      if (this.currentSnapshot) {
        if (this.currentSnapshot.owner.type === 'LOCATION') {
          return this.currentSnapshot.owner.name;
        }

        if (this.currentSnapshot.owner.type === 'USER') {
          return "".concat(this.currentSnapshot.owner.first_name, " ").concat(this.currentSnapshot.owner.last_name);
        }
      }

      return '';
    }
  },
  methods: {
    formatToUpper: function formatToUpper(tstring) {
      return tstring.replace(/_/g, ' ').toUpperCase();
    },
    formatToLower: function formatToLower(tstring) {
      return tstring.replace(/_/g, ' ').toLowerCase();
    },
    selectResult: function selectResult() {
      this.$props.selectTool(this.$props.entry.tool.id);
    },
    toggleDetails: function toggleDetails() {
      if (!this.showingDetails) {
        this.showDetails();
      } else {
        this.details = false;
      }
    },
    showDetails: function showDetails() {
      var _this = this;

      this.$apollo.query({
        query: (0, _graphqlTag.default)(_templateObject()),
        variables: {
          id: this.$props.entry.id
        }
      }).then(function (result) {
        _this.currentSnapshot = result.data.getToolSnapshot.tool;
        _this.metadata = result.data.getToolSnapshot.metadata;
        _this.previousSnapshot = result.data.getToolSnapshot.previous_tool_snapshot && result.data.getToolSnapshot.previous_tool_snapshot.tool;
        _this.diff = _this.findDiff(_this.previousSnapshot, _this.currentSnapshot);
        _this.details = true;
      });
    },
    findDiff: function findDiff(previous, current) {
      var _this2 = this;

      if (previous !== null) {
        previous.owner.name = previous.owner.name || previous.owner.first_name + ' ' + previous.owner.last_name;
        current.owner.name = current.owner.name || current.owner.first_name + ' ' + current.owner.last_name;

        var diff = _deepDiff.default.diff(previous, current);

        var finalDiff = [];

        if (diff) {
          diff.forEach(function (change) {
            if (change.path.indexOf('id') < 0 && change.path.indexOf('first_name') < 0 && change.path.indexOf('last_name') < 0 && change.path.indexOf('status') < 0 && change.path.indexOf('owner') < 0 && change.path.indexOf('photo') < 0) {
              if (change.path.indexOf('price') >= 0) {
                finalDiff.push({
                  lhs: change.lhs !== null ? "$".concat((change.lhs / 100).toFixed(2)) : null,
                  rhs: change.rhs !== null ? "$".concat((change.rhs / 100).toFixed(2)) : null,
                  path: change.path
                });
              } else if (change.path.indexOf('date_purchased') >= 0) {
                finalDiff.push({
                  lhs: change.lhs !== null ? new Date(change.lhs).toLocaleDateString('en-US') : null,
                  rhs: change.rhs !== null ? new Date(change.rhs).toLocaleDateString('en-US') : null,
                  path: change.path
                });
              } else {
                finalDiff.push(change);
              }
            }

            if (change.path.indexOf('owner') >= 0 && change.path.indexOf('first_name') < 0 && change.path.indexOf('last_name') < 0 && change.path.indexOf('type') < 0 && change.path.indexOf('__typename') < 0) {
              _this2.ownerDiff = change;
            }

            if (change.path.indexOf('status') >= 0) {
              _this2.statusDiff = change;
            }
          });
        }

        return finalDiff;
      } else {
        return null;
      }
    }
  }
};
exports.default = _default;
        var $e59030 = exports.default || module.exports;
      
      if (typeof $e59030 === 'function') {
        $e59030 = $e59030.options;
      }
    
        /* template */
        Object.assign($e59030, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"row-container"},[_c('div',{staticClass:"row",on:{"click":function($event){_vm.selectResult()}}},[_c('div',{staticClass:"dt-cell id",class:_vm.isDetailResult ? 'caret-box' : '',on:{"click":_vm.toggleDetails}},[(!_vm.isDetailResult)?_c('span',[_vm._v("\n        "+_vm._s(_vm.entry.tool.id)+"\n      ")]):_vm._e(),_vm._v(" "),(_vm.isDetailResult)?_c('i',{staticClass:"fas fa-angle-right",class:_vm.showingDetails ? 'down' : 'right'}):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"dt-cell name"},[_c('span',[_vm._v(_vm._s(((_vm.entry.tool.brand.name) + " " + (_vm.entry.tool.type.name))))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell date"},[_c('span',[_vm._v(_vm._s(new Date(_vm.entry.metadata.timestamp).toLocaleDateString('en-US')))])]),_vm._v(" "),_c('div',{staticClass:"dt-cell action"},[_c('span',[_vm._v(_vm._s(_vm.entry.metadata.tool_action.toLowerCase()))])])]),_vm._v(" "),_c('transition',{attrs:{"name":"history-detail"}},[(_vm.showingDetails)?_c('div',{staticClass:"details"},[_c('div',{staticClass:"detail-row"},[_c('span',{staticClass:"label"},[_vm._v("\n          TIME\n        ")]),_vm._v(" "),_c('span',{staticClass:"value"},[_vm._v("\n          "+_vm._s(new Date(_vm.entry.metadata.timestamp).toLocaleDateString('en-US') + ' ' + new Date(_vm.entry.metadata.timestamp).toLocaleTimeString('en-US'))+"\n        ")])]),_vm._v(" "),_c('div',{staticClass:"detail-row"},[_c('span',{staticClass:"label"},[_vm._v("\n          DONE BY\n        ")]),_vm._v(" "),_c('span',{staticClass:"value"},[_vm._v("\n          "+_vm._s(_vm.actorName)+"\n        ")])]),_vm._v(" "),_c('div',{staticClass:"detail-row"},[_c('span',{staticClass:"label"},[_vm._v("\n          STATUS\n        ")]),_vm._v(" "),(!_vm.statusDiff)?_c('span',{staticClass:"value"},[_vm._v("\n          "+_vm._s(_vm.formatToLower(_vm.status))+"\n        ")]):_vm._e(),_vm._v(" "),(_vm.statusDiff)?_c('span',{staticClass:"value"},[_c('span',{staticClass:"lhs"},[_vm._v("\n            "+_vm._s(_vm.formatToLower(_vm.status.lhs))+"\n          ")]),_vm._v(" "),_c('i',{staticClass:"fas fa-long-arrow-alt-right"}),_vm._v(" "),_c('span',{staticClass:"rhs"},[_vm._v("\n            "+_vm._s(_vm.formatToLower(_vm.status.rhs))+"\n          ")])]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"detail-row"},[_c('span',{staticClass:"label"},[_vm._v("\n          OWNER\n        ")]),_vm._v(" "),(!_vm.ownerDiff)?_c('span',{staticClass:"value"},[_vm._v("\n          "+_vm._s(_vm.formatToLower(_vm.owner))+"\n        ")]):_vm._e(),_vm._v(" "),(_vm.ownerDiff)?_c('span',{staticClass:"value"},[_c('span',{staticClass:"lhs"},[_vm._v("\n            "+_vm._s(_vm.formatToLower(_vm.owner.lhs))+"\n          ")]),_vm._v(" "),_c('i',{staticClass:"fas fa-long-arrow-alt-right"}),_vm._v(" "),_c('span',{staticClass:"rhs"},[_vm._v("\n            "+_vm._s(_vm.formatToLower(_vm.owner.rhs))+"\n          ")])]):_vm._e()]),_vm._v(" "),_vm._l(((_vm.diff || []).filter(function (d) { return !!d; })),function(change){return _c('div',{key:change.path[0],staticClass:"detail-row diff-row"},[_c('span',{staticClass:"label"},[_vm._v("\n          "+_vm._s(_vm.formatToUpper(change.path[0]))+"\n        ")]),_vm._v(" "),_c('span',{staticClass:"value"},[_c('span',{staticClass:"lhs"},[_vm._v("\n            "+_vm._s(change.lhs || '-')+"\n          ")]),_vm._v(" "),_c('i',{staticClass:"fas fa-long-arrow-alt-right"}),_vm._v(" "),_c('span',{staticClass:"rhs"},[_vm._v("\n            "+_vm._s(change.rhs || '-')+"\n          ")])])])}),_vm._v(" "),(_vm.metadata.action_note !== null)?_c('div',{staticClass:"detail-row diff-row"},[_c('span',{staticClass:"label"},[_vm._v("\n          NOTE\n        ")]),_vm._v(" "),_c('span',{staticClass:"value"},[_vm._v("\n          "+_vm._s(_vm.metadata.action_note)+"\n        ")])]):_vm._e()],2):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"graphql-tag":"MbWf","deep-diff":"a4M8"}],"YEEH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vue = _interopRequireDefault(require("vue"));

var _historySearchInput = _interopRequireDefault(require("../components/history-search-input"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab.vue"));

var _fab = _interopRequireDefault(require("../components/fab"));

var _html2pdf = _interopRequireDefault(require("html2pdf.js"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _historyTable = _interopRequireDefault(require("../components/history-table"));

var _historySearchResult = _interopRequireDefault(require("../components/history-search-result"));

var _statuses = _interopRequireDefault(require("../utils/statuses"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n              mutation recomissionTool($tool_id: ID!, $status: InServiceToolStatus!) {\n                recomissionTool(tool_id: $tool_id, recomissioned_status: $status) {\n                  status\n                }\n              }\n            "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["query searchToolSnapshot($toolSnapshotFilter: ToolSnapshotFilter){\n        searchToolSnapshot(toolSnapshotFilter: $toolSnapshotFilter){\n          id\n          tool {\n            id\n            brand {\n              id\n              name\n            }\n            type {\n              id,\n              name\n            }\n            status\n            owner {\n              ... on Location {\n                 id\n                 name\n                 type\n              }\n              ... on User {\n                 id\n                 first_name\n                 last_name\n                 type\n              }\n            }\n          }\n          metadata {\n            timestamp,\n            tool_action\n          }\n        }\n      }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'History',
  components: {
    HistorySearchInput: _historySearchInput.default,
    Fab: _fab.default,
    ExtendedFab: _extendedFab.default,
    HistoryTable: _historyTable.default,
    HistorySearchResult: _historySearchResult.default
  },
  apollo: {
    searchToolSnapshot: {
      query: (0, _graphqlTag.default)(_templateObject()),
      variables: function variables() {
        return {
          toolSnapshotFilter: _objectSpread({
            only_latest_snapshot: !this.currentToolId,
            tool_ids: this.currentToolId
          }, this.filters)
        };
      },
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    return {
      filterMap: {
        USER: 'owner_ids',
        LOCATION: 'owner_ids',
        ACTION: 'tool_actions',
        TOOL: 'tool_ids',
        BRAND: 'brand_ids',
        TYPE: 'type_ids',
        STATUS: 'tool_statuses'
      },
      currentToolId: this.$router.currentRoute.params.toolId,
      searchToolSnapshot: [],
      tags: [],
      tagFilters: null,
      dateRange: null,
      isDatepickerShown: false,
      loading: false
    };
  },
  computed: {
    isDecomissionedTool: function isDecomissionedTool() {
      return this.searchToolSnapshot[0] && this.currentToolId ? this.searchToolSnapshot[0].tool.status === _statuses.default.BEYOND_REPAIR || this.searchToolSnapshot[0].tool.status === _statuses.default.LOST_OR_STOLEN : false;
    },
    datePickerVisibility: function datePickerVisibility() {
      return this.isDatepickerShown ? 'visible' : 'hidden';
    },
    isNativeApp: function isNativeApp() {
      return !!window.device && !!window.device.cordova;
    },
    dateRangeFilter: function dateRangeFilter() {
      var dateRange;

      if (this.dateRange) {
        dateRange = {};
        var startTime = new Date(this.dateRange.start);
        var endTime = new Date(this.dateRange.end);
        endTime.setDate(endTime.getDate() + 1);
        endTime.setUTCHours(0);
        startTime.setUTCHours(0);
        dateRange.start_time = startTime.toISOString();
        dateRange.end_time = endTime.toISOString();
      }

      return dateRange;
    },
    filters: function filters() {
      return _objectSpread({
        time_span: this.dateRangeFilter
      }, this.tagFilters);
    }
  },
  methods: {
    recover: function recover() {
      var _this = this;

      (0, _sweetalert.default)({
        type: 'warning',
        title: 'CONFIRM RECOVERY',
        text: "Are you sure you want to recover this tool?",
        reverseButtons: true,
        showCancelButton: true,
        confirmButtonText: 'RECOVER',
        cancelButtonText: 'CANCEL',
        confirmButtonColor: '#CE352F'
      }).then(function (result) {
        if (result.value) {
          _this.$apollo.mutate({
            mutation: (0, _graphqlTag.default)(_templateObject2()),
            variables: {
              tool_id: _this.$router.currentRoute.params.toolId,
              status: 'AVAILABLE'
            }
          }).then(function (result) {
            (0, _sweetalert.default)({
              type: 'success',
              title: 'TOOL RECOVERED',
              timer: 1500
            });

            _this.$apollo.queries.searchToolSnapshot.refresh();
          });
        }
      });
    },
    goBack: function goBack() {
      this.currentToolId = null;
      this.$router.go(-1);
    },
    selectHistoryEntry: function selectHistoryEntry(toolId) {
      this.$router.push({
        name: 'historyDetail',
        params: {
          toolId: toolId
        }
      });
      this.clearFilters();
      this.currentToolId = toolId;
    },
    clearFilters: function clearFilters() {
      this.dateRange = null;
      this.tagFilters = null;
      this.updateTagFilters();
    },
    updateDateFilterTag: function updateDateFilterTag() {
      if (this.dateRange) {
        var idx = this.tags.findIndex(function (tag) {
          return tag.isDatespanFilter;
        });
        var startTime = new Date(this.dateRange.start);
        var endTime = new Date(this.dateRange.end);
        var dateRangeTag = {
          isDatespanFilter: true,
          text: "".concat(startTime.getMonth(), "/").concat(startTime.getDate(), "-").concat(endTime.getMonth(), "/").concat(endTime.getDate()),
          name: "".concat(startTime.getMonth(), "/").concat(startTime.getDate(), "-").concat(endTime.getMonth(), "/").concat(endTime.getDate()),
          iconClass: 'fa-calendar-alt'
        };

        if (idx > -1) {
          _vue.default.set(this.tags, idx, dateRangeTag);
        } else {
          this.tags.push(dateRangeTag);
        }
      }
    },
    toggleDatepicker: function toggleDatepicker() {
      this.isDatepickerShown = !this.isDatepickerShown;
      this.updateDateFilterTag();
    },
    exportTable: function exportTable() {
      var _this2 = this;

      this.loading = true;
      var element = document.querySelector('.history-table-export');
      var opt = {
        filename: 'transactions_export.pdf',
        image: {
          type: 'jpeg',
          quality: 1
        },
        html2canvas: {
          scale: 2
        },
        margin: 0.5,
        pagebreak: {
          mode: 'avoid-all'
        },
        jsPDF: {
          unit: 'in',
          format: 'letter',
          orientation: 'portrait'
        }
      };
      (0, _html2pdf.default)().from(element).set(opt).save().then(function () {
        _this2.loading = false;
      });
    },
    printTable: function printTable() {
      var element = document.querySelector('.history-table-export');
      window.cordova.plugins.printer.print(element, {
        name: 'retina_history.html',
        landscape: true
      });
    },
    checkDateFilter: function checkDateFilter() {
      var hasDateFilter = this.tags.some(function (tag) {
        return tag.isDatespanFilter;
      });

      if (!hasDateFilter && this.dateRange) {
        this.dateRange = null;
      }
    },
    updateTagFilters: function updateTagFilters() {
      var _this3 = this;

      var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.tags = filters;
      var newFilters = filters.length ? {} : null;
      filters.forEach(function (filter) {
        if (!filter.isDatespanFilter) {
          var key = _this3.filterMap[filter.type];

          if (!newFilters[key]) {
            newFilters[key] = [filter.id];
          } else {
            newFilters[key].push(filter.id);
          }
        }
      });
      this.checkDateFilter();
      this.tagFilters = newFilters;
    }
  }
};
exports.default = _default;
        var $873f7a = exports.default || module.exports;
      
      if (typeof $873f7a === 'function') {
        $873f7a = $873f7a.options;
      }
    
        /* template */
        Object.assign($873f7a, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page history-page"},[_c('history-table',{attrs:{"search-tool-snapshot":_vm.searchToolSnapshot}}),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.loading)?_c('div',{staticClass:"overlay"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"search-bar"},[_c('history-search-input',{attrs:{"allow-tool-id-search":!_vm.currentToolId,"update-tags":_vm.updateTagFilters,"tags":_vm.tags}}),_vm._v(" "),_c('v-date-picker',{attrs:{"input-props":{ readonly: true },"attributes":[{ popover: { visibility: 'hidden' } }],"max-date":new Date(),"popover-visibility":_vm.datePickerVisibility,"popover-direction":"bottom","popover-align":"right","mode":"range"},on:{"input":_vm.toggleDatepicker},scopedSlots:_vm._u([{key:"default",fn:function(scope){return _c('button',{staticClass:"fas fa-calendar-alt open-datepicker",class:{ active: !!_vm.dateRange },on:{"click":_vm.toggleDatepicker}})}}]),model:{value:(_vm.dateRange),callback:function ($$v) {_vm.dateRange=$$v},expression:"dateRange"}})],1),_vm._v(" "),_c('div',{staticClass:"history-main-content"},[(_vm.$mq === 'mobile' && _vm.isNativeApp)?_c('fab',{staticClass:"print-btn",attrs:{"on-click":_vm.printTable,"icon-class":"fa-print"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'mobile' && !_vm.isNativeApp)?_c('fab',{staticClass:"print-btn",attrs:{"on-click":_vm.exportTable,"icon-class":"fa-file-pdf"}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"floating-action-bar"},[(_vm.$mq === 'desktop' && _vm.isNativeApp)?_c('extended-fab',{attrs:{"on-click":_vm.printTable,"icon-class":"fa-print","button-text":"PRINT"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && !_vm.isNativeApp)?_c('extended-fab',{attrs:{"on-click":_vm.exportTable,"icon-class":"fa-file-pdf","button-text":"DOWNLOAD"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.isDecomissionedTool)?_c('extended-fab',{attrs:{"on-click":_vm.recover,"icon-class":"fa-undo-alt","button-text":"RECOVER"}}):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"report"},[(!_vm.currentToolId)?_c('span',{staticClass:"title",staticStyle:{"text-align":"center","font-weight":"600"}},[_vm._v("\n        LATEST TRANSACTIONS\n      ")]):_vm._e(),_vm._v(" "),(_vm.currentToolId)?_c('span',{staticClass:"title"},[_c('span',{staticClass:"fas fa-arrow-left back",on:{"click":_vm.goBack}}),_vm._v("\n        #"+_vm._s(_vm.currentToolId)+" "+_vm._s(_vm.searchToolSnapshot[0] && _vm.searchToolSnapshot[0].tool.brand.name)+" "+_vm._s(_vm.searchToolSnapshot[0] && _vm.searchToolSnapshot[0].tool.type.name)+"\n      ")]):_vm._e(),_vm._v(" "),_c('div',{attrs:{"id":"export-table"}},[_c('transition',{attrs:{"name":"list-loading"}},[(_vm.$apollo.queries.searchToolSnapshot.loading)?_c('div',{staticClass:"loading-container"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"dt-body"},[_c('transition-group',{attrs:{"name":"list-element"}},_vm._l((_vm.searchToolSnapshot),function(entry){return _c('history-search-result',{key:entry.id,attrs:{"entry":entry,"select-tool":_vm.selectHistoryEntry,"is-detail-result":!!_vm.currentToolId}})}))],1)],1),_vm._v(" "),(_vm.$mq === 'mobile' && _vm.isDecomissionedTool)?_c('extended-fab',{staticClass:"restore-efab",attrs:{"on-click":_vm.recover,"button-text":"RECOVER","icon-class":"fa-undo-alt"}}):_vm._e()],1)],1)],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"vue":"4673","../components/history-search-input":"IPWF","../components/extended-fab.vue":"9Y+B","../components/fab":"TC0j","html2pdf.js":"km1w","graphql-tag":"MbWf","sweetalert2":"Y8u2","../components/history-table":"Inql","../components/history-search-result":"F5eQ","../utils/statuses":"HBwF"}],"W0L9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'ButtonDropdown',
  props: {
    iconClass: {
      type: String,
      required: false,
      default: 'fa-pen'
    },
    buttonText: {
      type: String,
      required: true
    },
    options: {
      type: Array,
      required: true
    },
    onClick: {
      type: Function,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    flag: {
      type: Function,
      required: false,
      default: function _default() {}
    }
  },
  data: function data() {
    return {
      activated: false
    };
  },
  methods: {
    clickOption: function clickOption(selectedOption) {
      this.onClick(selectedOption);
      this.flag();
      this.activated = false;
    },
    toggle: function toggle() {
      if (!this.disabled) {
        this.activated = !this.activated;
      }

      this.flag();
    },
    filteredOptions: function filteredOptions() {
      var array = this.options;
      var index = array.indexOf(this.buttonText);

      if (index !== -1) {
        array.splice(index, 1);
      }

      return array;
    }
  }
};
exports.default = _default;
        var $589eb0 = exports.default || module.exports;
      
      if (typeof $589eb0 === 'function') {
        $589eb0 = $589eb0.options;
      }
    
        /* template */
        Object.assign($589eb0, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container",class:{ disabled: _vm.disabled }},[_c('transition',{attrs:{"name":"fade"}},[(_vm.activated)?_c('div',{staticClass:"scrim",on:{"click":_vm.toggle}}):_vm._e()]),_vm._v(" "),_c('button',{staticClass:"button",on:{"click":_vm.toggle}},[_c('div',{staticClass:"fab-icon-container"},[(!_vm.activated)?_c('i',{staticClass:"fas",class:_vm.iconClass}):_vm._e()]),_vm._v(" "),(!_vm.activated)?_c('span',{staticClass:"text"},[_vm._v("\n      "+_vm._s(_vm.buttonText)+"\n    ")]):_vm._e(),_vm._v(" "),(_vm.activated)?_c('i',{staticClass:"close fas fa-times"}):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.activated)?_c('div',{staticClass:"options"},_vm._l((_vm.options),function(option){return _c('button',{key:option,staticClass:"option button slide-item",on:{"click":function($event){_vm.clickOption(option)}}},[_vm._v("\n        "+_vm._s(option)+"\n      ")])})):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"U77M":[function(require,module,exports) {
module.exports = function(string, index, replacement, options) {
  if (typeof(string) !== 'string') {
    throw new TypeError('Expected a string but got: ' + typeof(string));
  } else if (typeof(index) !== 'number') {
    throw new TypeError('Expected a number but got: ' + typeof(index));
  } else if(typeof(replacement) !== 'string') {
    throw new TypeError('Expected a string but got: ' + typeof(replacement));
  }

  if (index > string.length) {
    throw new RangeError('Index is out of range');
  }

  options = Object.assign({
    inline: false
  }, options);

  if (options['inline']) {
    return string.substring(0, index) + replacement + string.substring(index + replacement.length);
  } else {
    return string.substring(0, index) + replacement + string.substring(index + 1);
  }
}

},{}],"vTXv":[function(require,module,exports) {
const replaceAt = require('replace-at')
const privateMethods = {
  convertSingleChar(char) {
    const keyboard = {
      2: ['a', 'b', 'c'],
      3: ['d', 'e', 'f'],
      4: ['g', 'h', 'i'],
      5: ['j', 'k', 'l'],
      6: ['m', 'n', 'o'],
      7: ['p', 'q', 'r', 's'],
      8: ['t', 'u', 'v'],
      9: ['w', 'x', 'y', 'z']
    }

    let value = char;

    Object.keys(keyboard).forEach(function(key) {
      if (keyboard[key].includes(String(char).toLowerCase())) {
        value = key;
      }
    });

    return value;
  }
}

let types = {
  local: {
    key: 'XXX-XXXX',
    length: '7',
    delimiters: {
      number: 'X',
      areaCode: 'Y',
    }
  },
  domestic: {
    key: '(XXX) XXX-XXXX',
    length: '10',
    delimiters: {
      number: 'X',
      areaCode: 'Y',
    }
  },
  international: {
    key: '+YYY (XXX) XXX-XXXX',
    length: '11',
    delimiters: {
      number: 'X',
      areaCode: 'Y',
    }
  }
}

module.exports = class phoneNumberFormatter {
  constructor(string) {
    if (typeof string !== 'string') {
      throw new TypeError('Expected a string but got type: ' + typeof(number));
    }
    this.string = string;
    this.type = null;
    this.areaCode = null;
  }

  format(options) {
    options = Object.assign({
      type: 'local',
      areaCode: '',
      separator: '',
      letters: true
    }, options);

    // Check if type exists
    if (!types[options['type']]) {
     throw new TypeError('Type of name `' + options['type'] + '` does not exist');
    }

    let key = types[options['type']]['key'];
    let keyLength = types[options['type']]['length'];

    if (options['letters']) {
      // Remove all but letters and numbers
      this.string = this.string.replace(/[^a-zA-Z0-9]/g, '');
    } else {
      // Remove all but numbers
      this.string = this.string.replace(/\D/g, '');
    }

    if (this.string.length < keyLength) {
      // Allows too-short numbers to be converted to international with an area code
      if (this.string.length + options['areaCode'].length < keyLength && options['type'] !== 'international') {
        throw new TypeError('Expected a sufficient number of numbers. Needed ' + keyLength + ' but got: ' + this.string.length);
      }
    }

    // Set string to the area code and the number minus the area code (assumes type is international)
    if (options['areaCode'] && options['type'] === 'international') {
      this.string = options['areaCode'] + this.string.substring(this.string.length - types['international']['length'] + 1);
    }

    let index;
    let i;
    let numberDelimiter = types[options['type']]['delimiters']['number'];
    let areaCodeDelimiter = types[options['type']]['delimiters']['areaCode'];
    let newString = key;
    if (!options['areaCode']) {
      for (i = this.string.length - 1; i >= 0; i--) {
        if (!newString.includes(numberDelimiter) && !newString.includes(areaCodeDelimiter)) break;

        let X = newString.lastIndexOf(numberDelimiter);
        let Y = newString.lastIndexOf(areaCodeDelimiter);
        if (X > Y) {
          index = X;
        } else {
          index = Y;
          options['areaCode'] += this.string[i];
        }
        newString = replaceAt(newString, index, this.string[i]);
      }
    } else {
      for (i = this.string.length - 1; i >= 0; i--) {
        if (!newString.includes('X')) break;

        index = newString.lastIndexOf(numberDelimiter);
        newString = replaceAt(newString, index, this.string[i]);
      }
      for (i = options['areaCode'].length - 1; i >= 0; i--) {
        if (!newString.includes(areaCodeDelimiter)) break;

        index = newString.lastIndexOf(areaCodeDelimiter);
        newString = replaceAt(newString, index, options['areaCode'][i]);
      }
    }

    // Remove excess delimiters
    newString = newString.replace(new RegExp(numberDelimiter + '|' + areaCodeDelimiter, 'g'), '');
    this.string = newString;

    // If a separator, remove and replace non-numeric characters
    if (options['separator']) {
      this.string = this.string.replace(/[()]/g, '');
      // If letters are allowed, don't remove them
      if (options['letters']) {
        this.string = this.string.replace(/[^a-zA-Z0-9+]/g, options['separator']);
      } else {
        this.string = this.string.replace(/[^0-9+]/g, options['separator']);
      }
    }

    this.type = options['type'];
    this.areaCode = options['areaCode'] === '' ? null : options['areaCode'];

    return this;
  }

  convert() {
    let letter = '';
    for (var i = this.string.length - 1; i >= 0; i--) {
      this.string = replaceAt(this.string, i, privateMethods.convertSingleChar(this.string[i]))
    }

    return this;
  }

  toString() {
    return this.string;
  }

  getType() {
    return this.type;
  }

  getAreaCode() {
    return this.areaCode;
  }
}

module.exports.addType = function(name, string, options) {
  options = Object.assign({
    number: 'X',
    areaCode: 'Y'
  }, options);

  types[name] = {
    key: string,
    length: string.replace(/[^0-9]/g, '').length,
    delimiters: {
      number: options['number'],
      areaCode: options['areaCode']
    }
  }

  return true;
}

 module.exports.getType = function(name) {
   if (!types[name]) {
     throw new TypeError('Type of name `' + name + '` does not exist');
   }

   return (types[name]['key']);
 }

},{"replace-at":"U77M"}],"puwS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _fab = _interopRequireDefault(require("../components/fab"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab"));

var _buttonDropdown = _interopRequireDefault(require("../components/button-dropdown"));

var _roles = _interopRequireDefault(require("../utils/roles"));

var _phoneNumberFormats = _interopRequireDefault(require("phone-number-formats"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject6() {
  var data = _taggedTemplateLiteral(["\n            mutation updateStatus($user: UpdatedUser!) {\n              updateUser(updatedUser: $user) {\n                role\n              }\n            }\n          "]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["\n                   fragment patchUser on User {\n                     first_name\n                     last_name\n                     email\n                     phone_number\n                     role\n                     status\n                     __typename\n                   }\n                  "]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n                mutation updateStatus($user: UpdatedUser!) {\n                  updateUser(updatedUser: $user) {\n                    id\n                    first_name\n                    last_name\n                    email\n                    phone_number\n                    role\n                    status\n                  }\n                }\n              "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n                query {\n                  getAllUser {\n                    id\n                    first_name\n                    last_name\n                    role\n                  }\n                }\n              "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["mutation deleteUser($updatedUser: UpdatedUser!) {\n              updateUser(updatedUser: $updatedUser) {\n                id\n              }\n            }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        query users($user_id: ID!) {\n          getUser(user_id: $user_id) {\n            id\n            first_name\n            last_name\n            email\n            phone_number\n            role\n            status\n          }\n        }\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'ToolDetail',
  components: {
    Fab: _fab.default,
    ExtendedFab: _extendedFab.default,
    ButtonDropdown: _buttonDropdown.default
  },
  apollo: {
    getUser: {
      query: (0, _graphqlTag.default)(_templateObject()),
      variables: function variables() {
        var options = {};
        options.user_id = this.$router.currentRoute.params.userId;
        return options;
      },
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    return {
      getUser: {},
      roles: Object.values(_roles.default),
      editState: false,
      newFirstName: '',
      newLastName: '',
      newPhone: '',
      newEmail: '',
      changingRole: false
    };
  },
  computed: {
    isCurrentUser: function isCurrentUser() {
      return JSON.parse(window.localStorage.getItem('currentUser')).id === this.getUser.id;
    },
    isAdmin: function isAdmin() {
      return JSON.parse(window.localStorage.getItem('currentUser')).role === _roles.default.ADMIN;
    },
    canEdit: function canEdit() {
      return this.isAdmin || this.isCurrentUser;
    },
    formattedPhone: function formattedPhone() {
      if (this.getUser && this.getUser.phone_number) {
        return new _phoneNumberFormats.default(this.getUser.phone_number).format({
          type: 'domestic'
        }).string;
      }

      return '';
    },
    phoneNumber: function phoneNumber() {
      return this.getUser.phone_number;
    },
    email: function email() {
      return this.getUser.email;
    }
  },
  methods: {
    showSuccessfulDeleteMsg: function showSuccessfulDeleteMsg() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'SUCCESS',
        text: 'Successfully Delete User',
        timer: 1500,
        showConfirmButton: false
      });
    },
    deactivateUser: function deactivateUser() {
      var _this = this;

      (0, _sweetalert.default)({
        type: 'warning',
        title: 'CONFIRM DELETE USER',
        text: "Are You Sure You Want To Delete ".concat(this.getUser.first_name, " ").concat(this.getUser.last_name, "? This Action Cannot Be Undone"),
        reverseButtons: true,
        showCancelButton: true,
        confirmButtonText: 'DELETE',
        cancelButtonText: 'CANCEL',
        confirmButtonColor: '#CE352F'
      }).then(function (result) {
        if (result.value) {
          _this.getUser.status = 'INACTIVE';

          _this.$apollo.mutate({
            mutation: (0, _graphqlTag.default)(_templateObject2()),
            variables: {
              updatedUser: {
                id: _this.getUser.id,
                first_name: _this.newFirstName,
                last_name: _this.newLastName,
                email: _this.newEmail,
                phone_number: _this.newPhone,
                role: _this.getUser.role,
                status: _this.getUser.status
              }
            },
            refetchQueries: [{
              query: (0, _graphqlTag.default)(_templateObject3())
            }]
          }).then(function () {
            _this.showSuccessfulDeleteMsg();

            _this.transitionToUsers();
          });
        }
      });
    },
    toggleChangingRole: function toggleChangingRole() {
      this.changingRole = !this.changingRole;
    },
    transitionToUsers: function transitionToUsers() {
      this.$router.push({
        name: 'users'
      });
    },
    cancelEdit: function cancelEdit() {
      this.editState = false;
    },
    toggleEditState: function toggleEditState() {
      if (this.editState) {
        this.saveUser();
      } else {
        this.newFirstName = this.getUser.first_name;
        this.newLastName = this.getUser.last_name;
        this.newPhone = this.getUser.phone_number;
        this.newEmail = this.getUser.email;
        this.editState = true;
      }
    },
    saveUser: function saveUser() {
      var _this2 = this;

      this.$validator.validate().then(function (result) {
        if (result) {
          _this2.$apollo.mutate({
            mutation: (0, _graphqlTag.default)(_templateObject4()),
            variables: {
              user: {
                id: _this2.getUser.id,
                first_name: _this2.newFirstName,
                last_name: _this2.newLastName,
                email: _this2.newEmail,
                phone_number: _this2.newPhone,
                role: _this2.getUser.role,
                status: _this2.getUser.status
              }
            }
          }).then(function (result) {
            if (result) {
              _this2.$apollo.queries.getUser.refetch();

              var _result$data$updateUs = result.data.updateUser,
                  id = _result$data$updateUs.id,
                  first_name = _result$data$updateUs.first_name,
                  last_name = _result$data$updateUs.last_name,
                  email = _result$data$updateUs.email,
                  phone_number = _result$data$updateUs.phone_number,
                  role = _result$data$updateUs.role,
                  status = _result$data$updateUs.status;

              _this2.$apollo.provider.clients.defaultClient.writeFragment({
                id: "".concat(id, "User"),
                fragment: (0, _graphqlTag.default)(_templateObject5()),
                data: {
                  first_name: first_name,
                  last_name: last_name,
                  email: email,
                  phone_number: phone_number,
                  role: role,
                  status: status,
                  __typename: 'User'
                }
              });

              _this2.editState = false;
            }
          }).catch(function () {
            (0, _sweetalert.default)({
              type: 'error',
              title: 'ERROR',
              text: 'There was an error saving changes. Please try again.',
              timer: 2000,
              showConfirmButton: false
            });
          });
        }
      });
    },
    updateRole: function updateRole(newRole) {
      var _this3 = this;

      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject6()),
        variables: {
          user: {
            id: this.getUser.id,
            first_name: this.getUser.first_name,
            last_name: this.getUser.last_name,
            email: this.getUser.email,
            phone_number: this.getUser.phone_number,
            role: newRole,
            status: this.getUser.status
          }
        }
      }).then(function (result) {
        if (result) {
          _this3.$apollo.queries.getUser.refetch();
        }
      });
    },
    phoneCall: function phoneCall() {
      window.location.href = "tel:".concat(this.getUser.phone_number);
    },
    sendEmail: function sendEmail() {
      window.location = "mailto:".concat(this.getUser.email);
    }
  }
};
exports.default = _default;
        var $c29e33 = exports.default || module.exports;
      
      if (typeof $c29e33 === 'function') {
        $c29e33 = $c29e33.options;
      }
    
        /* template */
        Object.assign($c29e33, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page user-detail-page"},[_c('div',{staticClass:"info-menu-container"},[_c('div',{staticClass:"floating-action-bar"},[(_vm.$mq === 'desktop')?_c('extended-fab',{staticClass:"action-btn transfer-btn",attrs:{"on-click":_vm.transitionToUsers,"outline-display":true,"icon-class":"fa-arrow-left","button-text":"BACK"}}):_vm._e(),_vm._v(" "),(_vm.canEdit && _vm.$mq === 'desktop')?_c('extended-fab',{attrs:{"on-click":_vm.toggleEditState,"icon-class":_vm.editState ? 'fa-save' : 'fa-pen',"disabled":_vm.changingRole,"button-text":_vm.editState ? 'SAVE CHANGES' : 'EDIT USER'}}):_vm._e(),_vm._v(" "),(_vm.editState && _vm.$mq === 'desktop')?_c('extended-fab',{attrs:{"on-click":_vm.cancelEdit,"disabled":_vm.changingRole,"icon-class":"fa-times","button-text":"CANCEL"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.isAdmin)?_c('button-dropdown',{attrs:{"on-click":_vm.updateRole,"options":_vm.roles,"flag":_vm.toggleChangingRole,"disabled":_vm.editState,"button-text":"CHANGE ROLE"}}):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"header-cards-container"},[_c('div',{staticClass:"header"},[(_vm.$mq === 'mobile')?_c('router-link',{staticClass:"fas fa-arrow-left",attrs:{"id":"backarrow","to":"/users/"}}):_vm._e(),_vm._v(" "),_c('span',{attrs:{"id":"userid"}},[_vm._v("\n          #"+_vm._s(_vm.getUser.id)+"\n        ")]),_vm._v(" "),(!_vm.editState)?_c('div',{staticClass:"name"},[_vm._v("\n          "+_vm._s(_vm.getUser.first_name)+" "+_vm._s(_vm.getUser.last_name)+"\n        ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('div',{staticClass:"name-inputs"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.newFirstName),expression:"newFirstName"}],staticClass:"name light-input",attrs:{"name":"first name"},domProps:{"value":(_vm.newFirstName)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newFirstName=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('first name')),expression:"errors.has('first name')"}],staticClass:"error"},[_vm._v("\n              "+_vm._s(_vm.errors.first('first name'))+"\n            ")])]),_vm._v(" "),_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.newLastName),expression:"newLastName"}],staticClass:"name light-input",attrs:{"name":"last name"},domProps:{"value":(_vm.newLastName)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newLastName=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('last name')),expression:"errors.has('last name')"}],staticClass:"error"},[_vm._v("\n              "+_vm._s(_vm.errors.first('last name'))+"\n            ")])])]):_vm._e(),_vm._v(" "),_c('span',{staticClass:"user-role"},[_vm._v("\n          "+_vm._s(_vm.getUser.role)+"\n        ")]),_vm._v(" "),(_vm.isAdmin)?_c('div',{staticClass:"actions"},[(_vm.$mq === 'mobile' && _vm.isAdmin)?_c('button-dropdown',{attrs:{"on-click":_vm.updateRole,"options":_vm.roles,"button-text":"CHANGE ROLE"}}):_vm._e()],1):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"cards"},[_c('div',{staticClass:"card",attrs:{"id":"contact-card"}},[_c('div',{staticClass:"card-title"},[_vm._v("\n            Contact\n          ")]),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('phone')),expression:"errors.has('phone')"}],staticClass:"error"},[_vm._v("\n              "+_vm._s(_vm.errors.first('phone'))+"\n            ")])]),_vm._v(" "),_c('div',{staticClass:"card-details contact-details"},[_c('div',{staticClass:"contact-buttons"},[_c('div',{staticClass:"contact-item"},[_c('fab',{attrs:{"id":"call-btn","on-click":_vm.phoneNumber ? _vm.phoneCall : function () { return 0; },"active":!_vm.phoneNumber,"icon-class":"fa-phone"}}),_vm._v(" "),(!_vm.editState)?_c('button',{staticClass:"contact-text",on:{"click":function($event){_vm.phoneNumber ? _vm.phoneCall() : function () { return 0; }}}},[_vm._v("\n                  "+_vm._s(_vm.formattedPhone)+"\n                ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('input',{directives:[{name:"validate",rawName:"v-validate",value:({required: true, numeric: true, min: 10}),expression:"{required: true, numeric: true, min: 10}"},{name:"model",rawName:"v-model",value:(_vm.newPhone),expression:"newPhone"}],staticClass:"contact-text light-input",attrs:{"name":"phone","type":"number"},domProps:{"value":(_vm.newPhone)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newPhone=$event.target.value}}}):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"contact-item"},[_c('fab',{attrs:{"id":"email-btn","on-click":_vm.email ? _vm.sendEmail : function () { return 0; },"active":!_vm.email,"icon-class":"fa-envelope","type":"string"}}),_vm._v(" "),(!_vm.editState)?_c('button',{staticClass:"contact-text",on:{"click":function($event){_vm.email ? _vm.sendEmail() : function () { return 0; }}}},[_vm._v("\n                  "+_vm._s(_vm.getUser.email)+"\n                ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required|email'),expression:"'required|email'"},{name:"model",rawName:"v-model",value:(_vm.newEmail),expression:"newEmail"}],staticClass:"contact-text light-input",attrs:{"name":"email"},domProps:{"value":(_vm.newEmail)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newEmail=$event.target.value}}}):_vm._e()],1)])]),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('email')),expression:"errors.has('email')"}],staticClass:"error"},[_vm._v("\n              "+_vm._s(_vm.errors.first('email'))+"\n            ")])])]),_vm._v(" "),(_vm.editState && _vm.isAdmin && !_vm.isCurrentUser)?_c('div',{staticClass:"container search-result",on:{"click":_vm.deactivateUser}},[_vm._m(0)]):_vm._e()])])]),_vm._v(" "),(_vm.editState && _vm.$mq === 'mobile')?_c('fab',{staticClass:"cancel",attrs:{"on-click":_vm.cancelEdit,"icon-class":"fa-times"}}):_vm._e(),_vm._v(" "),(_vm.canEdit && _vm.$mq === 'mobile')?_c('fab',{staticClass:"edit",attrs:{"on-click":_vm.toggleEditState,"icon-class":_vm.editState ? 'fa-save' : 'fa-pen'}}):_vm._e()],1)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"default-text"},[_c('i',{staticClass:"fas fa-times"}),_vm._v("\n            DELETE USER\n          ")])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"graphql-tag":"MbWf","../components/fab":"TC0j","../components/extended-fab":"9Y+B","../components/button-dropdown":"W0L9","../utils/roles":"cosn","phone-number-formats":"vTXv","sweetalert2":"Y8u2"}],"gqzo":[function(require,module,exports) {
/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */
function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  debounced.flush = function() {
    if (timeout) {
      result = func.apply(context, args);
      context = args = null;
      
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

// Adds compatibility for ES modules
debounce.debounce = debounce;

module.exports = debounce;

},{}],"kPkr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debounce = _interopRequireDefault(require("debounce"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'UserSearchInput',
  props: {
    updateTags: {
      type: Function,
      required: true
    }
  },
  data: function data() {
    return {
      search: ''
    };
  },
  watch: {
    search: (0, _debounce.default)(function (search) {
      this.updateTags(search);
    }, 300)
  },
  methods: {
    searchAndBlur: function searchAndBlur() {
      this.updateTags(this.search);
      this.$refs.searchInput.blur();
    }
  }
};
exports.default = _default;
        var $2d1f4a = exports.default || module.exports;
      
      if (typeof $2d1f4a === 'function') {
        $2d1f4a = $2d1f4a.options;
      }
    
        /* template */
        Object.assign($2d1f4a, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-input"},[_vm._m(0),_vm._v(" "),_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.search),expression:"search"}],ref:"searchInput",staticClass:"user-search-input",attrs:{"placeholder":"Search"},domProps:{"value":(_vm.search)},on:{"keydown":function($event){if(!('button' in $event)&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.searchAndBlur($event)},"input":function($event){if($event.target.composing){ return; }_vm.search=$event.target.value}}})])}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-icon-container"},[_c('i',{staticClass:"fas fa-search"})])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"debounce":"gqzo"}],"CDlJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vueAvatar = _interopRequireDefault(require("vue-avatar"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'UserSearchResult',
  components: {
    Avatar: _vueAvatar.default
  },
  props: {
    user: {
      type: Object,
      required: true
    },
    onSelect: {
      type: Function,
      required: true
    }
  },
  methods: {
    onClick: function onClick() {
      this.onSelect(this.user.id);
    }
  }
};
exports.default = _default;
        var $e919bf = exports.default || module.exports;
      
      if (typeof $e919bf === 'function') {
        $e919bf = $e919bf.options;
      }
    
        /* template */
        Object.assign($e919bf, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"search-result"},[_c('div',{staticClass:"element-container",on:{"click":_vm.onClick}},[_c('avatar',{attrs:{"username":((_vm.user.first_name) + " " + (_vm.user.last_name))}}),_vm._v(" "),_c('div',{staticClass:"main-container"},[_c('div',{staticClass:"row"},[_c('span',{staticClass:"title"},[_vm._v("\n          "+_vm._s(_vm.user.first_name)+" "+_vm._s(_vm.user.last_name)+"\n        ")])]),_vm._v(" "),_c('div',{staticClass:"row"},[_c('span',{staticClass:"subtitle"},[_vm._v("\n          "+_vm._s(_vm.user.role)+"\n        ")])])])],1)])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"vue-avatar":"1JEr"}],"mmEQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _userSearchInput = _interopRequireDefault(require("../components/user-search-input"));

var _userSearchResult = _interopRequireDefault(require("../components/user-search-result"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _roles = _interopRequireDefault(require("../utils/roles"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab"));

var _addButton = _interopRequireDefault(require("../components/add-button"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n        query users($query: String!) {\n          searchUser(query: $query) {\n            id\n            first_name\n            last_name\n            role\n          }\n        }\n      "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        query {\n          getAllUser {\n            id\n            first_name\n            last_name\n            role\n          }\n        }\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'Users',
  components: {
    UserSearchInput: _userSearchInput.default,
    UserSearchResult: _userSearchResult.default,
    ExtendedFab: _extendedFab.default,
    AddButton: _addButton.default
  },
  apollo: {
    getAllUser: {
      query: (0, _graphqlTag.default)(_templateObject()),
      fetchPolicy: 'network-only'
    },
    searchUser: {
      query: (0, _graphqlTag.default)(_templateObject2()),
      variables: function variables() {
        var options = {
          query: ''
        };

        if (this.searchString) {
          options.query = this.searchString;
        }

        return options;
      },
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    return {
      searchUser: [],
      getAllUser: [],
      searchString: null
    };
  },
  computed: {
    isAdmin: function isAdmin() {
      return JSON.parse(window.localStorage.getItem('currentUser')).role === _roles.default.ADMIN;
    },
    users: function users() {
      if (!this.searchString) {
        return this.getAllUser || [];
      }

      return this.searchUser || [];
    }
  },
  methods: {
    transitionToAddUser: function transitionToAddUser() {
      this.$router.push({
        name: 'newUser'
      });
    },
    transitionToUserInfo: function transitionToUserInfo(userId) {
      this.$router.push({
        name: 'userDetail',
        params: {
          userId: userId
        }
      });
    },
    updateFilters: function updateFilters(fuzzySearch) {
      this.searchString = fuzzySearch;
    }
  }
};
exports.default = _default;
        var $cc7a79 = exports.default || module.exports;
      
      if (typeof $cc7a79 === 'function') {
        $cc7a79 = $cc7a79.options;
      }
    
        /* template */
        Object.assign($cc7a79, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page users-page"},[_c('div',{staticClass:"search-bar"},[_c('user-search-input',{attrs:{"update-tags":_vm.updateFilters}})],1),_vm._v(" "),_c('div',{staticClass:"users-menu-container"},[_c('div',{staticClass:"floating-action-bar"},[(_vm.isAdmin && _vm.$mq === 'desktop')?_c('extended-fab',{staticClass:"add-user-fab",attrs:{"on-click":_vm.transitionToAddUser,"icon-class":"fa-plus","button-text":"ADD USER"}}):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"user-scroll-container"},[(_vm.$mq === 'mobile' && _vm.isAdmin)?_c('add-button',{key:0,attrs:{"on-click":_vm.transitionToAddUser,"text":"USER"}}):_vm._e(),_vm._v(" "),_c('transition',{attrs:{"name":"list-loading"}},[(_vm.$apollo.queries.searchUser.loading)?_c('div',{staticClass:"loading-container"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(!_vm.$apollo.queries.searchUser.loading && !_vm.users.length)?_c('div',{staticClass:"no-users-container"},[_c('span',{staticClass:"no-users-text"},[_vm._v("\n            No Users To Display\n          ")])]):_vm._e()]),_vm._v(" "),_c('transition-group',{staticClass:"users",attrs:{"name":"list-element","tag":"div"}},_vm._l((_vm.users),function(user){return _c('user-search-result',{key:user.id,attrs:{"user":user,"on-select":_vm.transitionToUserInfo}})}))],1)])])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"../components/user-search-input":"kPkr","../components/user-search-result":"CDlJ","graphql-tag":"MbWf","../utils/roles":"cosn","../components/extended-fab":"9Y+B","../components/add-button":"VKUh"}],"l2gn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _nfc = _interopRequireDefault(require("../mixins/nfc"));

require("../assets/icons/svg/nfc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'NfcEncode',
  mixins: [_nfc.default],
  props: {
    toolId: {
      type: String,
      required: true
    }
  },
  methods: {
    showSuccessMsg: function showSuccessMsg() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'SUCCESS',
        text: 'Successfully encoded tag',
        timer: 1500,
        showConfirmButton: false
      });
    },
    showInfoMsg: function showInfoMsg() {
      (0, _sweetalert.default)({
        type: 'info',
        title: 'LOCKED TAG',
        text: 'This Tag Has Already Been Encoded and Cannot Be Written Again',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showErrorMsg: function showErrorMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'ERROR',
        text: 'An Error Occurred Trying to Write Tag. Please Try Again or Contact Support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showNfcDisabledMsg: function showNfcDisabledMsg() {
      (0, _sweetalert.default)({
        type: 'info',
        title: 'NFC NOT AVAILABLE',
        text: 'If You Want To Write NFC Tags Please Use The Mobile App on an Android Phone',
        timer: 2500,
        showConfirmButton: false
      });
    },
    onError: function onError(reason) {
      if (reason === 'Tag is read only') {
        this.showInfoMsg();
      } else {
        this.showErrorMsg();
      }

      this.pauseNfcListener();
    },
    _nfcCallback: function _nfcCallback(tag) {
      var _this = this;

      var record = [window.ndef.textRecord("".concat(this.toolId, " - Property of Renascent, Inc. (http://renascentinc.com)"))];

      var lock = function lock() {
        window.nfc.makeReadOnly(function () {
          return _this.showSuccessMsg();
        }, function (reason) {
          return _this.onError(reason);
        });

        _this.pauseNfcListener();
      };

      window.nfc.write(record, lock, function (reason) {
        return _this.onError(reason);
      });
    },
    onClick: function onClick() {
      if (this.isNfcWriteEnabled) {
        this.startNfcListener();
        this.showReadyToScanModal();
      } else {
        this.showNfcDisabledMsg();
      }
    }
  }
};
exports.default = _default;
        var $070384 = exports.default || module.exports;
      
      if (typeof $070384 === 'function') {
        $070384 = $070384.options;
      }
    
        /* template */
        Object.assign($070384, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('button',{staticClass:"nfc-encode",class:{ inactive: !_vm.isNfcWriteEnabled },on:{"click":_vm.onClick}},[_c('div',{staticClass:"fab-icon-container"},[_c('svgicon',{attrs:{"icon":"nfc","width":"22","height":"22"}})],1),_vm._v(" "),_c('span',{staticClass:"efab-text"},[_vm._v("\n    ENCODE TAG\n  ")])])}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"sweetalert2":"Y8u2","../mixins/nfc":"eLa2","../assets/icons/svg/nfc":"MIUb"}],"rY8c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function getDataUrlFromFile(t) {
  return new Promise(function (e, n) {
    var r = new FileReader();
    r.readAsDataURL(t), r.onload = function () {
      e(r.result);
    }, r.onerror = n;
  });
}

function getFilefromDataUrl(t, e) {
  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now();
  return new Promise(function (r) {
    for (var i = t.split(","), a = i[0].match(/:(.*?);/)[1], o = atob(i[1]), h = o.length, l = new Uint8Array(h); h--;) l[h] = o.charCodeAt(h);

    var u = void 0;

    try {
      u = new File([l], e, {
        type: a
      });
    } catch (t) {
      (u = new Blob([l], {
        type: a
      })).name = e, u.lastModified = n;
    }

    r(u);
  });
}

function loadImage(t) {
  return new Promise(function (e, n) {
    var r = new Image();
    r.onload = function () {
      e(r);
    }, r.onerror = n, r.src = t;
  });
}

function drawImageInCanvas(t, e) {
  var n = document.createElement("canvas"),
      r = n.getContext("2d");
  return Number.isInteger(e) && (t.width > e || t.height > e) ? t.width > t.height ? (n.width = e, n.height = t.height / t.width * e) : (n.width = t.width / t.height * e, n.height = e) : (n.width = t.width, n.height = t.height), r.drawImage(t, 0, 0, n.width, n.height), n;
}

function imageCompression(t) {
  var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.POSITIVE_INFINITY,
      n = arguments[2];
  return new Promise(function (r, i) {
    var a,
        o,
        h,
        l,
        u,
        d = void 0,
        c = void 0,
        s = void 0;
    return t instanceof Blob || t instanceof File ? /^image/.test(t.type) ? (d = 5, a = 1024 * e * 1024, getDataUrlFromFile(t).then(function (e) {
      try {
        return o = e, loadImage(o).then(function (e) {
          try {
            return h = e, l = drawImageInCanvas(h, n), c = .9, getFilefromDataUrl(l.toDataURL(t.type, c), t.name, t.lastModified).then(function (e) {
              try {
                var n = function () {
                  return r(s);
                };

                if (s = e, "image/png" === t.type) {
                  var o,
                      g = function e() {
                    if (d-- && s.size > a) {
                      var n = void 0;
                      return l.width *= .9, l.height *= .9, (u = l.getContext("2d")).drawImage(h, 0, 0, l.width, l.height), n = l.toDataURL(t.type, c), getFilefromDataUrl(n, t.name, t.lastModified).then(function (t) {
                        try {
                          return s = t, e;
                        } catch (t) {
                          return i(t);
                        }
                      }.bind(this), i);
                    }

                    return [1];
                  },
                      f = function () {
                    return n.call(this);
                  };

                  return (o = function (t) {
                    for (; t;) {
                      if (t.then) return void t.then(o, i);

                      try {
                        if (t.pop) {
                          if (t.length) return t.pop() ? f.call(this) : t;
                          t = g;
                        } else t = t.call(this);
                      } catch (t) {
                        return i(t);
                      }
                    }
                  }.bind(this))(g);
                }

                var m,
                    v = function e() {
                  if (d-- && s.size > a) {
                    var n = void 0;
                    return c *= .9, n = l.toDataURL(t.type, c), getFilefromDataUrl(n, t.name, t.lastModified).then(function (t) {
                      try {
                        return s = t, e;
                      } catch (t) {
                        return i(t);
                      }
                    }.bind(this), i);
                  }

                  return [1];
                },
                    w = function () {
                  return n.call(this);
                };

                return (m = function (t) {
                  for (; t;) {
                    if (t.then) return void t.then(m, i);

                    try {
                      if (t.pop) {
                        if (t.length) return t.pop() ? w.call(this) : t;
                        t = v;
                      } else t = t.call(this);
                    } catch (t) {
                      return i(t);
                    }
                  }
                }.bind(this))(v);
              } catch (t) {
                return i(t);
              }
            }.bind(this), i);
          } catch (t) {
            return i(t);
          }
        }.bind(this), i);
      } catch (t) {
        return i(t);
      }
    }.bind(this), i)) : i(new Error("The file given is not an image")) : i(new Error("The file given is not an instance of Blob or File"));
  }.bind(this));
}

imageCompression.drawImageInCanvas = drawImageInCanvas, imageCompression.getDataUrlFromFile = getDataUrlFromFile, imageCompression.getFilefromDataUrl = getFilefromDataUrl, imageCompression.loadImage = loadImage;
var _default = imageCompression;
exports.default = _default;
},{}],"RXyw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _headerCard = _interopRequireDefault(require("../components/header-card"));

var _toolSearchResult = _interopRequireDefault(require("../components/tool-search-result.vue"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab.vue"));

var _fab = _interopRequireDefault(require("../components/fab"));

var _select = _interopRequireDefault(require("../components/select"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _configurableItems = _interopRequireDefault(require("../utils/configurable-items"));

var _statuses = _interopRequireDefault(require("../utils/statuses"));

var _nfcEncode = _interopRequireDefault(require("../components/nfc-encode"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _browserImageCompression = _interopRequireDefault(require("browser-image-compression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject5() {
  var data = _taggedTemplateLiteral(["query tools($pagingParameters: PagingParameters) {\n              searchTool(pagingParameters: $pagingParameters) {\n                id\n                type {\n                  id\n                  name\n                }\n                brand {\n                  id\n                  name\n                }\n                status\n                owner {\n                  ... on Location {\n                     id\n                     name\n                     type\n                  }\n                  ... on User {\n                     id\n                     first_name\n                     last_name\n                     type\n                  }\n                }\n              }\n            }"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["mutation newTool($newTool: NewTool!) {\n            createTool(newTool: $newTool) {\n              id\n              type {\n                name\n              }\n              brand {\n                name\n              }\n              status\n              owner {\n                ... on Location {\n                   name\n                   type\n                }\n                ... on User {\n                   first_name\n                   last_name\n                   type\n                }\n              }\n            }\n          }"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["mutation newConfigurableItem($newConfigurableItem: NewConfigurableItem!) {\n          createConfigurableItem(newConfigurableItem: $newConfigurableItem) {\n            id\n          }\n        }"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["query {\n        getAllConfigurableItem {\n          id\n          type\n          name\n          sanctioned\n        }\n      }"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["query {\n        getAllUser {\n          id\n          first_name\n          last_name\n          role\n        }\n      }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'NewTool',
  components: {
    HeaderCard: _headerCard.default,
    ToolSearchResult: _toolSearchResult.default,
    ExtendedFab: _extendedFab.default,
    Fab: _fab.default,
    vSelect: _select.default,
    NfcEncode: _nfcEncode.default
  },
  apollo: {
    getAllUser: {
      query: (0, _graphqlTag.default)(_templateObject()),
      fetchPolicy: 'network-only'
    },
    getAllConfigurableItem: {
      query: (0, _graphqlTag.default)(_templateObject2()),
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    var statuses = [{
      name: 'Available',
      id: _statuses.default.AVAILABLE
    }, {
      name: 'In Use',
      id: _statuses.default.IN_USE
    }, {
      name: 'Maintenance',
      id: _statuses.default.MAINTENANCE
    }];
    return {
      brand: null,
      type: null,
      owner: JSON.parse(window.localStorage.getItem('currentUser')),
      modelNumber: null,
      serialNumber: null,
      modelYear: null,
      purchasedFrom: null,
      price: null,
      photo: null,
      status: statuses[1],
      currentState: 1,
      purchaseDate: null,
      datePickerVisibility: 'hidden',
      getAllConfigurableItem: [],
      getAllUser: [],
      tool: null,
      imgSrc: null,
      isSavingTool: false,
      statuses: statuses,
      validations: {
        modelYear: "numeric|date_format:YYYY|date_between:1950,".concat(new Date().getFullYear(), ",true")
      },
      moneyInputConfig: {
        decimal: '.',
        thousands: '',
        prefix: '$ ',
        suffix: '',
        precision: 2,
        masked: false
      }
    };
  },
  computed: {
    userOptions: function userOptions() {
      return this.getAllUser.map(function (user) {
        user.full_name = "".concat(user.first_name, " ").concat(user.last_name);
        return user;
      });
    },
    brandOptions: function brandOptions() {
      return this.getConfigurableItemsForType(_configurableItems.default.BRAND);
    },
    typeOptions: function typeOptions() {
      return this.getConfigurableItemsForType(_configurableItems.default.TYPE);
    },
    purchasedFromOptions: function purchasedFromOptions() {
      return this.getConfigurableItemsForType(_configurableItems.default.PURCHASED_FROM);
    },
    nfcDisabled: function nfcDisabled() {
      return !window.nfc;
    }
  },
  methods: {
    showSuccessMsg: function showSuccessMsg() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'SUCCESS',
        text: 'Successfully Added Tool',
        timer: 1500,
        showConfirmButton: false
      });
    },
    showErrorMsg: function showErrorMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'SAVE FAILURE',
        text: 'There was an issue saving new tool. Please try again or contact support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    toggleDatepicker: function toggleDatepicker() {
      if (this.datePickerVisibility === 'visible') {
        this.datePickerVisibility = 'hidden';
      } else {
        this.datePickerVisibility = 'visible';
      }
    },
    updateImageDisplay: function updateImageDisplay() {
      this.imgSrc = window.URL.createObjectURL(this.$refs.file.files[0]);
    },
    deletePhoto: function deletePhoto() {
      var _this = this;

      this.$refs.file.value = '';
      this.imgSrc = null;
      this.$nextTick(function () {
        return _this.$refs.file.addEventListener('change', function () {
          return _this.updateImageDisplay();
        });
      });
    },
    getConfigurableItemsForType: function getConfigurableItemsForType(type) {
      return this.getAllConfigurableItem.filter(function (item) {
        return item.type === type && item.sanctioned;
      });
    },
    advanceStep: function advanceStep() {
      var _this2 = this;

      this.$validator.validate().then(function (result) {
        if (result) {
          if (_this2.currentState === 3) {
            _this2.saveTool();
          } else if (_this2.currentState === 2) {
            ++_this2.currentState;

            _this2.$nextTick(function () {
              return _this2.$refs.file.addEventListener('change', function () {
                return _this2.updateImageDisplay();
              });
            });
          } else {
            ++_this2.currentState;
          }
        }
      });
    },
    addAnother: function addAnother() {
      this.resetData();
      this.currentState = 1;
    },
    resetData: function resetData() {
      this.brand = null;
      this.type = null;
      this.owner = JSON.parse(window.localStorage.getItem('currentUser'));
      this.modelNumber = null;
      this.serialNumber = null;
      this.modelYear = null;
      this.purchasedFrom = null;
      this.price = null;
      this.photo = null;
      this.tool = null;
      this.status = this.statuses[0];
      this.purchaseDate = null;
      this.imgSrc = null;
    },
    transitionToToolInfo: function transitionToToolInfo(toolId) {
      this.$router.push({
        name: 'toolDetail',
        params: {
          toolId: toolId
        }
      });
    },
    transitionToTools: function transitionToTools() {
      this.$router.push({
        path: '/tools'
      });
    },
    createNewConfigurableItem: function createNewConfigurableItem(configurableItem) {
      return this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject3()),
        variables: {
          newConfigurableItem: {
            type: configurableItem.type,
            name: configurableItem.name,
            sanctioned: false
          }
        }
      });
    },
    saveTool: function saveTool() {
      var _this3 = this;

      this.isSavingTool = true;
      var brandRequest = this.brand && this.brand.isNewConfigurableItem ? this.createNewConfigurableItem(this.brand) : null;
      var typeRequest = this.type && this.type.isNewConfigurableItem ? this.createNewConfigurableItem(this.type) : null;
      var purchaseRequest = this.purchasedFrom && this.purchasedFrom.isNewConfigurableItem ? this.createNewConfigurableItem(this.purchasedFrom) : null;
      var purchaseDate = this.purchaseDate && new Date(this.purchaseDate).toISOString();
      var photoRequest = new Promise(function (resolve) {
        var file = _this3.$refs.file.files[0];

        if (file) {
          (0, _browserImageCompression.default)(file, 1, 1920).then(function (compressedImage) {
            var fd = new FormData();
            var key = "tool_preview-".concat(new Date().getTime());
            fd.append('key', key);
            fd.append('acl', 'public-read');
            fd.append('Content-Type', compressedImage.type); // TODO enable auth for photo upload
            // fd.append('AWSAccessKeyId', 'YOUR ACCESS KEY')
            // fd.append('policy', 'YOUR POLICY')
            // fd.append('signature', 'YOUR SIGNATURE')

            fd.append('file', compressedImage);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', 'https://retina-images.s3.amazonaws.com/', true);

            xhr.onload = function () {
              resolve("https://s3.us-east-2.amazonaws.com/retina-images/".concat(key));
            };

            xhr.send(fd);
          });
        } else {
          resolve(null);
        }
      });
      Promise.all([brandRequest, typeRequest, purchaseRequest, photoRequest]).then(function (responses) {
        var _responses = _slicedToArray(responses, 4),
            brandResponse = _responses[0],
            typeResponse = _responses[1],
            purchaseResponse = _responses[2],
            photoResponse = _responses[3];

        if (brandResponse) {
          _this3.brand.id = brandResponse.data.createConfigurableItem.id;
        }

        if (typeResponse) {
          _this3.type.id = typeResponse.data.createConfigurableItem.id;
        }

        if (purchaseResponse) {
          _this3.purchasedFrom.id = purchaseResponse.data.createConfigurableItem.id;
        }

        _this3.$apollo.mutate({
          mutation: (0, _graphqlTag.default)(_templateObject4()),
          variables: {
            newTool: {
              type_id: _this3.type.id,
              brand_id: _this3.brand.id,
              model_number: _this3.modelNumber,
              serial_number: _this3.serialNumber,
              purchased_from_id: _this3.purchasedFrom && _this3.purchasedFrom.id,
              date_purchased: purchaseDate,
              status: _this3.status ? _this3.status.id : _statuses.default.AVAILABLE,
              owner_id: _this3.owner ? _this3.owner.id : JSON.parse(window.localStorage.getItem('currentUser')).id,
              price: _this3.price ? (_this3.price.slice(2) * 100).toFixed(2) : null,
              year: _this3.modelYear,
              photo: photoResponse
            }
          },
          refetchQueries: [{
            query: (0, _graphqlTag.default)(_templateObject5()),
            variables: {
              pagingParameters: {
                page_size: 15,
                page_number: 0
              }
            }
          }]
        }).then(function (response) {
          _this3.tool = response.data.createTool;
          ++_this3.currentState;

          _this3.showSuccessMsg();
        }).catch(function () {
          _this3.showErrorMsg();
        });
      }).catch(function () {
        _this3.showErrorMsg();
      }).finally(function () {
        _this3.isSavingTool = false;

        _this3.$apollo.queries.getAllConfigurableItem.refetch();
      });
    }
  }
};
exports.default = _default;
        var $dae391 = exports.default || module.exports;
      
      if (typeof $dae391 === 'function') {
        $dae391 = $dae391.options;
      }
    
        /* template */
        Object.assign($dae391, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page new-tool-page"},[_c('header-card',{attrs:{"title":"New Tool","exit-link":"/tools"}}),_vm._v(" "),_c('transition',{attrs:{"name":"fade"}},[(_vm.isSavingTool)?_c('div',{staticClass:"overlay"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState === 1)?_c('div',{staticClass:"new-tool-input-card"},[_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          BRAND\n        ")]),_vm._v(" "),_c('v-select',{directives:[{name:"validate",rawName:"v-validate:brand",value:('required|max:40'),expression:"'required|max:40'",arg:"brand"}],staticClass:"dark-input",attrs:{"options":_vm.brandOptions,"name":"brand","label":"name","placeholder":"eg. DeWalt"},scopedSlots:_vm._u([{key:"no-options",fn:function(props){return [_c('button',{staticClass:"option-container",on:{"click":function () { return props.select({ name: props.value, type: 'BRAND', isNewConfigurableItem: true }); }}},[_vm._v("\n              Set Brand To \""+_vm._s(props.value)+"\"\n            ")])]}}]),model:{value:(_vm.brand),callback:function ($$v) {_vm.brand=$$v},expression:"brand"}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('brand')),expression:"errors.has('brand')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('brand'))+"\n          ")])])],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          TYPE\n        ")]),_vm._v(" "),_c('v-select',{directives:[{name:"validate",rawName:"v-validate:type",value:('required|max:40'),expression:"'required|max:40'",arg:"type"}],staticClass:"dark-input",attrs:{"options":_vm.typeOptions,"name":"type","label":"name","placeholder":"eg. Saw"},scopedSlots:_vm._u([{key:"no-options",fn:function(props){return [_c('button',{staticClass:"no-options-btn",on:{"click":function () { return props.select({ name: props.value, type: 'TYPE', isNewConfigurableItem: true }); }}},[_vm._v("\n              Set Type To \""+_vm._s(props.value)+"\"\n            ")])]}}]),model:{value:(_vm.type),callback:function ($$v) {_vm.type=$$v},expression:"type"}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('type')),expression:"errors.has('type')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('type'))+"\n          ")])])],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          MODEL NUMBER\n        ")]),_vm._v(" "),_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required|max:40'),expression:"'required|max:40'"},{name:"model",rawName:"v-model",value:(_vm.modelNumber),expression:"modelNumber"}],staticClass:"light-input",attrs:{"name":"modelNumber","placeholder":"eg. 18392049437","autocorrect":"off","autocapitalize":"off","spellcheck":"false"},domProps:{"value":(_vm.modelNumber)},on:{"input":function($event){if($event.target.composing){ return; }_vm.modelNumber=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('modelNumber')),expression:"errors.has('modelNumber')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('modelNumber'))+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          SERIAL NUMBER\n        ")]),_vm._v(" "),_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required|max:40'),expression:"'required|max:40'"},{name:"model",rawName:"v-model",value:(_vm.serialNumber),expression:"serialNumber"}],staticClass:"light-input",attrs:{"name":"serialNumber","placeholder":"eg. 0348529873023","autocorrect":"off","autocapitalize":"off","spellcheck":"false"},domProps:{"value":(_vm.serialNumber)},on:{"input":function($event){if($event.target.composing){ return; }_vm.serialNumber=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('serialNumber')),expression:"errors.has('serialNumber')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('serialNumber'))+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          MODEL YEAR\n        ")]),_vm._v(" "),_c('input',{directives:[{name:"validate",rawName:"v-validate",value:(_vm.validations.modelYear),expression:"validations.modelYear"},{name:"model",rawName:"v-model",value:(_vm.modelYear),expression:"modelYear"}],staticClass:"light-input",attrs:{"name":"modelYear","placeholder":"eg. 2018","type":"number","inputmode":"numeric","pattern":"[0-9]*"},domProps:{"value":(_vm.modelYear)},on:{"input":function($event){if($event.target.composing){ return; }_vm.modelYear=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('modelYear')),expression:"errors.has('modelYear')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('modelYear'))+"\n          ")])])])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState === 2)?_c('div',{staticClass:"new-tool-input-card"},[_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          ASSIGN TO USER\n        ")]),_vm._v(" "),_c('v-select',{staticClass:"dark-input",attrs:{"options":_vm.userOptions,"label":"full_name"},model:{value:(_vm.owner),callback:function ($$v) {_vm.owner=$$v},expression:"owner"}})],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          PURCHASED FROM\n        ")]),_vm._v(" "),_c('v-select',{staticClass:"dark-input",attrs:{"options":_vm.purchasedFromOptions,"label":"name","placeholder":"eg. Lowes"},scopedSlots:_vm._u([{key:"no-options",fn:function(props){return [_c('button',{staticClass:"no-options-btn",on:{"click":function () { return props.select({ name: props.value, type: 'PURCHASED_FROM', isNewConfigurableItem: true }); }}},[_vm._v("\n              Set Purchased From To \""+_vm._s(props.value)+"\"\n            ")])]}}]),model:{value:(_vm.purchasedFrom),callback:function ($$v) {_vm.purchasedFrom=$$v},expression:"purchasedFrom"}})],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          STATUS\n        ")]),_vm._v(" "),_c('v-select',{staticClass:"dark-input",attrs:{"options":_vm.statuses,"searchable":false,"label":"name"},model:{value:(_vm.status),callback:function ($$v) {_vm.status=$$v},expression:"status"}})],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          PURCHASE DATE\n        ")]),_vm._v(" "),_c('v-date-picker',{attrs:{"input-props":{ readonly: true },"attributes":[{ popover: { visibility: 'hidden' } }],"max-date":new Date(),"popover-visibility":_vm.datePickerVisibility,"popover-direction":"top","mode":"single"},on:{"input":_vm.toggleDatepicker},scopedSlots:_vm._u([{key:"default",fn:function(ref){
var inputValue = ref.inputValue;
return _c('button',{staticClass:"dark-input purchase-date-input",class:{ placeholder: !inputValue },on:{"click":_vm.toggleDatepicker}},[_vm._v("\n            "+_vm._s(inputValue || ("eg. " + (new Date().toLocaleDateString('en-US'))))+"\n          ")])}}]),model:{value:(_vm.purchaseDate),callback:function ($$v) {_vm.purchaseDate=$$v},expression:"purchaseDate"}})],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('span',{staticClass:"form-label"},[_vm._v("\n          PRICE\n        ")]),_vm._v(" "),_c('input',{directives:[{name:"money",rawName:"v-money",value:(_vm.moneyInputConfig),expression:"moneyInputConfig"},{name:"model",rawName:"v-model",value:(_vm.price),expression:"price"}],staticClass:"light-input",attrs:{"name":"price"},domProps:{"value":(_vm.price)},on:{"input":function($event){if($event.target.composing){ return; }_vm.price=$event.target.value}}})])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState === 3)?_c('div',{staticClass:"new-tool-input-card photo-input-card"},[_c('input',{ref:"file",staticStyle:{"display":"none"},attrs:{"id":"file","name":"file","type":"file","accept":"image/*","capture":"camera"}}),_vm._v(" "),(!_vm.imgSrc)?_c('label',{staticClass:"dark-input add-photo",attrs:{"for":"file"}},[_c('label',{staticClass:"fas fa-camera",attrs:{"for":"file"}}),_vm._v("\n        Add Photo\n      ")]):_vm._e(),_vm._v(" "),(_vm.imgSrc)?_c('div',{staticClass:"image-container"},[_c('img',{staticClass:"img-preview",attrs:{"src":_vm.imgSrc}})]):_vm._e(),_vm._v(" "),(_vm.imgSrc)?_c('extended-fab',{staticClass:"delete-photo-efab",attrs:{"on-click":_vm.deletePhoto,"outline-display":true,"icon-class":"fa-times","button-text":"REMOVE PHOTO"}}):_vm._e()],1):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState === 4)?_c('div',{staticClass:"new-tool-input-card step-4"},[_c('nfc-encode',{attrs:{"tool-id":_vm.tool ? _vm.tool.id : ''}}),_vm._v(" "),_c('tool-search-result',{attrs:{"tool":_vm.tool,"on-select":_vm.transitionToToolInfo}}),_vm._v(" "),_c('div',{staticClass:"done-action-container"},[_c('extended-fab',{staticClass:"add-another-efab",attrs:{"on-click":_vm.addAnother,"outline-display":true,"icon-class":"fa-undo","button-text":"ADD ANOTHER"}}),_vm._v(" "),_c('extended-fab',{staticClass:"done-efab",attrs:{"on-click":_vm.transitionToTools,"icon-class":"fa-arrow-right","button-text":"DONE"}})],1)],1):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState !== 4)?_c('div',{staticClass:"pager-container"},[_c('div',{staticClass:"pager-btn-container"},[_c('fab',{staticClass:"page-back",attrs:{"disabled":_vm.currentState === 1,"on-click":function () { return --_vm.currentState; },"icon-class":"fa-arrow-left"}})],1),_vm._v(" "),_c('div',{staticClass:"pager"},[_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 1 }}),_vm._v(" "),_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 2 }}),_vm._v(" "),_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 3 }}),_vm._v(" "),_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 4 }})]),_vm._v(" "),_c('div',{staticClass:"pager-btn-container"},[(_vm.currentState !== 3)?_c('fab',{staticClass:"page-forward",attrs:{"disabled":!!_vm.errors.items.length,"on-click":_vm.advanceStep,"icon-class":"fa-arrow-right"}}):_vm._e(),_vm._v(" "),(_vm.currentState === 3)?_c('extended-fab',{staticClass:"page-forward",attrs:{"on-click":_vm.advanceStep,"icon-class":"","button-text":"FINISH"}}):_vm._e()],1)]):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"../components/header-card":"KS7g","../components/tool-search-result.vue":"Yq/j","../components/extended-fab.vue":"9Y+B","../components/fab":"TC0j","../components/select":"i+Lh","graphql-tag":"MbWf","../utils/configurable-items":"b0fn","../utils/statuses":"HBwF","../components/nfc-encode":"l2gn","sweetalert2":"Y8u2","browser-image-compression":"rY8c"}],"RQAl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

var _fab = _interopRequireDefault(require("../components/fab.vue"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab.vue"));

var _select = _interopRequireDefault(require("../components/select"));

var _configurableItems = _interopRequireDefault(require("../utils/configurable-items.js"));

var _buttonDropdown = _interopRequireDefault(require("../components/button-dropdown.vue"));

var _nfcEncode = _interopRequireDefault(require("../components/nfc-encode"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _nfc = _interopRequireDefault(require("../mixins/nfc"));

var _platforms = _interopRequireDefault(require("../utils/platforms"));

var _browserImageCompression = _interopRequireDefault(require("browser-image-compression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject9() {
  var data = _taggedTemplateLiteral(["\n             fragment patchToolStatus on Tool {\n               status\n               __typename\n             }\n            "]);

  _templateObject9 = function _templateObject9() {
    return data;
  };

  return data;
}

function _templateObject8() {
  var data = _taggedTemplateLiteral(["\n            mutation update($tool: UpdatedTool!) {\n              updateTool(updatedTool: $tool) {\n                status\n              }\n            }\n          "]);

  _templateObject8 = function _templateObject8() {
    return data;
  };

  return data;
}

function _templateObject7() {
  var data = _taggedTemplateLiteral(["\n                 fragment patchToolStatus on Tool {\n                   status\n                   __typename\n                 }\n                "]);

  _templateObject7 = function _templateObject7() {
    return data;
  };

  return data;
}

function _templateObject6() {
  var data = _taggedTemplateLiteral(["query tools($pagingParameters: PagingParameters) {\n                    searchTool(pagingParameters: $pagingParameters) {\n                      id\n                      type {\n                        id\n                        name\n                      }\n                      brand {\n                        id\n                        name\n                      }\n                      status\n                      owner {\n                        ... on Location {\n                           id\n                           name\n                           type\n                        }\n                        ... on User {\n                           id\n                           first_name\n                           last_name\n                           type\n                        }\n                      }\n                    }\n                  }"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["mutation decomission($tool_id: ID!, $decomissioned_status: DecomissionedToolStatus!, $decomission_reason: String!) {\n                decomissionTool(tool_id: $tool_id, decomissioned_status: $decomissioned_status, decomission_reason: $decomission_reason) {\n                  id\n                }\n              }"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["\n                mutation updateTool($tool: UpdatedTool!) {\n                  updateTool(updatedTool: $tool) {\n                    id\n                  }\n                }\n              "]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject3() {
  var data = _taggedTemplateLiteral(["\n          mutation newConfigurableItem(\n            $newConfigurableItem: NewConfigurableItem!\n          ) {\n            createConfigurableItem(newConfigurableItem: $newConfigurableItem) {\n              id\n            }\n          }\n        "]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n        query tool($tool_id: ID!) {\n          getTool(tool_id: $tool_id) {\n            id\n            brand {\n              id\n              name\n            }\n            type {\n              id\n              name\n            }\n            year\n            status\n            model_number\n            serial_number\n            purchased_from {\n              id\n              name\n            }\n            date_purchased\n            price\n            photo\n\n            owner {\n              ... on Location {\n                id\n                name\n                type\n              }\n              ... on User {\n                id\n                first_name\n                last_name\n                email\n                phone_number\n                type\n              }\n            }\n          }\n        }\n      "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n        query {\n          getAllConfigurableItem {\n            id\n            type\n            name\n            sanctioned\n          }\n        }\n      "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'ToolDetail',
  components: {
    Fab: _fab.default,
    ExtendedFab: _extendedFab.default,
    ButtonDropdown: _buttonDropdown.default,
    vSelect: _select.default,
    NfcEncode: _nfcEncode.default
  },
  mixins: [_nfc.default],
  apollo: {
    getAllConfigurableItem: {
      query: (0, _graphqlTag.default)(_templateObject()),
      fetchPolicy: 'network-only'
    },
    getTool: {
      query: (0, _graphqlTag.default)(_templateObject2()),
      variables: function variables() {
        var options = {};
        options.tool_id = this.$router.currentRoute.params.toolId;
        return options;
      },
      result: function result(apiResult) {
        if (!apiResult.data.getTool) {
          this.showInvalidIDMsg();
          this.$router.push({
            path: '/tools'
          });
        }
      },
      fetchPolicy: 'network-only'
    }
  },
  data: function data() {
    return {
      newImgSrc: null,
      reason: null,
      changingStatus: false,
      getTool: {},
      editState: false,
      newBrand: null,
      newType: null,
      newSerial: null,
      newModel: null,
      newYear: null,
      newPurchasedFrom: null,
      newPurchaseDate: null,
      newPrice: null,
      oosStatus: null,
      saving: false,
      datePickerVisibility: 'hidden',
      validations: {
        modelYear: "date_format:YYYY|date_between:1950,".concat(new Date().getFullYear() + 1)
      },
      moneyInputConfig: {
        decimal: '.',
        thousands: '',
        prefix: '$ ',
        suffix: '',
        precision: 2,
        masked: false
      }
    };
  },
  computed: {
    statusOptions: function statusOptions() {
      var statusOptions = ['AVAILABLE', 'IN USE', 'MAINTENANCE'];

      if (this.canEdit) {
        statusOptions = statusOptions.concat(['LOST OR STOLEN', 'BEYOND REPAIR']);
      }

      return statusOptions;
    },
    statusClass: function statusClass() {
      return this.getTool.status && this.getTool.status.split('_').join('-').toLowerCase();
    },
    isToolSelected: function isToolSelected() {
      return !!this.$store.state.selectedToolsMap[this.getTool.id];
    },
    brandOptions: function brandOptions() {
      return this.getConfigurableItemsForType(_configurableItems.default.BRAND);
    },
    purchasedFromOptions: function purchasedFromOptions() {
      return this.getConfigurableItemsForType(_configurableItems.default.PURCHASED_FROM);
    },
    typeOptions: function typeOptions() {
      return this.getConfigurableItemsForType(_configurableItems.default.TYPE);
    },
    canEdit: function canEdit() {
      var currentUser = JSON.parse(window.localStorage.getItem('currentUser'));
      return currentUser.role === 'ADMINISTRATOR';
    },
    owner: function owner() {
      return this.getTool.owner || {};
    },
    brand: function brand() {
      var brand = this.getTool.brand;
      return brand && brand.name;
    },
    type: function type() {
      var type = this.getTool.type;
      return type && type.name;
    },
    purchasedFrom: function purchasedFrom() {
      var purchasedFrom = this.getTool.purchased_from;
      return purchasedFrom ? purchasedFrom.name : '-';
    },
    formattedStatus: function formattedStatus() {
      var status = this.getTool.status;
      return status && status.replace(/_/g, ' ').toUpperCase();
    },
    formattedPrice: function formattedPrice() {
      var priceString = this.getTool.price;
      return priceString ? "".concat(priceString / 100) : ' -';
    },
    isTransferable: function isTransferable() {
      var currentUser = JSON.parse(window.localStorage.getItem('currentUser'));
      return currentUser.role === 'ADMINISTRATOR' || this.owner.type === 'LOCATION' && this.status === 'AVAILABLE' || this.owner.type === 'USER' && currentUser.id === this.owner.id;
    },
    phoneNumber: function phoneNumber() {
      if (this.owner.type === 'USER') {
        return this.owner.phone_number;
      } else if (this.owner.type === 'LOCATION') {
        return this.owner.phone_number;
      }

      return '';
    },
    email: function email() {
      if (this.owner.type === 'USER') {
        return this.owner.email;
      } else if (this.owner.type === 'LOCATION') {
        return this.owner.email;
      }

      return '';
    }
  },
  mounted: function mounted() {
    if (this.checkIsNfcEnabled() && window.device.platform === _platforms.default.ANDROID) {
      // add a noop nfc listener to keep nfc scans on android from bubbling up to the OS
      window.nfc.addNdefListener(function () {
        return 0;
      });
    }
  },
  methods: {
    showInvalidIDMsg: function showInvalidIDMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'ERROR',
        text: 'Invalid Tool ID',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showSuccessMsg: function showSuccessMsg() {
      (0, _sweetalert.default)({
        type: 'success',
        title: 'TOOL DECOMISSIONED',
        text: 'Successfully Decomissioned Tool',
        timer: 1500,
        showConfirmButton: false
      });
    },
    showDecomissionErrorMsg: function showDecomissionErrorMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'ERROR',
        text: 'An Error Occurred Trying to Decomission Tool. Please Try Again or Contact Support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    showSaveErrorMsg: function showSaveErrorMsg() {
      (0, _sweetalert.default)({
        type: 'error',
        title: 'ERROR',
        text: 'An Error Occurred Trying to Save Tool. Please Try Again or Contact Support',
        timer: 2000,
        showConfirmButton: false
      });
    },
    toggleDatepicker: function toggleDatepicker() {
      if (this.datePickerVisibility === 'visible') {
        this.datePickerVisibility = 'hidden';
      } else {
        this.datePickerVisibility = 'visible';
      }
    },
    deletePhoto: function deletePhoto() {
      var _this = this;

      this.$refs.file.value = '';
      this.newImgSrc = null;
      this.$nextTick(function () {
        return _this.$refs.file.addEventListener('change', function () {
          return _this.updateImageDisplay();
        });
      });
    },
    toggleChangingStatus: function toggleChangingStatus() {
      this.changingStatus = !this.changingStatus;
    },
    transitionToHistory: function transitionToHistory() {
      this.$router.push({
        name: 'historyDetail',
        params: {
          toolId: this.getTool.id
        }
      });
    },
    transitionToTools: function transitionToTools() {
      this.$router.push({
        name: 'tools'
      });
    },
    formattedDate: function formattedDate(date) {
      var datePurchased = date;
      return datePurchased ? new Date(datePurchased).toLocaleDateString('en-US') : '-';
    },
    getConfigurableItemsForType: function getConfigurableItemsForType(type) {
      return this.getAllConfigurableItem.filter(function (item) {
        return item.type === type && item.sanctioned;
      });
    },
    cancelEdit: function cancelEdit() {
      this.editState = false;
    },
    toggleEditState: function toggleEditState() {
      var _this2 = this;

      if (this.editState) {
        this.$validator.validate().then(function (result) {
          if (result) {
            _this2.saveTool();
          }
        });
      } else {
        this.newBrand = this.getTool.brand;
        this.newType = this.getTool.type;
        this.newSerial = this.getTool.serial_number;
        this.newModel = this.getTool.model_number;
        this.newYear = this.getTool.year;
        this.newPurchasedFrom = this.getTool.purchased_from;
        this.newPurchaseDate = this.getTool.date_purchased && new Date(this.getTool.date_purchased);
        this.newPrice = this.getTool.price ? this.getTool.price : null;
        this.editState = true;
        this.$nextTick(function () {
          return _this2.$refs.file.addEventListener('change', function () {
            return _this2.updateImageDisplay();
          });
        });
      }
    },
    createNewConfigurableItem: function createNewConfigurableItem(configurableItem) {
      return this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject3()),
        variables: {
          newConfigurableItem: {
            type: configurableItem.type,
            name: configurableItem.name,
            sanctioned: true
          }
        }
      });
    },
    updateImageDisplay: function updateImageDisplay() {
      this.newImgSrc = window.URL.createObjectURL(this.$refs.file.files[0]);
    },
    saveTool: function saveTool() {
      var _this3 = this;

      this.saving = true;
      var brandRequest = this.newBrand && this.newBrand.isNewConfigurableItem ? this.createNewConfigurableItem(this.newBrand) : null;
      var typeRequest = this.newType && this.newType.isNewConfigurableItem ? this.createNewConfigurableItem(this.newType) : null;
      var purchaseRequest = this.newPurchasedFrom && this.newPurchasedFrom.isNewConfigurableItem ? this.createNewConfigurableItem(this.newPurchasedFrom) : null;
      var photoRequest = new Promise(function (resolve) {
        var file = _this3.$refs.file.files[0];

        if (file) {
          (0, _browserImageCompression.default)(file, 1, 1920).then(function (compressedImage) {
            var fd = new FormData();
            var key = "tool_preview-".concat(new Date().getTime());
            fd.append('key', key);
            fd.append('acl', 'public-read');
            fd.append('Content-Type', compressedImage.type); // TODO enable auth for photo upload
            // fd.append('AWSAccessKeyId', 'YOUR ACCESS KEY')
            // fd.append('policy', 'YOUR POLICY')
            // fd.append('signature', 'YOUR SIGNATURE')

            fd.append('file', compressedImage);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', 'https://retina-images.s3.amazonaws.com/', true);

            xhr.onload = function () {
              resolve("https://s3.us-east-2.amazonaws.com/retina-images/".concat(key));
            };

            xhr.send(fd);
          });
        } else {
          resolve(null);
        }
      });
      Promise.all([brandRequest, typeRequest, purchaseRequest, photoRequest]).then(function (responses) {
        var _responses = _slicedToArray(responses, 4),
            brandResponse = _responses[0],
            typeResponse = _responses[1],
            purchaseResponse = _responses[2],
            photoResponse = _responses[3];

        if (brandResponse) {
          _this3.newBrand.id = brandResponse.data.createConfigurableItem.id;
        }

        if (typeResponse) {
          _this3.newType.id = typeResponse.data.createConfigurableItem.id;
        }

        if (purchaseResponse) {
          _this3.newPurchasedFrom.id = purchaseResponse.data.createConfigurableItem.id;
        }

        var photo = _this3.getTool.photo;

        if (photoResponse) {
          photo = photoResponse;
          _this3.newImgSrc = null;
        }

        _this3.$apollo.mutate({
          mutation: (0, _graphqlTag.default)(_templateObject4()),
          variables: {
            tool: {
              id: _this3.getTool.id,
              type_id: _this3.newType.id,
              brand_id: _this3.newBrand.id,
              model_number: _this3.newModel,
              serial_number: _this3.newSerial,
              status: _this3.getTool.status,
              owner_id: _this3.getTool.owner.id,
              purchased_from_id: _this3.newPurchasedFrom && _this3.newPurchasedFrom.id,
              date_purchased: _this3.newPurchaseDate ? new Date(_this3.newPurchaseDate).toISOString() : null,
              price: _this3.newPrice ? (_this3.newPrice.slice(2) * 100).toFixed(2) : null,
              year: _this3.newYear ? _this3.newYear : null,
              photo: photo
            }
          }
        }).then(function (result) {
          _this3.$apollo.queries.getTool.refetch();

          _this3.$apollo.queries.getAllConfigurableItem.refetch();

          _this3.editState = false;
        });
      }).catch(function () {
        _this3.showSaveErrorMsg();
      }).finally(function () {
        _this3.saving = false;
      });
    },
    toggleTransferStatus: function toggleTransferStatus() {
      this.$store.commit('toggleToolSelection', this.getTool.id);

      if (this.$store.state.transferState === 'INITIAL') {
        this.$store.commit('updateTransferStatus', 'SELECTING');
      }

      this.$router.push({
        path: '/tools'
      });
    },
    phoneCall: function phoneCall() {
      window.location.href = "tel:".concat(this.owner.phone_number);
    },
    sendEmail: function sendEmail() {
      window.location = "mailto:".concat(this.owner.email);
    },
    updateStatus: function updateStatus(newStatus) {
      var _this4 = this;

      if (newStatus === 'LOST OR STOLEN' || newStatus === 'BEYOND REPAIR') {
        (0, _sweetalert.default)({
          type: 'warning',
          title: 'CONFIRM DECOMISSION',
          text: "Are you sure you want to mark this tool as ".concat(newStatus, "? This action cannot be undone."),
          input: 'textarea',
          inputPlaceholder: "Please Explain Why This Tool is Being Marked as ".concat(newStatus),
          reverseButtons: true,
          showCancelButton: true,
          cancelButtonText: 'CANCEL',
          confirmButtonText: 'SUBMIT',
          confirmButtonColor: '#404040',
          inputValidator: function inputValidator(value) {
            return !value && "Decomission Reason is Required";
          }
        }).then(function (result) {
          newStatus = newStatus.replace(/ /g, '_').toUpperCase();

          if (result.value) {
            _this4.$apollo.mutate({
              mutation: (0, _graphqlTag.default)(_templateObject5()),
              variables: {
                tool_id: _this4.getTool.id,
                decomissioned_status: newStatus,
                decomission_reason: result.value
              },
              refetchQueries: [{
                query: (0, _graphqlTag.default)(_templateObject6()),
                variables: {
                  pagingParameters: {
                    page_size: 15,
                    page_number: 0
                  }
                }
              }]
            }).then(function () {
              _this4.$apollo.provider.clients.defaultClient.writeFragment({
                id: "".concat(_this4.getTool.id, "Tool"),
                fragment: (0, _graphqlTag.default)(_templateObject7()),
                data: {
                  status: newStatus,
                  __typename: 'Tool'
                }
              });

              _this4.$store.commit('setToolSelection', _this4.getTool.id, false);

              _this4.showSuccessMsg();

              _this4.$router.push({
                path: '/tools'
              });
            }).catch(function () {
              _this4.showDecomissionErrorMsg();
            });
          }
        });
      } else {
        newStatus = newStatus.replace(/ /g, '_').toUpperCase();
        this.saveStatusChange(newStatus);
      }
    },
    saveStatusChange: function saveStatusChange(newStatus) {
      var _this5 = this;

      // save current status in case request fails but set the tool status assuming it will succeed
      var currentStatus = this.getTool.status;
      this.getTool.status = newStatus;
      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject8()),
        variables: {
          tool: {
            id: this.getTool.id,
            type_id: this.getTool.type.id,
            brand_id: this.getTool.brand.id,
            model_number: this.getTool.model_number,
            serial_number: this.getTool.serial_number,
            status: newStatus,
            purchased_from_id: this.getTool.purchased_from && this.getTool.purchased_from.id,
            date_purchased: this.getTool.date_purchased,
            owner_id: this.owner.id,
            photo: this.getTool.photo,
            price: this.getTool.price,
            year: this.getTool.year
          }
        }
      }).then(function (status) {
        _this5.getTool.status = status.data.updateTool.status;

        _this5.$apollo.provider.clients.defaultClient.writeFragment({
          id: "".concat(_this5.getTool.id, "Tool"),
          fragment: (0, _graphqlTag.default)(_templateObject9()),
          data: {
            status: _this5.getTool.status,
            __typename: 'Tool'
          }
        });
      }).catch(function () {
        _this5.getTool.status = currentStatus;

        _this5.showSaveErrorMsg();
      });
    }
  }
};
exports.default = _default;
        var $f43695 = exports.default || module.exports;
      
      if (typeof $f43695 === 'function') {
        $f43695 = $f43695.options;
      }
    
        /* template */
        Object.assign($f43695, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page tool-detail-page"},[_c('transition',{attrs:{"name":"fade"}},[(_vm.saving)?_c('div',{staticClass:"overlay"},[_c('div',{staticClass:"half-circle-spinner"},[_c('div',{staticClass:"circle circle-1"}),_vm._v(" "),_c('div',{staticClass:"circle circle-2"})])]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"info-menu-container"},[_c('div',{staticClass:"floating-action-bar"},[(_vm.$mq === 'desktop')?_c('extended-fab',{staticClass:"action-btn transfer-btn",attrs:{"on-click":_vm.transitionToTools,"outline-display":true,"icon-class":"fa-arrow-left","button-text":"BACK"}}):_vm._e(),_vm._v(" "),(_vm.canEdit && _vm.$mq === 'desktop')?_c('extended-fab',{attrs:{"on-click":_vm.toggleEditState,"disabled":_vm.changingStatus,"icon-class":_vm.editState ? 'fa-save' : 'fa-pen',"button-text":_vm.editState ? 'SAVE CHANGES' : 'EDIT TOOL'}}):_vm._e(),_vm._v(" "),(_vm.editState && _vm.$mq === 'desktop')?_c('extended-fab',{attrs:{"on-click":_vm.cancelEdit,"disabled":_vm.changingStatus,"icon-class":"fa-times","button-text":"CANCEL"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.isTransferable)?_c('extended-fab',{staticClass:"action-btn transfer-btn",attrs:{"disabled":_vm.editState || _vm.changingStatus,"on-click":_vm.toggleTransferStatus,"button-text":_vm.isToolSelected ? 'DESELECT' : 'TRANSFER',"icon-class":"fa-exchange-alt"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop')?_c('extended-fab',{attrs:{"disabled":_vm.editState || _vm.changingStatus,"on-click":_vm.transitionToHistory,"outline-display":false,"icon-class":"fa-book-open","button-text":"VIEW HISTORY"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'desktop' && _vm.isTransferable)?_c('button-dropdown',{attrs:{"on-click":_vm.updateStatus,"options":_vm.statusOptions,"button-text":"CHANGE STATUS"}}):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"header-cards-container"},[_c('div',{staticClass:"header"},[(_vm.$mq === 'mobile')?_c('router-link',{staticClass:"fas fa-arrow-left backarrow",attrs:{"to":"/tools"}}):_vm._e(),_vm._v(" "),_c('span',{staticClass:"toolid"},[_vm._v("\n          #"+_vm._s(_vm.getTool.id)+"\n        ")]),_vm._v(" "),(!_vm.editState)?_c('div',{staticClass:"name"},[_vm._v("\n          "+_vm._s(_vm.brand)+" "+_vm._s(_vm.type)+"\n        ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('div',{staticClass:"input-group-container"},[_c('v-select',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"}],staticClass:"dark-input",attrs:{"options":_vm.brandOptions,"name":"brand","label":"name","placeholder":"Brand"},scopedSlots:_vm._u([{key:"no-options",fn:function(props){return [_c('button',{staticClass:"no-options-btn",on:{"click":function () { return _vm.newBrand = { name: props.value, type: 'BRAND', isNewConfigurableItem: true }; }}},[_vm._v("\n                Set Brand To \""+_vm._s(props.value)+"\"\n              ")])]}}]),model:{value:(_vm.newBrand),callback:function ($$v) {_vm.newBrand=$$v},expression:"newBrand"}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('brand')),expression:"errors.has('brand')"}],staticClass:"error"},[_vm._v("\n              "+_vm._s(_vm.errors.first('brand'))+"\n            ")])])],1):_vm._e(),_vm._v(" "),(_vm.editState)?_c('div',{staticClass:"input-group-container"},[_c('v-select',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"}],staticClass:"dark-input",attrs:{"options":_vm.typeOptions,"name":"type","label":"name","placeholder":"Type"},scopedSlots:_vm._u([{key:"no-options",fn:function(props){return [_c('button',{staticClass:"no-options-btn",on:{"click":function () { return _vm.newType = { name: props.value, type: 'TYPE', isNewConfigurableItem: true }; }}},[_vm._v("\n                Set Type To \""+_vm._s(props.value)+"\"\n              ")])]}}]),model:{value:(_vm.newType),callback:function ($$v) {_vm.newType=$$v},expression:"newType"}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('type')),expression:"errors.has('type')"}],staticClass:"error"},[_vm._v("\n              "+_vm._s(_vm.errors.first('type'))+"\n            ")])])],1):_vm._e(),_vm._v(" "),_c('span',{staticClass:"tool-status",class:_vm.statusClass},[_vm._v("\n          "+_vm._s(_vm.formattedStatus)+"\n        ")]),_vm._v(" "),(_vm.isTransferable)?_c('div',{staticClass:"actions"},[(_vm.$mq === 'mobile')?_c('button-dropdown',{attrs:{"on-click":_vm.updateStatus,"options":_vm.statusOptions,"button-text":"CHANGE STATUS"}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'mobile')?_c('button',{staticClass:"action-btn transfer-btn",on:{"click":_vm.toggleTransferStatus}},[_c('i',{staticClass:"fas fa-exchange-alt action-icon"}),_vm._v(" "),_c('span',{staticClass:"action-title"},[_vm._v("\n              "+_vm._s(_vm.isToolSelected ? 'DESELECT' : 'TRANSFER')+"\n            ")])]):_vm._e()],1):_vm._e()],1),_vm._v(" "),_c('div',{staticClass:"cards"},[_c('div',{staticClass:"card owner-card"},[_c('div',{staticClass:"card-title"},[_vm._v("\n            Assigned To\n          ")]),_vm._v(" "),_c('div',{staticClass:"card-details owner-details"},[_c('div',{staticClass:"user-symbol"},[_c('i',{staticClass:"fas fa-user",class:{ 'fa-user': _vm.owner.type === 'USER', 'fa-map-marker-alt': _vm.owner.type === 'LOCATION' }})]),_vm._v(" "),_c('div',{staticClass:"owner-name"},[(_vm.owner.type === 'LOCATION')?_c('div',{staticClass:"owner-location"},[_vm._v("\n                "+_vm._s(_vm.owner.name)+"\n              ")]):_vm._e(),_vm._v(" "),(_vm.owner.type === 'USER')?_c('div',{staticClass:"owner-user"},[_c('span',[_vm._v(" "+_vm._s(_vm.owner.first_name)+" ")]),_vm._v(" "),_c('span',[_vm._v(" "+_vm._s(_vm.owner.last_name)+" ")])]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"contact-buttons"},[_c('fab',{staticClass:"call-btn",attrs:{"on-click":_vm.phoneCall,"disabled":!_vm.phoneNumber,"icon-class":"fa-phone"}}),_vm._v(" "),_c('div',{staticClass:"spacer"}),_vm._v(" "),_c('fab',{staticClass:"email-btn",attrs:{"on-click":_vm.sendEmail,"disabled":!_vm.email,"icon-class":"fa-envelope"}})],1)])]),_vm._v(" "),_c('div',{staticClass:"card general-card"},[_c('div',{staticClass:"card-title"},[_vm._v("\n            General\n          ")]),_vm._v(" "),_c('div',{staticClass:"card-details general-details"},[_c('span',{staticClass:"general-label"},[_vm._v("\n              Retina ID\n            ")]),_vm._v(" "),_c('span',{staticClass:"general-data"},[_vm._v("\n              "+_vm._s(_vm.getTool.id)+"\n            ")]),_vm._v(" "),_c('nfc-encode',{attrs:{"tool-id":_vm.getTool && _vm.getTool.id ? _vm.getTool.id : ''}}),_vm._v(" "),_c('span',{staticClass:"general-label"},[_vm._v("\n              Serial Number\n            ")]),_vm._v(" "),(!_vm.editState)?_c('span',{staticClass:"general-data"},[_vm._v("\n              "+_vm._s(_vm.getTool.serial_number || '-')+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.newSerial),expression:"newSerial"}],staticClass:"general-data light-input",attrs:{"name":"serial"},domProps:{"value":(_vm.newSerial)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newSerial=$event.target.value}}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('serial')),expression:"errors.has('serial')"}],staticClass:"error"},[_vm._v("\n                "+_vm._s(_vm.errors.first('serial'))+"\n              ")])]),_vm._v(" "),_c('span',{staticClass:"general-label"},[_vm._v("\n              Model Number\n            ")]),_vm._v(" "),(!_vm.editState)?_c('span',{staticClass:"general-data"},[_vm._v("\n              "+_vm._s(_vm.getTool.model_number || '-')+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.newModel),expression:"newModel"}],staticClass:"general-data light-input",attrs:{"name":"model"},domProps:{"value":(_vm.newModel)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newModel=$event.target.value}}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('model')),expression:"errors.has('model')"}],staticClass:"error"},[_vm._v("\n                "+_vm._s(_vm.errors.first('model'))+"\n              ")])]),_vm._v(" "),_c('span',{staticClass:"general-label"},[_vm._v("\n              Model Year\n            ")]),_vm._v(" "),(!_vm.editState)?_c('span',{staticClass:"general-data"},[_vm._v("\n              "+_vm._s(_vm.getTool.year || '-')+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('input',{directives:[{name:"validate",rawName:"v-validate",value:(_vm.validations.modelYear),expression:"validations.modelYear"},{name:"model",rawName:"v-model",value:(_vm.newYear),expression:"newYear"}],staticClass:"general-data light-input",attrs:{"name":"year","type":"number"},domProps:{"value":(_vm.newYear)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newYear=$event.target.value}}}):_vm._e(),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('year')),expression:"errors.has('year')"}],staticClass:"error"},[_vm._v("\n                "+_vm._s(_vm.errors.first('year'))+"\n              ")])]),_vm._v(" "),_c('span',{staticClass:"general-label"},[_vm._v("\n              Purchased From\n            ")]),_vm._v(" "),(!_vm.editState)?_c('span',{staticClass:"general-data"},[_vm._v("\n              "+_vm._s(_vm.purchasedFrom)+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('v-select',{staticClass:"general-data dark-input",attrs:{"options":_vm.purchasedFromOptions,"label":"name","placeholder":"Purchased From"},scopedSlots:_vm._u([{key:"no-options",fn:function(props){return [_c('button',{staticClass:"no-options-btn",on:{"click":function () { return _vm.newPurchasedFrom = { name: props.value, type: 'PURCHASED_FROM', isNewConfigurableItem: true }; }}},[_vm._v("\n                  Set Type To \""+_vm._s(props.value)+"\"\n                ")])]}}]),model:{value:(_vm.newPurchasedFrom),callback:function ($$v) {_vm.newPurchasedFrom=$$v},expression:"newPurchasedFrom"}}):_vm._e(),_vm._v(" "),_c('span',{staticClass:"general-label"},[_vm._v("\n              Purchase Date\n            ")]),_vm._v(" "),(!_vm.editState)?_c('span',{staticClass:"general-data"},[_vm._v("\n              "+_vm._s(_vm.formattedDate(_vm.getTool.date_purchased))+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('v-date-picker',{staticClass:"general-data",attrs:{"input-props":{ readonly: true },"attributes":[{ popover: { visibility: 'hidden' } }],"max-date":new Date(),"popover-visibility":_vm.datePickerVisibility,"popover-direction":"top","mode":"single"},on:{"input":_vm.toggleDatepicker},scopedSlots:_vm._u([{key:"default",fn:function(ref){
var inputValue = ref.inputValue;
return _c('button',{staticClass:"dark-input purchase-date-input",class:{ placeholder: !inputValue },on:{"click":_vm.toggleDatepicker}},[_vm._v("\n                "+_vm._s(inputValue || ("eg. " + (new Date().toLocaleDateString('en-US'))))+"\n              ")])}}]),model:{value:(_vm.newPurchaseDate),callback:function ($$v) {_vm.newPurchaseDate=$$v},expression:"newPurchaseDate"}}):_vm._e(),_vm._v(" "),_c('span',{staticClass:"general-label"},[_vm._v("\n              Purchase Price\n            ")]),_vm._v(" "),(!_vm.editState)?_c('span',{staticClass:"general-data"},[_vm._v("\n              $"+_vm._s(_vm.formattedPrice)+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('input',{directives:[{name:"money",rawName:"v-money",value:(_vm.moneyInputConfig),expression:"moneyInputConfig"},{name:"model",rawName:"v-model",value:(_vm.newPrice),expression:"newPrice"}],staticClass:"light-input",attrs:{"name":"newPrice","placeholder":"Price"},domProps:{"value":(_vm.newPrice)},on:{"input":function($event){if($event.target.composing){ return; }_vm.newPrice=$event.target.value}}}):_vm._e(),_vm._v(" "),(_vm.$mq === 'mobile')?_c('extended-fab',{attrs:{"on-click":_vm.transitionToHistory,"outline-display":false,"icon-class":"fa-book-open","button-text":"VIEW HISTORY"}}):_vm._e()],1)]),_vm._v(" "),_c('div',{staticClass:"card photo-card"},[_c('div',{staticClass:"card-title"},[_vm._v("\n            Photo\n          ")]),_vm._v(" "),(!_vm.editState)?_c('div',{staticClass:"photo-box"},[(_vm.getTool.photo)?_c('img',{directives:[{name:"lazy",rawName:"v-lazy",value:(("" + (_vm.getTool.photo))),expression:"`${getTool.photo}`"}],staticClass:"image"}):_vm._e(),_vm._v(" "),(!_vm.getTool.photo)?_c('i',{staticClass:"fas fa-image no-image"}):_vm._e()]):_vm._e(),_vm._v(" "),(_vm.editState)?_c('div',{staticClass:"add-photo-container"},[_c('input',{ref:"file",staticStyle:{"display":"none"},attrs:{"id":"file","name":"file","type":"file","accept":"image/*","capture":"camera"}}),_vm._v(" "),(!_vm.newImgSrc)?_c('label',{staticClass:"dark-input add-photo",attrs:{"for":"file"}},[_c('label',{staticClass:"fas fa-camera",attrs:{"for":"file"}}),_vm._v("\n              "+_vm._s(_vm.getTool.photo ? 'UPDATE PHOTO' : 'Add Photo')+"\n            ")]):_vm._e(),_vm._v(" "),(_vm.newImgSrc)?_c('div',{staticClass:"image-container"},[(_vm.newImgSrc)?_c('img',{staticClass:"img-preview",attrs:{"src":_vm.newImgSrc}}):_vm._e()]):_vm._e(),_vm._v(" "),(_vm.newImgSrc)?_c('extended-fab',{staticClass:"delete-photo-efab",attrs:{"on-click":_vm.deletePhoto,"outline-display":true,"icon-class":"fa-times","button-text":"REMOVE PHOTO"}}):_vm._e()],1):_vm._e()])])])]),_vm._v(" "),(_vm.editState && _vm.$mq === 'mobile')?_c('fab',{staticClass:"cancel",attrs:{"on-click":_vm.cancelEdit,"icon-class":"fa-times"}}):_vm._e(),_vm._v(" "),(_vm.canEdit && _vm.$mq === 'mobile')?_c('fab',{staticClass:"edit",attrs:{"on-click":_vm.toggleEditState,"icon-class":_vm.editState ? 'fa-save' : 'fa-pen'}}):_vm._e()],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"graphql-tag":"MbWf","../components/fab.vue":"TC0j","../components/extended-fab.vue":"9Y+B","../components/select":"i+Lh","../utils/configurable-items.js":"b0fn","../components/button-dropdown.vue":"W0L9","../components/nfc-encode":"l2gn","sweetalert2":"Y8u2","../mixins/nfc":"eLa2","../utils/platforms":"O2n5","browser-image-compression":"rY8c"}],"xbai":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _headerCard = _interopRequireDefault(require("../components/header-card"));

var _userSearchResult = _interopRequireDefault(require("../components/user-search-result.vue"));

var _extendedFab = _interopRequireDefault(require("../components/extended-fab.vue"));

var _fab = _interopRequireDefault(require("../components/fab"));

var _select = _interopRequireDefault(require("../components/select"));

var _roles = _interopRequireDefault(require("../utils/roles"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _graphqlTag = _interopRequireDefault(require("graphql-tag"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject2() {
  var data = _taggedTemplateLiteral(["\n            query {\n              getAllUser {\n                id\n                first_name\n                last_name\n                role\n              }\n            }\n          "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["\n          mutation createUser($newUser: NewUser!){\n          createUser(newUser: $newUser) {\n              id,\n              first_name,\n              last_name,\n              role\n            }\n          }"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var _default = {
  name: 'NewTool',
  components: {
    HeaderCard: _headerCard.default,
    UserSearchResult: _userSearchResult.default,
    ExtendedFab: _extendedFab.default,
    vSelect: _select.default,
    Fab: _fab.default
  },
  data: function data() {
    return {
      firstName: null,
      lastName: null,
      email: null,
      phoneNumber: null,
      role: null,
      currentState: 1,
      firstPassword: null,
      secondPassword: null,
      getUser: {}
    };
  },
  computed: {
    roles: function roles() {
      return [{
        name: 'User',
        id: _roles.default.USER
      }, {
        name: 'Administrator',
        id: _roles.default.ADMIN
      }];
    }
  },
  methods: {
    advanceStep: function advanceStep() {
      var _this = this;

      this.$validator.validate().then(function (result) {
        if (result) {
          if (_this.currentState === 2) {
            _this.saveUser();
          } else {
            ++_this.currentState;
          }
        }
      });
    },
    transitionToUserInfo: function transitionToUserInfo(userId) {
      this.$router.push({
        name: 'userDetail',
        params: {
          userId: userId
        }
      });
    },
    transitionToUsers: function transitionToUsers() {
      this.$router.push({
        name: 'users'
      });
    },
    saveUser: function saveUser() {
      var _this2 = this;

      this.$apollo.mutate({
        mutation: (0, _graphqlTag.default)(_templateObject()),
        variables: {
          newUser: {
            first_name: this.firstName,
            last_name: this.lastName,
            email: this.email,
            phone_number: this.phoneNumber,
            password: this.secondPassword,
            role: this.role.id,
            status: 'ACTIVE'
          }
        },
        refetchQueries: [{
          query: (0, _graphqlTag.default)(_templateObject2())
        }]
      }).then(function (result) {
        ++_this2.currentState;
        _this2.getUser = result.data.createUser;
      }).catch(function () {
        _this2.resetData();

        _this2.currentState = 1;
        (0, _sweetalert.default)({
          type: 'error',
          title: 'ERROR',
          text: 'There was an error creating the user. Please try again.',
          timer: 2000,
          showConfirmButton: false
        });
      });
    },
    resetData: function resetData() {
      this.firstName = null;
      this.lastName = null;
      this.email = null;
      this.phoneNumber = null;
      this.role = null;
      this.firstPassword = null;
      this.secondPassword = null;
    }
  }
};
exports.default = _default;
        var $284b04 = exports.default || module.exports;
      
      if (typeof $284b04 === 'function') {
        $284b04 = $284b04.options;
      }
    
        /* template */
        Object.assign($284b04, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page new-user-page"},[_c('header-card',{attrs:{"title":"New User","exit-link":"/users"}}),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState === 1)?_c('div',{staticClass:"new-user-input-card"},[_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.firstName),expression:"firstName"}],staticClass:"light-input",attrs:{"name":"first name","placeholder":"First Name","type":"string"},domProps:{"value":(_vm.firstName)},on:{"input":function($event){if($event.target.composing){ return; }_vm.firstName=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('first name')),expression:"errors.has('first name')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('first name'))+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.lastName),expression:"lastName"}],staticClass:"light-input",attrs:{"name":"last name","placeholder":"Last Name","type":"string"},domProps:{"value":(_vm.lastName)},on:{"input":function($event){if($event.target.composing){ return; }_vm.lastName=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('last name')),expression:"errors.has('last name')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('last name'))+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('email|required'),expression:"'email|required'"},{name:"model",rawName:"v-model",value:(_vm.email),expression:"email"}],staticClass:"light-input",attrs:{"data-vv-as":"email","name":"email","placeholder":"Email","type":"string"},domProps:{"value":(_vm.email)},on:{"input":function($event){if($event.target.composing){ return; }_vm.email=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('email')),expression:"errors.has('email')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('email'))+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:({ required: true, numeric: true, min: 10 }),expression:"{ required: true, numeric: true, min: 10 }"},{name:"model",rawName:"v-model",value:(_vm.phoneNumber),expression:"phoneNumber"}],staticClass:"light-input",attrs:{"name":"phone number","placeholder":"Phone #","type":"number","inputmode":"numeric","pattern":"[0-9]*"},domProps:{"value":(_vm.phoneNumber)},on:{"input":function($event){if($event.target.composing){ return; }_vm.phoneNumber=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('phone number')),expression:"errors.has('phone number')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('phone number'))+"\n          ")])])])]):_vm._e()]),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState === 2)?_c('div',{staticClass:"new-user-input-card"},[_c('div',{staticClass:"input-group-container"},[_c('v-select',{directives:[{name:"validate",rawName:"v-validate:role",value:('required'),expression:"'required'",arg:"role"}],staticClass:"dark-input",attrs:{"options":_vm.roles,"filterable":false,"label":"name","placeholder":"Role","name":"role"},model:{value:(_vm.role),callback:function ($$v) {_vm.role=$$v},expression:"role"}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('role')),expression:"errors.has('role')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('role'))+"\n          ")])])],1),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:('required'),expression:"'required'"},{name:"model",rawName:"v-model",value:(_vm.firstPassword),expression:"firstPassword"}],staticClass:"light-input",attrs:{"name":"first password","placeholder":"Password","type":"password"},domProps:{"value":(_vm.firstPassword)},on:{"input":function($event){if($event.target.composing){ return; }_vm.firstPassword=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('first password')),expression:"errors.has('first password')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('first password'))+"\n          ")])])]),_vm._v(" "),_c('div',{staticClass:"input-group-container"},[_c('input',{directives:[{name:"validate",rawName:"v-validate",value:({ required: true, is: _vm.firstPassword }),expression:"{ required: true, is: firstPassword }"},{name:"model",rawName:"v-model",value:(_vm.secondPassword),expression:"secondPassword"}],staticClass:"light-input",attrs:{"name":"second password","placeholder":"Re-Enter Password","type":"password"},domProps:{"value":(_vm.secondPassword)},on:{"input":function($event){if($event.target.composing){ return; }_vm.secondPassword=$event.target.value}}}),_vm._v(" "),_c('div',{staticClass:"error-container"},[_c('span',{directives:[{name:"show",rawName:"v-show",value:(_vm.errors.has('second password')),expression:"errors.has('second password')"}],staticClass:"error"},[_vm._v("\n            "+_vm._s(_vm.errors.first('second password'))+"\n          ")])])])]):_vm._e(),_vm._v(" "),(_vm.currentState === 3)?_c('user-search-result',{staticClass:"user-preview",attrs:{"user":_vm.getUser,"on-select":_vm.transitionToUserInfo}}):_vm._e()],1),_vm._v(" "),_c('transition',{attrs:{"name":"card-change"}},[(_vm.currentState !== 3)?_c('div',{staticClass:"pager-container"},[_c('fab',{staticClass:"page-back",attrs:{"disabled":_vm.currentState === 1,"on-click":function () { return --_vm.currentState; },"icon-class":"fa-arrow-left"}}),_vm._v(" "),_c('div',{staticClass:"pager"},[_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 1 }}),_vm._v(" "),_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 2 }}),_vm._v(" "),_c('div',{staticClass:"pager-page",class:{ selected: _vm.currentState === 3 }})]),_vm._v(" "),_c('fab',{staticClass:"page-forward",attrs:{"disabled":!!_vm.errors.items.length,"on-click":_vm.advanceStep,"icon-class":"fa-arrow-right"}})],1):_vm._e(),_vm._v(" "),(_vm.currentState === 3)?_c('div',{staticClass:"actions"},[_c('extended-fab',{attrs:{"on-click":_vm.transitionToUsers,"icon-class":"fa-arrow-right","button-text":"DONE"}})],1):_vm._e()])],1)}
var staticRenderFns = []

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{"../components/header-card":"KS7g","../components/user-search-result.vue":"CDlJ","../components/extended-fab.vue":"9Y+B","../components/fab":"TC0j","../components/select":"i+Lh","../utils/roles":"cosn","sweetalert2":"Y8u2","graphql-tag":"MbWf"}],"EaJd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
var _default = {
  name: 'Privacy'
};
exports.default = _default;
        var $6cd808 = exports.default || module.exports;
      
      if (typeof $6cd808 === 'function') {
        $6cd808 = $6cd808.options;
      }
    
        /* template */
        Object.assign($6cd808, (function () {
          var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"page privacy-page"},[_c('div',{staticClass:"text-container"},[_c('h1',[_vm._v("\n      Privacy Policy\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      Renascent, Inc. is committed to protecting the integrity and privacy of personal information gathered from users of Retina through all of our communication channels. If you are a visitor, we do not collect information unless you register to become a customer. If you are a customer, the information collected (name, postal address, email address, phone number) is never shared or sold.\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      The protection of your privacy is of great importance to us, we have created this privacy policy to communicate our practices regarding the collection and dissemination of personal information that you provide to us and that can be linked to a specific individual, such as a name, postal address, telephone number(s), email address, or any other information, provided to us by our partners and Site visitors (hereinafter \"Personal Information\"), as well as certain non-personally identifiable information collected when you visit many of our web pages such as the type of browser you are using (e.g. Internet Explorer or Firefox), the type of operating system you are using (e.g., Windows XP or Mac OS), the domain name of your internet service provider (e.g., Comcast or Verizon), aggregate data about the number of visits to the Site and/or aggregate data about the pages visited (hereinafter \"Aggregate Data\").\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      This policy will be updated periodically, so please be sure to reread it from time to time. By submitting your personal information to us, you are agreeing that Retina may use the information in accordance with this privacy policy.\n    ")]),_vm._v(" "),_c('h2',[_vm._v("\n      Collection and Use of Personal Information\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      Retina collects Personal Information supplied to us voluntarily by customers and visitors to this Site. We may use such voluntarily provided information to improve our understanding of your interests, to improve our services, or to contact you about issues that may affect you. In order to utilize certain features of our site or receive information from Retina or become a customer, you may choose to provide Personal Information. If you do submit information to us, we will use that information for the purposes for which it was submitted. We may also use your name, postal address and telephone number(s) to contact you offline.\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      Retina uses third-party vendors to provide services on this Site and in offline business operations. The information that you submit on this site may be provided to those vendors on a confidential basis so that those vendors can provide services (such as maintaining our database or sending email messages) on our behalf.\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      Other than as described in this privacy policy, or as may be necessary to protect the rights, property, and safety of Retina or others, or as may be necessary to comply with applicable law, Retina will not share or sell the Personal Information you provide online.\n    ")]),_vm._v(" "),_c('h2',[_vm._v("\n      Use of Email Address\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      When you contact us or sign up as a partner on our Site, you will be asked to supply your email address. Retina does not sell or rent your email address to any third party. Email addresses gathered from partners of Retina are only available to employees managing this information for purposes of contacting you or sending you emails based on your request for information, and to contracted service providers and vendors for purposes of providing services relating to our communications with you.\n    ")]),_vm._v(" "),_c('h2',[_vm._v("\n      User Submissions\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      Retina welcomes your comments and feedback on its site. However, you acknowledge that you are responsible for your own communications and are responsible for the consequences of their posting. Therefore, do not impersonate another person or business.\n    ")]),_vm._v(" "),_c('h2',[_vm._v("\n      Children\n    ")]),_vm._v(" "),_c('p',[_vm._v("\n      Retina does not knowingly gather any personally identifiable information from children under the age of 13. You must be 13 years of age or older to access the site. Retina has no interest in collecting information from children under the age of 13.\n    ")])])])}]

          return {
            render: render,
            staticRenderFns: staticRenderFns,
            _compiled: true,
            _scopeId: null,
            functional: undefined
          };
        })());
      
},{}],"Fe6F":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vue = _interopRequireDefault(require("vue"));

var _vueRouter = _interopRequireDefault(require("vue-router"));

var _login = _interopRequireDefault(require("./routes/login"));

var _application = _interopRequireDefault(require("./routes/application"));

var _landingPage = _interopRequireDefault(require("./routes/landing-page"));

var _tools = _interopRequireDefault(require("./routes/tools"));

var _passwordReset = _interopRequireDefault(require("./routes/password-reset"));

var _configuration = _interopRequireDefault(require("./routes/configuration"));

var _history = _interopRequireDefault(require("./routes/history"));

var _userDetail = _interopRequireDefault(require("./routes/user-detail"));

var _users = _interopRequireDefault(require("./routes/users"));

var _newTool = _interopRequireDefault(require("./routes/new-tool"));

var _toolDetail = _interopRequireDefault(require("./routes/tool-detail"));

var _newUser = _interopRequireDefault(require("./routes/new-user"));

var _privacy = _interopRequireDefault(require("./routes/privacy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue.default.use(_vueRouter.default);

var _default = new _vueRouter.default({
  // mode: 'history',
  routes: [{
    path: '/login',
    component: _login.default,
    name: 'login'
  }, {
    path: '/password-reset',
    component: _passwordReset.default,
    name: 'passwordReset'
  }, {
    path: '/privacy',
    component: _privacy.default,
    name: 'privacy'
  }, {
    path: '/',
    component: _application.default,
    children: [{
      path: '/',
      component: _landingPage.default,
      name: 'landingPage'
    }, {
      path: 'tools',
      component: _tools.default,
      name: 'tools'
    }, {
      path: 'tool/:toolId',
      component: _toolDetail.default,
      name: 'toolDetail'
    }, {
      path: 'users',
      component: _users.default,
      name: 'users'
    }, {
      path: 'user/:userId',
      component: _userDetail.default,
      name: 'userDetail'
    }, {
      path: 'new-tool',
      component: _newTool.default,
      name: 'newTool'
    }, {
      path: 'history',
      component: _history.default,
      name: 'history'
    }, {
      path: 'detail-history/:toolId',
      component: _history.default,
      name: 'historyDetail'
    }, {
      path: 'new-user',
      component: _newUser.default,
      name: 'newUser'
    }, {
      path: 'configuration',
      component: _configuration.default,
      name: 'configuration'
    }]
  }]
});

exports.default = _default;
},{"vue":"4673","vue-router":"1iTB","./routes/login":"VPle","./routes/application":"sJcJ","./routes/landing-page":"xve9","./routes/tools":"hUa8","./routes/password-reset":"hUDr","./routes/configuration":"ERTQ","./routes/history":"YEEH","./routes/user-detail":"puwS","./routes/users":"mmEQ","./routes/new-tool":"RXyw","./routes/tool-detail":"RQAl","./routes/new-user":"xbai","./routes/privacy":"EaJd"}],"AwB4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.install = install;
exports.default = exports.createNamespacedHelpers = exports.mapActions = exports.mapGetters = exports.mapMutations = exports.mapState = exports.Store = void 0;

/**
 * vuex v3.0.1
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({
      beforeCreate: vuexInit
    });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;

    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};
      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;

      _init.call(this, options);
    };
  }
  /**
   * Vuex init hook, injected into each instances init hooks list.
   */


  function vuexInit() {
    var options = this.$options; // store injection

    if (options.store) {
      this.$store = typeof options.store === 'function' ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;
  devtoolHook.emit('vuex:init', store);
  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });
  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}
/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */

/**
 * forEach for object
 */


function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

var Module = function Module(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = {
  namespaced: {
    configurable: true
  }
};

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;

  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }

  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }

  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  if ("production" !== 'production') {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);

  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  } // register nested modules


  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(path, targetModule, newModule) {
  if ("production" !== 'production') {
    assertRawModule(path, newModule);
  } // update target module


  targetModule.update(newModule); // update nested modules

  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ("production" !== 'production') {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        }

        return;
      }

      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var functionAssert = {
  assert: function (value) {
    return typeof value === 'function';
  },
  expected: 'function'
};
var objectAssert = {
  assert: function (value) {
    return typeof value === 'function' || typeof value === 'object' && typeof value.handler === 'function';
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function (value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}

function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";

  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }

  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {}; // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731

  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if ("production" !== 'production') {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "Store must be called with the new operator.");
  }

  var plugins = options.plugins;
  if (plugins === void 0) plugins = [];
  var strict = options.strict;
  if (strict === void 0) strict = false;
  var state = options.state;
  if (state === void 0) state = {};

  if (typeof state === 'function') {
    state = state() || {};
  } // store internal state


  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue(); // bind commit and dispatch to self

  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;

  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };

  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  }; // strict mode


  this.strict = strict; // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters

  installModule(this, state, [], this._modules.root); // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)

  resetStoreVM(this, state); // apply plugins

  plugins.forEach(function (plugin) {
    return plugin(this$1);
  });

  if (Vue.config.devtools) {
    devtoolPlugin(this);
  }
};

exports.Store = Store;
var prototypeAccessors = {
  state: {
    configurable: true
  }
};

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors.state.set = function (v) {
  if ("production" !== 'production') {
    assert(false, "Use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this; // check object-style commit

  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;
  var mutation = {
    type: type,
    payload: payload
  };
  var entry = this._mutations[type];

  if (!entry) {
    if ("production" !== 'production') {
      console.error("[vuex] unknown mutation type: " + type);
    }

    return;
  }

  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });

  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if ("production" !== 'production' && options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1 = this; // check object-style dispatch

  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;
  var action = {
    type: type,
    payload: payload
  };
  var entry = this._actions[type];

  if (!entry) {
    if ("production" !== 'production') {
      console.error("[vuex] unknown action type: " + type);
    }

    return;
  }

  this._actionSubscribers.forEach(function (sub) {
    return sub(action, this$1.state);
  });

  return entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
};

Store.prototype.subscribe = function subscribe(fn) {
  return genericSubscribe(fn, this._subscribers);
};

Store.prototype.subscribeAction = function subscribeAction(fn) {
  return genericSubscribe(fn, this._actionSubscribers);
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  if ("production" !== 'production') {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }

  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0) options = {};

  if (typeof path === 'string') {
    path = [path];
  }

  if ("production" !== 'production') {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);

  installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if ("production" !== 'production') {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);

  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });

  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);

  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);

function genericSubscribe(fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }

  return function () {
    var i = subs.indexOf(fn);

    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state; // init all modules

  installModule(store, state, [], store._modules.root, true); // reset vm

  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm; // bind store public getters

  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };

    Object.defineProperty(store.getters, key, {
      get: function () {
        return store._vm[key];
      },
      enumerable: true // for local getters

    });
  }); // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins

  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent; // enable strict mode for new vm

  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }

    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;

  var namespace = store._modules.getNamespace(path); // register in namespace map


  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  } // set state


  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];

    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);
  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */


function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';
  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if ("production" !== 'production' && !store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if ("production" !== 'production' && !store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  }; // getters and state object must be gotten lazily
  // because they will be changed by vm update

  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function () {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};
  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    } // extract local getter type


    var localType = type.slice(splitPos); // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.

    Object.defineProperty(gettersProxy, localType, {
      get: function () {
        return store.getters[type];
      },
      enumerable: true
    });
  });
  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);

    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }

    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);

        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ("production" !== 'production') {
      console.error("[vuex] duplicate getter key: " + type);
    }

    return;
  }

  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    if ("production" !== 'production') {
      assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
    }
  }, {
    deep: true,
    sync: true
  });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ("production" !== 'production') {
    assert(typeof type === 'string', "Expects string as the type, but found " + typeof type + ".");
  }

  return {
    type: type,
    payload: payload,
    options: options
  };
}

function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if ("production" !== 'production') {
      console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    }

    return;
  }

  Vue = _Vue;
  applyMixin(Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

        if (!module) {
          return;
        }

        state = module.context.state;
        getters = module.context.getters;
      }

      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
exports.mapState = mapState;
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var commit = this.$store.commit;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

        if (!module) {
          return;
        }

        commit = module.context.commit;
      }

      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
exports.mapMutations = mapMutations;
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;
    val = namespace + val;

    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }

      if ("production" !== 'production' && !(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }

      return this.$store.getters[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
exports.mapGetters = mapGetters;
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var dispatch = this.$store.dispatch;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

        if (!module) {
          return;
        }

        dispatch = module.context.dispatch;
      }

      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
exports.mapActions = mapActions;

var createNamespacedHelpers = function (namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};

exports.createNamespacedHelpers = createNamespacedHelpers;

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return {
      key: key,
      val: key
    };
  }) : Object.keys(map).map(function (key) {
    return {
      key: key,
      val: map[key]
    };
  });
}

function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }

    return fn(namespace, map);
  };
}

function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];

  if ("production" !== 'production' && !module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }

  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.0.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};
var _default = index_esm;
exports.default = _default;
},{}],"O/Nc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vuex = _interopRequireDefault(require("vuex"));

var _vue = _interopRequireDefault(require("vue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue.default.use(_vuex.default);

var _default = new _vuex.default.Store({
  state: {
    selectedToolsMap: {},
    transferState: 'INITIAL',
    showOnlySelectedTools: false
  },
  getters: {
    selectedTools: function selectedTools(state) {
      var selectedTools = [];
      Object.entries(state.selectedToolsMap).forEach(function (entry) {
        if (entry[1]) {
          selectedTools.push(entry[0]);
        }
      });
      return selectedTools;
    }
  },
  mutations: {
    toggleToolSelection: function toggleToolSelection(state, id) {
      _vue.default.set(state.selectedToolsMap, id, !state.selectedToolsMap[id]);
    },
    setToolSelection: function setToolSelection(state, id, newValue) {
      _vue.default.set(state.selectedToolsMap, id, newValue);
    },
    resetSelectedTools: function resetSelectedTools(state) {
      state.selectedToolsMap = {};
    },
    updateTransferStatus: function updateTransferStatus(state, newStatus) {
      state.transferState = newStatus;
    },
    toggleShowOnlySelectedTools: function toggleShowOnlySelectedTools(state) {
      state.showOnlySelectedTools = !state.showOnlySelectedTools;
    },
    setShowOnlySelectedTools: function setShowOnlySelectedTools(state, newState) {
      state.showOnlySelectedTools = newState;
    }
  }
});

exports.default = _default;
},{"vuex":"AwB4","vue":"4673"}],"c2Ns":[function(require,module,exports) {
var define;
;(function () {
	'use strict';

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/
	
	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		/**
		 * The check for whether to track touch event start from event.timeStamp (default) or current time (to handle negative timestamp issue)
		 *
		 * @type boolean
		 */
		this.isUsingEventTimeStamp = true;

		/**
		 * The last cick event time stamp
		 *
		 * @type number
		 */
		this.lastClickTime = 0;

		/**
		 * The base time to use for comparison, when not tracking touch by event.timeStamp
		 *
		 * @type number
		 */
		this.nonEventTrackingTimeBase = null;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		if (deviceIsAndroid) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection, touchTimeStamp;

		if (this.isUsingEventTimeStamp && event.timeStamp > -1) {
			touchTimeStamp = event.timeStamp;
		} else {
			if (this.isUsingEventTimeStamp) {
				// Set the base time minus twice the tap delay, to avoid the user seeing a non-response this first time through.
				// This would occur when comparing touchTimeStamp - lastClickTime, which would be roughly 0, and expecting it not to be < this.tapDelay.
				this.nonEventTrackingTimeBase = ((new Date()).getTime() - (this.tapDelay * 2));
				this.lastClickTime = 0;
				this.isUsingEventTimeStamp = false;
			}

			touchTimeStamp = ((new Date()).getTime() - this.nonEventTrackingTimeBase);
		}

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = touchTimeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((touchTimeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, touchEndTime, targetElement = this.targetElement;

		if (this.isUsingEventTimeStamp) {
			touchEndTime = event.timeStamp;
		} else {
			// iOS 11.3+ and Safari 11.1+ can return negative event.timeStamp values after resuming.
			// https://github.com/ftlabs/fastclick/issues/549
			touchEndTime = ((new Date()).getTime() - this.nonEventTrackingTimeBase)
		}

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((touchEndTime - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((touchEndTime - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = touchEndTime;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((touchEndTime - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;
		var firefoxVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		// Firefox version - zero for other browsers
		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (firefoxVersion >= 27) {
			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

			metaViewport = document.querySelector('meta[name=viewport]');
			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
				return true;
			}
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	} else {
		window.FastClick = FastClick;
	}
}());

},{}],"m2w4":[function(require,module,exports) {
var define;
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e() : "function" == typeof define && define.amd ? define(e) : e();
}(0, function () {
  "use strict";

  var t = function (t, e, i) {
    return e in t ? Object.defineProperty(t, e, {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : t[e] = i, t;
  },
      e = function () {
    return function (t, e) {
      if (Array.isArray(t)) return t;
      if (Symbol.iterator in Object(t)) return function (t, e) {
        var i = [],
            n = !0,
            a = !1,
            o = void 0;

        try {
          for (var s, r = t[Symbol.iterator](); !(n = (s = r.next()).done) && (i.push(s.value), !e || i.length !== e); n = !0);
        } catch (t) {
          a = !0, o = t;
        } finally {
          try {
            !n && r.return && r.return();
          } finally {
            if (a) throw o;
          }
        }

        return i;
      }(t, e);
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    };
  }();

  !function () {
    if ("undefined" != typeof document) {
      var t = document.head || document.getElementsByTagName("head")[0],
          e = document.createElement("style"),
          i = ".drawer-layout[data-v-7e696ca1] { position: absolute; top: 0; left: 0; bottom: 0; right: 0; overflow: hidden; } .drawer-wrap[data-v-7e696ca1] { position: absolute; top: 0; bottom: 0; transform: translateZ(0); } .content-wrap[data-v-7e696ca1] { position: absolute; top: 0; right: 0; bottom: 0; left: 0; overflow: hidden; transform: translateZ(0); } .drawer-mask[data-v-7e696ca1] { position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #000; z-index: 818; } .moving[data-v-7e696ca1] { transition: transform 0.3s ease; } .will-change[data-v-7e696ca1] { will-change: transform; } ";
      e.type = "text/css", e.styleSheet ? e.styleSheet.cssText = i : e.appendChild(document.createTextNode(i)), t.appendChild(e);
    }
  }();

  var i = function () {
    var t = !1;

    try {
      var e = Object.defineProperty({}, "passive", {
        get: function () {
          t = !0;
        }
      });
      window.addEventListener("test", null, e);
    } catch (t) {}

    return t;
  }(),
      n = "ontouchstart" in window,
      a = n ? {
    down: "touchstart",
    move: "touchmove",
    up: "touchend"
  } : {
    down: "mousedown",
    move: "mousemove",
    up: "mouseup"
  },
      o = {
    render: function () {
      var t = this,
          e = t.$createElement,
          i = t._self._c || e;
      return i("div", {
        staticClass: "drawer-layout"
      }, [i("div", {
        staticClass: "drawer-wrap",
        class: t.animateStyle,
        style: t.drawerStyle
      }, [t._t("drawer")], 2), t._v(" "), i("div", {
        staticClass: "content-wrap",
        class: t.contentDrawable ? t.animateStyle : {},
        style: t.contentDrawable ? t.contentStyle : {}
      }, [i("div", {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: t.backdrop && t.pos,
          expression: "backdrop && pos"
        }],
        staticClass: "drawer-mask",
        style: {
          opacity: t.backdropOpacity
        },
        on: {
          click: t.handleMaskClick
        }
      }), t._v(" "), t._t("content")], 2)]);
    },
    staticRenderFns: [],
    _scopeId: "data-v-7e696ca1",
    name: "vue-drawer-layout",
    props: {
      drawerWidth: {
        type: Number
      },
      drawableDistance: {
        type: Number
      },
      zIndex: {
        type: Number,
        default: 818
      },
      contentDrawable: {
        type: Boolean,
        default: !1
      },
      backdrop: {
        type: Boolean,
        default: !0
      },
      backdropOpacityRange: {
        type: Array,
        default: function () {
          return [0, .4];
        },
        validator: function (t) {
          var i = e(t, 2),
              n = i[0],
              a = i[1];
          return n < a && n >= 0 && a <= 1;
        }
      },
      enable: {
        type: Boolean,
        default: !0
      },
      animatable: {
        type: Boolean,
        default: !0
      },
      reverse: {
        type: Boolean,
        default: !1
      }
    },
    data: function () {
      return {
        width: this.drawerWidth,
        distance: this.drawableDistance,
        pos: 0,
        visible: !1,
        moving: !1,
        willChange: !1
      };
    },
    methods: {
      toggle: function (t) {
        void 0 === t && (t = !this.visible), this.visible = t, this.pos = t ? this.width : 0, this.moving = !0;
      },
      handleMaskClick: function () {
        this.moving || this.$emit("mask-click");
      }
    },
    watch: {
      moving: function () {
        this.animatable || (this.moving = !1);
      },
      willChange: function () {
        this.animatable || (this.willChange = !1);
      }
    },
    computed: {
      animateStyle: function () {
        return {
          moving: this.moving,
          "will-change": this.willChange
        };
      },
      drawerStyle: function () {
        var e,
            i = this.zIndex,
            n = this.width,
            a = this.moveRate,
            o = this.pos,
            s = this.reverse;
        return t(e = {
          zIndex: i,
          width: n + "px"
        }, s ? "right" : "left", "-" + Math.ceil(n * a) + "px"), t(e, "transform", "translate3d(" + (s ? "-" : "") + Math.ceil(o * a) + "px,0,0)"), e;
      },
      contentStyle: function () {
        var t = this.pos;
        return {
          transform: "translate3d(" + (this.reverse ? "-" : "") + t + "px,0,0)"
        };
      },
      backdropOpacity: function () {
        var t = this.backdropOpacityRange,
            i = this.pos,
            n = this.width,
            a = e(t, 2);
        return a[0] + a[1] * (i / n) || 0;
      },
      moveRate: function () {
        var t = this.width;
        return this.distance / t;
      }
    },
    mounted: function () {
      var t = this,
          e = this.$el,
          o = .8 * parseInt(window.getComputedStyle(this.$el.parentNode).width);
      this.width = this.width || o, this.distance = this.distance || o;

      var s = this.width,
          r = this.reverse,
          d = void 0,
          l = void 0,
          c = void 0,
          h = void 0,
          u = void 0,
          v = void 0,
          p = void 0,
          m = void 0,
          f = void 0,
          w = void 0,
          b = function (t) {
        this.enable && (this.willChange = !0, w = void 0, v = h = t.clientX || t.changedTouches[0].clientX, u = t.clientY || t.changedTouches[0].clientY, l = +new Date(), f = this.pos, document.addEventListener(a.move, y, !(!n || !i) && {
          passive: !0
        }), document.addEventListener(a.up, g, !(!n || !i) && {
          passive: !0
        }), this.$emit("slide-start"));
      }.bind(this),
          y = function (t) {
        d = l, l = +new Date(), m = v, v = t.clientX || t.changedTouches[0].clientX, p = t.clientY || t.changedTouches[0].clientY, c = [1, -1][+r] * (v - m) / (l - d);
        var e = f + [1, -1][+r] * (v - h);
        e = Math.min(s, e), e = Math.max(0, e), void 0 === w && (w = Math.abs(v - h) / Math.abs(p - u) < Math.sqrt(3)), w || (n && i || t.preventDefault(), this.pos = e, this.$emit("slide-move", e));
      }.bind(this),
          g = function (t) {
        if (void 0 !== w) {
          if (!w) {
            var e = this.pos;
            this.visible = c > 0 ? (s - e) / c < 500 || e > 3 * s / 5 : !((0 - e) / c < 500 || e < 3 * s / 5), this.pos > 0 && this.pos < s && (this.moving = !0);
          }

          this.pos = this.visible ? s : 0;
        }

        this.moving || (this.willChange = !1, this.$emit("slide-end", this.visible)), w = void 0, document.removeEventListener(a.move, y, !(!n || !i) && {
          passive: !0
        }), document.removeEventListener(a.up, g, !(!n || !i) && {
          passive: !0
        });
      }.bind(this);

      "transitionend webkitTransitionEnd msTransitionEnd otransitionend oTransitionEnd".split(" ").forEach(function (e) {
        t.$el.addEventListener(e, function () {
          t.moving && (t.moving = !1, t.willChange = !1, t.pos = t.visible ? s : 0, t.$emit("slide-end", t.visible));
        }, !1);
      }), e.addEventListener(a.down, b, !(!n || !i) && {
        passive: !0
      });
    }
  };

  module.exports = {
    DrawerLayout: o,
    install: function t(e) {
      t.installed || e.component(o.name, o);
    }
  }, module.exports.default = module.exports;
});
},{}],"pmZl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.visitInParallel = visitInParallel;
exports.visitWithTypeInfo = visitWithTypeInfo;
exports.getVisitFn = getVisitFn;
exports.BREAK = exports.QueryDocumentKeys = void 0;

var _inspect = _interopRequireDefault(require("../jsutils/inspect"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *  strict
 */


var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
exports.QueryDocumentKeys = QueryDocumentKeys;
var BREAK = {};
/**
 * visit() will walk through an AST using a depth first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

exports.BREAK = BREAK;

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;
  /* eslint-disable no-undef-init */

  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var k in node) {
            if (node.hasOwnProperty(k)) {
              clone[k] = node[k];
            }
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error('Invalid AST Node: ' + (0, _inspect.default)(node));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : visitorKeys[node.kind] || [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}

function isNode(maybeNode) {
  return Boolean(maybeNode && typeof maybeNode.kind === 'string');
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */


function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          false);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          true);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
/**
 * Creates a new visitor instance which maintains a provided TypeInfo instance
 * along with visiting visitor.
 */


function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter: function enter(node) {
      typeInfo.enter(node);
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      false);

      if (fn) {
        var result = fn.apply(visitor, arguments);

        if (result !== undefined) {
          typeInfo.leave(node);

          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }

        return result;
      }
    },
    leave: function leave(node) {
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      true);
      var result;

      if (fn) {
        result = fn.apply(visitor, arguments);
      }

      typeInfo.leave(node);
      return result;
    }
  };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */


function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}
},{"../jsutils/inspect":"Choh"}],"h5rv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.print = print;

var _visitor = require("./visitor");
/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */


function print(ast) {
  return (0, _visitor.visit)(ast, {
    leave: printDocASTReducer
  });
}

var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: function SchemaDefinition(_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (args.every(function (arg) {
      return arg.indexOf('\n') === -1;
    }) ? wrap('(', join(args, ', '), ')') : wrap('(\n', indent(join(args, '\n')), '\n)')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        locations = _ref31.locations;
    return 'directive @' + name + (args.every(function (arg) {
      return arg.indexOf('\n') === -1;
    }) ? wrap('(', join(args, ', '), ')') : wrap('(\n', indent(join(args, '\n')), '\n)')) + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter(function (x) {
    return x;
  }).join(separator || '') : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */


function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || '') : '';
}

function indent(maybeString) {
  return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 */


function printBlockString(value, isDescription) {
  var escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === ' ' || value[0] === '\t') && value.indexOf('\n') === -1 ? "\"\"\"".concat(escaped.replace(/"$/, '"\n'), "\"\"\"") : "\"\"\"\n".concat(isDescription ? escaped : indent(escaped), "\n\"\"\"");
}
},{"./visitor":"pmZl"}],"Ka33":[function(require,module,exports) {
'use strict';

module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

},{}],"vqoJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isScalarValue = isScalarValue;
exports.isNumberValue = isNumberValue;
exports.valueToObjectRepresentation = valueToObjectRepresentation;
exports.storeKeyNameFromField = storeKeyNameFromField;
exports.getStoreKeyName = getStoreKeyName;
exports.argumentsObjectFromField = argumentsObjectFromField;
exports.resultKeyNameFromField = resultKeyNameFromField;
exports.isField = isField;
exports.isInlineFragment = isInlineFragment;
exports.isIdValue = isIdValue;
exports.toIdValue = toIdValue;
exports.isJsonValue = isJsonValue;
exports.valueFromNode = valueFromNode;

var _fastJsonStableStringify = _interopRequireDefault(require("fast-json-stable-stringify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function isScalarValue(value) {
  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;
}

function isNumberValue(value) {
  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;
}

function isStringValue(value) {
  return value.kind === 'StringValue';
}

function isBooleanValue(value) {
  return value.kind === 'BooleanValue';
}

function isIntValue(value) {
  return value.kind === 'IntValue';
}

function isFloatValue(value) {
  return value.kind === 'FloatValue';
}

function isVariable(value) {
  return value.kind === 'Variable';
}

function isObjectValue(value) {
  return value.kind === 'ObjectValue';
}

function isListValue(value) {
  return value.kind === 'ListValue';
}

function isEnumValue(value) {
  return value.kind === 'EnumValue';
}

function isNullValue(value) {
  return value.kind === 'NullValue';
}

function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function (obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function (listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw new Error("The inline argument \"" + name.value + "\" of kind \"" + value.kind + "\"" + 'is not supported. Use variables instead of inline arguments to ' + 'overcome this limitation.');
  }
}

function storeKeyNameFromField(field, variables) {
  var directivesObj = null;

  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function (directive) {
      directivesObj[directive.name.value] = {};

      if (directive.arguments) {
        directive.arguments.forEach(function (_a) {
          var name = _a.name,
              value = _a.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }

  var argObj = null;

  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function (_a) {
      var name = _a.name,
          value = _a.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }

  return getStoreKeyName(field.name.value, argObj, directivesObj);
}

var KNOWN_DIRECTIVES = ['connection', 'include', 'skip', 'client', 'rest', 'export'];

function getStoreKeyName(fieldName, args, directives) {
  if (directives && directives['connection'] && directives['connection']['key']) {
    if (directives['connection']['filter'] && directives['connection']['filter'].length > 0) {
      var filterKeys = directives['connection']['filter'] ? directives['connection']['filter'] : [];
      filterKeys.sort();
      var queryArgs_1 = args;
      var filteredArgs_1 = {};
      filterKeys.forEach(function (key) {
        filteredArgs_1[key] = queryArgs_1[key];
      });
      return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
    } else {
      return directives['connection']['key'];
    }
  }

  var completeFieldName = fieldName;

  if (args) {
    var stringifiedArgs = (0, _fastJsonStableStringify.default)(args);
    completeFieldName += "(" + stringifiedArgs + ")";
  }

  if (directives) {
    Object.keys(directives).forEach(function (key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;

      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
      } else {
        completeFieldName += "@" + key;
      }
    });
  }

  return completeFieldName;
}

function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function (_a) {
      var name = _a.name,
          value = _a.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }

  return null;
}

function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}

function isField(selection) {
  return selection.kind === 'Field';
}

function isInlineFragment(selection) {
  return selection.kind === 'InlineFragment';
}

function isIdValue(idObject) {
  return idObject && idObject.type === 'id';
}

function toIdValue(idConfig, generated) {
  if (generated === void 0) {
    generated = false;
  }

  return __assign({
    type: 'id',
    generated: generated
  }, typeof idConfig === 'string' ? {
    id: idConfig,
    typename: undefined
  } : idConfig);
}

function isJsonValue(jsonObject) {
  return jsonObject != null && typeof jsonObject === 'object' && jsonObject.type === 'json';
}

function defaultValueFromVariable(node) {
  throw new Error("Variable nodes are not supported by valueFromNode");
}

function valueFromNode(node, onVariable) {
  if (onVariable === void 0) {
    onVariable = defaultValueFromVariable;
  }

  switch (node.kind) {
    case 'Variable':
      return onVariable(node);

    case 'NullValue':
      return null;

    case 'IntValue':
      return parseInt(node.value, 10);

    case 'FloatValue':
      return parseFloat(node.value);

    case 'ListValue':
      return node.values.map(function (v) {
        return valueFromNode(v, onVariable);
      });

    case 'ObjectValue':
      {
        var value = {};

        for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {
          var field = _a[_i];
          value[field.name.value] = valueFromNode(field.value, onVariable);
        }

        return value;
      }

    default:
      return node.value;
  }
}
},{"fast-json-stable-stringify":"Ka33"}],"EZe8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDirectiveInfoFromField = getDirectiveInfoFromField;
exports.shouldInclude = shouldInclude;
exports.flattenSelections = flattenSelections;
exports.getDirectiveNames = getDirectiveNames;
exports.hasDirectives = hasDirectives;

var _storeUtils = require("./storeUtils");

function getDirectiveInfoFromField(field, variables) {
  if (field.directives && field.directives.length) {
    var directiveObj_1 = {};
    field.directives.forEach(function (directive) {
      directiveObj_1[directive.name.value] = (0, _storeUtils.argumentsObjectFromField)(directive, variables);
    });
    return directiveObj_1;
  }

  return null;
}

function shouldInclude(selection, variables) {
  if (variables === void 0) {
    variables = {};
  }

  if (!selection.directives) {
    return true;
  }

  var res = true;
  selection.directives.forEach(function (directive) {
    if (directive.name.value !== 'skip' && directive.name.value !== 'include') {
      return;
    }

    var directiveArguments = directive.arguments || [];
    var directiveName = directive.name.value;

    if (directiveArguments.length !== 1) {
      throw new Error("Incorrect number of arguments for the @" + directiveName + " directive.");
    }

    var ifArgument = directiveArguments[0];

    if (!ifArgument.name || ifArgument.name.value !== 'if') {
      throw new Error("Invalid argument for the @" + directiveName + " directive.");
    }

    var ifValue = directiveArguments[0].value;
    var evaledValue = false;

    if (!ifValue || ifValue.kind !== 'BooleanValue') {
      if (ifValue.kind !== 'Variable') {
        throw new Error("Argument for the @" + directiveName + " directive must be a variable or a boolean value.");
      } else {
        evaledValue = variables[ifValue.name.value];

        if (evaledValue === undefined) {
          throw new Error("Invalid variable referenced in @" + directiveName + " directive.");
        }
      }
    } else {
      evaledValue = ifValue.value;
    }

    if (directiveName === 'skip') {
      evaledValue = !evaledValue;
    }

    if (!evaledValue) {
      res = false;
    }
  });
  return res;
}

function flattenSelections(selection) {
  if (!selection.selectionSet || !(selection.selectionSet.selections.length > 0)) return [selection];
  return [selection].concat(selection.selectionSet.selections.map(function (selectionNode) {
    return [selectionNode].concat(flattenSelections(selectionNode));
  }).reduce(function (selections, selected) {
    return selections.concat(selected);
  }, []));
}

function getDirectiveNames(doc) {
  var directiveNames = doc.definitions.filter(function (definition) {
    return definition.selectionSet && definition.selectionSet.selections;
  }).map(function (x) {
    return flattenSelections(x);
  }).reduce(function (selections, selected) {
    return selections.concat(selected);
  }, []).filter(function (selection) {
    return selection.directives && selection.directives.length > 0;
  }).map(function (selection) {
    return selection.directives;
  }).reduce(function (directives, directive) {
    return directives.concat(directive);
  }, []).map(function (directive) {
    return directive.name.value;
  });
  return directiveNames;
}

function hasDirectives(names, doc) {
  return getDirectiveNames(doc).some(function (name) {
    return names.indexOf(name) > -1;
  });
}
},{"./storeUtils":"vqoJ"}],"rdXk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFragmentQueryDocument = getFragmentQueryDocument;

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function getFragmentQueryDocument(document, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document.definitions.forEach(function (definition) {
    if (definition.kind === 'OperationDefinition') {
      throw new Error("Found a " + definition.operation + " operation" + (definition.name ? " named '" + definition.name.value + "'" : '') + ". " + 'No operations are allowed when using a fragment as a query. Only fragments are allowed.');
    }

    if (definition.kind === 'FragmentDefinition') {
      fragments.push(definition);
    }
  });

  if (typeof actualFragmentName === 'undefined') {
    if (fragments.length !== 1) {
      throw new Error("Found " + fragments.length + " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.");
    }

    actualFragmentName = fragments[0].name.value;
  }

  var query = __assign({}, document, {
    definitions: [{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections: [{
          kind: 'FragmentSpread',
          name: {
            kind: 'Name',
            value: actualFragmentName
          }
        }]
      }
    }].concat(document.definitions)
  });

  return query;
}
},{}],"SjNH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assign = assign;

function assign(target) {
  var sources = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }

  sources.forEach(function (source) {
    if (typeof source === 'undefined' || source === null) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
}
},{}],"pDe0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMutationDefinition = getMutationDefinition;
exports.checkDocument = checkDocument;
exports.getOperationDefinition = getOperationDefinition;
exports.getOperationDefinitionOrDie = getOperationDefinitionOrDie;
exports.getOperationName = getOperationName;
exports.getFragmentDefinitions = getFragmentDefinitions;
exports.getQueryDefinition = getQueryDefinition;
exports.getFragmentDefinition = getFragmentDefinition;
exports.getMainDefinition = getMainDefinition;
exports.createFragmentMap = createFragmentMap;
exports.getDefaultValues = getDefaultValues;
exports.variablesInOperation = variablesInOperation;

var _assign = require("./util/assign");

var _storeUtils = require("./storeUtils");

function getMutationDefinition(doc) {
  checkDocument(doc);
  var mutationDef = doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition' && definition.operation === 'mutation';
  })[0];

  if (!mutationDef) {
    throw new Error('Must contain a mutation definition.');
  }

  return mutationDef;
}

function checkDocument(doc) {
  if (doc.kind !== 'Document') {
    throw new Error("Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
  }

  var operations = doc.definitions.filter(function (d) {
    return d.kind !== 'FragmentDefinition';
  }).map(function (definition) {
    if (definition.kind !== 'OperationDefinition') {
      throw new Error("Schema type definitions not allowed in queries. Found: \"" + definition.kind + "\"");
    }

    return definition;
  });

  if (operations.length > 1) {
    throw new Error("Ambiguous GraphQL document: contains " + operations.length + " operations");
  }
}

function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition';
  })[0];
}

function getOperationDefinitionOrDie(document) {
  var def = getOperationDefinition(document);

  if (!def) {
    throw new Error("GraphQL document is missing an operation");
  }

  return def;
}

function getOperationName(doc) {
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition' && definition.name;
  }).map(function (x) {
    return x.name.value;
  })[0] || null;
}

function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'FragmentDefinition';
  });
}

function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);

  if (!queryDef || queryDef.operation !== 'query') {
    throw new Error('Must contain a query definition.');
  }

  return queryDef;
}

function getFragmentDefinition(doc) {
  if (doc.kind !== 'Document') {
    throw new Error("Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql");
  }

  if (doc.definitions.length > 1) {
    throw new Error('Fragment must have exactly one definition.');
  }

  var fragmentDef = doc.definitions[0];

  if (fragmentDef.kind !== 'FragmentDefinition') {
    throw new Error('Must be a fragment definition.');
  }

  return fragmentDef;
}

function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;

  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
    var definition = _a[_i];

    if (definition.kind === 'OperationDefinition') {
      var operation = definition.operation;

      if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {
        return definition;
      }
    }

    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }

  if (fragmentDefinition) {
    return fragmentDefinition;
  }

  throw new Error('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');
}

function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }

  var symTable = {};
  fragments.forEach(function (fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}

function getDefaultValues(definition) {
  if (definition && definition.variableDefinitions && definition.variableDefinitions.length) {
    var defaultValues = definition.variableDefinitions.filter(function (_a) {
      var defaultValue = _a.defaultValue;
      return defaultValue;
    }).map(function (_a) {
      var variable = _a.variable,
          defaultValue = _a.defaultValue;
      var defaultValueObj = {};
      (0, _storeUtils.valueToObjectRepresentation)(defaultValueObj, variable.name, defaultValue);
      return defaultValueObj;
    });
    return _assign.assign.apply(void 0, [{}].concat(defaultValues));
  }

  return {};
}

function variablesInOperation(operation) {
  var names = new Set();

  if (operation.variableDefinitions) {
    for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {
      var definition = _a[_i];
      names.add(definition.variable.name.value);
    }
  }

  return names;
}
},{"./util/assign":"SjNH","./storeUtils":"vqoJ"}],"S184":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"Quj6":[function(require,module,exports) {
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"aq/z":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"aMB2":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"S184","ieee754":"Quj6","isarray":"aq/z","buffer":"aMB2"}],"hAqB":[function(require,module,exports) {
var define;
var Buffer = require("buffer").Buffer;
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('fclone', [], factory);
    } else if (typeof module === 'object' && module.exports) {
			  //node
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.fclone = factory();
    }
}(this, function () {
  'use strict';

// see if it looks and smells like an iterable object, and do accept length === 0

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function isArrayLike(item) {
  if (Array.isArray(item)) return true;

  var len = item && item.length;
  return typeof len === 'number' && (len === 0 || len - 1 in item) && typeof item.indexOf === 'function';
}

function fclone(obj, refs) {
  if (!obj || "object" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) return obj;

  if (obj instanceof Date) {
    return new Date(obj);
  }

  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {
    return new Buffer(obj);
  }

  // typed array Int32Array etc.
  if (typeof obj.subarray === 'function' && /[A-Z][A-Za-z\d]+Array/.test(Object.prototype.toString.call(obj))) {
    return obj.subarray(0);
  }

  if (!refs) {
    refs = [];
  }

  if (isArrayLike(obj)) {
    refs[refs.length] = obj;
    var _l = obj.length;
    var i = -1;
    var _copy = [];

    while (_l > ++i) {
      _copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);
    }

    refs.length && refs.length--;
    return _copy;
  }

  refs[refs.length] = obj;
  var copy = {};

  if (obj instanceof Error) {
    copy.name = obj.name;
    copy.message = obj.message;
    copy.stack = obj.stack;
  }

  var keys = Object.keys(obj);
  var l = keys.length;

  while (l--) {
    var k = keys[l];
    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);
  }

  refs.length && refs.length--;
  return copy;
}

fclone.default = fclone;
  return fclone
}));
},{"buffer":"aMB2"}],"tmx1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneDeep = cloneDeep;

var _fclone = _interopRequireDefault(require("fclone"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeep(value) {
  return (0, _fclone.default)(value);
}
},{"fclone":"hAqB"}],"znFu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeDirectivesFromDocument = removeDirectivesFromDocument;
exports.addTypenameToDocument = addTypenameToDocument;
exports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
exports.getDirectivesFromDocument = getDirectivesFromDocument;

var _cloneDeep = require("./util/cloneDeep");

var _getFromAST = require("./getFromAST");

var TYPENAME_FIELD = {
  kind: 'Field',
  name: {
    kind: 'Name',
    value: '__typename'
  }
};

function isNotEmpty(op, fragments) {
  return op.selectionSet.selections.filter(function (selectionSet) {
    return !(selectionSet && selectionSet.kind === 'FragmentSpread' && !isNotEmpty(fragments[selectionSet.name.value], fragments));
  }).length > 0;
}

function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function (dir) {
      if (dir.name && dir.name === directive.name.value) return true;
      if (dir.test && dir.test(directive)) return true;
      return false;
    });
  };
}

function addTypenameToSelectionSet(selectionSet, isRoot) {
  if (isRoot === void 0) {
    isRoot = false;
  }

  if (selectionSet.selections) {
    if (!isRoot) {
      var alreadyHasThisField = selectionSet.selections.some(function (selection) {
        return selection.kind === 'Field' && selection.name.value === '__typename';
      });

      if (!alreadyHasThisField) {
        selectionSet.selections.push(TYPENAME_FIELD);
      }
    }

    selectionSet.selections.forEach(function (selection) {
      if (selection.kind === 'Field') {
        if (selection.name.value.lastIndexOf('__', 0) !== 0 && selection.selectionSet) {
          addTypenameToSelectionSet(selection.selectionSet);
        }
      } else if (selection.kind === 'InlineFragment') {
        if (selection.selectionSet) {
          addTypenameToSelectionSet(selection.selectionSet);
        }
      }
    });
  }
}

function removeDirectivesFromSelectionSet(directives, selectionSet) {
  if (!selectionSet.selections) return selectionSet;
  var agressiveRemove = directives.some(function (dir) {
    return dir.remove;
  });
  selectionSet.selections = selectionSet.selections.map(function (selection) {
    if (selection.kind !== 'Field' || !selection || !selection.directives) return selection;
    var directiveMatcher = getDirectiveMatcher(directives);
    var remove;
    selection.directives = selection.directives.filter(function (directive) {
      var shouldKeep = !directiveMatcher(directive);
      if (!remove && !shouldKeep && agressiveRemove) remove = true;
      return shouldKeep;
    });
    return remove ? null : selection;
  }).filter(function (x) {
    return !!x;
  });
  selectionSet.selections.forEach(function (selection) {
    if ((selection.kind === 'Field' || selection.kind === 'InlineFragment') && selection.selectionSet) {
      removeDirectivesFromSelectionSet(directives, selection.selectionSet);
    }
  });
  return selectionSet;
}

function removeDirectivesFromDocument(directives, doc) {
  var docClone = (0, _cloneDeep.cloneDeep)(doc);
  docClone.definitions.forEach(function (definition) {
    removeDirectivesFromSelectionSet(directives, definition.selectionSet);
  });
  var operation = (0, _getFromAST.getOperationDefinitionOrDie)(docClone);
  var fragments = (0, _getFromAST.createFragmentMap)((0, _getFromAST.getFragmentDefinitions)(docClone));
  return isNotEmpty(operation, fragments) ? docClone : null;
}

function addTypenameToDocument(doc) {
  (0, _getFromAST.checkDocument)(doc);
  var docClone = (0, _cloneDeep.cloneDeep)(doc);
  docClone.definitions.forEach(function (definition) {
    var isRoot = definition.kind === 'OperationDefinition';
    addTypenameToSelectionSet(definition.selectionSet, isRoot);
  });
  return docClone;
}

var connectionRemoveConfig = {
  test: function (directive) {
    var willRemove = directive.name.value === 'connection';

    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function (arg) {
        return arg.name.value === 'key';
      })) {
        console.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');
      }
    }

    return willRemove;
  }
};

function removeConnectionDirectiveFromDocument(doc) {
  (0, _getFromAST.checkDocument)(doc);
  return removeDirectivesFromDocument([connectionRemoveConfig], doc);
}

function hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {
  if (nestedCheck === void 0) {
    nestedCheck = true;
  }

  if (!(selectionSet && selectionSet.selections)) {
    return false;
  }

  var matchedSelections = selectionSet.selections.filter(function (selection) {
    return hasDirectivesInSelection(directives, selection, nestedCheck);
  });
  return matchedSelections.length > 0;
}

function hasDirectivesInSelection(directives, selection, nestedCheck) {
  if (nestedCheck === void 0) {
    nestedCheck = true;
  }

  if (selection.kind !== 'Field' || !selection) {
    return true;
  }

  if (!selection.directives) {
    return false;
  }

  var directiveMatcher = getDirectiveMatcher(directives);
  var matchedDirectives = selection.directives.filter(directiveMatcher);
  return matchedDirectives.length > 0 || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);
}

function getDirectivesFromSelectionSet(directives, selectionSet) {
  selectionSet.selections = selectionSet.selections.filter(function (selection) {
    return hasDirectivesInSelection(directives, selection, true);
  }).map(function (selection) {
    if (hasDirectivesInSelection(directives, selection, false)) {
      return selection;
    }

    if ((selection.kind === 'Field' || selection.kind === 'InlineFragment') && selection.selectionSet) {
      selection.selectionSet = getDirectivesFromSelectionSet(directives, selection.selectionSet);
    }

    return selection;
  });
  return selectionSet;
}

function getDirectivesFromDocument(directives, doc, includeAllFragments) {
  if (includeAllFragments === void 0) {
    includeAllFragments = false;
  }

  (0, _getFromAST.checkDocument)(doc);
  var docClone = (0, _cloneDeep.cloneDeep)(doc);
  docClone.definitions = docClone.definitions.map(function (definition) {
    if ((definition.kind === 'OperationDefinition' || definition.kind === 'FragmentDefinition' && !includeAllFragments) && definition.selectionSet) {
      definition.selectionSet = getDirectivesFromSelectionSet(directives, definition.selectionSet);
    }

    return definition;
  });
  var operation = (0, _getFromAST.getOperationDefinitionOrDie)(docClone);
  var fragments = (0, _getFromAST.createFragmentMap)((0, _getFromAST.getFragmentDefinitions)(docClone));
  return isNotEmpty(operation, fragments) ? docClone : null;
}
},{"./util/cloneDeep":"tmx1","./getFromAST":"pDe0"}],"0p0q":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEnv = getEnv;
exports.isEnv = isEnv;
exports.isProduction = isProduction;
exports.isDevelopment = isDevelopment;
exports.isTest = isTest;

function getEnv() {
  if (typeof process !== 'undefined' && "production") {
    return "production";
  }

  return 'development';
}

function isEnv(env) {
  return getEnv() === env;
}

function isProduction() {
  return isEnv('production') === true;
}

function isDevelopment() {
  return isEnv('development') === true;
}

function isTest() {
  return isEnv('test') === true;
}
},{"process":"g5I+"}],"fCuK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tryFunctionOrLogError = tryFunctionOrLogError;
exports.graphQLResultHasError = graphQLResultHasError;

function tryFunctionOrLogError(f) {
  try {
    return f();
  } catch (e) {
    if (console.error) {
      console.error(e);
    }
  }
}

function graphQLResultHasError(result) {
  return result.errors && result.errors.length;
}
},{}],"+t6c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqual = isEqual;

function isEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }

  if (a != null && typeof a === 'object' && b != null && typeof b === 'object') {
    for (var key in a) {
      if (Object.prototype.hasOwnProperty.call(a, key)) {
        if (!Object.prototype.hasOwnProperty.call(b, key)) {
          return false;
        }

        if (!isEqual(a[key], b[key])) {
          return false;
        }
      }
    }

    for (var key in b) {
      if (!Object.prototype.hasOwnProperty.call(a, key)) {
        return false;
      }
    }

    return true;
  }

  return false;
}
},{}],"trhY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maybeDeepFreeze = maybeDeepFreeze;

var _environment = require("./environment");

function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
}

function maybeDeepFreeze(obj) {
  if ((0, _environment.isDevelopment)() || (0, _environment.isTest)()) {
    var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';

    if (!symbolIsPolyfilled) {
      return deepFreeze(obj);
    }
  }

  return obj;
}
},{"./environment":"0p0q"}],"IyS2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warnOnceInDevelopment = warnOnceInDevelopment;

var _environment = require("./environment");

var haveWarned = Object.create({});

function warnOnceInDevelopment(msg, type) {
  if (type === void 0) {
    type = 'warn';
  }

  if ((0, _environment.isProduction)()) {
    return;
  }

  if (!haveWarned[msg]) {
    if (!(0, _environment.isTest)()) {
      haveWarned[msg] = true;
    }

    switch (type) {
      case 'error':
        console.error(msg);
        break;

      default:
        console.warn(msg);
    }
  }
}
},{"./environment":"0p0q"}],"OZ5m":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stripSymbols = stripSymbols;

function stripSymbols(data) {
  return JSON.parse(JSON.stringify(data));
}
},{}],"cD8x":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _directives = require("./directives");

Object.keys(_directives).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _directives[key];
    }
  });
});

var _fragments = require("./fragments");

Object.keys(_fragments).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fragments[key];
    }
  });
});

var _getFromAST = require("./getFromAST");

Object.keys(_getFromAST).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _getFromAST[key];
    }
  });
});

var _transform = require("./transform");

Object.keys(_transform).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _transform[key];
    }
  });
});

var _storeUtils = require("./storeUtils");

Object.keys(_storeUtils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _storeUtils[key];
    }
  });
});

var _assign = require("./util/assign");

Object.keys(_assign).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _assign[key];
    }
  });
});

var _cloneDeep = require("./util/cloneDeep");

Object.keys(_cloneDeep).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cloneDeep[key];
    }
  });
});

var _environment = require("./util/environment");

Object.keys(_environment).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _environment[key];
    }
  });
});

var _errorHandling = require("./util/errorHandling");

Object.keys(_errorHandling).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _errorHandling[key];
    }
  });
});

var _isEqual = require("./util/isEqual");

Object.keys(_isEqual).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _isEqual[key];
    }
  });
});

var _maybeDeepFreeze = require("./util/maybeDeepFreeze");

Object.keys(_maybeDeepFreeze).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _maybeDeepFreeze[key];
    }
  });
});

var _warnOnce = require("./util/warnOnce");

Object.keys(_warnOnce).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _warnOnce[key];
    }
  });
});

var _stripSymbols = require("./util/stripSymbols");

Object.keys(_stripSymbols).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _stripSymbols[key];
    }
  });
});
},{"./directives":"EZe8","./fragments":"rdXk","./getFromAST":"pDe0","./transform":"znFu","./storeUtils":"vqoJ","./util/assign":"SjNH","./util/cloneDeep":"tmx1","./util/environment":"0p0q","./util/errorHandling":"fCuK","./util/isEqual":"+t6c","./util/maybeDeepFreeze":"trhY","./util/warnOnce":"IyS2","./util/stripSymbols":"OZ5m"}],"x3yF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNetworkRequestInFlight = isNetworkRequestInFlight;
exports.NetworkStatus = void 0;
var NetworkStatus;
exports.NetworkStatus = NetworkStatus;

(function (NetworkStatus) {
  NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
  NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
  NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
  NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
  NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
  NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
  NetworkStatus[NetworkStatus["error"] = 8] = "error";
})(NetworkStatus || (exports.NetworkStatus = NetworkStatus = {}));

function isNetworkRequestInFlight(networkStatus) {
  return networkStatus < 7;
}
},{}],"mggo":[function(require,module,exports) {
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// === Symbol Support ===

var hasSymbols = function () {
  return typeof Symbol === 'function';
};
var hasSymbol = function (name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function (name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

// === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];

  if (value == null) return undefined;

  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');

  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== undefined) {
    ctor = ctor[getSymbol('species')];
    if (ctor === null) {
      ctor = undefined;
    }
  }
  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;

  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = undefined;
  subscription._state = 'ready';
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';

  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);
    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;
      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;
      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({ type: type, value: value });
    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{ type: type, value: value }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription = function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription);

    // ASSERT: observer is an object
    // ASSERT: subscriber is callable

    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';

    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  _createClass(Subscription, [{
    key: 'unsubscribe',
    value: function unsubscribe() {
      if (this._state !== 'closed') {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    }
  }, {
    key: 'closed',
    get: function () {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver = function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: 'next',
    value: function next(value) {
      onNotify(this._subscription, 'next', value);
    }
  }, {
    key: 'error',
    value: function error(value) {
      onNotify(this._subscription, 'error', value);
    }
  }, {
    key: 'complete',
    value: function complete() {
      onNotify(this._subscription, 'complete');
    }
  }, {
    key: 'closed',
    get: function () {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable = exports.Observable = function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');

    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');

    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: 'subscribe',
    value: function subscribe(observer) {
      if (typeof observer !== 'object' || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }
      return new Subscription(observer, this._subscriber);
    }
  }, {
    key: 'forEach',
    value: function forEach(fn) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (typeof fn !== 'function') {
          reject(new TypeError(fn + ' is not a function'));
          return;
        }

        function done() {
          subscription.unsubscribe();
          resolve();
        }

        var subscription = _this.subscribe({
          next: function (value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },

          error: reject,
          complete: resolve
        });
      });
    }
  }, {
    key: 'map',
    value: function map(fn) {
      var _this2 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        return _this2.subscribe({
          next: function (value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'filter',
    value: function filter(fn) {
      var _this3 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        return _this3.subscribe({
          next: function (value) {
            try {
              if (!fn(value)) return;
            } catch (e) {
              return observer.error(e);
            }
            observer.next(value);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'reduce',
    value: function reduce(fn) {
      var _this4 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;

      return new C(function (observer) {
        return _this4.subscribe({
          next: function (value) {
            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));

            observer.next(acc);
            observer.complete();
          }
        });
      });
    }
  }, {
    key: 'concat',
    value: function concat() {
      var _this5 = this;

      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }

      var C = getSpecies(this);

      return new C(function (observer) {
        var subscription = void 0;

        function startNext(next) {
          subscription = next.subscribe({
            next: function (v) {
              observer.next(v);
            },
            error: function (e) {
              observer.error(e);
            },
            complete: function () {
              if (sources.length === 0) {
                subscription = undefined;
                observer.complete();
              } else {
                startNext(C.from(sources.shift()));
              }
            }
          });
        }

        startNext(_this5);

        return function () {
          if (subscription) {
            subscription.unsubscribe();
            subscription = undefined;
          }
        };
      });
    }
  }, {
    key: 'flatMap',
    value: function flatMap(fn) {
      var _this6 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');

      var C = getSpecies(this);

      return new C(function (observer) {
        var subscriptions = [];

        var outer = _this6.subscribe({
          next: function (value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }

            var inner = C.from(value).subscribe({
              next: function (value) {
                observer.next(value);
              },
              error: function (e) {
                observer.error(e);
              },
              complete: function () {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });

            subscriptions.push(inner);
          },
          error: function (e) {
            observer.error(e);
          },
          complete: function () {
            completeIfDone();
          }
        });

        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }
  }, {
    key: getSymbol('observable'),
    value: function () {
      return this;
    }
  }], [{
    key: 'from',
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;

      if (x == null) throw new TypeError(x + ' is not an object');

      var method = getMethod(x, getSymbol('observable'));
      if (method) {
        var observable = method.call(x);

        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');

        if (isObservable(observable) && observable.constructor === C) return observable;

        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      if (hasSymbol('iterator')) {
        method = getMethod(x, getSymbol('iterator'));
        if (method) {
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var item = _step.value;

                  observer.next(item);
                  if (observer.closed) return;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              observer.complete();
            });
          });
        }
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;
            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      }

      throw new TypeError(x + ' is not observable');
    }
  }, {
    key: 'of',
    value: function of() {
      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      var C = typeof this === 'function' ? this : Observable;

      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;
          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }
          observer.complete();
        });
      });
    }
  }, {
    key: getSymbol('species'),
    get: function () {
      return this;
    }
  }]);

  return Observable;
}();

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: getSymbol('observable'),
      hostReportError: hostReportError
    },
    configurabe: true
  });
}
},{}],"0qoK":[function(require,module,exports) {
module.exports = require('./lib/Observable.js').Observable;

},{"./lib/Observable.js":"mggo"}],"hT/B":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observable = void 0;

var _zenObservable = _interopRequireDefault(require("zen-observable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* tslint:disable */
var Observable = _zenObservable.default;
exports.Observable = Observable;
},{"zen-observable":"0qoK"}],"ngXU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports.default = void 0;

var _zenObservable = require("./zenObservable");

Object.keys(_zenObservable).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _zenObservable[key];
    }
  });
});
var _default = _zenObservable.Observable;
exports.default = _default;
},{"./zenObservable":"hT/B"}],"zBX+":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateOperation = validateOperation;
exports.isTerminating = isTerminating;
exports.toPromise = toPromise;
exports.fromPromise = fromPromise;
exports.fromError = fromError;
exports.transformOperation = transformOperation;
exports.createOperation = createOperation;
exports.getKey = getKey;
exports.makePromise = exports.LinkError = void 0;

var _apolloUtilities = require("apollo-utilities");

var _zenObservableTs = _interopRequireDefault(require("zen-observable-ts"));

var _printer = require("graphql/language/printer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function validateOperation(operation) {
  var OPERATION_FIELDS = ['query', 'operationName', 'variables', 'extensions', 'context'];

  for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
    var key = _a[_i];

    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw new Error("illegal argument: " + key);
    }
  }

  return operation;
}

var LinkError =
/** @class */
function (_super) {
  __extends(LinkError, _super);

  function LinkError(message, link) {
    var _this = _super.call(this, message) || this;

    _this.link = link;
    return _this;
  }

  return LinkError;
}(Error);

exports.LinkError = LinkError;

function isTerminating(link) {
  return link.request.length <= 1;
}

function toPromise(observable) {
  var completed = false;
  return new Promise(function (resolve, reject) {
    observable.subscribe({
      next: function (data) {
        if (completed) {
          console.warn("Promise Wrapper does not support multiple results from Observable");
        } else {
          completed = true;
          resolve(data);
        }
      },
      error: reject
    });
  });
} // backwards compat


var makePromise = toPromise;
exports.makePromise = makePromise;

function fromPromise(promise) {
  return new _zenObservableTs.default(function (observer) {
    promise.then(function (value) {
      observer.next(value);
      observer.complete();
    }).catch(observer.error.bind(observer));
  });
}

function fromError(errorValue) {
  return new _zenObservableTs.default(function (observer) {
    observer.error(errorValue);
  });
}

function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  }; // best guess at an operation name

  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== 'string' ? (0, _apolloUtilities.getOperationName)(transformedOperation.query) : '';
  }

  return transformedOperation;
}

function createOperation(starting, operation) {
  var context = __assign({}, starting);

  var setContext = function (next) {
    if (typeof next === 'function') {
      context = __assign({}, context, next(context));
    } else {
      context = __assign({}, context, next);
    }
  };

  var getContext = function () {
    return __assign({}, context);
  };

  Object.defineProperty(operation, 'setContext', {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, 'getContext', {
    enumerable: false,
    value: getContext
  });
  Object.defineProperty(operation, 'toKey', {
    enumerable: false,
    value: function () {
      return getKey(operation);
    }
  });
  return operation;
}

function getKey(operation) {
  // XXX we're assuming here that variables will be serialized in the same order.
  // that might not always be true
  return (0, _printer.print)(operation.query) + "|" + JSON.stringify(operation.variables) + "|" + operation.operationName;
}
},{"apollo-utilities":"cD8x","zen-observable-ts":"ngXU","graphql/language/printer":"h5rv"}],"O/XI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.execute = execute;
exports.ApolloLink = exports.concat = exports.split = exports.from = exports.empty = void 0;

var _zenObservableTs = _interopRequireDefault(require("zen-observable-ts"));

var _linkUtils = require("./linkUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var passthrough = function (op, forward) {
  return forward ? forward(op) : _zenObservableTs.default.of();
};

var toLink = function (handler) {
  return typeof handler === 'function' ? new ApolloLink(handler) : handler;
};

var empty = function () {
  return new ApolloLink(function (op, forward) {
    return _zenObservableTs.default.of();
  });
};

exports.empty = empty;

var from = function (links) {
  if (links.length === 0) return empty();
  return links.map(toLink).reduce(function (x, y) {
    return x.concat(y);
  });
};

exports.from = from;

var split = function (test, left, right) {
  if (right === void 0) {
    right = new ApolloLink(passthrough);
  }

  var leftLink = toLink(left);
  var rightLink = toLink(right);

  if ((0, _linkUtils.isTerminating)(leftLink) && (0, _linkUtils.isTerminating)(rightLink)) {
    return new ApolloLink(function (operation) {
      return test(operation) ? leftLink.request(operation) || _zenObservableTs.default.of() : rightLink.request(operation) || _zenObservableTs.default.of();
    });
  } else {
    return new ApolloLink(function (operation, forward) {
      return test(operation) ? leftLink.request(operation, forward) || _zenObservableTs.default.of() : rightLink.request(operation, forward) || _zenObservableTs.default.of();
    });
  }
}; // join two Links together


exports.split = split;

var concat = function (first, second) {
  var firstLink = toLink(first);

  if ((0, _linkUtils.isTerminating)(firstLink)) {
    console.warn(new _linkUtils.LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
    return firstLink;
  }

  var nextLink = toLink(second);

  if ((0, _linkUtils.isTerminating)(nextLink)) {
    return new ApolloLink(function (operation) {
      return firstLink.request(operation, function (op) {
        return nextLink.request(op) || _zenObservableTs.default.of();
      }) || _zenObservableTs.default.of();
    });
  } else {
    return new ApolloLink(function (operation, forward) {
      return firstLink.request(operation, function (op) {
        return nextLink.request(op, forward) || _zenObservableTs.default.of();
      }) || _zenObservableTs.default.of();
    });
  }
};

exports.concat = concat;

var ApolloLink =
/** @class */
function () {
  function ApolloLink(request) {
    if (request) this.request = request;
  }

  ApolloLink.prototype.split = function (test, left, right) {
    if (right === void 0) {
      right = new ApolloLink(passthrough);
    }

    return this.concat(split(test, left, right));
  };

  ApolloLink.prototype.concat = function (next) {
    return concat(this, next);
  };

  ApolloLink.prototype.request = function (operation, forward) {
    throw new Error('request is not implemented');
  };

  ApolloLink.empty = empty;
  ApolloLink.from = from;
  ApolloLink.split = split;
  ApolloLink.execute = execute;
  return ApolloLink;
}();

exports.ApolloLink = ApolloLink;

function execute(link, operation) {
  return link.request((0, _linkUtils.createOperation)(operation.context, (0, _linkUtils.transformOperation)((0, _linkUtils.validateOperation)(operation)))) || _zenObservableTs.default.of();
}
},{"zen-observable-ts":"ngXU","./linkUtils":"zBX+"}],"uD5J":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createOperation: true,
  makePromise: true,
  toPromise: true,
  fromPromise: true,
  fromError: true,
  Observable: true
};
Object.defineProperty(exports, "createOperation", {
  enumerable: true,
  get: function () {
    return _linkUtils.createOperation;
  }
});
Object.defineProperty(exports, "makePromise", {
  enumerable: true,
  get: function () {
    return _linkUtils.makePromise;
  }
});
Object.defineProperty(exports, "toPromise", {
  enumerable: true,
  get: function () {
    return _linkUtils.toPromise;
  }
});
Object.defineProperty(exports, "fromPromise", {
  enumerable: true,
  get: function () {
    return _linkUtils.fromPromise;
  }
});
Object.defineProperty(exports, "fromError", {
  enumerable: true,
  get: function () {
    return _linkUtils.fromError;
  }
});
Object.defineProperty(exports, "Observable", {
  enumerable: true,
  get: function () {
    return _zenObservableTs.default;
  }
});

var _link = require("./link");

Object.keys(_link).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _link[key];
    }
  });
});

var _linkUtils = require("./linkUtils");

var _zenObservableTs = _interopRequireDefault(require("zen-observable-ts"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./link":"O/XI","./linkUtils":"zBX+","zen-observable-ts":"ngXU"}],"nqmn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = symbolObservablePonyfill;

function symbolObservablePonyfill(root) {
  var result;
  var Symbol = root.Symbol;

  if (typeof Symbol === 'function') {
    if (Symbol.observable) {
      result = Symbol.observable;
    } else {
      result = Symbol('observable');
      Symbol.observable = result;
    }
  } else {
    result = '@@observable';
  }

  return result;
}

;
},{}],"KzwE":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ponyfill = _interopRequireDefault(require("./ponyfill.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global window */
var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill.default)(root);
var _default = result;
exports.default = _default;
},{"./ponyfill.js":"nqmn"}],"MWAe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observable = void 0;

var _apolloLink = require("apollo-link");

var _symbolObservable = _interopRequireDefault(require("symbol-observable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var Observable = function (_super) {
  __extends(Observable, _super);

  function Observable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Observable.prototype[_symbolObservable.default] = function () {
    return this;
  };

  Observable.prototype['@@observable'] = function () {
    return this;
  };

  return Observable;
}(_apolloLink.Observable);

exports.Observable = Observable;
},{"apollo-link":"uD5J","symbol-observable":"KzwE"}],"eRUa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isApolloError = isApolloError;
exports.ApolloError = void 0;

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

function isApolloError(err) {
  return err.hasOwnProperty('graphQLErrors');
}

var generateErrorMessage = function (err) {
  var message = '';

  if (Array.isArray(err.graphQLErrors) && err.graphQLErrors.length !== 0) {
    err.graphQLErrors.forEach(function (graphQLError) {
      var errorMessage = graphQLError ? graphQLError.message : 'Error message not found.';
      message += "GraphQL error: " + errorMessage + "\n";
    });
  }

  if (err.networkError) {
    message += 'Network error: ' + err.networkError.message + '\n';
  }

  message = message.replace(/\n$/, '');
  return message;
};

var ApolloError = function (_super) {
  __extends(ApolloError, _super);

  function ApolloError(_a) {
    var graphQLErrors = _a.graphQLErrors,
        networkError = _a.networkError,
        errorMessage = _a.errorMessage,
        extraInfo = _a.extraInfo;

    var _this = _super.call(this, errorMessage) || this;

    _this.graphQLErrors = graphQLErrors || [];
    _this.networkError = networkError || null;

    if (!errorMessage) {
      _this.message = generateErrorMessage(_this);
    } else {
      _this.message = errorMessage;
    }

    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError.prototype;
    return _this;
  }

  return ApolloError;
}(Error);

exports.ApolloError = ApolloError;
},{}],"FomV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchType = void 0;
var FetchType;
exports.FetchType = FetchType;

(function (FetchType) {
  FetchType[FetchType["normal"] = 1] = "normal";
  FetchType[FetchType["refetch"] = 2] = "refetch";
  FetchType[FetchType["poll"] = 3] = "poll";
})(FetchType || (exports.FetchType = FetchType = {}));
},{}],"4PSG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObservableQuery = exports.hasError = void 0;

var _apolloUtilities = require("apollo-utilities");

var _networkStatus = require("./networkStatus");

var _Observable = require("../util/Observable");

var _ApolloError = require("../errors/ApolloError");

var _types = require("./types");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var hasError = function (storeValue, policy) {
  if (policy === void 0) {
    policy = 'none';
  }

  return storeValue && (storeValue.graphQLErrors && storeValue.graphQLErrors.length > 0 && policy === 'none' || storeValue.networkError);
};

exports.hasError = hasError;

var ObservableQuery = function (_super) {
  __extends(ObservableQuery, _super);

  function ObservableQuery(_a) {
    var scheduler = _a.scheduler,
        options = _a.options,
        _b = _a.shouldSubscribe,
        shouldSubscribe = _b === void 0 ? true : _b;

    var _this = _super.call(this, function (observer) {
      return _this.onSubscribe(observer);
    }) || this;

    _this.isCurrentlyPolling = false;
    _this.isTornDown = false;
    _this.options = options;
    _this.variables = options.variables || {};
    _this.queryId = scheduler.queryManager.generateQueryId();
    _this.shouldSubscribe = shouldSubscribe;
    _this.scheduler = scheduler;
    _this.queryManager = scheduler.queryManager;
    _this.observers = [];
    _this.subscriptionHandles = [];
    return _this;
  }

  ObservableQuery.prototype.result = function () {
    var that = this;
    return new Promise(function (resolve, reject) {
      var subscription;
      var observer = {
        next: function (result) {
          resolve(result);

          if (!that.observers.some(function (obs) {
            return obs !== observer;
          })) {
            that.queryManager.removeQuery(that.queryId);
          }

          setTimeout(function () {
            subscription.unsubscribe();
          }, 0);
        },
        error: function (error) {
          reject(error);
        }
      };
      subscription = that.subscribe(observer);
    });
  };

  ObservableQuery.prototype.currentResult = function () {
    if (this.isTornDown) {
      return {
        data: this.lastError ? {} : this.lastResult ? this.lastResult.data : {},
        error: this.lastError,
        loading: false,
        networkStatus: _networkStatus.NetworkStatus.error
      };
    }

    var queryStoreValue = this.queryManager.queryStore.get(this.queryId);

    if (hasError(queryStoreValue, this.options.errorPolicy)) {
      return {
        data: {},
        loading: false,
        networkStatus: queryStoreValue.networkStatus,
        error: new _ApolloError.ApolloError({
          graphQLErrors: queryStoreValue.graphQLErrors,
          networkError: queryStoreValue.networkError
        })
      };
    }

    var _a = this.queryManager.getCurrentQueryResult(this),
        data = _a.data,
        partial = _a.partial;

    var queryLoading = !queryStoreValue || queryStoreValue.networkStatus === _networkStatus.NetworkStatus.loading;
    var loading = this.options.fetchPolicy === 'network-only' && queryLoading || partial && this.options.fetchPolicy !== 'cache-only';
    var networkStatus;

    if (queryStoreValue) {
      networkStatus = queryStoreValue.networkStatus;
    } else {
      networkStatus = loading ? _networkStatus.NetworkStatus.loading : _networkStatus.NetworkStatus.ready;
    }

    var result = {
      data: data,
      loading: (0, _networkStatus.isNetworkRequestInFlight)(networkStatus),
      networkStatus: networkStatus
    };

    if (queryStoreValue && queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {
      result.errors = queryStoreValue.graphQLErrors;
    }

    if (!partial) {
      var stale = false;
      this.lastResult = __assign({}, result, {
        stale: stale
      });
    }

    return __assign({}, result, {
      partial: partial
    });
  };

  ObservableQuery.prototype.getLastResult = function () {
    return this.lastResult;
  };

  ObservableQuery.prototype.getLastError = function () {
    return this.lastError;
  };

  ObservableQuery.prototype.resetLastResults = function () {
    delete this.lastResult;
    delete this.lastError;
    this.isTornDown = false;
  };

  ObservableQuery.prototype.refetch = function (variables) {
    var fetchPolicy = this.options.fetchPolicy;

    if (fetchPolicy === 'cache-only') {
      return Promise.reject(new Error('cache-only fetchPolicy option should not be used together with query refetch.'));
    }

    if (!(0, _apolloUtilities.isEqual)(this.variables, variables)) {
      this.variables = Object.assign({}, this.variables, variables);
    }

    if (!(0, _apolloUtilities.isEqual)(this.options.variables, this.variables)) {
      this.options.variables = Object.assign({}, this.options.variables, this.variables);
    }

    var isNetworkFetchPolicy = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';

    var combinedOptions = __assign({}, this.options, {
      fetchPolicy: isNetworkFetchPolicy ? fetchPolicy : 'network-only'
    });

    return this.queryManager.fetchQuery(this.queryId, combinedOptions, _types.FetchType.refetch).then(function (result) {
      return result;
    });
  };

  ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
    var _this = this;

    if (!fetchMoreOptions.updateQuery) {
      throw new Error('updateQuery option is required. This function defines how to update the query data with the new results.');
    }

    var combinedOptions;
    return Promise.resolve().then(function () {
      var qid = _this.queryManager.generateQueryId();

      if (fetchMoreOptions.query) {
        combinedOptions = fetchMoreOptions;
      } else {
        combinedOptions = __assign({}, _this.options, fetchMoreOptions, {
          variables: Object.assign({}, _this.variables, fetchMoreOptions.variables)
        });
      }

      combinedOptions.fetchPolicy = 'network-only';
      return _this.queryManager.fetchQuery(qid, combinedOptions, _types.FetchType.normal, _this.queryId);
    }).then(function (fetchMoreResult) {
      _this.updateQuery(function (previousResult) {
        return fetchMoreOptions.updateQuery(previousResult, {
          fetchMoreResult: fetchMoreResult.data,
          variables: combinedOptions.variables
        });
      });

      return fetchMoreResult;
    });
  };

  ObservableQuery.prototype.subscribeToMore = function (options) {
    var _this = this;

    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables
    }).subscribe({
      next: function (subscriptionData) {
        if (options.updateQuery) {
          _this.updateQuery(function (previous, _a) {
            var variables = _a.variables;
            return options.updateQuery(previous, {
              subscriptionData: subscriptionData,
              variables: variables
            });
          });
        }
      },
      error: function (err) {
        if (options.onError) {
          options.onError(err);
          return;
        }

        console.error('Unhandled GraphQL subscription error', err);
      }
    });
    this.subscriptionHandles.push(subscription);
    return function () {
      var i = _this.subscriptionHandles.indexOf(subscription);

      if (i >= 0) {
        _this.subscriptionHandles.splice(i, 1);

        subscription.unsubscribe();
      }
    };
  };

  ObservableQuery.prototype.setOptions = function (opts) {
    var oldOptions = this.options;
    this.options = Object.assign({}, this.options, opts);

    if (opts.pollInterval) {
      this.startPolling(opts.pollInterval);
    } else if (opts.pollInterval === 0) {
      this.stopPolling();
    }

    var tryFetch = oldOptions.fetchPolicy !== 'network-only' && opts.fetchPolicy === 'network-only' || oldOptions.fetchPolicy === 'cache-only' && opts.fetchPolicy !== 'cache-only' || oldOptions.fetchPolicy === 'standby' && opts.fetchPolicy !== 'standby' || false;
    return this.setVariables(this.options.variables, tryFetch, opts.fetchResults);
  };

  ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
    if (tryFetch === void 0) {
      tryFetch = false;
    }

    if (fetchResults === void 0) {
      fetchResults = true;
    }

    this.isTornDown = false;
    var newVariables = variables ? variables : this.variables;

    if ((0, _apolloUtilities.isEqual)(newVariables, this.variables) && !tryFetch) {
      if (this.observers.length === 0 || !fetchResults) {
        return new Promise(function (resolve) {
          return resolve();
        });
      }

      return this.result();
    } else {
      this.variables = newVariables;
      this.options.variables = newVariables;

      if (this.observers.length === 0) {
        return new Promise(function (resolve) {
          return resolve();
        });
      }

      return this.queryManager.fetchQuery(this.queryId, __assign({}, this.options, {
        variables: this.variables
      })).then(function (result) {
        return result;
      });
    }
  };

  ObservableQuery.prototype.updateQuery = function (mapFn) {
    var _a = this.queryManager.getQueryWithPreviousResult(this.queryId),
        previousResult = _a.previousResult,
        variables = _a.variables,
        document = _a.document;

    var newResult = (0, _apolloUtilities.tryFunctionOrLogError)(function () {
      return mapFn(previousResult, {
        variables: variables
      });
    });

    if (newResult) {
      this.queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
      this.queryManager.broadcastQueries();
    }
  };

  ObservableQuery.prototype.stopPolling = function () {
    if (this.isCurrentlyPolling) {
      this.scheduler.stopPollingQuery(this.queryId);
      this.options.pollInterval = undefined;
      this.isCurrentlyPolling = false;
    }
  };

  ObservableQuery.prototype.startPolling = function (pollInterval) {
    if (this.options.fetchPolicy === 'cache-first' || this.options.fetchPolicy === 'cache-only') {
      throw new Error('Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
    }

    if (this.isCurrentlyPolling) {
      this.scheduler.stopPollingQuery(this.queryId);
      this.isCurrentlyPolling = false;
    }

    this.options.pollInterval = pollInterval;
    this.isCurrentlyPolling = true;
    this.scheduler.startPollingQuery(this.options, this.queryId);
  };

  ObservableQuery.prototype.onSubscribe = function (observer) {
    var _this = this;

    if (observer._subscription && observer._subscription._observer && !observer._subscription._observer.error) {
      observer._subscription._observer.error = function (error) {
        console.error('Unhandled error', error.message, error.stack);
      };
    }

    this.observers.push(observer);
    if (observer.next && this.lastResult) observer.next(this.lastResult);
    if (observer.error && this.lastError) observer.error(this.lastError);
    if (this.observers.length === 1) this.setUpQuery();
    return function () {
      _this.observers = _this.observers.filter(function (obs) {
        return obs !== observer;
      });

      if (_this.observers.length === 0) {
        _this.tearDownQuery();
      }
    };
  };

  ObservableQuery.prototype.setUpQuery = function () {
    var _this = this;

    if (this.shouldSubscribe) {
      this.queryManager.addObservableQuery(this.queryId, this);
    }

    if (!!this.options.pollInterval) {
      if (this.options.fetchPolicy === 'cache-first' || this.options.fetchPolicy === 'cache-only') {
        throw new Error('Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');
      }

      this.isCurrentlyPolling = true;
      this.scheduler.startPollingQuery(this.options, this.queryId);
    }

    var observer = {
      next: function (result) {
        _this.lastResult = result;

        _this.observers.forEach(function (obs) {
          return obs.next && obs.next(result);
        });
      },
      error: function (error) {
        _this.lastError = error;

        _this.observers.forEach(function (obs) {
          return obs.error && obs.error(error);
        });
      }
    };
    this.queryManager.startQuery(this.queryId, this.options, this.queryManager.queryListenerForObserver(this.queryId, this.options, observer));
  };

  ObservableQuery.prototype.tearDownQuery = function () {
    this.isTornDown = true;

    if (this.isCurrentlyPolling) {
      this.scheduler.stopPollingQuery(this.queryId);
      this.isCurrentlyPolling = false;
    }

    this.subscriptionHandles.forEach(function (sub) {
      return sub.unsubscribe();
    });
    this.subscriptionHandles = [];
    this.queryManager.removeObservableQuery(this.queryId);
    this.queryManager.stopQuery(this.queryId);
    this.observers = [];
  };

  return ObservableQuery;
}(_Observable.Observable);

exports.ObservableQuery = ObservableQuery;
},{"apollo-utilities":"cD8x","./networkStatus":"x3yF","../util/Observable":"MWAe","../errors/ApolloError":"eRUa","./types":"FomV"}],"RIW2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DedupLink = void 0;

var _apolloLink = require("apollo-link");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/*
 * Expects context to contain the forceFetch field if no dedup
 */
var DedupLink =
/** @class */
function (_super) {
  __extends(DedupLink, _super);

  function DedupLink() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.inFlightRequestObservables = new Map();
    _this.subscribers = new Map();
    return _this;
  }

  DedupLink.prototype.request = function (operation, forward) {
    var _this = this; // sometimes we might not want to deduplicate a request, for example when we want to force fetch it.


    if (operation.getContext().forceFetch) {
      return forward(operation);
    }

    var key = operation.toKey();

    var cleanup = function (operationKey) {
      _this.inFlightRequestObservables.delete(operationKey);

      var prev = _this.subscribers.get(operationKey);

      return prev;
    };

    if (!this.inFlightRequestObservables.get(key)) {
      // this is a new request, i.e. we haven't deduplicated it yet
      // call the next link
      var singleObserver_1 = forward(operation);
      var subscription_1;
      var sharedObserver = new _apolloLink.Observable(function (observer) {
        // this will still be called by each subscriber regardless of
        // deduplication status
        var prev = _this.subscribers.get(key);

        if (!prev) prev = {
          next: [],
          error: [],
          complete: []
        };

        _this.subscribers.set(key, {
          next: prev.next.concat([observer.next.bind(observer)]),
          error: prev.error.concat([observer.error.bind(observer)]),
          complete: prev.complete.concat([observer.complete.bind(observer)])
        });

        if (!subscription_1) {
          subscription_1 = singleObserver_1.subscribe({
            next: function (result) {
              var previous = cleanup(key);

              _this.subscribers.delete(key);

              if (previous) {
                previous.next.forEach(function (next) {
                  return next(result);
                });
                previous.complete.forEach(function (complete) {
                  return complete();
                });
              }
            },
            error: function (error) {
              var previous = cleanup(key);

              _this.subscribers.delete(key);

              if (previous) previous.error.forEach(function (err) {
                return err(error);
              });
            }
          });
        }

        return function () {
          if (subscription_1) subscription_1.unsubscribe();

          _this.inFlightRequestObservables.delete(key);
        };
      });
      this.inFlightRequestObservables.set(key, sharedObserver);
    } // return shared Observable


    return this.inFlightRequestObservables.get(key);
  };

  return DedupLink;
}(_apolloLink.ApolloLink);

exports.DedupLink = DedupLink;
},{"apollo-link":"uD5J"}],"pWAM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dedupLink = require("./dedupLink");

Object.keys(_dedupLink).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _dedupLink[key];
    }
  });
});
},{"./dedupLink":"RIW2"}],"oMJx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryScheduler = void 0;

var _types = require("../core/types");

var _ObservableQuery = require("../core/ObservableQuery");

var _networkStatus = require("../core/networkStatus");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var QueryScheduler = function () {
  function QueryScheduler(_a) {
    var queryManager = _a.queryManager,
        ssrMode = _a.ssrMode;
    this.inFlightQueries = {};
    this.registeredQueries = {};
    this.intervalQueries = {};
    this.pollingTimers = {};
    this.ssrMode = false;
    this.queryManager = queryManager;
    this.ssrMode = ssrMode || false;
  }

  QueryScheduler.prototype.checkInFlight = function (queryId) {
    var query = this.queryManager.queryStore.get(queryId);
    return query && query.networkStatus !== _networkStatus.NetworkStatus.ready && query.networkStatus !== _networkStatus.NetworkStatus.error;
  };

  QueryScheduler.prototype.fetchQuery = function (queryId, options, fetchType) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      _this.queryManager.fetchQuery(queryId, options, fetchType).then(function (result) {
        resolve(result);
      }).catch(function (error) {
        reject(error);
      });
    });
  };

  QueryScheduler.prototype.startPollingQuery = function (options, queryId, listener) {
    if (!options.pollInterval) {
      throw new Error('Attempted to start a polling query without a polling interval.');
    }

    if (this.ssrMode) return queryId;
    this.registeredQueries[queryId] = options;

    if (listener) {
      this.queryManager.addQueryListener(queryId, listener);
    }

    this.addQueryOnInterval(queryId, options);
    return queryId;
  };

  QueryScheduler.prototype.stopPollingQuery = function (queryId) {
    delete this.registeredQueries[queryId];
  };

  QueryScheduler.prototype.fetchQueriesOnInterval = function (interval) {
    var _this = this;

    this.intervalQueries[interval] = this.intervalQueries[interval].filter(function (queryId) {
      if (!(_this.registeredQueries.hasOwnProperty(queryId) && _this.registeredQueries[queryId].pollInterval === interval)) {
        return false;
      }

      if (_this.checkInFlight(queryId)) {
        return true;
      }

      var queryOptions = _this.registeredQueries[queryId];

      var pollingOptions = __assign({}, queryOptions);

      pollingOptions.fetchPolicy = 'network-only';

      _this.fetchQuery(queryId, pollingOptions, _types.FetchType.poll).catch(function () {});

      return true;
    });

    if (this.intervalQueries[interval].length === 0) {
      clearInterval(this.pollingTimers[interval]);
      delete this.intervalQueries[interval];
    }
  };

  QueryScheduler.prototype.addQueryOnInterval = function (queryId, queryOptions) {
    var _this = this;

    var interval = queryOptions.pollInterval;

    if (!interval) {
      throw new Error("A poll interval is required to start polling query with id '" + queryId + "'.");
    }

    if (this.intervalQueries.hasOwnProperty(interval.toString()) && this.intervalQueries[interval].length > 0) {
      this.intervalQueries[interval].push(queryId);
    } else {
      this.intervalQueries[interval] = [queryId];
      this.pollingTimers[interval] = setInterval(function () {
        _this.fetchQueriesOnInterval(interval);
      }, interval);
    }
  };

  QueryScheduler.prototype.registerPollingQuery = function (queryOptions) {
    if (!queryOptions.pollInterval) {
      throw new Error('Attempted to register a non-polling query with the scheduler.');
    }

    return new _ObservableQuery.ObservableQuery({
      scheduler: this,
      options: queryOptions
    });
  };

  return QueryScheduler;
}();

exports.QueryScheduler = QueryScheduler;
},{"../core/types":"FomV","../core/ObservableQuery":"4PSG","../core/networkStatus":"x3yF"}],"9xN4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MutationStore = void 0;

var MutationStore = function () {
  function MutationStore() {
    this.store = {};
  }

  MutationStore.prototype.getStore = function () {
    return this.store;
  };

  MutationStore.prototype.get = function (mutationId) {
    return this.store[mutationId];
  };

  MutationStore.prototype.initMutation = function (mutationId, mutationString, variables) {
    this.store[mutationId] = {
      mutationString: mutationString,
      variables: variables || {},
      loading: true,
      error: null
    };
  };

  MutationStore.prototype.markMutationError = function (mutationId, error) {
    var mutation = this.store[mutationId];

    if (!mutation) {
      return;
    }

    mutation.loading = false;
    mutation.error = error;
  };

  MutationStore.prototype.markMutationResult = function (mutationId) {
    var mutation = this.store[mutationId];

    if (!mutation) {
      return;
    }

    mutation.loading = false;
    mutation.error = null;
  };

  MutationStore.prototype.reset = function () {
    this.store = {};
  };

  return MutationStore;
}();

exports.MutationStore = MutationStore;
},{}],"VODt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryStore = void 0;

var _printer = require("graphql/language/printer");

var _apolloUtilities = require("apollo-utilities");

var _networkStatus = require("../core/networkStatus");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var QueryStore = function () {
  function QueryStore() {
    this.store = {};
  }

  QueryStore.prototype.getStore = function () {
    return this.store;
  };

  QueryStore.prototype.get = function (queryId) {
    return this.store[queryId];
  };

  QueryStore.prototype.initQuery = function (query) {
    var previousQuery = this.store[query.queryId];

    if (previousQuery && previousQuery.document !== query.document && (0, _printer.print)(previousQuery.document) !== (0, _printer.print)(query.document)) {
      throw new Error('Internal Error: may not update existing query string in store');
    }

    var isSetVariables = false;
    var previousVariables = null;

    if (query.storePreviousVariables && previousQuery && previousQuery.networkStatus !== _networkStatus.NetworkStatus.loading) {
      if (!(0, _apolloUtilities.isEqual)(previousQuery.variables, query.variables)) {
        isSetVariables = true;
        previousVariables = previousQuery.variables;
      }
    }

    var networkStatus;

    if (isSetVariables) {
      networkStatus = _networkStatus.NetworkStatus.setVariables;
    } else if (query.isPoll) {
      networkStatus = _networkStatus.NetworkStatus.poll;
    } else if (query.isRefetch) {
      networkStatus = _networkStatus.NetworkStatus.refetch;
    } else {
      networkStatus = _networkStatus.NetworkStatus.loading;
    }

    var graphQLErrors = [];

    if (previousQuery && previousQuery.graphQLErrors) {
      graphQLErrors = previousQuery.graphQLErrors;
    }

    this.store[query.queryId] = {
      document: query.document,
      variables: query.variables,
      previousVariables: previousVariables,
      networkError: null,
      graphQLErrors: graphQLErrors,
      networkStatus: networkStatus,
      metadata: query.metadata
    };

    if (typeof query.fetchMoreForQueryId === 'string' && this.store[query.fetchMoreForQueryId]) {
      this.store[query.fetchMoreForQueryId].networkStatus = _networkStatus.NetworkStatus.fetchMore;
    }
  };

  QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
    if (!this.store[queryId]) return;
    this.store[queryId].networkError = null;
    this.store[queryId].graphQLErrors = result.errors && result.errors.length ? result.errors : [];
    this.store[queryId].previousVariables = null;
    this.store[queryId].networkStatus = _networkStatus.NetworkStatus.ready;

    if (typeof fetchMoreForQueryId === 'string' && this.store[fetchMoreForQueryId]) {
      this.store[fetchMoreForQueryId].networkStatus = _networkStatus.NetworkStatus.ready;
    }
  };

  QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
    if (!this.store[queryId]) return;
    this.store[queryId].networkError = error;
    this.store[queryId].networkStatus = _networkStatus.NetworkStatus.error;

    if (typeof fetchMoreForQueryId === 'string') {
      this.markQueryResultClient(fetchMoreForQueryId, true);
    }
  };

  QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
    if (!this.store[queryId]) return;
    this.store[queryId].networkError = null;
    this.store[queryId].previousVariables = null;
    this.store[queryId].networkStatus = complete ? _networkStatus.NetworkStatus.ready : _networkStatus.NetworkStatus.loading;
  };

  QueryStore.prototype.stopQuery = function (queryId) {
    delete this.store[queryId];
  };

  QueryStore.prototype.reset = function (observableQueryIds) {
    var _this = this;

    this.store = Object.keys(this.store).filter(function (queryId) {
      return observableQueryIds.indexOf(queryId) > -1;
    }).reduce(function (res, key) {
      res[key] = __assign({}, _this.store[key], {
        networkStatus: _networkStatus.NetworkStatus.loading
      });
      return res;
    }, {});
  };

  return QueryStore;
}();

exports.QueryStore = QueryStore;
},{"graphql/language/printer":"h5rv","apollo-utilities":"cD8x","../core/networkStatus":"x3yF"}],"Zptr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryManager = void 0;

var _apolloLink = require("apollo-link");

var _printer = require("graphql/language/printer");

var _apolloLinkDedup = require("apollo-link-dedup");

var _apolloUtilities = require("apollo-utilities");

var _scheduler = require("../scheduler/scheduler");

var _ApolloError = require("../errors/ApolloError");

var _Observable = require("../util/Observable");

var _mutations = require("../data/mutations");

var _queries = require("../data/queries");

var _ObservableQuery = require("./ObservableQuery");

var _networkStatus = require("./networkStatus");

var _types = require("./types");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var defaultQueryInfo = {
  listeners: [],
  invalidated: false,
  document: null,
  newData: null,
  lastRequestId: null,
  observableQuery: null,
  subscriptions: []
};

var QueryManager = function () {
  function QueryManager(_a) {
    var link = _a.link,
        _b = _a.queryDeduplication,
        queryDeduplication = _b === void 0 ? false : _b,
        store = _a.store,
        _c = _a.onBroadcast,
        onBroadcast = _c === void 0 ? function () {
      return undefined;
    } : _c,
        _d = _a.ssrMode,
        ssrMode = _d === void 0 ? false : _d;
    this.mutationStore = new _mutations.MutationStore();
    this.queryStore = new _queries.QueryStore();
    this.idCounter = 1;
    this.queries = new Map();
    this.fetchQueryPromises = new Map();
    this.queryIdsByName = {};
    this.link = link;
    this.deduplicator = _apolloLink.ApolloLink.from([new _apolloLinkDedup.DedupLink(), link]);
    this.queryDeduplication = queryDeduplication;
    this.dataStore = store;
    this.onBroadcast = onBroadcast;
    this.scheduler = new _scheduler.QueryScheduler({
      queryManager: this,
      ssrMode: ssrMode
    });
  }

  QueryManager.prototype.mutate = function (_a) {
    var _this = this;

    var mutation = _a.mutation,
        variables = _a.variables,
        optimisticResponse = _a.optimisticResponse,
        updateQueriesByName = _a.updateQueries,
        _b = _a.refetchQueries,
        refetchQueries = _b === void 0 ? [] : _b,
        _c = _a.awaitRefetchQueries,
        awaitRefetchQueries = _c === void 0 ? false : _c,
        updateWithProxyFn = _a.update,
        _d = _a.errorPolicy,
        errorPolicy = _d === void 0 ? 'none' : _d,
        fetchPolicy = _a.fetchPolicy,
        _e = _a.context,
        context = _e === void 0 ? {} : _e;

    if (!mutation) {
      throw new Error('mutation option is required. You must specify your GraphQL document in the mutation option.');
    }

    if (fetchPolicy && fetchPolicy !== 'no-cache') {
      throw new Error("fetchPolicy for mutations currently only supports the 'no-cache' policy");
    }

    var mutationId = this.generateQueryId();
    var cache = this.dataStore.getCache();
    mutation = cache.transformDocument(mutation), variables = (0, _apolloUtilities.assign)({}, (0, _apolloUtilities.getDefaultValues)((0, _apolloUtilities.getMutationDefinition)(mutation)), variables);
    var mutationString = (0, _printer.print)(mutation);
    this.setQuery(mutationId, function () {
      return {
        document: mutation
      };
    });

    var generateUpdateQueriesInfo = function () {
      var ret = {};

      if (updateQueriesByName) {
        Object.keys(updateQueriesByName).forEach(function (queryName) {
          return (_this.queryIdsByName[queryName] || []).forEach(function (queryId) {
            ret[queryId] = {
              updater: updateQueriesByName[queryName],
              query: _this.queryStore.get(queryId)
            };
          });
        });
      }

      return ret;
    };

    this.mutationStore.initMutation(mutationId, mutationString, variables);
    this.dataStore.markMutationInit({
      mutationId: mutationId,
      document: mutation,
      variables: variables || {},
      updateQueries: generateUpdateQueriesInfo(),
      update: updateWithProxyFn,
      optimisticResponse: optimisticResponse
    });
    this.broadcastQueries();
    return new Promise(function (resolve, reject) {
      var storeResult;
      var error;

      var operation = _this.buildOperationForLink(mutation, variables, __assign({}, context, {
        optimisticResponse: optimisticResponse
      }));

      var completeMutation = function () {
        return __awaiter(_this, void 0, void 0, function () {
          var refetchQueryPromises, _i, refetchQueries_1, refetchQuery, promise, queryOptions;

          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (error) {
                  this.mutationStore.markMutationError(mutationId, error);
                }

                this.dataStore.markMutationComplete({
                  mutationId: mutationId,
                  optimisticResponse: optimisticResponse
                });
                this.broadcastQueries();

                if (error) {
                  throw error;
                }

                if (typeof refetchQueries === 'function') {
                  refetchQueries = refetchQueries(storeResult);
                }

                refetchQueryPromises = [];

                for (_i = 0, refetchQueries_1 = refetchQueries; _i < refetchQueries_1.length; _i++) {
                  refetchQuery = refetchQueries_1[_i];

                  if (typeof refetchQuery === 'string') {
                    promise = this.refetchQueryByName(refetchQuery);

                    if (promise) {
                      refetchQueryPromises.push(promise);
                    }

                    continue;
                  }

                  queryOptions = {
                    query: refetchQuery.query,
                    variables: refetchQuery.variables,
                    fetchPolicy: 'network-only'
                  };

                  if (refetchQuery.context) {
                    queryOptions.context = refetchQuery.context;
                  }

                  refetchQueryPromises.push(this.query(queryOptions));
                }

                if (!awaitRefetchQueries) return [3, 2];
                return [4, Promise.all(refetchQueryPromises)];

              case 1:
                _a.sent();

                _a.label = 2;

              case 2:
                this.setQuery(mutationId, function () {
                  return {
                    document: undefined
                  };
                });

                if (errorPolicy === 'ignore' && storeResult && (0, _apolloUtilities.graphQLResultHasError)(storeResult)) {
                  delete storeResult.errors;
                }

                return [2, storeResult];
            }
          });
        });
      };

      (0, _apolloLink.execute)(_this.link, operation).subscribe({
        next: function (result) {
          if ((0, _apolloUtilities.graphQLResultHasError)(result) && errorPolicy === 'none') {
            error = new _ApolloError.ApolloError({
              graphQLErrors: result.errors
            });
            return;
          }

          _this.mutationStore.markMutationResult(mutationId);

          if (fetchPolicy !== 'no-cache') {
            _this.dataStore.markMutationResult({
              mutationId: mutationId,
              result: result,
              document: mutation,
              variables: variables || {},
              updateQueries: generateUpdateQueriesInfo(),
              update: updateWithProxyFn
            });
          }

          storeResult = result;
        },
        error: function (err) {
          _this.mutationStore.markMutationError(mutationId, err);

          _this.dataStore.markMutationComplete({
            mutationId: mutationId,
            optimisticResponse: optimisticResponse
          });

          _this.broadcastQueries();

          _this.setQuery(mutationId, function () {
            return {
              document: undefined
            };
          });

          reject(new _ApolloError.ApolloError({
            networkError: err
          }));
        },
        complete: function () {
          return completeMutation().then(resolve, reject);
        }
      });
    });
  };

  QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
    var _this = this;

    var _a = options.variables,
        variables = _a === void 0 ? {} : _a,
        _b = options.metadata,
        metadata = _b === void 0 ? null : _b,
        _c = options.fetchPolicy,
        fetchPolicy = _c === void 0 ? 'cache-first' : _c;
    var cache = this.dataStore.getCache();
    var query = cache.transformDocument(options.query);
    var storeResult;
    var needToFetch = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';

    if (fetchType !== _types.FetchType.refetch && fetchPolicy !== 'network-only' && fetchPolicy !== 'no-cache') {
      var _d = this.dataStore.getCache().diff({
        query: query,
        variables: variables,
        returnPartialData: true,
        optimistic: false
      }),
          complete = _d.complete,
          result = _d.result;

      needToFetch = !complete || fetchPolicy === 'cache-and-network';
      storeResult = result;
    }

    var shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
    if ((0, _apolloUtilities.hasDirectives)(['live'], query)) shouldFetch = true;
    var requestId = this.generateRequestId();
    var cancel = this.updateQueryWatch(queryId, query, options);
    this.setQuery(queryId, function () {
      return {
        document: query,
        lastRequestId: requestId,
        invalidated: true,
        cancel: cancel
      };
    });
    this.invalidate(true, fetchMoreForQueryId);
    this.queryStore.initQuery({
      queryId: queryId,
      document: query,
      storePreviousVariables: shouldFetch,
      variables: variables,
      isPoll: fetchType === _types.FetchType.poll,
      isRefetch: fetchType === _types.FetchType.refetch,
      metadata: metadata,
      fetchMoreForQueryId: fetchMoreForQueryId
    });
    this.broadcastQueries();
    var shouldDispatchClientResult = !shouldFetch || fetchPolicy === 'cache-and-network';

    if (shouldDispatchClientResult) {
      this.queryStore.markQueryResultClient(queryId, !shouldFetch);
      this.invalidate(true, queryId, fetchMoreForQueryId);
      this.broadcastQueries();
    }

    if (shouldFetch) {
      var networkResult = this.fetchRequest({
        requestId: requestId,
        queryId: queryId,
        document: query,
        options: options,
        fetchMoreForQueryId: fetchMoreForQueryId
      }).catch(function (error) {
        if ((0, _ApolloError.isApolloError)(error)) {
          throw error;
        } else {
          var lastRequestId = _this.getQuery(queryId).lastRequestId;

          if (requestId >= (lastRequestId || 1)) {
            _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);

            _this.invalidate(true, queryId, fetchMoreForQueryId);

            _this.broadcastQueries();
          }

          _this.removeFetchQueryPromise(requestId);

          throw new _ApolloError.ApolloError({
            networkError: error
          });
        }
      });

      if (fetchPolicy !== 'cache-and-network') {
        return networkResult;
      } else {
        networkResult.catch(function () {});
      }
    }

    return Promise.resolve({
      data: storeResult
    });
  };

  QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
    var _this = this;

    var previouslyHadError = false;
    return function (queryStoreValue, newData) {
      _this.invalidate(false, queryId);

      if (!queryStoreValue) return;

      var observableQuery = _this.getQuery(queryId).observableQuery;

      var fetchPolicy = observableQuery ? observableQuery.options.fetchPolicy : options.fetchPolicy;
      if (fetchPolicy === 'standby') return;
      var errorPolicy = observableQuery ? observableQuery.options.errorPolicy : options.errorPolicy;
      var lastResult = observableQuery ? observableQuery.getLastResult() : null;
      var lastError = observableQuery ? observableQuery.getLastError() : null;
      var shouldNotifyIfLoading = !newData && queryStoreValue.previousVariables != null || fetchPolicy === 'cache-only' || fetchPolicy === 'cache-and-network';
      var networkStatusChanged = Boolean(lastResult && queryStoreValue.networkStatus !== lastResult.networkStatus);
      var errorStatusChanged = errorPolicy && (lastError && lastError.graphQLErrors) !== queryStoreValue.graphQLErrors && errorPolicy !== 'none';

      if (!(0, _networkStatus.isNetworkRequestInFlight)(queryStoreValue.networkStatus) || networkStatusChanged && options.notifyOnNetworkStatusChange || shouldNotifyIfLoading) {
        if ((!errorPolicy || errorPolicy === 'none') && queryStoreValue.graphQLErrors && queryStoreValue.graphQLErrors.length > 0 || queryStoreValue.networkError) {
          var apolloError_1 = new _ApolloError.ApolloError({
            graphQLErrors: queryStoreValue.graphQLErrors,
            networkError: queryStoreValue.networkError
          });
          previouslyHadError = true;

          if (observer.error) {
            try {
              observer.error(apolloError_1);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          } else {
            setTimeout(function () {
              throw apolloError_1;
            }, 0);

            if (!(0, _apolloUtilities.isProduction)()) {
              console.info('An unhandled error was thrown because no error handler is registered ' + 'for the query ' + (0, _printer.print)(queryStoreValue.document));
            }
          }

          return;
        }

        try {
          var data = void 0;
          var isMissing = void 0;

          if (newData) {
            if (fetchPolicy !== 'no-cache') {
              _this.setQuery(queryId, function () {
                return {
                  newData: null
                };
              });
            }

            data = newData.result;
            isMissing = !newData.complete || false;
          } else {
            if (lastResult && lastResult.data && !errorStatusChanged) {
              data = lastResult.data;
              isMissing = false;
            } else {
              var document_1 = _this.getQuery(queryId).document;

              var readResult = _this.dataStore.getCache().diff({
                query: document_1,
                variables: queryStoreValue.previousVariables || queryStoreValue.variables,
                optimistic: true
              });

              data = readResult.result;
              isMissing = !readResult.complete;
            }
          }

          var resultFromStore = void 0;

          if (isMissing && fetchPolicy !== 'cache-only') {
            resultFromStore = {
              data: lastResult && lastResult.data,
              loading: (0, _networkStatus.isNetworkRequestInFlight)(queryStoreValue.networkStatus),
              networkStatus: queryStoreValue.networkStatus,
              stale: true
            };
          } else {
            resultFromStore = {
              data: data,
              loading: (0, _networkStatus.isNetworkRequestInFlight)(queryStoreValue.networkStatus),
              networkStatus: queryStoreValue.networkStatus,
              stale: false
            };
          }

          if (errorPolicy === 'all' && queryStoreValue.graphQLErrors && queryStoreValue.graphQLErrors.length > 0) {
            resultFromStore.errors = queryStoreValue.graphQLErrors;
          }

          if (observer.next) {
            var isDifferentResult = !(lastResult && resultFromStore && lastResult.networkStatus === resultFromStore.networkStatus && lastResult.stale === resultFromStore.stale && lastResult.data === resultFromStore.data);

            if (isDifferentResult || previouslyHadError) {
              try {
                observer.next(resultFromStore);
              } catch (e) {
                setTimeout(function () {
                  throw e;
                }, 0);
              }
            }
          }

          previouslyHadError = false;
        } catch (error) {
          previouslyHadError = true;
          if (observer.error) observer.error(new _ApolloError.ApolloError({
            networkError: error
          }));
          return;
        }
      }
    };
  };

  QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
    if (shouldSubscribe === void 0) {
      shouldSubscribe = true;
    }

    if (options.fetchPolicy === 'standby') {
      throw new Error('client.watchQuery cannot be called with fetchPolicy set to "standby"');
    }

    var queryDefinition = (0, _apolloUtilities.getQueryDefinition)(options.query);

    if (queryDefinition.variableDefinitions && queryDefinition.variableDefinitions.length) {
      var defaultValues = (0, _apolloUtilities.getDefaultValues)(queryDefinition);
      options.variables = (0, _apolloUtilities.assign)({}, defaultValues, options.variables);
    }

    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
      options.notifyOnNetworkStatusChange = false;
    }

    var transformedOptions = __assign({}, options);

    return new _ObservableQuery.ObservableQuery({
      scheduler: this.scheduler,
      options: transformedOptions,
      shouldSubscribe: shouldSubscribe
    });
  };

  QueryManager.prototype.query = function (options) {
    var _this = this;

    if (!options.query) {
      throw new Error('query option is required. You must specify your GraphQL document ' + 'in the query option.');
    }

    if (options.query.kind !== 'Document') {
      throw new Error('You must wrap the query string in a "gql" tag.');
    }

    if (options.returnPartialData) {
      throw new Error('returnPartialData option only supported on watchQuery.');
    }

    if (options.pollInterval) {
      throw new Error('pollInterval option only supported on watchQuery.');
    }

    var requestId = this.idCounter;
    return new Promise(function (resolve, reject) {
      _this.addFetchQueryPromise(requestId, resolve, reject);

      return _this.watchQuery(options, false).result().then(function (result) {
        _this.removeFetchQueryPromise(requestId);

        resolve(result);
      }).catch(function (error) {
        _this.removeFetchQueryPromise(requestId);

        reject(error);
      });
    });
  };

  QueryManager.prototype.generateQueryId = function () {
    var queryId = this.idCounter.toString();
    this.idCounter++;
    return queryId;
  };

  QueryManager.prototype.stopQueryInStore = function (queryId) {
    this.queryStore.stopQuery(queryId);
    this.invalidate(true, queryId);
    this.broadcastQueries();
  };

  QueryManager.prototype.addQueryListener = function (queryId, listener) {
    this.setQuery(queryId, function (_a) {
      var _b = _a.listeners,
          listeners = _b === void 0 ? [] : _b;
      return {
        listeners: listeners.concat([listener]),
        invalidate: false
      };
    });
  };

  QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
    var _this = this;

    var cancel = this.getQuery(queryId).cancel;
    if (cancel) cancel();

    var previousResult = function () {
      var previousResult = null;

      var observableQuery = _this.getQuery(queryId).observableQuery;

      if (observableQuery) {
        var lastResult = observableQuery.getLastResult();

        if (lastResult) {
          previousResult = lastResult.data;
        }
      }

      return previousResult;
    };

    return this.dataStore.getCache().watch({
      query: document,
      variables: options.variables,
      optimistic: true,
      previousResult: previousResult,
      callback: function (newData) {
        _this.setQuery(queryId, function () {
          return {
            invalidated: true,
            newData: newData
          };
        });
      }
    });
  };

  QueryManager.prototype.addFetchQueryPromise = function (requestId, resolve, reject) {
    this.fetchQueryPromises.set(requestId.toString(), {
      resolve: resolve,
      reject: reject
    });
  };

  QueryManager.prototype.removeFetchQueryPromise = function (requestId) {
    this.fetchQueryPromises.delete(requestId.toString());
  };

  QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
    this.setQuery(queryId, function () {
      return {
        observableQuery: observableQuery
      };
    });
    var queryDef = (0, _apolloUtilities.getQueryDefinition)(observableQuery.options.query);

    if (queryDef.name && queryDef.name.value) {
      var queryName = queryDef.name.value;
      this.queryIdsByName[queryName] = this.queryIdsByName[queryName] || [];
      this.queryIdsByName[queryName].push(observableQuery.queryId);
    }
  };

  QueryManager.prototype.removeObservableQuery = function (queryId) {
    var _a = this.getQuery(queryId),
        observableQuery = _a.observableQuery,
        cancel = _a.cancel;

    if (cancel) cancel();
    if (!observableQuery) return;
    var definition = (0, _apolloUtilities.getQueryDefinition)(observableQuery.options.query);
    var queryName = definition.name ? definition.name.value : null;
    this.setQuery(queryId, function () {
      return {
        observableQuery: null
      };
    });

    if (queryName) {
      this.queryIdsByName[queryName] = this.queryIdsByName[queryName].filter(function (val) {
        return !(observableQuery.queryId === val);
      });
    }
  };

  QueryManager.prototype.clearStore = function () {
    this.fetchQueryPromises.forEach(function (_a) {
      var reject = _a.reject;
      reject(new Error('Store reset while query was in flight(not completed in link chain)'));
    });
    var resetIds = [];
    this.queries.forEach(function (_a, queryId) {
      var observableQuery = _a.observableQuery;
      if (observableQuery) resetIds.push(queryId);
    });
    this.queryStore.reset(resetIds);
    this.mutationStore.reset();
    var reset = this.dataStore.reset();
    return reset;
  };

  QueryManager.prototype.resetStore = function () {
    var _this = this;

    return this.clearStore().then(function () {
      return _this.reFetchObservableQueries();
    });
  };

  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
    var observableQueryPromises = this.getObservableQueryPromises(includeStandby);
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };

  QueryManager.prototype.startQuery = function (queryId, options, listener) {
    this.addQueryListener(queryId, listener);
    this.fetchQuery(queryId, options).catch(function () {
      return undefined;
    });
    return queryId;
  };

  QueryManager.prototype.startGraphQLSubscription = function (options) {
    var _this = this;

    var query = options.query;
    var isCacheEnabled = !(options.fetchPolicy && options.fetchPolicy === 'no-cache');
    var cache = this.dataStore.getCache();
    var transformedDoc = cache.transformDocument(query);
    var variables = (0, _apolloUtilities.assign)({}, (0, _apolloUtilities.getDefaultValues)((0, _apolloUtilities.getOperationDefinition)(query)), options.variables);
    var sub;
    var observers = [];
    return new _Observable.Observable(function (observer) {
      observers.push(observer);

      if (observers.length === 1) {
        var handler = {
          next: function (result) {
            if (isCacheEnabled) {
              _this.dataStore.markSubscriptionResult(result, transformedDoc, variables);

              _this.broadcastQueries();
            }

            observers.forEach(function (obs) {
              if ((0, _apolloUtilities.graphQLResultHasError)(result) && obs.error) {
                obs.error(new _ApolloError.ApolloError({
                  graphQLErrors: result.errors
                }));
              } else if (obs.next) {
                obs.next(result);
              }
            });
          },
          error: function (error) {
            observers.forEach(function (obs) {
              if (obs.error) {
                obs.error(error);
              }
            });
          }
        };

        var operation = _this.buildOperationForLink(transformedDoc, variables);

        sub = (0, _apolloLink.execute)(_this.link, operation).subscribe(handler);
      }

      return function () {
        observers = observers.filter(function (obs) {
          return obs !== observer;
        });

        if (observers.length === 0 && sub) {
          sub.unsubscribe();
        }
      };
    });
  };

  QueryManager.prototype.stopQuery = function (queryId) {
    this.stopQueryInStore(queryId);
    this.removeQuery(queryId);
  };

  QueryManager.prototype.removeQuery = function (queryId) {
    var subscriptions = this.getQuery(queryId).subscriptions;
    subscriptions.forEach(function (x) {
      return x.unsubscribe();
    });
    this.queries.delete(queryId);
  };

  QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
    if (optimistic === void 0) {
      optimistic = true;
    }

    var _a = observableQuery.options,
        variables = _a.variables,
        query = _a.query;
    var lastResult = observableQuery.getLastResult();
    var newData = this.getQuery(observableQuery.queryId).newData;

    if (newData) {
      return {
        data: newData.result,
        partial: false
      };
    } else {
      try {
        var data = this.dataStore.getCache().read({
          query: query,
          variables: variables,
          previousResult: lastResult ? lastResult.data : undefined,
          optimistic: optimistic
        });
        return {
          data: data,
          partial: false
        };
      } catch (e) {
        return {
          data: {},
          partial: true
        };
      }
    }
  };

  QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
    var observableQuery;

    if (typeof queryIdOrObservable === 'string') {
      var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;

      if (!foundObserveableQuery) {
        throw new Error("ObservableQuery with this id doesn't exist: " + queryIdOrObservable);
      }

      observableQuery = foundObserveableQuery;
    } else {
      observableQuery = queryIdOrObservable;
    }

    var _a = observableQuery.options,
        variables = _a.variables,
        query = _a.query;
    var data = this.getCurrentQueryResult(observableQuery, false).data;
    return {
      previousResult: data,
      variables: variables,
      document: query
    };
  };

  QueryManager.prototype.broadcastQueries = function () {
    var _this = this;

    this.onBroadcast();
    this.queries.forEach(function (info, id) {
      if (!info.invalidated || !info.listeners) return;
      info.listeners.filter(function (x) {
        return !!x;
      }).forEach(function (listener) {
        listener(_this.queryStore.get(id), info.newData);
      });
    });
  };

  QueryManager.prototype.getObservableQueryPromises = function (includeStandby) {
    var _this = this;

    var observableQueryPromises = [];
    this.queries.forEach(function (_a, queryId) {
      var observableQuery = _a.observableQuery;
      if (!observableQuery) return;
      var fetchPolicy = observableQuery.options.fetchPolicy;
      observableQuery.resetLastResults();

      if (fetchPolicy !== 'cache-only' && (includeStandby || fetchPolicy !== 'standby')) {
        observableQueryPromises.push(observableQuery.refetch());
      }

      _this.setQuery(queryId, function () {
        return {
          newData: null
        };
      });

      _this.invalidate(true, queryId);
    });
    return observableQueryPromises;
  };

  QueryManager.prototype.fetchRequest = function (_a) {
    var _this = this;

    var requestId = _a.requestId,
        queryId = _a.queryId,
        document = _a.document,
        options = _a.options,
        fetchMoreForQueryId = _a.fetchMoreForQueryId;
    var variables = options.variables,
        context = options.context,
        _b = options.errorPolicy,
        errorPolicy = _b === void 0 ? 'none' : _b,
        fetchPolicy = options.fetchPolicy;
    var operation = this.buildOperationForLink(document, variables, __assign({}, context, {
      forceFetch: !this.queryDeduplication
    }));
    var resultFromStore;
    var errorsFromStore;
    return new Promise(function (resolve, reject) {
      _this.addFetchQueryPromise(requestId, resolve, reject);

      var subscription = (0, _apolloLink.execute)(_this.deduplicator, operation).subscribe({
        next: function (result) {
          var lastRequestId = _this.getQuery(queryId).lastRequestId;

          if (requestId >= (lastRequestId || 1)) {
            if (fetchPolicy !== 'no-cache') {
              try {
                _this.dataStore.markQueryResult(result, document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
              } catch (e) {
                reject(e);
                return;
              }
            } else {
              _this.setQuery(queryId, function () {
                return {
                  newData: {
                    result: result.data,
                    complete: true
                  }
                };
              });
            }

            _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);

            _this.invalidate(true, queryId, fetchMoreForQueryId);

            _this.broadcastQueries();
          }

          if (result.errors && errorPolicy === 'none') {
            reject(new _ApolloError.ApolloError({
              graphQLErrors: result.errors
            }));
            return;
          } else if (errorPolicy === 'all') {
            errorsFromStore = result.errors;
          }

          if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
            resultFromStore = result.data;
          } else {
            try {
              resultFromStore = _this.dataStore.getCache().read({
                variables: variables,
                query: document,
                optimistic: false
              });
            } catch (e) {}
          }
        },
        error: function (error) {
          _this.removeFetchQueryPromise(requestId);

          _this.setQuery(queryId, function (_a) {
            var subscriptions = _a.subscriptions;
            return {
              subscriptions: subscriptions.filter(function (x) {
                return x !== subscription;
              })
            };
          });

          reject(error);
        },
        complete: function () {
          _this.removeFetchQueryPromise(requestId);

          _this.setQuery(queryId, function (_a) {
            var subscriptions = _a.subscriptions;
            return {
              subscriptions: subscriptions.filter(function (x) {
                return x !== subscription;
              })
            };
          });

          resolve({
            data: resultFromStore,
            errors: errorsFromStore,
            loading: false,
            networkStatus: _networkStatus.NetworkStatus.ready,
            stale: false
          });
        }
      });

      _this.setQuery(queryId, function (_a) {
        var subscriptions = _a.subscriptions;
        return {
          subscriptions: subscriptions.concat([subscription])
        };
      });
    });
  };

  QueryManager.prototype.refetchQueryByName = function (queryName) {
    var _this = this;

    var refetchedQueries = this.queryIdsByName[queryName];
    if (refetchedQueries === undefined) return;
    return Promise.all(refetchedQueries.map(function (id) {
      return _this.getQuery(id).observableQuery;
    }).filter(function (x) {
      return !!x;
    }).map(function (x) {
      return x.refetch();
    }));
  };

  QueryManager.prototype.generateRequestId = function () {
    var requestId = this.idCounter;
    this.idCounter++;
    return requestId;
  };

  QueryManager.prototype.getQuery = function (queryId) {
    return this.queries.get(queryId) || __assign({}, defaultQueryInfo);
  };

  QueryManager.prototype.setQuery = function (queryId, updater) {
    var prev = this.getQuery(queryId);

    var newInfo = __assign({}, prev, updater(prev));

    this.queries.set(queryId, newInfo);
  };

  QueryManager.prototype.invalidate = function (invalidated, queryId, fetchMoreForQueryId) {
    if (queryId) this.setQuery(queryId, function () {
      return {
        invalidated: invalidated
      };
    });

    if (fetchMoreForQueryId) {
      this.setQuery(fetchMoreForQueryId, function () {
        return {
          invalidated: invalidated
        };
      });
    }
  };

  QueryManager.prototype.buildOperationForLink = function (document, variables, extraContext) {
    var cache = this.dataStore.getCache();
    return {
      query: cache.transformForLink ? cache.transformForLink(document) : document,
      variables: variables,
      operationName: (0, _apolloUtilities.getOperationName)(document) || undefined,
      context: __assign({}, extraContext, {
        cache: cache,
        getCacheKey: function (obj) {
          if (cache.config) {
            return cache.config.dataIdFromObject(obj);
          } else {
            throw new Error('To use context.getCacheKey, you need to use a cache that has a configurable dataIdFromObject, like apollo-cache-inmemory.');
          }
        }
      })
    };
  };

  return QueryManager;
}();

exports.QueryManager = QueryManager;
},{"apollo-link":"uD5J","graphql/language/printer":"h5rv","apollo-link-dedup":"pWAM","apollo-utilities":"cD8x","../scheduler/scheduler":"oMJx","../errors/ApolloError":"eRUa","../util/Observable":"MWAe","../data/mutations":"9xN4","../data/queries":"VODt","./ObservableQuery":"4PSG","./networkStatus":"x3yF","./types":"FomV"}],"+mu0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataStore = void 0;

var _apolloUtilities = require("apollo-utilities");

var DataStore = function () {
  function DataStore(initialCache) {
    this.cache = initialCache;
  }

  DataStore.prototype.getCache = function () {
    return this.cache;
  };

  DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
    if (ignoreErrors === void 0) {
      ignoreErrors = false;
    }

    var writeWithErrors = !(0, _apolloUtilities.graphQLResultHasError)(result);

    if (ignoreErrors && (0, _apolloUtilities.graphQLResultHasError)(result) && result.data) {
      writeWithErrors = true;
    }

    if (!fetchMoreForQueryId && writeWithErrors) {
      this.cache.write({
        result: result.data,
        dataId: 'ROOT_QUERY',
        query: document,
        variables: variables
      });
    }
  };

  DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
    if (!(0, _apolloUtilities.graphQLResultHasError)(result)) {
      this.cache.write({
        result: result.data,
        dataId: 'ROOT_SUBSCRIPTION',
        query: document,
        variables: variables
      });
    }
  };

  DataStore.prototype.markMutationInit = function (mutation) {
    var _this = this;

    if (mutation.optimisticResponse) {
      var optimistic_1;

      if (typeof mutation.optimisticResponse === 'function') {
        optimistic_1 = mutation.optimisticResponse(mutation.variables);
      } else {
        optimistic_1 = mutation.optimisticResponse;
      }

      var changeFn_1 = function () {
        _this.markMutationResult({
          mutationId: mutation.mutationId,
          result: {
            data: optimistic_1
          },
          document: mutation.document,
          variables: mutation.variables,
          updateQueries: mutation.updateQueries,
          update: mutation.update
        });
      };

      this.cache.recordOptimisticTransaction(function (c) {
        var orig = _this.cache;
        _this.cache = c;

        try {
          changeFn_1();
        } finally {
          _this.cache = orig;
        }
      }, mutation.mutationId);
    }
  };

  DataStore.prototype.markMutationResult = function (mutation) {
    var _this = this;

    if (!(0, _apolloUtilities.graphQLResultHasError)(mutation.result)) {
      var cacheWrites_1 = [];
      cacheWrites_1.push({
        result: mutation.result.data,
        dataId: 'ROOT_MUTATION',
        query: mutation.document,
        variables: mutation.variables
      });

      if (mutation.updateQueries) {
        Object.keys(mutation.updateQueries).filter(function (id) {
          return mutation.updateQueries[id];
        }).forEach(function (queryId) {
          var _a = mutation.updateQueries[queryId],
              query = _a.query,
              updater = _a.updater;

          var _b = _this.cache.diff({
            query: query.document,
            variables: query.variables,
            returnPartialData: true,
            optimistic: false
          }),
              currentQueryResult = _b.result,
              complete = _b.complete;

          if (!complete) {
            return;
          }

          var nextQueryResult = (0, _apolloUtilities.tryFunctionOrLogError)(function () {
            return updater(currentQueryResult, {
              mutationResult: mutation.result,
              queryName: (0, _apolloUtilities.getOperationName)(query.document) || undefined,
              queryVariables: query.variables
            });
          });

          if (nextQueryResult) {
            cacheWrites_1.push({
              result: nextQueryResult,
              dataId: 'ROOT_QUERY',
              query: query.document,
              variables: query.variables
            });
          }
        });
      }

      this.cache.performTransaction(function (c) {
        cacheWrites_1.forEach(function (write) {
          return c.write(write);
        });
      });
      var update_1 = mutation.update;

      if (update_1) {
        this.cache.performTransaction(function (c) {
          (0, _apolloUtilities.tryFunctionOrLogError)(function () {
            return update_1(c, mutation.result);
          });
        });
      }
    }
  };

  DataStore.prototype.markMutationComplete = function (_a) {
    var mutationId = _a.mutationId,
        optimisticResponse = _a.optimisticResponse;
    if (!optimisticResponse) return;
    this.cache.removeOptimistic(mutationId);
  };

  DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
    this.cache.write({
      result: newResult,
      dataId: 'ROOT_QUERY',
      variables: variables,
      query: document
    });
  };

  DataStore.prototype.reset = function () {
    return this.cache.reset();
  };

  return DataStore;
}();

exports.DataStore = DataStore;
},{"apollo-utilities":"cD8x"}],"NwP0":[function(require,module,exports) {
exports.version = "2.4.2"
},{}],"MWtH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apolloLink = require("apollo-link");

var _apolloUtilities = require("apollo-utilities");

var _QueryManager = require("./core/QueryManager");

var _store = require("./data/store");

var _version = require("./version");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var hasSuggestedDevtools = false;
var supportedDirectives = new _apolloLink.ApolloLink(function (operation, forward) {
  operation.query = (0, _apolloUtilities.removeConnectionDirectiveFromDocument)(operation.query);
  return forward(operation);
});

var ApolloClient = function () {
  function ApolloClient(options) {
    var _this = this;

    this.defaultOptions = {};
    this.resetStoreCallbacks = [];
    var link = options.link,
        cache = options.cache,
        _a = options.ssrMode,
        ssrMode = _a === void 0 ? false : _a,
        _b = options.ssrForceFetchDelay,
        ssrForceFetchDelay = _b === void 0 ? 0 : _b,
        connectToDevTools = options.connectToDevTools,
        _c = options.queryDeduplication,
        queryDeduplication = _c === void 0 ? true : _c,
        defaultOptions = options.defaultOptions;

    if (!link || !cache) {
      throw new Error("\n        In order to initialize Apollo Client, you must specify link & cache properties on the config object.\n        This is part of the required upgrade when migrating from Apollo Client 1.0 to Apollo Client 2.0.\n        For more information, please visit:\n          https://www.apollographql.com/docs/react/basics/setup.html\n        to help you get started.\n      ");
    }

    this.link = supportedDirectives.concat(link);
    this.cache = cache;
    this.store = new _store.DataStore(cache);
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.ssrMode = ssrMode;
    this.defaultOptions = defaultOptions || {};

    if (ssrForceFetchDelay) {
      setTimeout(function () {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }

    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    var defaultConnectToDevTools = !(0, _apolloUtilities.isProduction)() && typeof window !== 'undefined' && !window.__APOLLO_CLIENT__;

    if (typeof connectToDevTools === 'undefined' ? defaultConnectToDevTools : connectToDevTools && typeof window !== 'undefined') {
      window.__APOLLO_CLIENT__ = this;
    }

    if (!hasSuggestedDevtools && !(0, _apolloUtilities.isProduction)()) {
      hasSuggestedDevtools = true;

      if (typeof window !== 'undefined' && window.document && window.top === window.self) {
        if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
          if (window.navigator && window.navigator.userAgent.indexOf('Chrome') > -1) {
            console.debug('Download the Apollo DevTools ' + 'for a better development experience: ' + 'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
          }
        }
      }
    }

    this.version = _version.version;
  }

  ApolloClient.prototype.watchQuery = function (options) {
    if (this.defaultOptions.watchQuery) {
      options = __assign({}, this.defaultOptions.watchQuery, options);
    }

    if (this.disableNetworkFetches && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {
      options = __assign({}, options, {
        fetchPolicy: 'cache-first'
      });
    }

    return this.initQueryManager().watchQuery(options);
  };

  ApolloClient.prototype.query = function (options) {
    if (this.defaultOptions.query) {
      options = __assign({}, this.defaultOptions.query, options);
    }

    if (options.fetchPolicy === 'cache-and-network') {
      throw new Error('cache-and-network fetchPolicy can only be used with watchQuery');
    }

    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
      options = __assign({}, options, {
        fetchPolicy: 'cache-first'
      });
    }

    return this.initQueryManager().query(options);
  };

  ApolloClient.prototype.mutate = function (options) {
    if (this.defaultOptions.mutate) {
      options = __assign({}, this.defaultOptions.mutate, options);
    }

    return this.initQueryManager().mutate(options);
  };

  ApolloClient.prototype.subscribe = function (options) {
    return this.initQueryManager().startGraphQLSubscription(options);
  };

  ApolloClient.prototype.readQuery = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.initProxy().readQuery(options, optimistic);
  };

  ApolloClient.prototype.readFragment = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.initProxy().readFragment(options, optimistic);
  };

  ApolloClient.prototype.writeQuery = function (options) {
    var result = this.initProxy().writeQuery(options);
    this.initQueryManager().broadcastQueries();
    return result;
  };

  ApolloClient.prototype.writeFragment = function (options) {
    var result = this.initProxy().writeFragment(options);
    this.initQueryManager().broadcastQueries();
    return result;
  };

  ApolloClient.prototype.writeData = function (options) {
    var result = this.initProxy().writeData(options);
    this.initQueryManager().broadcastQueries();
    return result;
  };

  ApolloClient.prototype.__actionHookForDevTools = function (cb) {
    this.devToolsHookCb = cb;
  };

  ApolloClient.prototype.__requestRaw = function (payload) {
    return (0, _apolloLink.execute)(this.link, payload);
  };

  ApolloClient.prototype.initQueryManager = function () {
    var _this = this;

    if (!this.queryManager) {
      this.queryManager = new _QueryManager.QueryManager({
        link: this.link,
        store: this.store,
        queryDeduplication: this.queryDeduplication,
        ssrMode: this.ssrMode,
        onBroadcast: function () {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager ? _this.queryManager.queryStore.getStore() : {},
                mutations: _this.queryManager ? _this.queryManager.mutationStore.getStore() : {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        }
      });
    }

    return this.queryManager;
  };

  ApolloClient.prototype.resetStore = function () {
    var _this = this;

    return Promise.resolve().then(function () {
      return _this.queryManager ? _this.queryManager.clearStore() : Promise.resolve(null);
    }).then(function () {
      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {
        return fn();
      }));
    }).then(function () {
      return _this.queryManager && _this.queryManager.reFetchObservableQueries ? _this.queryManager.reFetchObservableQueries() : Promise.resolve(null);
    });
  };

  ApolloClient.prototype.clearStore = function () {
    var queryManager = this.queryManager;
    return Promise.resolve().then(function () {
      return queryManager ? queryManager.clearStore() : Promise.resolve(null);
    });
  };

  ApolloClient.prototype.onResetStore = function (cb) {
    var _this = this;

    this.resetStoreCallbacks.push(cb);
    return function () {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {
        return c !== cb;
      });
    };
  };

  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
    return this.queryManager ? this.queryManager.reFetchObservableQueries(includeStandby) : Promise.resolve(null);
  };

  ApolloClient.prototype.extract = function (optimistic) {
    return this.initProxy().extract(optimistic);
  };

  ApolloClient.prototype.restore = function (serializedState) {
    return this.initProxy().restore(serializedState);
  };

  ApolloClient.prototype.initProxy = function () {
    if (!this.proxy) {
      this.initQueryManager();
      this.proxy = this.cache;
    }

    return this.proxy;
  };

  return ApolloClient;
}();

var _default = ApolloClient;
exports.default = _default;
},{"apollo-link":"uD5J","apollo-utilities":"cD8x","./core/QueryManager":"Zptr","./data/store":"+mu0","./version":"NwP0"}],"pd9I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  printAST: true,
  ObservableQuery: true,
  NetworkStatus: true,
  ApolloError: true,
  ApolloClient: true
};
Object.defineProperty(exports, "printAST", {
  enumerable: true,
  get: function () {
    return _printer.print;
  }
});
Object.defineProperty(exports, "ObservableQuery", {
  enumerable: true,
  get: function () {
    return _ObservableQuery.ObservableQuery;
  }
});
Object.defineProperty(exports, "NetworkStatus", {
  enumerable: true,
  get: function () {
    return _networkStatus.NetworkStatus;
  }
});
Object.defineProperty(exports, "ApolloError", {
  enumerable: true,
  get: function () {
    return _ApolloError.ApolloError;
  }
});
Object.defineProperty(exports, "ApolloClient", {
  enumerable: true,
  get: function () {
    return _ApolloClient.default;
  }
});
exports.default = void 0;

var _printer = require("graphql/language/printer");

var _ObservableQuery = require("./core/ObservableQuery");

var _networkStatus = require("./core/networkStatus");

var _types = require("./core/types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});

var _ApolloError = require("./errors/ApolloError");

var _ApolloClient = _interopRequireDefault(require("./ApolloClient"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _ApolloClient.default;
exports.default = _default;
},{"graphql/language/printer":"h5rv","./core/ObservableQuery":"4PSG","./core/networkStatus":"x3yF","./core/types":"FomV","./errors/ApolloError":"eRUa","./ApolloClient":"MWtH"}],"y+nU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectURI = exports.serializeFetchParameter = exports.selectHttpOptionsAndBody = exports.createSignalIfSupported = exports.checkFetcher = exports.parseAndCheckHttpResponse = exports.throwServerError = exports.fallbackHttpConfig = void 0;

var _printer = require("graphql/language/printer");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: '*/*',
  'content-type': 'application/json'
};
var defaultOptions = {
  method: 'POST'
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
exports.fallbackHttpConfig = fallbackHttpConfig;

var throwServerError = function (response, result, message) {
  var error = new Error(message);
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
}; //TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>


exports.throwServerError = throwServerError;

var parseAndCheckHttpResponse = function (operations) {
  return function (response) {
    return response.text().then(function (bodyText) {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        var parseError = err;
        parseError.response = response;
        parseError.statusCode = response.status;
        parseError.bodyText = bodyText;
        return Promise.reject(parseError);
      }
    }) //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult
    .then(function (result) {
      if (response.status >= 300) {
        //Network error
        throwServerError(response, result, "Response not successful: Received status code " + response.status);
      } //TODO should really error per response in a Batch based on properties
      //    - could be done in a validation link


      if (!Array.isArray(result) && !result.hasOwnProperty('data') && !result.hasOwnProperty('errors')) {
        //Data error
        throwServerError(response, result, "Server response was missing for query '" + (Array.isArray(operations) ? operations.map(function (op) {
          return op.operationName;
        }) : operations.operationName) + "'.");
      }

      return result;
    });
  };
};

exports.parseAndCheckHttpResponse = parseAndCheckHttpResponse;

var checkFetcher = function (fetcher) {
  if (!fetcher && typeof fetch === 'undefined') {
    var library = 'unfetch';
    if (typeof window === 'undefined') library = 'node-fetch';
    throw new Error("\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/" + library + ".\n\nFor example:\nimport fetch from '" + library + "';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });");
  }
};

exports.checkFetcher = checkFetcher;

var createSignalIfSupported = function () {
  if (typeof AbortController === 'undefined') return {
    controller: false,
    signal: false
  };
  var controller = new AbortController();
  var signal = controller.signal;
  return {
    controller: controller,
    signal: signal
  };
};

exports.createSignalIfSupported = createSignalIfSupported;

var selectHttpOptionsAndBody = function (operation, fallbackConfig) {
  var configs = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }

  var options = __assign({}, fallbackConfig.options, {
    headers: fallbackConfig.headers,
    credentials: fallbackConfig.credentials
  });

  var http = fallbackConfig.http;
  /*
   * use the rest of the configs to populate the options
   * configs later in the list will overwrite earlier fields
   */

  configs.forEach(function (config) {
    options = __assign({}, options, config.options, {
      headers: __assign({}, options.headers, config.headers)
    });
    if (config.credentials) options.credentials = config.credentials;
    http = __assign({}, http, config.http);
  }); //The body depends on the http options

  var operationName = operation.operationName,
      extensions = operation.extensions,
      variables = operation.variables,
      query = operation.query;
  var body = {
    operationName: operationName,
    variables: variables
  };
  if (http.includeExtensions) body.extensions = extensions; // not sending the query (i.e persisted queries)

  if (http.includeQuery) body.query = (0, _printer.print)(query);
  return {
    options: options,
    body: body
  };
};

exports.selectHttpOptionsAndBody = selectHttpOptionsAndBody;

var serializeFetchParameter = function (p, label) {
  var serialized;

  try {
    serialized = JSON.stringify(p);
  } catch (e) {
    var parseError = new Error("Network request failed. " + label + " is not serializable: " + e.message);
    parseError.parseError = e;
    throw parseError;
  }

  return serialized;
}; //selects "/graphql" by default


exports.serializeFetchParameter = serializeFetchParameter;

var selectURI = function (operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;

  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === 'function') {
    return fallbackURI(operation);
  } else {
    return fallbackURI || '/graphql';
  }
};

exports.selectURI = selectURI;
},{"graphql/language/printer":"h5rv"}],"Xpu8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HttpLink = exports.createHttpLink = void 0;

var _apolloLink = require("apollo-link");

var _apolloLinkHttpCommon = require("apollo-link-http-common");

/* tslint:disable */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
};

var createHttpLink = function (linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }

  var _a = linkOptions.uri,
      uri = _a === void 0 ? '/graphql' : _a,
      // use default global fetch is nothing passed in
  fetcher = linkOptions.fetch,
      includeExtensions = linkOptions.includeExtensions,
      useGETForQueries = linkOptions.useGETForQueries,
      requestOptions = __rest(linkOptions, ["uri", "fetch", "includeExtensions", "useGETForQueries"]); // dev warnings to ensure fetch is present


  (0, _apolloLinkHttpCommon.checkFetcher)(fetcher); //fetcher is set here rather than the destructuring to ensure fetch is
  //declared before referencing it. Reference in the destructuring would cause
  //a ReferenceError

  if (!fetcher) {
    fetcher = fetch;
  }

  var linkConfig = {
    http: {
      includeExtensions: includeExtensions
    },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new _apolloLink.ApolloLink(function (operation) {
    var chosenURI = (0, _apolloLinkHttpCommon.selectURI)(operation, uri);
    var context = operation.getContext();
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: context.headers
    }; //uses fallback, link, and then context to build options

    var _a = (0, _apolloLinkHttpCommon.selectHttpOptionsAndBody)(operation, _apolloLinkHttpCommon.fallbackHttpConfig, linkConfig, contextConfig),
        options = _a.options,
        body = _a.body;

    var controller;

    if (!options.signal) {
      var _b = (0, _apolloLinkHttpCommon.createSignalIfSupported)(),
          _controller = _b.controller,
          signal = _b.signal;

      controller = _controller;
      if (controller) options.signal = signal;
    } // If requested, set method to GET if there are no mutations.


    var definitionIsMutation = function (d) {
      return d.kind === 'OperationDefinition' && d.operation === 'mutation';
    };

    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = 'GET';
    }

    if (options.method === 'GET') {
      var _c = rewriteURIForGET(chosenURI, body),
          newURI = _c.newURI,
          parseError = _c.parseError;

      if (parseError) {
        return (0, _apolloLink.fromError)(parseError);
      }

      chosenURI = newURI;
    } else {
      try {
        options.body = (0, _apolloLinkHttpCommon.serializeFetchParameter)(body, 'Payload');
      } catch (parseError) {
        return (0, _apolloLink.fromError)(parseError);
      }
    }

    return new _apolloLink.Observable(function (observer) {
      fetcher(chosenURI, options).then(function (response) {
        operation.setContext({
          response: response
        });
        return response;
      }).then((0, _apolloLinkHttpCommon.parseAndCheckHttpResponse)(operation)).then(function (result) {
        // we have data and can send it to back up the link chain
        observer.next(result);
        observer.complete();
        return result;
      }).catch(function (err) {
        // fetch was cancelled so its already been cleaned up in the unsubscribe
        if (err.name === 'AbortError') return; // if it is a network error, BUT there is graphql result info
        // fire the next observer before calling error
        // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`
        // to pass to UI
        // this should only happen if we *also* have data as part of the response key per
        // the spec

        if (err.result && err.result.errors && err.result.data) {
          // if we dont' call next, the UI can only show networkError because AC didn't
          // get andy graphqlErrors
          // this is graphql execution result info (i.e errors and possibly data)
          // this is because there is no formal spec how errors should translate to
          // http status codes. So an auth error (401) could have both data
          // from a public field, errors from a private field, and a status of 401
          // {
          //  user { // this will have errors
          //    firstName
          //  }
          //  products { // this is public so will have data
          //    cost
          //  }
          // }
          //
          // the result of above *could* look like this:
          // {
          //   data: { products: [{ cost: "$10" }] },
          //   errors: [{
          //      message: 'your session has timed out',
          //      path: []
          //   }]
          // }
          // status code of above would be a 401
          // in the UI you want to show data where you can, errors as data where you can
          // and use correct http status codes
          observer.next(err.result);
        }

        observer.error(err);
      });
      return function () {
        // XXX support canceling this request
        // https://developers.google.com/web/updates/2017/09/abortable-fetch
        if (controller) controller.abort();
      };
    });
  });
}; // For GET operations, returns the given URI rewritten with parameters, or a
// parse error.


exports.createHttpLink = createHttpLink;

function rewriteURIForGET(chosenURI, body) {
  // Implement the standard HTTP GET serialization, plus 'extensions'. Note
  // the extra level of JSON serialization!
  var queryParams = [];

  var addQueryParam = function (key, value) {
    queryParams.push(key + "=" + encodeURIComponent(value));
  };

  if ('query' in body) {
    addQueryParam('query', body.query);
  }

  if (body.operationName) {
    addQueryParam('operationName', body.operationName);
  }

  if (body.variables) {
    var serializedVariables = void 0;

    try {
      serializedVariables = (0, _apolloLinkHttpCommon.serializeFetchParameter)(body.variables, 'Variables map');
    } catch (parseError) {
      return {
        parseError: parseError
      };
    }

    addQueryParam('variables', serializedVariables);
  }

  if (body.extensions) {
    var serializedExtensions = void 0;

    try {
      serializedExtensions = (0, _apolloLinkHttpCommon.serializeFetchParameter)(body.extensions, 'Extensions map');
    } catch (parseError) {
      return {
        parseError: parseError
      };
    }

    addQueryParam('extensions', serializedExtensions);
  } // Reconstruct the URI with added query params.
  // XXX This assumes that the URI is well-formed and that it doesn't
  //     already contain any of these query params. We could instead use the
  //     URL API and take a polyfill (whatwg-url@6) for older browsers that
  //     don't support URLSearchParams. Note that some browsers (and
  //     versions of whatwg-url) support URL but not URLSearchParams!


  var fragment = '',
      preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf('#');

  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }

  var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';
  var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;
  return {
    newURI: newURI
  };
}

var HttpLink =
/** @class */
function (_super) {
  __extends(HttpLink, _super);

  function HttpLink(opts) {
    return _super.call(this, createHttpLink(opts).request) || this;
  }

  return HttpLink;
}(_apolloLink.ApolloLink);

exports.HttpLink = HttpLink;
},{"apollo-link":"uD5J","apollo-link-http-common":"y+nU"}],"YLHZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _httpLink = require("./httpLink");

Object.keys(_httpLink).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _httpLink[key];
    }
  });
});
},{"./httpLink":"Xpu8"}],"QduR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setContext = void 0;

var _apolloLink = require("apollo-link");

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];
  return t;
};

var setContext = function (setter) {
  return new _apolloLink.ApolloLink(function (operation, forward) {
    var request = __rest(operation, []);

    return new _apolloLink.Observable(function (observer) {
      var handle;
      Promise.resolve(request).then(function (req) {
        return setter(req, operation.getContext());
      }).then(operation.setContext).then(function () {
        handle = forward(operation).subscribe({
          next: observer.next.bind(observer),
          error: observer.error.bind(observer),
          complete: observer.complete.bind(observer)
        });
      }).catch(observer.error.bind(observer));
      return function () {
        if (handle) handle.unsubscribe();
      };
    });
  });
};

exports.setContext = setContext;
},{"apollo-link":"uD5J"}],"dTX1":[function(require,module,exports) {
var frozen = {};
var frozenTestMap = new Map();
if (typeof Object.freeze === 'function') {
    Object.freeze(frozen);
}
try {
    frozenTestMap.set(frozen, frozen).delete(frozen);
}
catch (_a) {
    var wrap = function (method) {
        return method && (function (obj) {
            try {
                frozenTestMap.set(obj, obj).delete(obj);
            }
            finally {
                return method.call(Object, obj);
            }
        });
    };
    Object.freeze = wrap(Object.freeze);
    Object.seal = wrap(Object.seal);
    Object.preventExtensions = wrap(Object.preventExtensions);
}

},{}],"chJR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.queryFromPojo = queryFromPojo;
exports.fragmentFromPojo = fragmentFromPojo;
exports.justTypenameQuery = void 0;

function queryFromPojo(obj) {
  var op = {
    kind: 'OperationDefinition',
    operation: 'query',
    name: {
      kind: 'Name',
      value: 'GeneratedClientQuery'
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: 'Document',
    definitions: [op]
  };
  return out;
}

function fragmentFromPojo(obj, typename) {
  var frag = {
    kind: 'FragmentDefinition',
    typeCondition: {
      kind: 'NamedType',
      name: {
        kind: 'Name',
        value: typename || '__FakeType'
      }
    },
    name: {
      kind: 'Name',
      value: 'GeneratedClientQuery'
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: 'Document',
    definitions: [frag]
  };
  return out;
}

function selectionSetFromObj(obj) {
  if (typeof obj === 'number' || typeof obj === 'boolean' || typeof obj === 'string' || typeof obj === 'undefined' || obj === null) {
    return null;
  }

  if (Array.isArray(obj)) {
    return selectionSetFromObj(obj[0]);
  }

  var selections = [];
  Object.keys(obj).forEach(function (key) {
    var field = {
      kind: 'Field',
      name: {
        kind: 'Name',
        value: key
      }
    };
    var nestedSelSet = selectionSetFromObj(obj[key]);

    if (nestedSelSet) {
      field.selectionSet = nestedSelSet;
    }

    selections.push(field);
  });
  var selectionSet = {
    kind: 'SelectionSet',
    selections: selections
  };
  return selectionSet;
}

var justTypenameQuery = {
  kind: 'Document',
  definitions: [{
    kind: 'OperationDefinition',
    operation: 'query',
    name: null,
    variableDefinitions: null,
    directives: [],
    selectionSet: {
      kind: 'SelectionSet',
      selections: [{
        kind: 'Field',
        alias: null,
        name: {
          kind: 'Name',
          value: '__typename'
        },
        arguments: [],
        directives: [],
        selectionSet: null
      }]
    }
  }]
};
exports.justTypenameQuery = justTypenameQuery;
},{}],"AlM8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApolloCache = void 0;

var _apolloUtilities = require("apollo-utilities");

var _utils = require("./utils");

var ApolloCache = function () {
  function ApolloCache() {}

  ApolloCache.prototype.transformDocument = function (document) {
    return document;
  };

  ApolloCache.prototype.transformForLink = function (document) {
    return document;
  };

  ApolloCache.prototype.readQuery = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: options.query,
      variables: options.variables,
      optimistic: optimistic
    });
  };

  ApolloCache.prototype.readFragment = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: (0, _apolloUtilities.getFragmentQueryDocument)(options.fragment, options.fragmentName),
      variables: options.variables,
      rootId: options.id,
      optimistic: optimistic
    });
  };

  ApolloCache.prototype.writeQuery = function (options) {
    this.write({
      dataId: 'ROOT_QUERY',
      result: options.data,
      query: options.query,
      variables: options.variables
    });
  };

  ApolloCache.prototype.writeFragment = function (options) {
    this.write({
      dataId: options.id,
      result: options.data,
      variables: options.variables,
      query: (0, _apolloUtilities.getFragmentQueryDocument)(options.fragment, options.fragmentName)
    });
  };

  ApolloCache.prototype.writeData = function (_a) {
    var id = _a.id,
        data = _a.data;

    if (typeof id !== 'undefined') {
      var typenameResult = null;

      try {
        typenameResult = this.read({
          rootId: id,
          optimistic: false,
          query: _utils.justTypenameQuery
        });
      } catch (e) {}

      var __typename = typenameResult && typenameResult.__typename || '__ClientData';

      var dataToWrite = Object.assign({
        __typename: __typename
      }, data);
      this.writeFragment({
        id: id,
        fragment: (0, _utils.fragmentFromPojo)(dataToWrite, __typename),
        data: dataToWrite
      });
    } else {
      this.writeQuery({
        query: (0, _utils.queryFromPojo)(data),
        data: data
      });
    }
  };

  return ApolloCache;
}();

exports.ApolloCache = ApolloCache;
},{"apollo-utilities":"cD8x","./utils":"chJR"}],"zn0i":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Cache = void 0;
var Cache;
exports.Cache = Cache;

(function (Cache) {})(Cache || (exports.Cache = Cache = {}));
},{}],"yHNe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Cache = require("./Cache");

Object.keys(_Cache).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Cache[key];
    }
  });
});
},{"./Cache":"zn0i"}],"IZbR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cache = require("./cache");

Object.keys(_cache).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _cache[key];
    }
  });
});

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _types[key];
    }
  });
});
},{"./cache":"AlM8","./types":"yHNe"}],"Z2JP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IntrospectionFragmentMatcher = exports.HeuristicFragmentMatcher = void 0;

var _apolloUtilities = require("apollo-utilities");

var haveWarned = false;

var HeuristicFragmentMatcher = function () {
  function HeuristicFragmentMatcher() {}

  HeuristicFragmentMatcher.prototype.ensureReady = function () {
    return Promise.resolve();
  };

  HeuristicFragmentMatcher.prototype.canBypassInit = function () {
    return true;
  };

  HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
    var obj = context.store.get(idValue.id);

    if (!obj && idValue.id === 'ROOT_QUERY') {
      return true;
    }

    if (!obj) {
      return false;
    }

    if (!obj.__typename) {
      if (!haveWarned) {
        console.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
        console.warn('Could not find __typename on Fragment ', typeCondition, obj);
        console.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " + "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");

        if (!(0, _apolloUtilities.isTest)()) {
          haveWarned = true;
        }
      }

      return 'heuristic';
    }

    if (obj.__typename === typeCondition) {
      return true;
    }

    (0, _apolloUtilities.warnOnceInDevelopment)('You are using the simple (heuristic) fragment matcher, but your ' + 'queries contain union or interface types. Apollo Client will not be ' + 'able to accurately map fragments. To make this error go away, use ' + 'the `IntrospectionFragmentMatcher` as described in the docs: ' + 'https://www.apollographql.com/docs/react/recipes/fragment-matching.html', 'error');
    return 'heuristic';
  };

  return HeuristicFragmentMatcher;
}();

exports.HeuristicFragmentMatcher = HeuristicFragmentMatcher;

var IntrospectionFragmentMatcher = function () {
  function IntrospectionFragmentMatcher(options) {
    if (options && options.introspectionQueryResultData) {
      this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
      this.isReady = true;
    } else {
      this.isReady = false;
    }

    this.match = this.match.bind(this);
  }

  IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
    if (!this.isReady) {
      throw new Error('FragmentMatcher.match() was called before FragmentMatcher.init()');
    }

    var obj = context.store.get(idValue.id);

    if (!obj) {
      return false;
    }

    if (!obj.__typename) {
      throw new Error("Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
    }

    if (obj.__typename === typeCondition) {
      return true;
    }

    var implementingTypes = this.possibleTypesMap[typeCondition];

    if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {
      return true;
    }

    return false;
  };

  IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {
    var typeMap = {};

    introspectionResultData.__schema.types.forEach(function (type) {
      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
        typeMap[type.name] = type.possibleTypes.map(function (implementingType) {
          return implementingType.name;
        });
      }
    });

    return typeMap;
  };

  return IntrospectionFragmentMatcher;
}();

exports.IntrospectionFragmentMatcher = IntrospectionFragmentMatcher;
},{"apollo-utilities":"cD8x"}],"wqzJ":[function(require,module,exports) {
"use strict";

function Cache(options) {
  this.map = new Map;
  this.newest = null;
  this.oldest = null;
  this.max = options && options.max;
  this.dispose = options && options.dispose;
}

exports.Cache = Cache;

var Cp = Cache.prototype;

Cp.has = function (key) {
  return this.map.has(key);
};

Cp.get = function (key) {
  var entry = getEntry(this, key);
  return entry && entry.value;
};

function getEntry(cache, key) {
  var entry = cache.map.get(key);
  if (entry &&
      entry !== cache.newest) {
    var older = entry.older;
    var newer = entry.newer;

    if (newer) {
      newer.older = older;
    }

    if (older) {
      older.newer = newer;
    }

    entry.older = cache.newest;
    entry.older.newer = entry;

    entry.newer = null;
    cache.newest = entry;

    if (entry === cache.oldest) {
      cache.oldest = newer;
    }
  }

  return entry;
}

Cp.set = function (key, value) {
  var entry = getEntry(this, key);
  if (entry) {
    return entry.value = value;
  }

  entry = {
    key: key,
    value: value,
    newer: null,
    older: this.newest
  };

  if (this.newest) {
    this.newest.newer = entry;
  }

  this.newest = entry;
  this.oldest = this.oldest || entry;

  this.map.set(key, entry);

  if (typeof this.max === "number") {
    while (this.oldest &&
           this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  }

  return entry.value;
};

Cp.delete = function (key) {
  var entry = this.map.get(key);
  if (entry) {
    if (entry === this.newest) {
      this.newest = entry.older;
    }

    if (entry === this.oldest) {
      this.oldest = entry.newer;
    }

    if (entry.newer) {
      entry.newer.older = entry.older;
    }

    if (entry.older) {
      entry.older.newer = entry.newer;
    }

    this.map.delete(key);

    if (typeof this.dispose === "function") {
      this.dispose(key, entry.value);
    }

    return true;
  }

  return false;
};

},{}],"XipD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tuple = tuple;
exports.lookup = lookup;
exports.default = void 0;

// A map data structure that holds object keys weakly, yet can also hold
// non-object keys, unlike the native `WeakMap`.
var UniversalWeakMap = function UniversalWeakMap() {
  // Since a `WeakMap` cannot hold primitive values as keys, we need a
  // backup `Map` instance to hold primitive keys. Both `this._weakMap`
  // and `this._strongMap` are lazily initialized.
  this._weakMap = null;
  this._strongMap = null;
  this.data = null;
}; // Since `get` and `set` are the only methods used, that's all I've
// implemented here.


UniversalWeakMap.prototype.get = function get(key) {
  var map = this._getMap(key, false);

  if (map) {
    return map.get(key);
  }
};

UniversalWeakMap.prototype.set = function set(key, value) {
  this._getMap(key, true).set(key, value); // An actual `Map` or `WeakMap` would return `this` here, but
  // returning the `value` is more convenient for the `tuple`
  // implementation.


  return value;
};

UniversalWeakMap.prototype._getMap = function _getMap(key, canCreate) {
  if (!canCreate) {
    return isObjRef(key) ? this._weakMap : this._strongMap;
  }

  if (isObjRef(key)) {
    return this._weakMap || (this._weakMap = new WeakMap());
  }

  return this._strongMap || (this._strongMap = new Map());
};

function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null) {
        return false;
      }

    case "function":
      return true;

    default:
      return false;
  }
} // Although `Symbol` is widely supported these days, we can safely fall
// back to using a non-enumerable string property without violating any
// assumptions elsewhere in the implementation.


var useSymbol = typeof Symbol === "function"; // Used to mark `tuple.prototype` so that all objects that inherit from
// any `tuple.prototype` object (there could be more than one) will test
// positive according to `tuple.isTuple`.

var brand = useSymbol ? Symbol.for("immutable-tuple") : "@@__IMMUTABLE_TUPLE__@@"; // Used to save a reference to the globally shared `UniversalWeakMap` that
// stores all known `tuple` objects.

var globalKey = useSymbol ? Symbol.for("immutable-tuple-root") : "@@__IMMUTABLE_TUPLE_ROOT__@@"; // Convenient helper for defining hidden immutable properties.

function def(obj, name, value, enumerable) {
  Object.defineProperty(obj, name, {
    value: value,
    enumerable: !!enumerable,
    writable: false,
    configurable: false
  });
  return value;
}

var freeze = Object.freeze || function (obj) {
  return obj;
}; // The `mustConvertThisToArray` value is true when the corresponding
// `Array` method does not attempt to modify `this`, which means we can
// pass a `tuple` object as `this` without first converting it to an
// `Array`.


function forEachArrayMethod(fn) {
  function call(name, mustConvertThisToArray) {
    var desc = Object.getOwnPropertyDescriptor(Array.prototype, name);
    fn(name, desc, !!mustConvertThisToArray);
  }

  call("every");
  call("filter");
  call("find");
  call("findIndex");
  call("forEach");
  call("includes");
  call("indexOf");
  call("join");
  call("lastIndexOf");
  call("map");
  call("reduce");
  call("reduceRight");
  call("slice");
  call("some");
  call("toLocaleString");
  call("toString"); // The `reverse` and `sort` methods are usually destructive, but for
  // `tuple` objects they return a new `tuple` object that has been
  // appropriately reversed/sorted.

  call("reverse", true);
  call("sort", true); // Make `[...someTuple]` work.

  call(useSymbol && Symbol.iterator || "@@iterator");
} // See [`universal-weak-map.js`](universal-weak-map.html).
// See [`util.js`](util.html).
// If this package is installed multiple times, there could be mutiple
// implementations of the `tuple` function with distinct `tuple.prototype`
// objects, but the shared pool of `tuple` objects must be the same across
// all implementations. While it would be ideal to use the `global`
// object, there's no reliable way to get the global object across all JS
// environments without using the `Function` constructor, so instead we
// use the global `Array` constructor as a shared namespace.


var root = Array[globalKey] || def(Array, globalKey, new UniversalWeakMap(), false);

function lookup() {
  var arguments$1 = arguments;
  var node = root; // Because we are building a tree of *weak* maps, the tree will not
  // prevent objects in tuples from being garbage collected, since the
  // tree itself will be pruned over time when the corresponding `tuple`
  // objects become unreachable. In addition to internalization, this
  // property is a key advantage of the `immutable-tuple` package.

  var argc = arguments.length;

  for (var i = 0; i < argc; ++i) {
    var item = arguments$1[i];
    node = node.get(item) || node.set(item, new UniversalWeakMap());
  } // Return node.data rather than node itself to prevent tampering with
  // the UniversalWeakMap tree.


  return node.data || (node.data = Object.create(null));
} // See [`lookup.js`](lookup.html).
// See [`util.js`](util.html).
// When called with any number of arguments, this function returns an
// object that inherits from `tuple.prototype` and is guaranteed to be
// `===` any other `tuple` object that has exactly the same items. In
// computer science jargon, `tuple` instances are "internalized" or just
// "interned," which allows for constant-time equality checking, and makes
// it possible for tuple objects to be used as `Map` or `WeakMap` keys, or
// stored in a `Set`.


function tuple() {
  var arguments$1 = arguments;
  var node = lookup.apply(null, arguments);

  if (node.tuple) {
    return node.tuple;
  }

  var t = Object.create(tuple.prototype); // Define immutable items with numeric indexes, and permanently fix the
  // `.length` property.

  var argc = arguments.length;

  for (var i = 0; i < argc; ++i) {
    t[i] = arguments$1[i];
  }

  def(t, "length", argc, false); // Remember this new `tuple` object so that we can return the same object
  // earlier next time.

  return freeze(node.tuple = t);
} // Since the `immutable-tuple` package could be installed multiple times
// in an application, there is no guarantee that the `tuple` constructor
// or `tuple.prototype` will be unique, so `value instanceof tuple` is
// unreliable. Instead, to test if a value is a tuple, you should use
// `tuple.isTuple(value)`.


def(tuple.prototype, brand, true, false);

function isTuple(that) {
  return !!(that && that[brand] === true);
}

tuple.isTuple = isTuple;

function toArray(tuple) {
  var array = [];
  var i = tuple.length;

  while (i--) {
    array[i] = tuple[i];
  }

  return array;
} // Copy all generic non-destructive Array methods to `tuple.prototype`.
// This works because (for example) `Array.prototype.slice` can be invoked
// against any `Array`-like object.


forEachArrayMethod(function (name, desc, mustConvertThisToArray) {
  var method = desc && desc.value;

  if (typeof method === "function") {
    desc.value = function () {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var result = method.apply(mustConvertThisToArray ? toArray(this) : this, args); // Of course, `tuple.prototype.slice` should return a `tuple` object,
      // not a new `Array`.

      return Array.isArray(result) ? tuple.apply(void 0, result) : result;
    };

    Object.defineProperty(tuple.prototype, name, desc);
  }
}); // Like `Array.prototype.concat`, except for the extra effort required to
// convert any tuple arguments to arrays, so that
// ```
// tuple(1).concat(tuple(2), 3) === tuple(1, 2, 3)
// ```

var ref = Array.prototype;
var concat = ref.concat;

tuple.prototype.concat = function () {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return tuple.apply(void 0, concat.apply(toArray(this), args.map(function (item) {
    return isTuple(item) ? toArray(item) : item;
  })));
};

var _default = tuple;
exports.default = _default;
},{}],"Eo/l":[function(require,module,exports) {
"use strict";

var fakeNullFiber = new (function Fiber(){});
var localKey = "_optimism_local";

function getCurrentFiber() {
  return fakeNullFiber;
}

if (typeof module === "object") {
  try {
    var Fiber = module["eriuqer".split("").reverse().join("")]("fibers");
    // If we were able to require fibers, redefine the getCurrentFiber
    // function so that it has a chance to return Fiber.current.
    getCurrentFiber = function () {
      return Fiber.current || fakeNullFiber;
    };
  } catch (e) {}
}

// Returns an object unique to Fiber.current, if fibers are enabled.
// This object is used for Fiber-local storage in ./entry.js.
exports.get = function () {
  var fiber = getCurrentFiber();
  return fiber[localKey] || (fiber[localKey] = Object.create(null));
};

},{}],"8gn+":[function(require,module,exports) {
"use strict";

var getLocal = require("./local.js").get;
var UNKNOWN_VALUE = Object.create(null);
var emptySetPool = [];
var entryPool = [];

// Don't let the emptySetPool or entryPool grow larger than this size,
// since unconstrained pool growth could lead to memory leaks.
exports.POOL_TARGET_SIZE = 100;

// Since this package might be used browsers, we should avoid using the
// Node built-in assert module.
function assert(condition, optionalMessage) {
  if (! condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}

function Entry(fn, key, args) {
  this.parents = new Set;
  this.childValues = new Map;

  // When this Entry has children that are dirty, this property becomes
  // a Set containing other Entry objects, borrowed from emptySetPool.
  // When the set becomes empty, it gets recycled back to emptySetPool.
  this.dirtyChildren = null;

  reset(this, fn, key, args);

  ++Entry.count;
}

Entry.count = 0;

function reset(entry, fn, key, args) {
  entry.fn = fn;
  entry.key = key;
  entry.args = args;
  entry.value = UNKNOWN_VALUE;
  entry.dirty = true;
  entry.subscribe = null;
  entry.unsubscribe = null;
  entry.recomputing = false;
  // Optional callback that will be invoked when entry.parents becomes
  // empty. The Entry object is given as the first parameter. If the
  // callback returns true, then this entry can be removed from the graph
  // and safely recycled into the entryPool.
  entry.reportOrphan = null;
}

Entry.acquire = function (fn, key, args) {
  var entry = entryPool.pop();
  if (entry) {
    reset(entry, fn, key, args);
    return entry;
  }
  return new Entry(fn, key, args);
};

function release(entry) {
  assert(entry.parents.size === 0);
  assert(entry.childValues.size === 0);
  assert(entry.dirtyChildren === null);
  if (entryPool.length < exports.POOL_TARGET_SIZE) {
    entryPool.push(entry);
  }
}

exports.Entry = Entry;

var Ep = Entry.prototype;

// The public API of Entry objects consists of the Entry constructor,
// along with the recompute, setDirty, and dispose methods.

Ep.recompute = function recompute() {
  if (! rememberParent(this) &&
      maybeReportOrphan(this)) {
    // The recipient of the entry.reportOrphan callback decided to dispose
    // of this orphan entry by calling entry.dispos(), which recycles it
    // into the entryPool, so we don't need to (and should not) proceed
    // with the recomputation.
    return;
  }

  return recomputeIfDirty(this);
};

// If the given entry has a reportOrphan method, and no remaining parents,
// call entry.reportOrphan and return true iff it returns true. The
// reportOrphan function should return true to indicate entry.dispose()
// has been called, and the entry has been removed from any other caches
// (see index.js for the only current example).
function maybeReportOrphan(entry) {
  var report = entry.reportOrphan;
  return typeof report === "function" &&
    entry.parents.size === 0 &&
    report(entry) === true;
}

Ep.setDirty = function setDirty() {
  if (this.dirty) return;
  this.dirty = true;
  this.value = UNKNOWN_VALUE;
  reportDirty(this);
  // We can go ahead and unsubscribe here, since any further dirty
  // notifications we receive will be redundant, and unsubscribing may
  // free up some resources, e.g. file watchers.
  unsubscribe(this);
};

Ep.dispose = function dispose() {
  var entry = this;
  forgetChildren(entry).forEach(maybeReportOrphan);
  unsubscribe(entry);

  // Because this entry has been kicked out of the cache (in index.js),
  // we've lost the ability to find out if/when this entry becomes dirty,
  // whether that happens through a subscription, because of a direct call
  // to entry.setDirty(), or because one of its children becomes dirty.
  // Because of this loss of future information, we have to assume the
  // worst (that this entry might have become dirty very soon), so we must
  // immediately mark this entry's parents as dirty. Normally we could
  // just call entry.setDirty() rather than calling parent.setDirty() for
  // each parent, but that would leave this entry in parent.childValues
  // and parent.dirtyChildren, which would prevent the child from being
  // truly forgotten.
  entry.parents.forEach(function (parent) {
    parent.setDirty();
    forgetChild(parent, entry);
  });

  // Since this entry has no parents and no children anymore, and the
  // caller of Entry#dispose has indicated that entry.value no longer
  // matters, we can safely recycle this Entry object for later use.
  release(entry);
};

function setClean(entry) {
  entry.dirty = false;

  if (mightBeDirty(entry)) {
    // This Entry may still have dirty children, in which case we can't
    // let our parents know we're clean just yet.
    return;
  }

  reportClean(entry);
}

function reportDirty(entry) {
  entry.parents.forEach(function (parent) {
    reportDirtyChild(parent, entry);
  });
}

function reportClean(entry) {
  entry.parents.forEach(function (parent) {
    reportCleanChild(parent, entry);
  });
}

function mightBeDirty(entry) {
  return entry.dirty ||
    (entry.dirtyChildren &&
     entry.dirtyChildren.size);
}

// Let a parent Entry know that one of its children may be dirty.
function reportDirtyChild(entry, child) {
  // Must have called rememberParent(child) before calling
  // reportDirtyChild(parent, child).
  assert(entry.childValues.has(child));
  assert(mightBeDirty(child));

  if (! entry.dirtyChildren) {
    entry.dirtyChildren = emptySetPool.pop() || new Set;

  } else if (entry.dirtyChildren.has(child)) {
    // If we already know this child is dirty, then we must have already
    // informed our own parents that we are dirty, so we can terminate
    // the recursion early.
    return;
  }

  entry.dirtyChildren.add(child);
  reportDirty(entry);
}

// Let a parent Entry know that one of its children is no longer dirty.
function reportCleanChild(entry, child) {
  var cv = entry.childValues;

  // Must have called rememberChild(child) before calling
  // reportCleanChild(parent, child).
  assert(cv.has(child));
  assert(! mightBeDirty(child));

  var childValue = cv.get(child);
  if (childValue === UNKNOWN_VALUE) {
    cv.set(child, child.value);
  } else if (childValue !== child.value) {
    entry.setDirty();
  }

  removeDirtyChild(entry, child);

  if (mightBeDirty(entry)) {
    return;
  }

  reportClean(entry);
}

function removeDirtyChild(entry, child) {
  var dc = entry.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < exports.POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      entry.dirtyChildren = null;
    }
  }
}

function rememberParent(entry) {
  var local = getLocal();
  var parent = local.currentParentEntry;
  if (parent) {
    entry.parents.add(parent);

    if (! parent.childValues.has(entry)) {
      parent.childValues.set(entry, UNKNOWN_VALUE);
    }

    if (mightBeDirty(entry)) {
      reportDirtyChild(parent, entry);
    } else {
      reportCleanChild(parent, entry);
    }

    return parent;
  }
}

// This is the most important method of the Entry API, because it
// determines whether the cached entry.value can be returned immediately,
// or must be recomputed. The overall performance of the caching system
// depends on the truth of the following observations: (1) this.dirty is
// usually false, (2) this.dirtyChildren is usually null/empty, and thus
// (3) this.value is usally returned very quickly, without recomputation.
function recomputeIfDirty(entry) {
  if (entry.dirty) {
    // If this Entry is explicitly dirty because someone called
    // entry.setDirty(), recompute.
    return reallyRecompute(entry);
  }

  if (mightBeDirty(entry)) {
    // Get fresh values for any dirty children, and if those values
    // disagree with this.childValues, mark this Entry explicitly dirty.
    entry.dirtyChildren.forEach(function (child) {
      assert(entry.childValues.has(child));
      try {
        recomputeIfDirty(child);
      } catch (e) {
        entry.setDirty();
      }
    });

    if (entry.dirty) {
      // If this Entry has become explicitly dirty after comparing the fresh
      // values of its dirty children against this.childValues, recompute.
      return reallyRecompute(entry);
    }
  }

  assert(entry.value !== UNKNOWN_VALUE);

  return entry.value;
}

function reallyRecompute(entry) {
  assert(! entry.recomputing, "already recomputing");
  entry.recomputing = true;

  // Since this recomputation is likely to re-remember some of this
  // entry's children, we forget our children here but do not call
  // maybeReportOrphan until after the recomputation finishes.
  var originalChildren = forgetChildren(entry);

  var local = getLocal();
  var parent = local.currentParentEntry;
  local.currentParentEntry = entry;

  var threw = true;
  try {
    entry.value = entry.fn.apply(null, entry.args);
    threw = false;

  } finally {
    entry.recomputing = false;

    assert(local.currentParentEntry === entry);
    local.currentParentEntry = parent;

    if (threw || ! subscribe(entry)) {
      // Mark this Entry dirty if entry.fn threw or we failed to
      // resubscribe. This is important because, if we have a subscribe
      // function and it failed, then we're going to miss important
      // notifications about the potential dirtiness of entry.value.
      entry.setDirty();
    } else {
      // If we successfully recomputed entry.value and did not fail to
      // (re)subscribe, then this Entry is no longer explicitly dirty.
      setClean(entry);
    }
  }

  // Now that we've had a chance to re-remember any children that were
  // involved in the recomputation, we can safely report any orphan
  // children that remain.
  originalChildren.forEach(maybeReportOrphan);

  return entry.value;
}

var reusableEmptyArray = [];

// Removes all children from this entry and returns an array of the
// removed children.
function forgetChildren(entry) {
  var children = reusableEmptyArray;

  if (entry.childValues.size > 0) {
    children = [];
    entry.childValues.forEach(function (value, child) {
      forgetChild(entry, child);
      children.push(child);
    });
  }

  // After we forget all our children, this.dirtyChildren must be empty
  // and therefor must have been reset to null.
  assert(entry.dirtyChildren === null);

  return children;
}

function forgetChild(entry, child) {
  child.parents.delete(entry);
  entry.childValues.delete(child);
  removeDirtyChild(entry, child);
}

function subscribe(entry) {
  if (typeof entry.subscribe === "function") {
    try {
      unsubscribe(entry); // Prevent double subscriptions.
      entry.unsubscribe = entry.subscribe.apply(null, entry.args);
    } catch (e) {
      // If this Entry has a subscribe function and it threw an exception
      // (or an unsubscribe function it previously returned now throws),
      // return false to indicate that we were not able to subscribe (or
      // unsubscribe), and this Entry should remain dirty.
      entry.setDirty();
      return false;
    }
  }

  // Returning true indicates either that there was no entry.subscribe
  // function or that it succeeded.
  return true;
}

function unsubscribe(entry) {
  var unsub = entry.unsubscribe;
  if (typeof unsub === "function") {
    entry.unsubscribe = null;
    unsub();
  }
}

},{"./local.js":"Eo/l"}],"lCyb":[function(require,module,exports) {
"use strict";

var Cache = require("./cache.js").Cache;
var tuple = require("immutable-tuple").tuple;
var Entry = require("./entry.js").Entry;
var getLocal = require("./local.js").get;

function defaultMakeCacheKey() {
  return tuple.apply(null, arguments);
}

// Exported so that custom makeCacheKey functions can easily reuse the
// default implementation (with different arguments).
exports.defaultMakeCacheKey = defaultMakeCacheKey;

function normalizeOptions(options) {
  options = options || Object.create(null);

  if (typeof options.makeCacheKey !== "function") {
    options.makeCacheKey = defaultMakeCacheKey;
  }

  if (typeof options.max !== "number") {
    options.max = Math.pow(2, 16);
  }

  return options;
}

function wrap(fn, options) {
  options = normalizeOptions(options);

  // If this wrapped function is disposable, then its creator does not
  // care about its return value, and it should be removed from the cache
  // immediately when it no longer has any parents that depend on it.
  var disposable = !! options.disposable;

  var cache = new Cache({
    max: options.max,
    dispose: function (key, entry) {
      entry.dispose();
    }
  });

  function reportOrphan(entry) {
    if (disposable) {
      // Triggers the entry.dispose() call above.
      cache.delete(entry.key);
      return true;
    }
  }

  function optimistic() {
    if (disposable && ! getLocal().currentParentEntry) {
      // If there's no current parent computation, and this wrapped
      // function is disposable (meaning we don't care about entry.value,
      // just dependency tracking), then we can short-cut everything else
      // in this function, because entry.recompute() is going to recycle
      // the entry object without recomputing anything, anyway.
      return;
    }

    var key = options.makeCacheKey.apply(null, arguments);
    if (! key) {
      return fn.apply(null, arguments);
    }

    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];

    var entry = cache.get(key);
    if (entry) {
      entry.args = args;
    } else {
      cache.set(key, entry = Entry.acquire(fn, key, args));
      entry.subscribe = options.subscribe;
      if (disposable) {
        entry.reportOrphan = reportOrphan;
      }
    }

    var value = entry.recompute();

    // If options.disposable is truthy, the caller of wrap is telling us
    // they don't care about the result of entry.recompute(), so we should
    // avoid returning the value, so it won't be accidentally used.
    if (! disposable) {
      return value;
    }
  }

  optimistic.dirty = function () {
    var key = options.makeCacheKey.apply(null, arguments);
    if (! key) {
      return;
    }

    if (! cache.has(key)) {
      return;
    }

    cache.get(key).setDirty();
  };

  return optimistic;
}

exports.wrap = wrap;

},{"./cache.js":"wqzJ","immutable-tuple":"XipD","./entry.js":"8gn+","./local.js":"Eo/l"}],"kcsq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CacheKeyNode = exports.wrap = void 0;

var wrap = require('optimism').wrap;

exports.wrap = wrap;

var CacheKeyNode = function () {
  function CacheKeyNode() {
    this.children = null;
    this.key = null;
  }

  CacheKeyNode.prototype.lookup = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return this.lookupArray(args);
  };

  CacheKeyNode.prototype.lookupArray = function (array) {
    var node = this;
    array.forEach(function (value) {
      node = node.getOrCreate(value);
    });
    return node.key || (node.key = Object.create(null));
  };

  CacheKeyNode.prototype.getOrCreate = function (value) {
    var map = this.children || (this.children = new Map());
    return map.get(value) || map.set(value, new CacheKeyNode()).get(value);
  };

  return CacheKeyNode;
}();

exports.CacheKeyNode = CacheKeyNode;
},{"optimism":"lCyb"}],"hWwM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultNormalizedCacheFactory = defaultNormalizedCacheFactory;
exports.DepTrackingCache = void 0;

var _optimism = require("./optimism");

var hasOwn = Object.prototype.hasOwnProperty;

var DepTrackingCache = function () {
  function DepTrackingCache(data) {
    if (data === void 0) {
      data = Object.create(null);
    }

    var _this = this;

    this.data = data;
    this.depend = (0, _optimism.wrap)(function (dataId) {
      return _this.data[dataId];
    }, {
      disposable: true,
      makeCacheKey: function (dataId) {
        return dataId;
      }
    });
  }

  DepTrackingCache.prototype.toObject = function () {
    return this.data;
  };

  DepTrackingCache.prototype.get = function (dataId) {
    this.depend(dataId);
    return this.data[dataId];
  };

  DepTrackingCache.prototype.set = function (dataId, value) {
    var oldValue = this.data[dataId];

    if (value !== oldValue) {
      this.data[dataId] = value;
      this.depend.dirty(dataId);
    }
  };

  DepTrackingCache.prototype.delete = function (dataId) {
    if (hasOwn.call(this.data, dataId)) {
      delete this.data[dataId];
      this.depend.dirty(dataId);
    }
  };

  DepTrackingCache.prototype.clear = function () {
    this.replace(null);
  };

  DepTrackingCache.prototype.replace = function (newData) {
    var _this = this;

    if (newData) {
      Object.keys(newData).forEach(function (dataId) {
        _this.set(dataId, newData[dataId]);
      });
      Object.keys(this.data).forEach(function (dataId) {
        if (!hasOwn.call(newData, dataId)) {
          _this.delete(dataId);
        }
      });
    } else {
      Object.keys(this.data).forEach(function (dataId) {
        _this.delete(dataId);
      });
    }
  };

  return DepTrackingCache;
}();

exports.DepTrackingCache = DepTrackingCache;

function defaultNormalizedCacheFactory(seed) {
  return new DepTrackingCache(seed);
}
},{"./optimism":"kcsq"}],"sKFj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryKeyMaker = void 0;

var _visitor = require("graphql/language/visitor");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var CIRCULAR = Object.create(null);
var objToStr = Object.prototype.toString;

var QueryKeyMaker = function () {
  function QueryKeyMaker(cacheKeyRoot) {
    this.cacheKeyRoot = cacheKeyRoot;
    this.perQueryKeyMakers = new Map();
  }

  QueryKeyMaker.prototype.forQuery = function (document) {
    if (!this.perQueryKeyMakers.has(document)) {
      this.perQueryKeyMakers.set(document, new PerQueryKeyMaker(this.cacheKeyRoot, document));
    }

    return this.perQueryKeyMakers.get(document);
  };

  return QueryKeyMaker;
}();

exports.QueryKeyMaker = QueryKeyMaker;

var PerQueryKeyMaker = function () {
  function PerQueryKeyMaker(cacheKeyRoot, query) {
    this.cacheKeyRoot = cacheKeyRoot;
    this.query = query;
    this.cache = new Map();
    this.lookupArray = this.cacheMethod(this.lookupArray);
    this.lookupObject = this.cacheMethod(this.lookupObject);
    this.lookupFragmentSpread = this.cacheMethod(this.lookupFragmentSpread);
  }

  PerQueryKeyMaker.prototype.cacheMethod = function (method) {
    var _this = this;

    return function (value) {
      if (_this.cache.has(value)) {
        var cached = _this.cache.get(value);

        if (cached === CIRCULAR) {
          throw new Error("QueryKeyMaker cannot handle circular query structures");
        }

        return cached;
      }

      _this.cache.set(value, CIRCULAR);

      try {
        var result = method.call(_this, value);

        _this.cache.set(value, result);

        return result;
      } catch (e) {
        _this.cache.delete(value);

        throw e;
      }
    };
  };

  PerQueryKeyMaker.prototype.lookupQuery = function (document) {
    return this.lookupObject(document);
  };

  PerQueryKeyMaker.prototype.lookupSelectionSet = function (selectionSet) {
    return this.lookupObject(selectionSet);
  };

  PerQueryKeyMaker.prototype.lookupFragmentSpread = function (fragmentSpread) {
    var name = fragmentSpread.name.value;
    var fragment = null;
    this.query.definitions.some(function (definition) {
      if (definition.kind === "FragmentDefinition" && definition.name.value === name) {
        fragment = definition;
        return true;
      }
    });
    return this.lookupObject(__assign({}, fragmentSpread, {
      fragment: fragment
    }));
  };

  PerQueryKeyMaker.prototype.lookupAny = function (value) {
    if (Array.isArray(value)) {
      return this.lookupArray(value);
    }

    if (typeof value === "object" && value !== null) {
      if (value.kind === "FragmentSpread") {
        return this.lookupFragmentSpread(value);
      }

      return this.lookupObject(value);
    }

    return value;
  };

  PerQueryKeyMaker.prototype.lookupArray = function (array) {
    var elements = array.map(this.lookupAny, this);
    return this.cacheKeyRoot.lookup(objToStr.call(array), this.cacheKeyRoot.lookupArray(elements));
  };

  PerQueryKeyMaker.prototype.lookupObject = function (object) {
    var _this = this;

    var keys = safeSortedKeys(object);
    var values = keys.map(function (key) {
      return _this.lookupAny(object[key]);
    });
    return this.cacheKeyRoot.lookup(objToStr.call(object), this.cacheKeyRoot.lookupArray(keys), this.cacheKeyRoot.lookupArray(values));
  };

  return PerQueryKeyMaker;
}();

var queryKeyMap = Object.create(null);
Object.keys(_visitor.QueryDocumentKeys).forEach(function (parentKind) {
  var childKeys = queryKeyMap[parentKind] = Object.create(null);

  _visitor.QueryDocumentKeys[parentKind].forEach(function (childKey) {
    childKeys[childKey] = true;
  });

  if (parentKind === "FragmentSpread") {
    childKeys["fragment"] = true;
  }
});

function safeSortedKeys(object) {
  var keys = Object.keys(object);
  var keyCount = keys.length;
  var knownKeys = typeof object.kind === "string" && queryKeyMap[object.kind];
  var target = 0;

  for (var source = target; source < keyCount; ++source) {
    var key = keys[source];
    var value = object[key];
    var isObjectOrArray = value !== null && typeof value === "object";

    if (!isObjectOrArray || !knownKeys || knownKeys[key] === true) {
      keys[target++] = key;
    }
  }

  keys.length = target;
  return keys.sort();
}
},{"graphql/language/visitor":"pmZl"}],"ki7v":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertIdValue = assertIdValue;
exports.StoreReader = void 0;

var _apolloUtilities = require("apollo-utilities");

var _optimism = require("./optimism");

var _depTrackingCache = require("./depTrackingCache");

var _queryKeyMaker = require("./queryKeyMaker");

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var StoreReader = function () {
  function StoreReader(cacheKeyRoot) {
    if (cacheKeyRoot === void 0) {
      cacheKeyRoot = new _optimism.CacheKeyNode();
    }

    var _this = this;

    this.cacheKeyRoot = cacheKeyRoot;
    var reader = this;
    var executeStoreQuery = reader.executeStoreQuery,
        executeSelectionSet = reader.executeSelectionSet;
    reader.keyMaker = new _queryKeyMaker.QueryKeyMaker(cacheKeyRoot);
    this.executeStoreQuery = (0, _optimism.wrap)(function (options) {
      return executeStoreQuery.call(_this, options);
    }, {
      makeCacheKey: function (_a) {
        var query = _a.query,
            rootValue = _a.rootValue,
            contextValue = _a.contextValue,
            variableValues = _a.variableValues,
            fragmentMatcher = _a.fragmentMatcher;

        if (contextValue.store instanceof _depTrackingCache.DepTrackingCache) {
          return reader.cacheKeyRoot.lookup(reader.keyMaker.forQuery(query).lookupQuery(query), contextValue.store, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
        }
      }
    });
    this.executeSelectionSet = (0, _optimism.wrap)(function (options) {
      return executeSelectionSet.call(_this, options);
    }, {
      makeCacheKey: function (_a) {
        var selectionSet = _a.selectionSet,
            rootValue = _a.rootValue,
            execContext = _a.execContext;

        if (execContext.contextValue.store instanceof _depTrackingCache.DepTrackingCache) {
          return reader.cacheKeyRoot.lookup(reader.keyMaker.forQuery(execContext.query).lookupSelectionSet(selectionSet), execContext.contextValue.store, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
        }
      }
    });
  }

  StoreReader.prototype.readQueryFromStore = function (options) {
    var optsPatch = {
      returnPartialData: false
    };
    return this.diffQueryAgainstStore(__assign({}, options, optsPatch)).result;
  };

  StoreReader.prototype.diffQueryAgainstStore = function (_a) {
    var store = _a.store,
        query = _a.query,
        variables = _a.variables,
        previousResult = _a.previousResult,
        _b = _a.returnPartialData,
        returnPartialData = _b === void 0 ? true : _b,
        _c = _a.rootId,
        rootId = _c === void 0 ? 'ROOT_QUERY' : _c,
        fragmentMatcherFunction = _a.fragmentMatcherFunction,
        config = _a.config;
    var queryDefinition = (0, _apolloUtilities.getQueryDefinition)(query);
    variables = (0, _apolloUtilities.assign)({}, (0, _apolloUtilities.getDefaultValues)(queryDefinition), variables);
    var context = {
      store: store,
      dataIdFromObject: config && config.dataIdFromObject || null,
      cacheRedirects: config && config.cacheRedirects || {}
    };
    var execResult = this.executeStoreQuery({
      query: query,
      rootValue: {
        type: 'id',
        id: rootId,
        generated: true,
        typename: 'Query'
      },
      contextValue: context,
      variableValues: variables,
      fragmentMatcher: fragmentMatcherFunction
    });
    var hasMissingFields = execResult.missing && execResult.missing.length > 0;

    if (hasMissingFields && !returnPartialData) {
      execResult.missing.forEach(function (info) {
        if (info.tolerable) return;
        throw new Error("Can't find field " + info.fieldName + " on object " + JSON.stringify(info.object, null, 2) + ".");
      });
    }

    if (previousResult) {
      if ((0, _apolloUtilities.isEqual)(previousResult, execResult.result)) {
        execResult.result = previousResult;
      }
    }

    return {
      result: execResult.result,
      complete: !hasMissingFields
    };
  };

  StoreReader.prototype.executeStoreQuery = function (_a) {
    var query = _a.query,
        rootValue = _a.rootValue,
        contextValue = _a.contextValue,
        variableValues = _a.variableValues,
        _b = _a.fragmentMatcher,
        fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
    var mainDefinition = (0, _apolloUtilities.getMainDefinition)(query);
    var fragments = (0, _apolloUtilities.getFragmentDefinitions)(query);
    var fragmentMap = (0, _apolloUtilities.createFragmentMap)(fragments);
    var execContext = {
      query: query,
      fragmentMap: fragmentMap,
      contextValue: contextValue,
      variableValues: variableValues,
      fragmentMatcher: fragmentMatcher
    };
    return this.executeSelectionSet({
      selectionSet: mainDefinition.selectionSet,
      rootValue: rootValue,
      execContext: execContext
    });
  };

  StoreReader.prototype.executeSelectionSet = function (_a) {
    var _this = this;

    var selectionSet = _a.selectionSet,
        rootValue = _a.rootValue,
        execContext = _a.execContext;
    var fragmentMap = execContext.fragmentMap,
        contextValue = execContext.contextValue,
        variables = execContext.variableValues;
    var finalResult = {
      result: {}
    };
    var object = contextValue.store.get(rootValue.id);
    var typename = object && object.__typename || rootValue.id === 'ROOT_QUERY' && 'Query' || void 0;

    function handleMissing(result) {
      var _a;

      if (result.missing) {
        finalResult.missing = finalResult.missing || [];

        (_a = finalResult.missing).push.apply(_a, result.missing);
      }

      return result.result;
    }

    selectionSet.selections.forEach(function (selection) {
      var _a;

      if (!(0, _apolloUtilities.shouldInclude)(selection, variables)) {
        return;
      }

      if ((0, _apolloUtilities.isField)(selection)) {
        var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));

        if (typeof fieldResult !== 'undefined') {
          merge(finalResult.result, (_a = {}, _a[(0, _apolloUtilities.resultKeyNameFromField)(selection)] = fieldResult, _a));
        }
      } else {
        var fragment = void 0;

        if ((0, _apolloUtilities.isInlineFragment)(selection)) {
          fragment = selection;
        } else {
          fragment = fragmentMap[selection.name.value];

          if (!fragment) {
            throw new Error("No fragment named " + selection.name.value);
          }
        }

        var typeCondition = fragment.typeCondition.name.value;
        var match = execContext.fragmentMatcher(rootValue, typeCondition, contextValue);

        if (match) {
          var fragmentExecResult = _this.executeSelectionSet({
            selectionSet: fragment.selectionSet,
            rootValue: rootValue,
            execContext: execContext
          });

          if (match === 'heuristic' && fragmentExecResult.missing) {
            fragmentExecResult = __assign({}, fragmentExecResult, {
              missing: fragmentExecResult.missing.map(function (info) {
                return __assign({}, info, {
                  tolerable: true
                });
              })
            });
          }

          merge(finalResult.result, handleMissing(fragmentExecResult));
        }
      }
    });
    return finalResult;
  };

  StoreReader.prototype.executeField = function (object, typename, field, execContext) {
    var variables = execContext.variableValues,
        contextValue = execContext.contextValue;
    var fieldName = field.name.value;
    var args = (0, _apolloUtilities.argumentsObjectFromField)(field, variables);
    var info = {
      resultKey: (0, _apolloUtilities.resultKeyNameFromField)(field),
      directives: (0, _apolloUtilities.getDirectiveInfoFromField)(field, variables)
    };
    var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);

    if (!field.selectionSet) {
      return readStoreResult;
    }

    if (readStoreResult.result == null) {
      return readStoreResult;
    }

    function handleMissing(res) {
      var missing = null;

      if (readStoreResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, readStoreResult.missing);
      }

      if (res.missing) {
        missing = missing || [];
        missing.push.apply(missing, res.missing);
      }

      return {
        result: res.result,
        missing: missing
      };
    }

    if (Array.isArray(readStoreResult.result)) {
      return handleMissing(this.executeSubSelectedArray(field, readStoreResult.result, execContext));
    }

    return handleMissing(this.executeSelectionSet({
      selectionSet: field.selectionSet,
      rootValue: readStoreResult.result,
      execContext: execContext
    }));
  };

  StoreReader.prototype.executeSubSelectedArray = function (field, result, execContext) {
    var _this = this;

    var missing = null;

    function handleMissing(childResult) {
      if (childResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, childResult.missing);
      }

      return childResult.result;
    }

    result = result.map(function (item) {
      if (item === null) {
        return null;
      }

      if (Array.isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray(field, item, execContext));
      }

      return handleMissing(_this.executeSelectionSet({
        selectionSet: field.selectionSet,
        rootValue: item,
        execContext: execContext
      }));
    });
    return {
      result: result,
      missing: missing
    };
  };

  return StoreReader;
}();

exports.StoreReader = StoreReader;

function defaultFragmentMatcher() {
  return true;
}

function assertIdValue(idValue) {
  if (!(0, _apolloUtilities.isIdValue)(idValue)) {
    throw new Error("Encountered a sub-selection on the query, but the store doesn't have an object reference. This should never happen during normal use unless you have custom code that is directly manipulating the store; please file an issue.");
  }
}

function readStoreResolver(object, typename, fieldName, args, context, _a) {
  var resultKey = _a.resultKey,
      directives = _a.directives;
  var storeKeyName = fieldName;

  if (args || directives) {
    storeKeyName = (0, _apolloUtilities.getStoreKeyName)(storeKeyName, args, directives);
  }

  var fieldValue = void 0;

  if (object) {
    fieldValue = object[storeKeyName];

    if (typeof fieldValue === 'undefined' && context.cacheRedirects && typeof typename === 'string') {
      var type = context.cacheRedirects[typename];

      if (type) {
        var resolver = type[fieldName];

        if (resolver) {
          fieldValue = resolver(object, args, {
            getCacheKey: function (storeObj) {
              return (0, _apolloUtilities.toIdValue)({
                id: context.dataIdFromObject(storeObj),
                typename: storeObj.__typename
              });
            }
          });
        }
      }
    }
  }

  if (typeof fieldValue === 'undefined') {
    return {
      result: fieldValue,
      missing: [{
        object: object,
        fieldName: storeKeyName,
        tolerable: false
      }]
    };
  }

  if ((0, _apolloUtilities.isJsonValue)(fieldValue)) {
    fieldValue = fieldValue.json;
  }

  return {
    result: fieldValue
  };
}

var hasOwn = Object.prototype.hasOwnProperty;

function merge(target, source) {
  if (source !== null && typeof source === 'object' && source !== target) {
    if (Object.isExtensible && !Object.isExtensible(target)) {
      target = __assign({}, target);
    }

    Object.keys(source).forEach(function (sourceKey) {
      var sourceVal = source[sourceKey];

      if (!hasOwn.call(target, sourceKey)) {
        target[sourceKey] = sourceVal;
      } else {
        target[sourceKey] = merge(target[sourceKey], sourceVal);
      }
    });
  }

  return target;
}
},{"apollo-utilities":"cD8x","./optimism":"kcsq","./depTrackingCache":"hWwM","./queryKeyMaker":"sKFj"}],"WhNr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultNormalizedCacheFactory = defaultNormalizedCacheFactory;
exports.ObjectCache = void 0;

var ObjectCache = function () {
  function ObjectCache(data) {
    if (data === void 0) {
      data = Object.create(null);
    }

    this.data = data;
  }

  ObjectCache.prototype.toObject = function () {
    return this.data;
  };

  ObjectCache.prototype.get = function (dataId) {
    return this.data[dataId];
  };

  ObjectCache.prototype.set = function (dataId, value) {
    this.data[dataId] = value;
  };

  ObjectCache.prototype.delete = function (dataId) {
    this.data[dataId] = undefined;
  };

  ObjectCache.prototype.clear = function () {
    this.data = Object.create(null);
  };

  ObjectCache.prototype.replace = function (newData) {
    this.data = newData || Object.create(null);
  };

  return ObjectCache;
}();

exports.ObjectCache = ObjectCache;

function defaultNormalizedCacheFactory(seed) {
  return new ObjectCache(seed);
}
},{}],"kob5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enhanceErrorWithDocument = enhanceErrorWithDocument;
exports.StoreWriter = exports.WriteError = void 0;

var _printer = require("graphql/language/printer");

var _apolloUtilities = require("apollo-utilities");

var _objectCache = require("./objectCache");

var _depTrackingCache = require("./depTrackingCache");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var WriteError = function (_super) {
  __extends(WriteError, _super);

  function WriteError() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'WriteError';
    return _this;
  }

  return WriteError;
}(Error);

exports.WriteError = WriteError;

function enhanceErrorWithDocument(error, document) {
  var enhancedError = new WriteError("Error writing result to store for query:\n " + (0, _printer.print)(document));
  enhancedError.message += '\n' + error.message;
  enhancedError.stack = error.stack;
  return enhancedError;
}

var StoreWriter = function () {
  function StoreWriter() {}

  StoreWriter.prototype.writeQueryToStore = function (_a) {
    var query = _a.query,
        result = _a.result,
        _b = _a.store,
        store = _b === void 0 ? (0, _depTrackingCache.defaultNormalizedCacheFactory)() : _b,
        variables = _a.variables,
        dataIdFromObject = _a.dataIdFromObject,
        fragmentMatcherFunction = _a.fragmentMatcherFunction;
    return this.writeResultToStore({
      dataId: 'ROOT_QUERY',
      result: result,
      document: query,
      store: store,
      variables: variables,
      dataIdFromObject: dataIdFromObject,
      fragmentMatcherFunction: fragmentMatcherFunction
    });
  };

  StoreWriter.prototype.writeResultToStore = function (_a) {
    var dataId = _a.dataId,
        result = _a.result,
        document = _a.document,
        _b = _a.store,
        store = _b === void 0 ? (0, _depTrackingCache.defaultNormalizedCacheFactory)() : _b,
        variables = _a.variables,
        dataIdFromObject = _a.dataIdFromObject,
        fragmentMatcherFunction = _a.fragmentMatcherFunction;
    var operationDefinition = (0, _apolloUtilities.getOperationDefinition)(document);

    try {
      return this.writeSelectionSetToStore({
        result: result,
        dataId: dataId,
        selectionSet: operationDefinition.selectionSet,
        context: {
          store: store,
          processedData: {},
          variables: (0, _apolloUtilities.assign)({}, (0, _apolloUtilities.getDefaultValues)(operationDefinition), variables),
          dataIdFromObject: dataIdFromObject,
          fragmentMap: (0, _apolloUtilities.createFragmentMap)((0, _apolloUtilities.getFragmentDefinitions)(document)),
          fragmentMatcherFunction: fragmentMatcherFunction
        }
      });
    } catch (e) {
      throw enhanceErrorWithDocument(e, document);
    }
  };

  StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
    var _this = this;

    var result = _a.result,
        dataId = _a.dataId,
        selectionSet = _a.selectionSet,
        context = _a.context;
    var variables = context.variables,
        store = context.store,
        fragmentMap = context.fragmentMap;
    selectionSet.selections.forEach(function (selection) {
      if (!(0, _apolloUtilities.shouldInclude)(selection, variables)) {
        return;
      }

      if ((0, _apolloUtilities.isField)(selection)) {
        var resultFieldKey = (0, _apolloUtilities.resultKeyNameFromField)(selection);
        var value = result[resultFieldKey];

        if (typeof value !== 'undefined') {
          _this.writeFieldToStore({
            dataId: dataId,
            value: value,
            field: selection,
            context: context
          });
        } else {
          var isDefered = selection.directives && selection.directives.length && selection.directives.some(function (directive) {
            return directive.name && directive.name.value === 'defer';
          });

          if (!isDefered && context.fragmentMatcherFunction) {
            if (!(0, _apolloUtilities.isProduction)()) {
              console.warn("Missing field " + resultFieldKey + " in " + JSON.stringify(result, null, 2).substring(0, 100));
            }
          }
        }
      } else {
        var fragment = void 0;

        if ((0, _apolloUtilities.isInlineFragment)(selection)) {
          fragment = selection;
        } else {
          fragment = (fragmentMap || {})[selection.name.value];

          if (!fragment) {
            throw new Error("No fragment named " + selection.name.value + ".");
          }
        }

        var matches = true;

        if (context.fragmentMatcherFunction && fragment.typeCondition) {
          var idValue = (0, _apolloUtilities.toIdValue)({
            id: 'self',
            typename: undefined
          });
          var fakeContext = {
            store: new _objectCache.ObjectCache({
              self: result
            }),
            cacheRedirects: {}
          };
          var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);

          if (!(0, _apolloUtilities.isProduction)() && match === 'heuristic') {
            console.error('WARNING: heuristic fragment matching going on!');
          }

          matches = !!match;
        }

        if (matches) {
          _this.writeSelectionSetToStore({
            result: result,
            selectionSet: fragment.selectionSet,
            dataId: dataId,
            context: context
          });
        }
      }
    });
    return store;
  };

  StoreWriter.prototype.writeFieldToStore = function (_a) {
    var field = _a.field,
        value = _a.value,
        dataId = _a.dataId,
        context = _a.context;

    var _b;

    var variables = context.variables,
        dataIdFromObject = context.dataIdFromObject,
        store = context.store;
    var storeValue;
    var storeObject;
    var storeFieldName = (0, _apolloUtilities.storeKeyNameFromField)(field, variables);

    if (!field.selectionSet || value === null) {
      storeValue = value != null && typeof value === 'object' ? {
        type: 'json',
        json: value
      } : value;
    } else if (Array.isArray(value)) {
      var generatedId = dataId + "." + storeFieldName;
      storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
    } else {
      var valueDataId = dataId + "." + storeFieldName;
      var generated = true;

      if (!isGeneratedId(valueDataId)) {
        valueDataId = '$' + valueDataId;
      }

      if (dataIdFromObject) {
        var semanticId = dataIdFromObject(value);

        if (semanticId && isGeneratedId(semanticId)) {
          throw new Error('IDs returned by dataIdFromObject cannot begin with the "$" character.');
        }

        if (semanticId || typeof semanticId === 'number' && semanticId === 0) {
          valueDataId = semanticId;
          generated = false;
        }
      }

      if (!isDataProcessed(valueDataId, field, context.processedData)) {
        this.writeSelectionSetToStore({
          dataId: valueDataId,
          result: value,
          selectionSet: field.selectionSet,
          context: context
        });
      }

      var typename = value.__typename;
      storeValue = (0, _apolloUtilities.toIdValue)({
        id: valueDataId,
        typename: typename
      }, generated);
      storeObject = store.get(dataId);
      var escapedId = storeObject && storeObject[storeFieldName];

      if (escapedId !== storeValue && (0, _apolloUtilities.isIdValue)(escapedId)) {
        var hadTypename = escapedId.typename !== undefined;
        var hasTypename = typename !== undefined;
        var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;

        if (generated && !escapedId.generated && !typenameChanged) {
          throw new Error("Store error: the application attempted to write an object with no provided id" + (" but the store already contains an id of " + escapedId.id + " for this object. The selectionSet") + " that was trying to be written is:\n" + (0, _printer.print)(field));
        }

        if (hadTypename && !hasTypename) {
          throw new Error("Store error: the application attempted to write an object with no provided typename" + (" but the store already contains an object with typename of " + escapedId.typename + " for the object of id " + escapedId.id + ". The selectionSet") + " that was trying to be written is:\n" + (0, _printer.print)(field));
        }

        if (escapedId.generated) {
          if (typenameChanged) {
            if (!generated) {
              store.delete(escapedId.id);
            }
          } else {
            mergeWithGenerated(escapedId.id, storeValue.id, store);
          }
        }
      }
    }

    storeObject = store.get(dataId);

    if (!storeObject || !(0, _apolloUtilities.isEqual)(storeValue, storeObject[storeFieldName])) {
      store.set(dataId, __assign({}, storeObject, (_b = {}, _b[storeFieldName] = storeValue, _b)));
    }
  };

  StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
    var _this = this;

    return value.map(function (item, index) {
      if (item === null) {
        return null;
      }

      var itemDataId = generatedId + "." + index;

      if (Array.isArray(item)) {
        return _this.processArrayValue(item, itemDataId, selectionSet, context);
      }

      var generated = true;

      if (context.dataIdFromObject) {
        var semanticId = context.dataIdFromObject(item);

        if (semanticId) {
          itemDataId = semanticId;
          generated = false;
        }
      }

      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
        _this.writeSelectionSetToStore({
          dataId: itemDataId,
          result: item,
          selectionSet: selectionSet,
          context: context
        });
      }

      return (0, _apolloUtilities.toIdValue)({
        id: itemDataId,
        typename: item.__typename
      }, generated);
    });
  };

  return StoreWriter;
}();

exports.StoreWriter = StoreWriter;

function isGeneratedId(id) {
  return id[0] === '$';
}

function mergeWithGenerated(generatedKey, realKey, cache) {
  if (generatedKey === realKey) {
    return false;
  }

  var generated = cache.get(generatedKey);
  var real = cache.get(realKey);
  var madeChanges = false;
  Object.keys(generated).forEach(function (key) {
    var value = generated[key];
    var realValue = real[key];

    if ((0, _apolloUtilities.isIdValue)(value) && isGeneratedId(value.id) && (0, _apolloUtilities.isIdValue)(realValue) && !(0, _apolloUtilities.isEqual)(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {
      madeChanges = true;
    }
  });
  cache.delete(generatedKey);

  var newRealValue = __assign({}, generated, real);

  if ((0, _apolloUtilities.isEqual)(newRealValue, real)) {
    return madeChanges;
  }

  cache.set(realKey, newRealValue);
  return true;
}

function isDataProcessed(dataId, field, processedData) {
  if (!processedData) {
    return false;
  }

  if (processedData[dataId]) {
    if (processedData[dataId].indexOf(field) >= 0) {
      return true;
    } else {
      processedData[dataId].push(field);
    }
  } else {
    processedData[dataId] = [field];
  }

  return false;
}
},{"graphql/language/printer":"h5rv","apollo-utilities":"cD8x","./objectCache":"WhNr","./depTrackingCache":"hWwM"}],"F6QY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.record = record;
exports.RecordingCache = void 0;

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var RecordingCache = function () {
  function RecordingCache(data) {
    if (data === void 0) {
      data = {};
    }

    this.data = data;
    this.recordedData = {};
  }

  RecordingCache.prototype.record = function (transaction) {
    transaction(this);
    var recordedData = this.recordedData;
    this.recordedData = {};
    return recordedData;
  };

  RecordingCache.prototype.toObject = function () {
    return __assign({}, this.data, this.recordedData);
  };

  RecordingCache.prototype.get = function (dataId) {
    if (this.recordedData.hasOwnProperty(dataId)) {
      return this.recordedData[dataId];
    }

    return this.data[dataId];
  };

  RecordingCache.prototype.set = function (dataId, value) {
    if (this.get(dataId) !== value) {
      this.recordedData[dataId] = value;
    }
  };

  RecordingCache.prototype.delete = function (dataId) {
    this.recordedData[dataId] = undefined;
  };

  RecordingCache.prototype.clear = function () {
    var _this = this;

    Object.keys(this.data).forEach(function (dataId) {
      return _this.delete(dataId);
    });
    this.recordedData = {};
  };

  RecordingCache.prototype.replace = function (newData) {
    this.clear();
    this.recordedData = __assign({}, newData);
  };

  return RecordingCache;
}();

exports.RecordingCache = RecordingCache;

function record(startingState, transaction) {
  var recordingCache = new RecordingCache(startingState);
  return recordingCache.record(transaction);
}
},{}],"ZhKB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultDataIdFromObject = defaultDataIdFromObject;
exports.InMemoryCache = void 0;

require("./fixPolyfills");

var _apolloCache = require("apollo-cache");

var _apolloUtilities = require("apollo-utilities");

var _fragmentMatcher = require("./fragmentMatcher");

var _readFromStore = require("./readFromStore");

var _writeToStore = require("./writeToStore");

var _depTrackingCache = require("./depTrackingCache");

var _optimism = require("./optimism");

var _recordingCache = require("./recordingCache");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var defaultConfig = {
  fragmentMatcher: new _fragmentMatcher.HeuristicFragmentMatcher(),
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true
};

function defaultDataIdFromObject(result) {
  if (result.__typename) {
    if (result.id !== undefined) {
      return result.__typename + ":" + result.id;
    }

    if (result._id !== undefined) {
      return result.__typename + ":" + result._id;
    }
  }

  return null;
}

var InMemoryCache = function (_super) {
  __extends(InMemoryCache, _super);

  function InMemoryCache(config) {
    if (config === void 0) {
      config = {};
    }

    var _this = _super.call(this) || this;

    _this.optimistic = [];
    _this.watches = new Set();
    _this.typenameDocumentCache = new Map();
    _this.cacheKeyRoot = new _optimism.CacheKeyNode();
    _this.silenceBroadcast = false;
    _this.config = __assign({}, defaultConfig, config);

    if (_this.config.customResolvers) {
      console.warn('customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.');
      _this.config.cacheRedirects = _this.config.customResolvers;
    }

    if (_this.config.cacheResolvers) {
      console.warn('cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.');
      _this.config.cacheRedirects = _this.config.cacheResolvers;
    }

    _this.addTypename = _this.config.addTypename;
    _this.data = (0, _depTrackingCache.defaultNormalizedCacheFactory)();
    _this.storeReader = new _readFromStore.StoreReader(_this.cacheKeyRoot);
    _this.storeWriter = new _writeToStore.StoreWriter();
    var cache = _this;
    var maybeBroadcastWatch = cache.maybeBroadcastWatch;
    _this.maybeBroadcastWatch = (0, _optimism.wrap)(function (c) {
      return maybeBroadcastWatch.call(_this, c);
    }, {
      makeCacheKey: function (c) {
        if (c.optimistic && cache.optimistic.length > 0) {
          return;
        }

        if (c.previousResult) {
          return;
        }

        if (cache.data instanceof _depTrackingCache.DepTrackingCache) {
          return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
        }
      }
    });
    return _this;
  }

  InMemoryCache.prototype.restore = function (data) {
    if (data) this.data.replace(data);
    return this;
  };

  InMemoryCache.prototype.extract = function (optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    if (optimistic && this.optimistic.length > 0) {
      var patches = this.optimistic.map(function (opt) {
        return opt.data;
      });
      return Object.assign.apply(Object, [{}, this.data.toObject()].concat(patches));
    }

    return this.data.toObject();
  };

  InMemoryCache.prototype.read = function (query) {
    if (query.rootId && this.data.get(query.rootId) === undefined) {
      return null;
    }

    var store = query.optimistic && this.optimistic.length ? (0, _depTrackingCache.defaultNormalizedCacheFactory)(this.extract(true)) : this.data;
    return this.storeReader.readQueryFromStore({
      store: store,
      query: this.transformDocument(query.query),
      variables: query.variables,
      rootId: query.rootId,
      fragmentMatcherFunction: this.config.fragmentMatcher.match,
      previousResult: query.previousResult,
      config: this.config
    });
  };

  InMemoryCache.prototype.write = function (write) {
    this.storeWriter.writeResultToStore({
      dataId: write.dataId,
      result: write.result,
      variables: write.variables,
      document: this.transformDocument(write.query),
      store: this.data,
      dataIdFromObject: this.config.dataIdFromObject,
      fragmentMatcherFunction: this.config.fragmentMatcher.match
    });
    this.broadcastWatches();
  };

  InMemoryCache.prototype.diff = function (query) {
    var store = query.optimistic && this.optimistic.length ? (0, _depTrackingCache.defaultNormalizedCacheFactory)(this.extract(true)) : this.data;
    return this.storeReader.diffQueryAgainstStore({
      store: store,
      query: this.transformDocument(query.query),
      variables: query.variables,
      returnPartialData: query.returnPartialData,
      previousResult: query.previousResult,
      fragmentMatcherFunction: this.config.fragmentMatcher.match,
      config: this.config
    });
  };

  InMemoryCache.prototype.watch = function (watch) {
    var _this = this;

    this.watches.add(watch);
    return function () {
      _this.watches.delete(watch);
    };
  };

  InMemoryCache.prototype.evict = function (query) {
    throw new Error("eviction is not implemented on InMemory Cache");
  };

  InMemoryCache.prototype.reset = function () {
    this.data.clear();
    this.broadcastWatches();
    return Promise.resolve();
  };

  InMemoryCache.prototype.removeOptimistic = function (id) {
    var _this = this;

    var toPerform = this.optimistic.filter(function (item) {
      return item.id !== id;
    });
    this.optimistic = [];
    toPerform.forEach(function (change) {
      _this.recordOptimisticTransaction(change.transaction, change.id);
    });
    this.broadcastWatches();
  };

  InMemoryCache.prototype.performTransaction = function (transaction) {
    var alreadySilenced = this.silenceBroadcast;
    this.silenceBroadcast = true;
    transaction(this);

    if (!alreadySilenced) {
      this.silenceBroadcast = false;
    }

    this.broadcastWatches();
  };

  InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
    var _this = this;

    this.silenceBroadcast = true;
    var patch = (0, _recordingCache.record)(this.extract(true), function (recordingCache) {
      var dataCache = _this.data;
      _this.data = recordingCache;

      _this.performTransaction(transaction);

      _this.data = dataCache;
    });
    this.optimistic.push({
      id: id,
      transaction: transaction,
      data: patch
    });
    this.silenceBroadcast = false;
    this.broadcastWatches();
  };

  InMemoryCache.prototype.transformDocument = function (document) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document);

      if (!result) {
        this.typenameDocumentCache.set(document, result = (0, _apolloUtilities.addTypenameToDocument)(document));
      }

      return result;
    }

    return document;
  };

  InMemoryCache.prototype.readQuery = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: options.query,
      variables: options.variables,
      optimistic: optimistic
    });
  };

  InMemoryCache.prototype.readFragment = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: this.transformDocument((0, _apolloUtilities.getFragmentQueryDocument)(options.fragment, options.fragmentName)),
      variables: options.variables,
      rootId: options.id,
      optimistic: optimistic
    });
  };

  InMemoryCache.prototype.writeQuery = function (options) {
    this.write({
      dataId: 'ROOT_QUERY',
      result: options.data,
      query: this.transformDocument(options.query),
      variables: options.variables
    });
  };

  InMemoryCache.prototype.writeFragment = function (options) {
    this.write({
      dataId: options.id,
      result: options.data,
      query: this.transformDocument((0, _apolloUtilities.getFragmentQueryDocument)(options.fragment, options.fragmentName)),
      variables: options.variables
    });
  };

  InMemoryCache.prototype.broadcastWatches = function () {
    var _this = this;

    if (!this.silenceBroadcast) {
      var optimistic_1 = this.optimistic.length > 0;
      this.watches.forEach(function (c) {
        _this.maybeBroadcastWatch(c);

        if (optimistic_1) {
          _this.maybeBroadcastWatch.dirty(c);
        }
      });
    }
  };

  InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
    var previousResult = c.previousResult && c.previousResult();
    var newData = this.diff({
      query: c.query,
      variables: c.variables,
      previousResult: previousResult,
      optimistic: c.optimistic
    });

    if (previousResult && previousResult === newData.result) {
      return;
    }

    c.callback(newData);
  };

  return InMemoryCache;
}(_apolloCache.ApolloCache);

exports.InMemoryCache = InMemoryCache;
},{"./fixPolyfills":"dTX1","apollo-cache":"IZbR","apollo-utilities":"cD8x","./fragmentMatcher":"Z2JP","./readFromStore":"ki7v","./writeToStore":"kob5","./depTrackingCache":"hWwM","./optimism":"kcsq","./recordingCache":"F6QY"}],"XyQB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  InMemoryCache: true,
  defaultDataIdFromObject: true
};
Object.defineProperty(exports, "InMemoryCache", {
  enumerable: true,
  get: function () {
    return _inMemoryCache.InMemoryCache;
  }
});
Object.defineProperty(exports, "defaultDataIdFromObject", {
  enumerable: true,
  get: function () {
    return _inMemoryCache.defaultDataIdFromObject;
  }
});

var _inMemoryCache = require("./inMemoryCache");

var _readFromStore = require("./readFromStore");

Object.keys(_readFromStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _readFromStore[key];
    }
  });
});

var _writeToStore = require("./writeToStore");

Object.keys(_writeToStore).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _writeToStore[key];
    }
  });
});

var _fragmentMatcher = require("./fragmentMatcher");

Object.keys(_fragmentMatcher).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _fragmentMatcher[key];
    }
  });
});

var _objectCache = require("./objectCache");

Object.keys(_objectCache).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _objectCache[key];
    }
  });
});

var _recordingCache = require("./recordingCache");

Object.keys(_recordingCache).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _recordingCache[key];
    }
  });
});
},{"./inMemoryCache":"ZhKB","./readFromStore":"ki7v","./writeToStore":"kob5","./fragmentMatcher":"Z2JP","./objectCache":"WhNr","./recordingCache":"F6QY"}],"n+qt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorLink = exports.onError = void 0;

var _apolloLink = require("apollo-link");

/* tslint:disable */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var onError = function (errorHandler) {
  return new _apolloLink.ApolloLink(function (operation, forward) {
    return new _apolloLink.Observable(function (observer) {
      var sub;
      var retriedSub;
      var retriedResult;

      try {
        sub = forward(operation).subscribe({
          next: function (result) {
            if (result.errors) {
              retriedResult = errorHandler({
                graphQLErrors: result.errors,
                response: result,
                operation: operation,
                forward: forward
              });

              if (retriedResult) {
                retriedSub = retriedResult.subscribe({
                  next: observer.next.bind(observer),
                  error: observer.error.bind(observer),
                  complete: observer.complete.bind(observer)
                });
                return;
              }
            }

            observer.next(result);
          },
          error: function (networkError) {
            retriedResult = errorHandler({
              operation: operation,
              networkError: networkError,
              //Network errors can return GraphQL errors on for example a 403
              graphQLErrors: networkError.result && networkError.result.errors,
              forward: forward
            });

            if (retriedResult) {
              retriedSub = retriedResult.subscribe({
                next: observer.next.bind(observer),
                error: observer.error.bind(observer),
                complete: observer.complete.bind(observer)
              });
              return;
            }

            observer.error(networkError);
          },
          complete: function () {
            // disable the previous sub from calling complete on observable
            // if retry is in flight.
            if (!retriedResult) {
              observer.complete.bind(observer)();
            }
          }
        });
      } catch (e) {
        errorHandler({
          networkError: e,
          operation: operation,
          forward: forward
        });
        observer.error(e);
      }

      return function () {
        if (sub) sub.unsubscribe();
        if (retriedSub) sub.unsubscribe();
      };
    });
  });
};

exports.onError = onError;

var ErrorLink =
/** @class */
function (_super) {
  __extends(ErrorLink, _super);

  function ErrorLink(errorHandler) {
    var _this = _super.call(this) || this;

    _this.link = onError(errorHandler);
    return _this;
  }

  ErrorLink.prototype.request = function (operation, forward) {
    return this.link.request(operation, forward);
  };

  return ErrorLink;
}(_apolloLink.ApolloLink);

exports.ErrorLink = ErrorLink;
},{"apollo-link":"uD5J"}],"iHcO":[function(require,module,exports) {
var define;
!function (t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports["v-calendar"] = e() : t["v-calendar"] = e();
}("undefined" != typeof self ? self : this, function () {
  return function (t) {
    var e = {};

    function n(r) {
      if (e[r]) return e[r].exports;
      var i = e[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
    }

    return n.m = t, n.c = e, n.d = function (t, e, r) {
      n.o(t, e) || Object.defineProperty(t, e, {
        configurable: !1,
        enumerable: !0,
        get: r
      });
    }, n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t.default;
      } : function () {
        return t;
      };
      return n.d(e, "a", e), e;
    }, n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, n.p = "/", n(n.s = 59);
  }([function (t, e, n) {
    "use strict";

    e.__esModule = !0;
    var r,
        i = n(31),
        a = (r = i, r && r.__esModule ? r : {
      default: r
    });

    e.default = a.default || function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];

        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
      }

      return t;
    };
  }, function (t, e) {
    t.exports = function (t, e, n, r, i, a) {
      var o,
          s = t = t || {},
          u = typeof t.default;
      "object" !== u && "function" !== u || (o = t, s = t.default);
      var c = "function" == typeof s ? s.options : s;
      e && (c.render = e.render, c.staticRenderFns = e.staticRenderFns, c._compiled = !0), n && (c.functional = !0), i && (c._scopeId = i);
      var l;

      if (a ? (l = function (t) {
        (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), r && r.call(this, t), t && t._registeredComponents && t._registeredComponents.add(a);
      }, c._ssrRegister = l) : r && (l = r), l) {
        var d = c.functional,
            f = d ? c.render : c.beforeCreate;
        d ? (c._injectStyles = l, c.render = function (t, e) {
          return l.call(e), f(t, e);
        }) : c.beforeCreate = f ? [].concat(f, l) : [l];
      }

      return {
        esModule: o,
        exports: s,
        options: c
      };
    };
  }, function (t, e, n) {
    "use strict";

    n.d(e, "x", function () {
      return d;
    }), n.d(e, "n", function () {
      return f;
    }), n.d(e, "c", function () {
      return h;
    }), n.d(e, "j", function () {
      return p;
    }), n.d(e, "q", function () {
      return v;
    }), n.d(e, "i", function () {
      return y;
    }), n.d(e, "d", function () {
      return m;
    }), n.d(e, "o", function () {
      return b;
    }), n.d(e, "k", function () {
      return g;
    }), n.d(e, "w", function () {
      return w;
    }), n.d(e, "u", function () {
      return _;
    }), n.d(e, "t", function () {
      return O;
    }), n.d(e, "v", function () {
      return C;
    }), n.d(e, "h", function () {
      return M;
    }), n.d(e, "p", function () {
      return x;
    }), n.d(e, "l", function () {
      return k;
    }), n.d(e, "m", function () {
      return S;
    }), n.d(e, "f", function () {
      return Y;
    }), n.d(e, "e", function () {
      return j;
    }), n.d(e, "g", function () {
      return P;
    }), n.d(e, "a", function () {
      return T;
    }), n.d(e, "b", function () {
      return I;
    }), n.d(e, "s", function () {
      return A;
    }), n.d(e, "r", function () {
      return L;
    });

    var r = n(0),
        i = n.n(r),
        a = n(3),
        o = n(4),
        s = n(8),
        u = {},
        c = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        l = new Date(),
        d = {
      year: l.getFullYear(),
      month: l.getMonth() + 1,
      day: l.getDate()
    },
        f = function (t) {
      var e,
          n = (e = t, Object(o.b)(e) ? new Date(e.getTime()) : Object(o.d)(e) ? new Date(e) : Object(o.f)(e) ? Object(s.b)(e, ["L", "YYYY-MM-DD", "YYYY/MM/DD"]) : Object(o.e)(e) ? new Date(e.year || l.getFullYear(), e.month || l.getMonth(), e.day || l.getDate()) : new Date(e));
      return n && {
        month: n.getMonth() + 1,
        year: n.getFullYear()
      };
    },
        h = function (t, e) {
      return Object(o.c)(t) ? t(e) : t;
    },
        p = function () {
      for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2e3, e = [], n = 0; n < 12; n++) e.push(new Date(t, n, 15));

      return e;
    },
        v = function (t) {
      for (var e = t.firstDayOfWeek, n = void 0 === e ? 1 : e, r = t.year, i = void 0 === r ? 2e3 : r, a = t.utc, o = void 0 !== a && a, s = [], u = 1, c = 0; c < 7; u++) {
        var l = o ? new Date(Date.UTC(i, 0, u)) : new Date(i, 0, u);
        ((o ? l.getUTCDay() : l.getDay()) === n - 1 || c > 0) && (s.push(l), c++);
      }

      return s;
    },
        y = function (t, e) {
      var n = t + "." + e,
          r = u[n];

      if (!r) {
        var i = a.a.firstDayOfWeek,
            o = e % 4 == 0 && e % 100 != 0 || e % 400 == 0,
            s = new Date(e, t - 1, 1).getDay() + 1,
            l = 2 === t && o ? 29 : c[t - 1];
        r = {
          firstDayOfWeek: i,
          inLeapYear: o,
          firstWeekday: s,
          days: l,
          weeks: Math.ceil((l + Math.abs(s - i)) / 7),
          month: t,
          year: e
        }, u[n] = r;
      }

      return r;
    },
        m = function (t) {
      if (t && t.getTime) return y(t.getMonth() + 1, t.getFullYear());
    },
        b = function (t, e) {
      return 1 === t ? y(12, e - 1) : y(t - 1, e);
    },
        g = function (t, e) {
      return 12 === t ? y(1, e + 1) : y(t + 1, e);
    };

    function D(t, e) {
      return t && e ? t.year === e.year ? t.month === e.month ? 0 : t.month < e.month ? -1 : 1 : t.year < e.year ? -1 : 1 : 0;
    }

    var w = function (t, e) {
      return 0 === D(t, e);
    },
        _ = function (t, e) {
      return -1 === D(t, e);
    },
        O = function (t, e) {
      return 1 === D(t, e);
    },
        C = function (t, e, n) {
      return !!t && !_(t, e) && !O(t, n);
    },
        M = function () {
      for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];

      return e.reduce(function (t, e) {
        return t ? e ? 1 === D(t, e) ? t : e : t : e;
      });
    },
        x = function (t) {
      if (t) {
        var e = b(t.month, t.year);
        return {
          month: e.month,
          year: e.year
        };
      }
    },
        k = function (t) {
      if (t) {
        var e = g(t.month, t.year);
        return {
          month: e.month,
          year: e.year
        };
      }
    },
        S = function (t, e, n) {
      if (t && !(e && -1 === D(t, e) || n && 1 === D(t, n))) return t;
    },
        Y = function () {
      for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];

      return e.find(function (t) {
        return !!t;
      });
    },
        j = function (t, e) {
      return t && t.length ? t[0] : e;
    },
        P = function (t, e) {
      return t && t.length ? t[t.length - 1] : e;
    },
        T = function (t) {
      return Object(o.a)(t) && t.length;
    },
        I = function (t, e) {
      return !!function t(e, n) {
        return e ? n(e) ? e : t(e.parentElement, n) : null;
      }(t, function (t) {
        return t === e;
      });
    },
        A = function (t) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "key";
      return t && t.length ? t.reduce(function (t, n) {
        return t[n[e]] = n, t;
      }, {}) : {};
    },
        L = function (t, e, n) {
      var r = [];
      return n.forEach(function (n) {
        var a = n.name || n.toString(),
            s = n.mixin,
            u = n.validate;

        if (Object.prototype.hasOwnProperty.call(t, a)) {
          var c = u ? u(t[a]) : t[a];
          e[a] = s && Object(o.e)(c) ? i()({}, s, c) : c, r.push(a);
        }
      }), {
        target: e,
        assigned: r.length ? r : null
      };
    };
  }, function (t, e, n) {
    "use strict";

    n.d(e, "c", function () {
      return l;
    }), n.d(e, "b", function () {
      return d;
    });
    var r = n(31),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(47),
        u = n(4),
        c = {
      componentPrefix: "v",
      firstDayOfWeek: 1,
      navVisibility: "focus",
      titlePosition: "center",
      titleTransition: "slide-h",
      weeksTransition: "slide-h",
      paneWidth: 256,
      showLinkedButtons: !1,
      formats: {
        title: "MMMM YYYY",
        weekdays: "W",
        navMonths: "MMM",
        input: ["L", "YYYY-MM-DD", "YYYY/MM/DD"],
        dayPopover: "WWW, MMM D, YYYY",
        data: ["L", "YYYY-MM-DD", "YYYY/MM/DD"]
      },
      datePickerInputProps: function (t) {
        var e = t.dragValue,
            n = t.mode,
            r = t.format;
        return o()({}, "single" === n && {
          style: {
            minWidth: "100px"
          },
          placeholder: r
        }, "multiple" === n && {
          style: {
            minWidth: "200px"
          },
          placeholder: r + ", ..."
        }, "range" === n && {
          style: o()({
            minWidth: "150px"
          }, e && {
            color: "rgba(0, 0, 0, 0.3)"
          }),
          placeholder: r + " - " + r
        });
      },
      datePickerUpdateOnInput: !1,
      datePickerTintColor: "#66B3CC",
      datePickerShowCaps: !1,
      datePickerShowDayPopover: !0,
      datePickerDisabledAttribute: {
        contentStyle: function (t) {
          var e = t.isHovered;
          return o()({
            color: "#d98c8c",
            fontWeight: 600,
            opacity: .6,
            borderRadius: "0"
          }, e && {
            cursor: "not-allowed",
            backgroundColor: "transparent"
          });
        }
      },
      popoverExpanded: !1,
      popoverDirection: "bottom",
      popoverAlign: "left",
      popoverVisibility: s.a.HOVER,
      popoverContentOffset: 10,
      popoverKeepVisibleOnInput: !1,
      maxSwipeTime: 300,
      minHorizontalSwipeDistance: 60,
      maxVerticalSwipeDistance: 80,
      maxTapTolerance: 0,
      maxTapDuration: 200,
      highlight: {
        animated: !0,
        height: "1.8rem",
        borderWidth: "0",
        borderStyle: "solid",
        opacity: 1
      },
      highlightCaps: {
        animated: !0,
        height: "1.8rem",
        borderWidth: "0",
        borderStyle: "solid",
        opacity: 1
      },
      dot: {
        diameter: "5px",
        backgroundColor: "#66b3cc",
        borderWidth: "0",
        borderStyle: "solid",
        borderRadius: "50%",
        opacity: 1
      },
      bar: {
        height: "3px",
        backgroundColor: "#66b3cc",
        borderWidth: "0",
        borderStyle: "solid",
        opacity: 1
      },
      themeStyles: {
        wrapper: {
          backgroundColor: "#fafafa",
          border: "1px solid #dadada"
        },
        verticalDivider: {
          borderLeft: "1px solid #dadada"
        },
        horizontalDivider: {
          borderTop: "1px solid #dadada"
        },
        pane: null,
        header: null,
        headerTitle: null,
        headerArrows: null,
        headerHorizontalDivider: null,
        weekdays: null,
        weekdaysHorizontalDivider: null,
        weeks: null,
        dayCell: null,
        dayCellNotInMonth: {
          opacity: .4
        },
        dayContent: null,
        dayContentHover: null,
        dots: null,
        bars: null,
        dayPopoverContent: {
          color: "#333333",
          fontSize: ".8rem",
          whiteSpace: "nowrap"
        },
        navHeader: null,
        navHeaderTitle: null,
        navHeaderArrows: null,
        navMonthCell: null,
        navYearCell: null
      }
    };
    e.a = c;

    var l = function (t, e) {
      return Object(u.e)(t) && t || Object(u.c)(t) && t(e) || t;
    },
        d = function () {
      for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];

      return i.a.apply(Object, [c].concat(e));
    };
  }, function (t, e, n) {
    "use strict";

    n.d(e, "d", function () {
      return i;
    }), n.d(e, "b", function () {
      return a;
    }), n.d(e, "f", function () {
      return o;
    }), n.d(e, "a", function () {
      return s;
    }), n.d(e, "e", function () {
      return u;
    }), n.d(e, "c", function () {
      return c;
    });

    var r = function (t) {
      return Object.prototype.toString.call(t).slice(8, -1);
    },
        i = function (t) {
      return "Number" === r(t);
    },
        a = function (t) {
      return "Date" === r(t);
    },
        o = function (t) {
      return "String" === r(t);
    },
        s = function (t) {
      return "Array" === r(t);
    },
        u = function (t) {
      return "Object" === r(t);
    },
        c = function (t) {
      return "Function" === r(t);
    };
  }, function (t, e) {
    var n = t.exports = {
      version: "2.5.3"
    };
    "number" == typeof __e && (__e = n);
  }, function (t, e, n) {
    var r = n(37)("wks"),
        i = n(38),
        a = n(9).Symbol,
        o = "function" == typeof a;
    (t.exports = function (t) {
      return r[t] || (r[t] = o && a[t] || (o ? a : i)("Symbol." + t));
    }).store = r;
  }, function (t, e, n) {
    var r = n(9),
        i = n(5),
        a = n(40),
        o = n(18),
        s = "prototype",
        u = function (t, e, n) {
      var c,
          l,
          d,
          f = t & u.F,
          h = t & u.G,
          p = t & u.S,
          v = t & u.P,
          y = t & u.B,
          m = t & u.W,
          b = h ? i : i[e] || (i[e] = {}),
          g = b[s],
          D = h ? r : p ? r[e] : (r[e] || {})[s];
      h && (n = e);

      for (c in n) (l = !f && D && void 0 !== D[c]) && c in b || (d = l ? D[c] : n[c], b[c] = h && "function" != typeof D[c] ? n[c] : y && l ? a(d, r) : m && D[c] == d ? function (t) {
        var e = function (e, n, r) {
          if (this instanceof t) {
            switch (arguments.length) {
              case 0:
                return new t();

              case 1:
                return new t(e);

              case 2:
                return new t(e, n);
            }

            return new t(e, n, r);
          }

          return t.apply(this, arguments);
        };

        return e[s] = t[s], e;
      }(d) : v && "function" == typeof d ? a(Function.call, d) : d, v && ((b.virtual || (b.virtual = {}))[c] = d, t & u.R && g && !g[c] && o(g, c, d)));
    };

    u.F = 1, u.G = 2, u.S = 4, u.P = 8, u.B = 16, u.W = 32, u.U = 64, u.R = 128, t.exports = u;
  }, function (t, e, n) {
    "use strict";

    n.d(e, "a", function () {
      return p;
    }), n.d(e, "b", function () {
      return v;
    });

    var r = n(3),
        i = n(4),
        a = /d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g,
        o = /\d\d?/,
        s = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
        u = /\[([^]*?)\]/gm,
        c = function () {};

    function l(t) {
      return function (e, n, r) {
        var i = r[t].indexOf(n.charAt(0).toUpperCase() + n.substr(1).toLowerCase());
        ~i && (e.month = i);
      };
    }

    function d(t, e) {
      for (t = String(t), e = e || 2; t.length < e;) t = "0" + t;

      return t;
    }

    var f = {
      D: function (t) {
        return t.getDate();
      },
      DD: function (t) {
        return d(t.getDate());
      },
      Do: function (t, e) {
        return e.DoFn(t.getDate());
      },
      d: function (t) {
        return t.getDay();
      },
      dd: function (t) {
        return d(t.getDay());
      },
      W: function (t, e) {
        return e.dayNamesNarrow[t.getDay()];
      },
      WW: function (t, e) {
        return e.dayNamesShorter[t.getDay()];
      },
      WWW: function (t, e) {
        return e.dayNamesShort[t.getDay()];
      },
      WWWW: function (t, e) {
        return e.dayNames[t.getDay()];
      },
      M: function (t) {
        return t.getMonth() + 1;
      },
      MM: function (t) {
        return d(t.getMonth() + 1);
      },
      MMM: function (t, e) {
        return e.monthNamesShort[t.getMonth()];
      },
      MMMM: function (t, e) {
        return e.monthNames[t.getMonth()];
      },
      YY: function (t) {
        return String(t.getFullYear()).substr(2);
      },
      YYYY: function (t) {
        return d(t.getFullYear(), 4);
      },
      h: function (t) {
        return t.getHours() % 12 || 12;
      },
      hh: function (t) {
        return d(t.getHours() % 12 || 12);
      },
      H: function (t) {
        return t.getHours();
      },
      HH: function (t) {
        return d(t.getHours());
      },
      m: function (t) {
        return t.getMinutes();
      },
      mm: function (t) {
        return d(t.getMinutes());
      },
      s: function (t) {
        return t.getSeconds();
      },
      ss: function (t) {
        return d(t.getSeconds());
      },
      S: function (t) {
        return Math.round(t.getMilliseconds() / 100);
      },
      SS: function (t) {
        return d(Math.round(t.getMilliseconds() / 10), 2);
      },
      SSS: function (t) {
        return d(t.getMilliseconds(), 3);
      },
      a: function (t, e) {
        return t.getHours() < 12 ? e.amPm[0] : e.amPm[1];
      },
      A: function (t, e) {
        return t.getHours() < 12 ? e.amPm[0].toUpperCase() : e.amPm[1].toUpperCase();
      },
      ZZ: function (t) {
        var e = t.getTimezoneOffset();
        return (e > 0 ? "-" : "+") + d(100 * Math.floor(Math.abs(e) / 60) + Math.abs(e) % 60, 4);
      }
    },
        h = {
      D: [o, function (t, e) {
        t.day = e;
      }],
      Do: [new RegExp(o.source + s.source), function (t, e) {
        t.day = parseInt(e, 10);
      }],
      d: [o, c],
      W: [s, c],
      M: [o, function (t, e) {
        t.month = e - 1;
      }],
      MMM: [s, l("monthNamesShort")],
      MMMM: [s, l("monthNames")],
      YY: [o, function (t, e) {
        var n = +new Date().getFullYear().toString().substr(0, 2);
        t.year = "" + (e > 68 ? n - 1 : n) + e;
      }],
      YYYY: [/\d{4}/, function (t, e) {
        t.year = e;
      }],
      S: [/\d/, function (t, e) {
        t.millisecond = 100 * e;
      }],
      SS: [/\d{2}/, function (t, e) {
        t.millisecond = 10 * e;
      }],
      SSS: [/\d{3}/, function (t, e) {
        t.millisecond = e;
      }],
      h: [o, function (t, e) {
        t.hour = e;
      }],
      m: [o, function (t, e) {
        t.minute = e;
      }],
      s: [o, function (t, e) {
        t.second = e;
      }],
      a: [s, function (t, e, n) {
        var r = e.toLowerCase();
        r === n.amPm[0] ? t.isPm = !1 : r === n.amPm[1] && (t.isPm = !0);
      }],
      ZZ: [/([\+\-]\d\d:?\d\d|Z)/, function (t, e) {
        "Z" === e && (e = "+00:00");
        var n = ("" + e).match(/([+-]|\d\d)/gi);

        if (n) {
          var r = 60 * n[1] + parseInt(n[2], 10);
          t.timezoneOffset = "+" === n[0] ? r : -r;
        }
      }]
    };
    h.DD = h.D, h.dd = h.d, h.WWWW = h.WWW = h.WW = h.W, h.MM = h.M, h.mm = h.m, h.hh = h.H = h.HH = h.h, h.ss = h.s, h.A = h.a;

    var p = function (t, e) {
      if ("number" == typeof t && (t = new Date(t)), "[object Date]" !== Object.prototype.toString.call(t) || isNaN(t.getTime())) throw new Error("Invalid Date in fecha.format");
      var n = [];
      return (e = (e = (e = r.a.masks[e] || e).replace(u, function (t, e) {
        return n.push(e), "??";
      })).replace(a, function (e) {
        return e in f ? f[e](t, r.a) : e.slice(1, e.length - 1);
      })).replace(/\?\?/g, function () {
        return n.shift();
      });
    },
        v = function (t, e) {
      return (Object(i.a)(e) && e || [Object(i.f)(e) && e || "YYYY-MM-DD"]).map(function (e) {
        return function (t, e) {
          if ("string" != typeof e) throw new Error("Invalid mask in fecha.parse");
          if (e = r.a.masks[e] || e, t.length > 1e3) return !1;
          var n = !0,
              i = {};
          if (e.replace(a, function (e) {
            if (h[e]) {
              var a = h[e],
                  o = t.search(a[0]);
              ~o ? t.replace(a[0], function (e) {
                return a[1](i, e, r.a), t = t.substr(o + e.length), e;
              }) : n = !1;
            }

            return h[e] ? "" : e.slice(1, e.length - 1);
          }), !n) return !1;
          var o = new Date();
          !0 === i.isPm && null != i.hour && 12 != +i.hour ? i.hour = +i.hour + 12 : !1 === i.isPm && 12 == +i.hour && (i.hour = 0);
          var s = void 0;
          return null != i.timezoneOffset ? (i.minute = +(i.minute || 0) - +i.timezoneOffset, s = new Date(Date.UTC(i.year || o.getFullYear(), i.month || 0, i.day || 1, i.hour || 0, i.minute || 0, i.second || 0, i.millisecond || 0))) : s = new Date(i.year || o.getFullYear(), i.month || 0, i.day || 1, i.hour || 0, i.minute || 0, i.second || 0, i.millisecond || 0), s;
        }(t, e);
      }).find(function (t) {
        return t;
      }) || new Date(t);
    };
  }, function (t, e) {
    var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n);
  }, function (t, e, n) {
    var r = n(19),
        i = n(67),
        a = n(68),
        o = Object.defineProperty;
    e.f = n(11) ? Object.defineProperty : function (t, e, n) {
      if (r(t), e = a(e, !0), r(n), i) try {
        return o(t, e, n);
      } catch (t) {}
      if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
      return "value" in n && (t[e] = n.value), t;
    };
  }, function (t, e, n) {
    t.exports = !n(20)(function () {
      return 7 != Object.defineProperty({}, "a", {
        get: function () {
          return 7;
        }
      }).a;
    });
  }, function (t, e, n) {
    "use strict";

    e.__esModule = !0;
    var r,
        i = n(74),
        a = (r = i, r && r.__esModule ? r : {
      default: r
    });

    e.default = function (t) {
      if (Array.isArray(t)) {
        for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];

        return n;
      }

      return (0, a.default)(t);
    };
  }, function (t, e, n) {
    "use strict";

    n.d(e, "a", function () {
      return s;
    });
    var r = n(0),
        i = n.n(r),
        a = n(14),
        o = n.n(a),
        s = {
      methods: {
        mergeListeners: function (t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.$listeners;
          return o()(t).reduce(function (e, n) {
            return e[n] = e[n] ? [e[n], t[n]] : t[n], e;
          }, i()({}, e));
        }
      }
    };
  }, function (t, e, n) {
    t.exports = {
      default: n(60),
      __esModule: !0
    };
  }, function (t, e, n) {
    var r = n(25);

    t.exports = function (t) {
      return Object(r(t));
    };
  }, function (t, e, n) {
    var r = n(62),
        i = n(39);

    t.exports = Object.keys || function (t) {
      return r(t, i);
    };
  }, function (t, e) {
    var n = {}.hasOwnProperty;

    t.exports = function (t, e) {
      return n.call(t, e);
    };
  }, function (t, e, n) {
    var r = n(10),
        i = n(30);
    t.exports = n(11) ? function (t, e, n) {
      return r.f(t, e, i(1, n));
    } : function (t, e, n) {
      return t[e] = n, t;
    };
  }, function (t, e, n) {
    var r = n(29);

    t.exports = function (t) {
      if (!r(t)) throw TypeError(t + " is not an object!");
      return t;
    };
  }, function (t, e) {
    t.exports = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(43);

    var i = function (t) {
      n(73);
    },
        a = n(1)(r.a, null, !1, i, "data-v-bc55024c", null);

    e.a = a.exports;
  }, function (t, e, n) {
    "use strict";

    var r = n(46),
        i = n(101);

    var a = function (t) {
      n(95);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-1ad2436f", null);

    e.a = o.exports;
  }, function (t, e, n) {
    "use strict";

    e.a = v;
    var r = n(0),
        i = n.n(r),
        a = n(14),
        o = n.n(a),
        s = n(4),
        u = n(3),
        c = n(2),
        l = n(8),
        d = 864e5;

    function f(t, e) {
      var n = t.toRange(),
          r = e.toRange(),
          i = null,
          a = null;
      return n.start ? i = r.start ? n.start < r.start ? n.start : r.start : n.start : r.start && (i = r.start), n.end && (!i || n.end >= i) && (a = n.end), r.end && (!i || r.end >= i) && (!a || r.end < a) && (a = r.end), {
        start: i,
        end: a
      };
    }

    function h(t, e) {
      return t.isDate ? e.isDate ? t.dateTime === e.dateTime : !(!e.startTime || !e.endTime) && t.dateTime === e.startTime && t.dateTime === e.endTime : e.isDate ? !(t.start && e.date < t.start) && !(t.end && e.date > t.end) : !(t.start && (!e.start || e.start < t.start)) && !(t.end && (!e.end || e.end > t.end));
    }

    function p(t) {
      if (!t) return null;
      var e = t.getMonth() + 1,
          n = t.getUTCFullYear(),
          r = Object(c.i)(e, n),
          i = t.getDate(),
          a = r.days - i + 1,
          o = t.getDay() + 1,
          s = Math.floor((i - 1) / 7 + 1),
          u = Math.floor((r.days - i) / 7 + 1),
          l = Math.ceil((i + Math.abs(r.firstWeekday - r.firstDayOfWeek)) / 7);
      return {
        day: i,
        dayFromEnd: a,
        weekday: o,
        weekdayOrdinal: s,
        weekdayOrdinalFromEnd: u,
        week: l,
        weekFromEnd: r.weeks - l + 1,
        month: e,
        year: n,
        date: t,
        dateTime: t.getTime()
      };
    }

    function v(t, e) {
      var n = new Date(t);
      return n.setDate(n.getDate() + e), n;
    }

    function y(t, e) {
      var n = t.start,
          r = t.end;
      if (!n || !r || !Object(s.c)(e)) return null;

      for (var i = {
        i: 0,
        date: n,
        day: p(n),
        finished: !1
      }, a = null; !i.finished && i.date <= r; i.i++) a = e(i), i.date = v(i.date, 1), i.day = p(i.date);

      return a;
    }

    function m(t) {
      var e = t.getDay() + 1,
          n = u.a.firstDayOfWeek;
      return v(t, e >= n ? n - e : -(7 - (n - e)));
    }

    function b(t, e) {
      return Math.round((e - t) / d);
    }

    function g(t, e) {
      return b(m(t), m(e));
    }

    function D(t, e) {
      return e.getUTCFullYear() - t.getUTCFullYear();
    }

    function w(t, e) {
      return 12 * D(t, e) + (e.getMonth() - t.getMonth());
    }

    var _ = {
      dailyInterval: {
        test: function (t, e, n) {
          return b(n.start || new Date(), t.date) % e == 0;
        }
      },
      weeklyInterval: {
        test: function (t, e, n) {
          return g(n.start || new Date(), t.date) % e == 0;
        }
      },
      monthlyInterval: {
        test: function (t, e, n) {
          return w(n.start || new Date(), t.date) % e == 0;
        }
      },
      yearlyInterval: {
        test: function () {
          return function (t, e, n) {
            return D(n.start || new Date(), t.date) % e == 0;
          };
        }
      },
      days: {
        validate: function (t) {
          return Object(s.a)(t) ? t : [parseInt(t, 10)];
        },
        test: function (t, e) {
          return e.includes(t.day) || e.includes(-t.dayFromEnd);
        }
      },
      weekdays: {
        validate: function (t) {
          return Object(s.a)(t) ? t : [parseInt(t, 10)];
        },
        test: function (t, e) {
          return e.includes(t.weekday);
        }
      },
      ordinalWeekdays: {
        validate: function (t) {
          return o()(t).reduce(function (e, n) {
            var r = t[n];
            return r ? (e[n] = Object(s.a)(r) ? r : [parseInt(r, 10)], e) : e;
          }, {});
        },
        test: function (t, e) {
          return o()(e).map(function (t) {
            return parseInt(t, 10);
          }).find(function (n) {
            return e[n].includes(t.weekday) && (n === t.weekdayOrdinal || n === -t.weekdayOrdinalFromEnd);
          });
        }
      },
      weekends: {
        validate: function (t) {
          return t;
        },
        test: function (t) {
          return 1 === t.weekday || 7 === t.weekday;
        }
      },
      workweek: {
        validate: function (t) {
          return t;
        },
        test: function (t) {
          return t.weekday >= 2 && t.weekday <= 6;
        }
      },
      weeks: {
        validate: function (t) {
          return Object(s.a)(t) ? t : [parseInt(t, 10)];
        },
        test: function (t, e) {
          return e.includes(t.week) || e.includes(-t.weekFromEnd);
        }
      },
      months: {
        validate: function (t) {
          return Object(s.a)(t) ? t : [parseInt(t, 10)];
        },
        test: function (t, e) {
          return e.includes(t.month);
        }
      },
      years: {
        validate: function (t) {
          return Object(s.a)(t) ? t : [parseInt(t, 10)];
        },
        test: function (t, e) {
          return e.includes(t.year);
        }
      }
    },
        O = o()(_).map(function (t) {
      return {
        name: t,
        validate: _[t].validate
      };
    }),
        C = function (t, e, n) {
      return Object(s.c)(t) ? t(e) : Object(s.e)(t) ? o()(t).every(function (r) {
        return _[r].test(e, t[r], n);
      }) : null;
    };

    e.b = function t(e, n) {
      if (!e) return null;
      var r = {
        isDateInfo: !0,
        isDate: Object(s.b)(e) || Object(s.f)(e) || Object(s.d)(e),
        isRange: Object(s.e)(e) || Object(s.c)(e),
        order: n || 0
      };

      if (r.isDate) {
        r.type = "date";
        var a = !Object(s.f)(e) && new Date(e) || Object(l.b)(e, u.a.formats.data || ["L", "YYYY-MM-DD", "YYYY/MM/DD"]);
        if (isNaN(a)) return null;
        a.setHours(0, 0, 0, 0), r.date = a, r.dateTime = a.getTime();
      }

      if (r.isRange) {
        if (r.type = "range", Object(s.c)(e)) r.on = {
          and: e
        };else {
          var o = e.start && new Date(e.start),
              d = e.end && new Date(e.end);

          if (o && d && o > d) {
            var p = o;
            o = d, d = p;
          } else o && e.span >= 1 && (d = v(o, e.span - 1));

          o && (isNaN(o.getTime()) ? o = null : o.setHours(0, 0, 0, 0)), d && (isNaN(d.getTime()) ? d = null : d.setHours(0, 0, 0, 0)), r.start = o, r.end = d, r.startTime = o && o.getTime(), r.endTime = d && d.getTime(), o && d && (r.daySpan = b(o, d), r.weekSpan = g(o, d), r.monthSpan = w(o, d), r.yearSpan = D(o, d));
          var m = Object(c.r)(e, {}, O);

          if (m.assigned && (r.on = {
            and: m.target
          }), e.on) {
            var _ = (Object(s.a)(e.on) ? e.on : [e.on]).map(function (t) {
              if (Object(s.c)(t)) return t;
              var e = Object(c.r)(t, {}, O);
              return e.assigned ? e.target : null;
            }).filter(function (t) {
              return t;
            });

            _.length && (r.on = i()({}, r.on, {
              or: _
            }));
          }
        }
        r.isComplex = !!r.on;
      }

      return r.shallowIntersectsDate = function (e) {
        return n = r, i = e.isDate ? e : t(e), n.isDate ? i.isDate ? n.dateTime === i.dateTime : h(i, n) : i.isDate ? h(n, i) : !(n.start && i.end && n.start > i.end || n.end && i.start && n.end < i.start);
        var n, i;
      }, r.intersectsDate = function (e) {
        var n = e.isDateInfo ? e : t(e);
        if (!r.shallowIntersectsDate(n)) return null;
        if (!r.on) return r;
        var i = !1;
        return y(f(r, n), function (t) {
          r.matchesDay(t.day) && (i = i || n.matchesDay(t.day), t.finished = i);
        }), i;
      }, r.shallowIncludesDate = function (e) {
        return h(r, e.isDate ? e : t(e));
      }, r.includesDate = function (e) {
        var n = e.isDateInfo ? e : t(e);
        if (!r.shallowIncludesDate(n)) return !1;
        if (!r.on) return !0;
        var i = !0;
        return y(f(r, n), function (t) {
          r.matchesDay(t.day) && (i = i && n.matchesDay(t.day), t.finished = !i);
        }), i;
      }, r.includesDay = function (e) {
        var n = t(e.date);
        return r.shallowIncludesDate(n) && r.matchesDay(e) ? r : null;
      }, r.matchesDay = function (t) {
        return !(r.on && (r.on.and && !C(r.on.and, t, r) || r.on.or && !r.on.or.find(function (e) {
          return C(e, t, r);
        })));
      }, r.toRange = function () {
        return r.isDate ? t({
          start: r.date,
          end: r.date
        }) : t({
          start: r.start,
          end: r.end
        });
      }, r.compare = function (t) {
        if (r.order !== t.order) return r.order - t.order;
        if (r.type !== t.type) return r.isDate ? 1 : -1;
        if (r.isDate) return 0;
        var e = r.start - t.start;
        return 0 !== e ? e : r.end - t.end;
      }, r;
    };
  }, function (t, e, n) {
    "use strict";

    n.d(e, "e", function () {
      return o;
    }), n.d(e, "f", function () {
      return l;
    }), n.d(e, "b", function () {
      return h;
    }), n.d(e, "c", function () {
      return p;
    }), n.d(e, "d", function () {
      return D;
    });

    var r = n(4),
        i = n(2),
        a = n(23),
        o = function (t) {
      return Object(r.b)(t) && !isNaN(t.getTime());
    },
        s = function (t, e) {
      return o(t) ? e(t) : "";
    },
        u = function (t, e) {
      var n = e(t.trim());
      return o(n) ? n : null;
    },
        c = function (t) {
      var e = t.value,
          n = t.isRequired,
          r = t.disabled,
          i = t.fallbackValue;
      return !o(e) && n ? i : o(e) && r && r.intersectsDate(e) ? null : e;
    },
        l = function (t, e) {
      return !o(t) && !o(e) || !(!o(t) || !o(e)) && t.getTime() === e.getTime();
    },
        d = function (t) {
      if (!o(t)) return null;
      var e = Object(i.d)(t);
      return {
        from: e,
        to: e
      };
    },
        f = function (t, e) {
      return {
        componentName: "single-date-picker",
        hasValue: o,
        formatValue: function (e) {
          return s(e, t);
        },
        parseValue: function (t) {
          return u(t, e);
        },
        normalizeValue: function (t) {
          return (e = t) && new Date(e);
          var e;
        },
        filterDisabled: c,
        valuesAreEqual: l,
        getPageRange: d
      };
    },
        h = function (t) {
      return Object(i.a)(t);
    },
        p = function (t) {
      if (!t || !t.length) return null;
      var e = {};
      return t.filter(function (t) {
        var n = t.getTime();
        return !Object.prototype.hasOwnProperty.call(e, n) && (e[n] = !0);
      }).sort(function (t, e) {
        return t.getTime() - e.getTime();
      });
    },
        v = function (t) {
      var e = t.value,
          n = t.isRequired,
          r = t.disabled,
          i = t.fallbackValue,
          a = e && e.filter(function (t) {
        return !r || !r.intersectsDate(t);
      });
      return !h(a) && n ? i : a;
    },
        y = function (t, e) {
      var n = Object(i.a)(t),
          r = Object(i.a)(e);
      return !n && !r || !(!n || !r || n !== r) && t.every(function (t) {
        return e.includes(t);
      });
    },
        m = function (t) {
      if (!h(t)) return null;
      var e = Object(i.d)(t[0]);
      return {
        from: e,
        to: Object(i.h)(Object(i.d)(Object(i.g)(t)), Object(i.l)(e))
      };
    },
        b = function (t, e) {
      return {
        componentName: "multiple-date-picker",
        hasValue: h,
        formatValue: function (e) {
          return r = t, h(n = e) ? n.map(function (t) {
            return r(t);
          }).join(", ") : "";
          var n, r;
        },
        parseValue: function (t) {
          return function (t, e) {
            var n = t && t.split(",").map(function (t) {
              return u(t, e);
            }).filter(function (t) {
              return o(t);
            });
            return n && n.length ? n : null;
          }(t, e);
        },
        normalizeValue: function (t) {
          return p(t);
        },
        filterDisabled: v,
        valuesAreEqual: y,
        getPageRange: m
      };
    },
        g = function (t) {
      return t && t.start && t.end;
    },
        D = function (t) {
      if (!t || !t.start || !t.end) return null;
      var e = new a.b({
        start: new Date(t.start),
        end: new Date(t.end)
      });
      return {
        start: e.start,
        end: e.end
      };
    },
        w = function (t) {
      var e = t.value,
          n = t.isRequired,
          r = t.disabled,
          i = t.fallbackValue;
      return !g(e) && n ? i : g(e) && r && r.intersectsDate(e) ? null : e;
    },
        _ = function (t, e) {
      return !g(t) && !g(e) || !(!g(t) || !g(e)) && l(t.start, e.start) && l(t.end, e.end);
    },
        O = function (t) {
      if (!g(t)) return null;
      var e = Object(i.d)(t.start);
      return {
        from: e,
        to: Object(i.h)(Object(i.d)(t.end), Object(i.l)(e))
      };
    },
        C = function (t, e) {
      return {
        componentName: "date-range-picker",
        hasValue: g,
        formatValue: function (e, n) {
          return function (t, e, n) {
            var r = void 0,
                i = void 0;
            return e ? (r = s(e.start, n), i = s(e.end, n)) : t && (r = s(t.start, n), i = s(t.end, n)), r || i ? i ? r + " - " + i : r : "";
          }(e, n, t);
        },
        normalizeValue: function (t) {
          return D(t);
        },
        parseValue: function (t) {
          return function (t, e) {
            var n = t.split("-").map(function (t) {
              return t.trim();
            });

            if (n.length >= 2) {
              var r = Object(a.b)({
                start: u(n[0], e),
                end: u(n[1], e)
              }),
                  i = r.start,
                  o = r.end;
              return i && o && {
                start: i,
                end: o
              };
            }

            return null;
          }(t, e);
        },
        filterDisabled: w,
        valuesAreEqual: _,
        getPageRange: O
      };
    };

    e.a = function (t, e, n) {
      switch (t) {
        case "single":
          return f(e, n);

        case "multiple":
          return b(e, n);

        case "range":
          return C(e, n);

        default:
          return null;
      }
    };
  }, function (t, e) {
    t.exports = function (t) {
      if (void 0 == t) throw TypeError("Can't call method on  " + t);
      return t;
    };
  }, function (t, e, n) {
    var r = n(34),
        i = n(25);

    t.exports = function (t) {
      return r(i(t));
    };
  }, function (t, e) {
    var n = Math.ceil,
        r = Math.floor;

    t.exports = function (t) {
      return isNaN(t = +t) ? 0 : (t > 0 ? r : n)(t);
    };
  }, function (t, e, n) {
    var r = n(37)("keys"),
        i = n(38);

    t.exports = function (t) {
      return r[t] || (r[t] = i(t));
    };
  }, function (t, e) {
    t.exports = function (t) {
      return "object" == typeof t ? null !== t : "function" == typeof t;
    };
  }, function (t, e) {
    t.exports = function (t, e) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: e
      };
    };
  }, function (t, e, n) {
    t.exports = {
      default: n(69),
      __esModule: !0
    };
  }, function (t, e) {
    t.exports = {};
  }, function (t, e, n) {
    "use strict";

    var r = n(52),
        i = n(118);

    var a = function (t) {
      n(117);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-12e91ab4", null);

    e.a = o.exports;
  }, function (t, e, n) {
    var r = n(35);
    t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
      return "String" == r(t) ? t.split("") : Object(t);
    };
  }, function (t, e) {
    var n = {}.toString;

    t.exports = function (t) {
      return n.call(t).slice(8, -1);
    };
  }, function (t, e, n) {
    var r = n(27),
        i = Math.min;

    t.exports = function (t) {
      return t > 0 ? i(r(t), 9007199254740991) : 0;
    };
  }, function (t, e, n) {
    var r = n(9),
        i = "__core-js_shared__",
        a = r[i] || (r[i] = {});

    t.exports = function (t) {
      return a[t] || (a[t] = {});
    };
  }, function (t, e) {
    var n = 0,
        r = Math.random();

    t.exports = function (t) {
      return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + r).toString(36));
    };
  }, function (t, e) {
    t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
  }, function (t, e, n) {
    var r = n(66);

    t.exports = function (t, e, n) {
      if (r(t), void 0 === e) return t;

      switch (n) {
        case 1:
          return function (n) {
            return t.call(e, n);
          };

        case 2:
          return function (n, r) {
            return t.call(e, n, r);
          };

        case 3:
          return function (n, r, i) {
            return t.call(e, n, r, i);
          };
      }

      return function () {
        return t.apply(e, arguments);
      };
    };
  }, function (t, e, n) {
    var r = n(29),
        i = n(9).document,
        a = r(i) && r(i.createElement);

    t.exports = function (t) {
      return a ? i.createElement(t) : {};
    };
  }, function (t, e) {
    e.f = {}.propertyIsEnumerable;
  }, function (t, e, n) {
    "use strict";

    var r = n(12),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(93),
        u = n(121),
        c = n(3),
        l = n(13),
        d = n(2);
    e.a = {
      mixins: [l.a],
      render: function (t) {
        var e = this,
            n = function (n) {
          return t(s.a, {
            attrs: o()({}, e.$attrs, {
              position: n,
              page: n < 2 ? e.fromPage_ : e.toPage_,
              minPage: n < 2 ? e.minPage_ : e.minToPage,
              maxPage: n < 2 ? e.maxFromPage : e.maxPage_,
              hideRightButton: !e.showLinkedButtons && 1 === n && e.isLinked && !e.isVertical,
              hideLeftButton: !e.showLinkedButtons && 2 === n && e.isLinked && !e.isVertical,
              paneWidth: e.paneWidth,
              styles: e.themeStyles_,
              attributes: e.attributes_,
              formats: e.formats_
            }),
            on: e.mergeListeners({
              "update:page": function (t) {
                n < 2 ? e.fromPage_ = t : e.toPage_ = t;
              }
            }),
            slots: e.$slots,
            scopedSlots: e.$scopedSlots
          });
        };

        return t("div", {
          class: {
            "c-pane-container": !0,
            "is-vertical": this.isVertical,
            "is-expanded": this.isExpanded
          },
          style: this.wrapperStyle,
          ref: "root"
        }, [n(this.isDoublePaned_ ? 1 : 0)].concat(i()(this.isDoublePaned_ && [t("div", {
          class: "c-pane-div",
          style: this.dividerStyle
        }), n(2)])));
      },
      name: "VCalendar",
      components: {
        CalendarPane: s.a
      },
      props: {
        minDate: Date,
        maxDate: Date,
        minPage: Object,
        maxPage: Object,
        fromPage: Object,
        toPage: Object,
        showLinkedButtons: {
          type: Boolean,
          default: function () {
            return c.a.showLinkedButtons;
          }
        },
        isDoublePaned: Boolean,
        isLinked: Boolean,
        isVertical: Boolean,
        isExpanded: Boolean,
        paneWidth: {
          type: Number,
          default: function () {
            return c.a.paneWidth;
          }
        },
        themeStyles: Object,
        attributes: Array,
        formats: Object
      },
      data: function () {
        return {
          isConstrained: !0,
          fromPage_: null,
          toPage_: null
        };
      },
      computed: {
        isDoublePaned_: function () {
          return this.isDoublePaned && (this.isVertical || !this.isConstrained);
        },
        minPage_: function () {
          return this.minPage || this.minDate && Object(d.n)(this.minDate) || null;
        },
        rightButtonHidden: function () {
          return 1 === this.position && this.isLinked && !this.isVertical;
        },
        leftButtonHidden: function () {
          return 2 === this.position && this.isLinked && !this.isVertical;
        },
        maxPage_: function () {
          return this.maxPage || this.maxDate && Object(d.n)(this.maxDate) || null;
        },
        maxFromPage: function () {
          return this.isDoublePaned_ ? Object(d.p)(this.maxPage_) : this.maxPage_;
        },
        minToPage: function () {
          return this.isDoublePaned_ ? Object(d.l)(this.minPage_) : null;
        },
        themeStyles_: function () {
          return o()({}, c.a.themeStyles, this.themeStyles);
        },
        wrapperStyle: function () {
          return this.themeStyles_.wrapper;
        },
        dividerStyle: function () {
          return this.isVertical ? this.themeStyles_.horizontalDivider : this.themeStyles_.verticalDivider;
        },
        attributes_: function () {
          return Object(u.a)(this.attributes);
        },
        formats_: function () {
          return o()({}, c.a.formats, this.formats);
        }
      },
      watch: {
        fromPage: function () {
          this.refreshFromPage();
        },
        toPage: function () {
          this.refreshToPage();
        },
        fromPage_: function (t, e) {
          Object(d.w)(t, e) || (this.$emit("update:frompage", t), this.$emit("update:fromPage", t), this.isDoublePaned && (!this.isLinked && Object(d.u)(t, this.toPage_) || (this.toPage_ = Object(d.l)(t))));
        },
        toPage_: function (t, e) {
          Object(d.w)(t, e) || (this.$emit("update:topage", t), this.$emit("update:toPage", t), this.isDoublePaned && (!this.isLinked && Object(d.t)(t, this.fromPage_) || (this.fromPage_ = Object(d.p)(t))));
        },
        isDoublePaned_: function () {
          this.refreshIsConstrained(), this.refreshToPage();
        },
        isLinked: function (t) {
          t && (this.toPage_ = Object(d.l)(this.fromPage_));
        },
        isExpanded: function () {
          this.refreshIsConstrained();
        }
      },
      created: function () {
        this.refreshFromPage(), this.refreshToPage();
      },
      mounted: function () {
        var t = this;
        this.$nextTick(function () {
          t.refreshIsConstrained(), window.addEventListener("resize", t.refreshIsConstrained);
        });
      },
      beforeDestroy: function () {
        window.removeEventListener("resize", this.refreshIsConstrained);
      },
      methods: {
        refreshFromPage: function () {
          var t = this;
          this.fromPage_ = d.f.apply(void 0, i()([this.fromPage, {
            month: d.x.month,
            year: d.x.year
          }].map(function (e) {
            return Object(d.m)(e, t.minPage_, t.maxPage_);
          })).concat([this.minPage_, Object(d.p)(this.maxPage_)]));
        },
        refreshToPage: function () {
          var t = this;
          this.toPage_ = d.f.apply(void 0, i()([this.toPage, Object(d.l)(this.fromPage_)].map(function (e) {
            return Object(d.m)(e, t.minPage_, t.maxPage_);
          })).concat([this.maxPage_, Object(d.l)(this.minPage_)]));
        },
        refreshIsConstrained: function () {
          var t = this.$refs.root;
          window && t && this.isDoublePaned && !this.isVertical ? window && window.innerWidth < 2 * this.paneWidth + 30 ? this.isConstrained = !0 : this.isExpanded ? this.isConstrained = t.parentElement.offsetWidth < 2 * this.paneWidth + 2 : this.isConstrained = !1 : this.isConstrained = !1;
        }
      }
    };
  }, function (t, e, n) {
    var r = n(10).f,
        i = n(17),
        a = n(6)("toStringTag");

    t.exports = function (t, e, n) {
      t && !i(t = n ? t : t.prototype, a) && r(t, a, {
        configurable: !0,
        value: e
      });
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(0),
        i = n.n(r),
        a = n(22),
        o = n(102),
        s = n(111),
        u = n(33),
        c = n(3),
        l = n(2),
        d = n(8),
        f = n(2);
    e.a = {
      components: {
        CalendarWeeks: o.a,
        CalendarNav: s.a,
        Popover: a.a,
        SvgIcon: u.a
      },
      props: {
        position: {
          type: Number,
          default: 1
        },
        page: {
          type: Object,
          default: function () {
            return f.x;
          }
        },
        navVisibility: {
          type: String,
          default: function () {
            return c.a.navVisibility;
          }
        },
        minPage: Object,
        maxPage: Object,
        styles: Object,
        formats: Object,
        titlePosition: {
          type: String,
          default: function () {
            return c.a.titlePosition;
          }
        },
        titleTransition: {
          type: String,
          default: function () {
            return c.a.titleTransition;
          }
        },
        weeksTransition: {
          type: String,
          default: function () {
            return c.a.weeksTransition;
          }
        },
        paneWidth: Number,
        hideLeftButton: Boolean,
        hideRightButton: Boolean
      },
      data: function () {
        return {
          todayComps: f.x,
          pages: [],
          page_: null,
          transitionDirection: "",
          touchState: {},
          navForceHidden: !1,
          weeksTransitioning: !1,
          moveTimeout: null
        };
      },
      computed: {
        navSlots: function () {
          var t = this;
          return ["nav-left-button", "nav-right-button"].filter(function (e) {
            return t.$scopedSlots[e];
          });
        },
        weekdayLabels: function () {
          var t = this;
          return Object(l.q)({
            firstDayOfWeek: c.a.firstDayOfWeek
          }).map(function (e) {
            return Object(d.a)(e, t.formats.weekdays);
          });
        },
        titleClass: function () {
          return this.titlePosition ? "align-" + this.titlePosition : "";
        },
        titleTransition_: function () {
          return this.getTransitionName("title", this.titleTransition, this.transitionDirection);
        },
        weeksTransition_: function () {
          return this.getTransitionName("weeks", this.weeksTransition, this.transitionDirection);
        },
        paneStyle: function () {
          return {
            minWidth: this.paneWidth + "px"
          };
        },
        headerStyle: function () {
          return Object(l.c)(this.styles.header, this.page_);
        },
        titleStyle: function () {
          return Object(l.c)(this.styles.headerTitle, this.page_);
        },
        arrowStyle: function () {
          return Object(l.c)(this.styles.headerArrows, this.page_);
        },
        headerHorizontalDividerStyle_: function () {
          return Object(l.c)(this.styles.headerHorizontalDivider, this.page_);
        },
        weekdaysStyle_: function () {
          return Object(l.c)(this.styles.weekdays, this.page_);
        },
        weekdaysHorizontalDividerStyle_: function () {
          return Object(l.c)(this.styles.weekdaysHorizontalDivider, this.page_);
        },
        weeksStyle_: function () {
          return i()({}, Object(l.c)(this.styles.weeks, this.page_), this.weeksTransitioning ? {
            overflow: "hidden"
          } : null);
        },
        navWrapperStyle: function () {
          return i()({
            padding: "1px"
          }, Object(l.c)(this.styles.navWrapper, this.page_));
        },
        canMovePrevMonth: function () {
          return this.canMove(this.page_.prevMonthComps);
        },
        canMoveNextMonth: function () {
          return this.canMove(this.page_.nextMonthComps);
        }
      },
      watch: {
        page: function (t) {
          this.move(t);
        },
        page_: function (t, e) {
          this.transitionDirection = this.getTransitionDirection(e, t);
        }
      },
      created: function () {
        this.page ? this.page_ = this.loadPage(this.page) : (this.page_ = this.loadPage(f.x), this.$emit("update:page", this.page_)), this.preloadPages();
      },
      methods: {
        navPageSelected: function (t) {
          this.navForceHidden = !0, this.move(t);
        },
        monthIsDisabled: function (t) {
          return this.minPage && this.yearNumber === this.minPage.year ? t < this.minPage.month : !(!this.maxPage || this.yearNumber !== this.maxPage.year) && t > this.maxPage.month;
        },
        yearIsDisabled: function (t) {
          return !!(this.minPage && t < this.minPage.year) || !!(this.maxPage && t > this.maxPage.year);
        },
        touchStart: function (t) {
          var e = t.changedTouches[0];
          this.touchState = {
            active: !0,
            startX: e.screenX,
            startY: e.screenY,
            startTime: new Date().getTime(),
            isSwiping: !1,
            isMonitoringSwipe: !0
          };
        },
        touchMove: function (t) {
          if (this.touchState.isMonitoringSwipe) {
            if (new Date().getTime() - this.touchState.startTime <= 5) t.preventDefault();else {
              var e = t.changedTouches[0],
                  n = e.screenX - this.touchState.startX,
                  r = e.screenY - this.touchState.startY;
              Math.abs(n) >= Math.abs(r) && (this.touchState.isSwiping = !0, t.preventDefault()), this.touchState.isMonitoringSwipe = !1;
            }
          } else this.touchState.isSwiping && t.preventDefault();
        },
        touchEnd: function (t) {
          var e = t.changedTouches[0],
              n = e.screenX - this.touchState.startX,
              r = e.screenY - this.touchState.startY;
          new Date().getTime() - this.touchState.startTime < c.a.maxSwipeTime && Math.abs(n) >= c.a.minHorizontalSwipeDistance && Math.abs(r) <= c.a.maxVerticalSwipeDistance && (n < 0 ? this.moveNextMonth() : this.movePrevMonth());
        },
        canMove: function (t) {
          return (!this.minPage || !Object(f.u)(t, this.minPage)) && (!this.maxPage || !Object(f.t)(t, this.maxPage));
        },
        movePrevYear: function () {
          this.move({
            month: this.page_.month,
            year: this.page_.year - 1
          });
        },
        movePrevMonth: function () {
          this.move(this.page_.prevMonthComps);
        },
        moveThisMonth: function () {
          this.move(f.x);
        },
        moveNextMonth: function () {
          this.move(this.page_.nextMonthComps);
        },
        moveNextYear: function () {
          this.move({
            month: this.page_.month,
            year: this.page_.year + 1
          });
        },
        move: function (t) {
          this.canMove(t) ? this.forceMove(t) : Object(f.u)(f.x, this.minPage) ? this.forceMove(this.minPage) : Object(f.t)(t, this.maxPage) && this.forceMove(this.maxPage);
        },
        forceMove: function (t) {
          var e = new Date();
          this.moveTimeout && e < this.moveTimeout || (this.moveTimeout = new Date(e.getTime() + 250), !t || t.month === this.page_.month && t.year === this.page_.year || (this.page_ = this.loadPage(t), this.$emit("update:page", this.page_), this.preloadPages()));
        },
        loadPage: function (t) {
          var e = this,
              n = t.month,
              r = t.year,
              i = r.toString() + "." + n.toString(),
              a = this.pages.find(function (t) {
            return t.key === i;
          });

          if (!a) {
            var o = new Date(r, n - 1, 15),
                s = Object(f.i)(n, r),
                u = Object(f.o)(n, r),
                c = Object(f.k)(n, r);
            a = {
              key: i,
              month: n,
              year: r,
              title: Object(d.a)(o, this.formats.title),
              shortMonthLabel: Object(d.a)(o, "MMM"),
              monthLabel: Object(d.a)(o, "MMMM"),
              shortYearLabel: r.toString().substring(2),
              yearLabel: r.toString(),
              monthComps: s,
              prevMonthComps: u,
              nextMonthComps: c,
              canMove: function (t) {
                return e.canMove(t);
              },
              move: function (t) {
                return e.move(t);
              },
              moveThisMonth: function () {
                return e.moveThisMonth();
              },
              movePrevMonth: function () {
                return e.move(u);
              },
              moveNextMonth: function () {
                return e.move(c);
              }
            }, this.pages.push(a);
          }

          return a.position = this.position, a.loaded = !0, a;
        },
        preloadPages: function () {
          var t = this;
          this.$nextTick(function () {
            t.loadPage(t.page_.prevMonthComps), t.loadPage(t.page_.nextMonthComps), t.pages = t.pages.filter(function (t) {
              return t.loaded;
            }), t.pages.forEach(function (t) {
              t.loaded = !1;
            });
          });
        },
        getTransitionDirection: function (t, e) {
          return t && e ? t.year !== e.year ? t.year < e.year ? "next" : "prev" : t.month !== e.month ? t.month < e.month ? "next" : "prev" : "" : "";
        },
        getTransitionName: function (t, e, n) {
          return "slide-h" === e ? t + "-" + ("next" === n ? "slide-left" : "slide-right") : "slide-v" === e ? t + "-" + ("next" === n ? "slide-up" : "slide-down") : t + "-" + e;
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(96),
        i = n.n(r),
        a = n(3),
        o = n(100),
        s = n(2),
        u = n(47);
    e.a = {
      props: {
        isExpanded: {
          type: Boolean,
          default: function () {
            return a.a.popoverExpanded;
          }
        },
        direction: {
          type: String,
          default: function () {
            return a.a.popoverDirection;
          }
        },
        align: {
          type: String,
          default: function () {
            return a.a.popoverAlign;
          }
        },
        visibility: {
          type: String,
          default: function () {
            return a.a.popoverVisibility;
          }
        },
        isInteractive: Boolean,
        forceHidden: Boolean,
        toggleVisibleOnClick: Boolean,
        contentStyle: Object,
        contentOffset: {
          type: Number,
          default: function () {
            return a.a.popoverContentOffset;
          }
        },
        transition: {
          type: String,
          default: "slide-fade"
        },
        showClearMargin: Boolean
      },
      data: function () {
        return {
          hoverVisible: !1,
          focusVisible: !1,
          clearMargin: 0,
          contentTransitioning: !1,
          contentTransitioningCancelled: !1,
          disableNextClick: !1,
          windowTapClickRegistration: null
        };
      },
      computed: {
        containerStyle: function () {
          return this.visible && i()({}, "margin-" + this.direction, this.clearMargin + "px");
        },
        contentWrapperStyle: function () {
          var t = {};
          return t["padding" + this.contentOffsetDirection] = this.contentOffset + "px", t;
        },
        contentOffsetDirection: function () {
          switch (this.direction) {
            case "bottom":
              return "Top";

            case "top":
              return "Bottom";

            case "left":
              return "Right";

            case "right":
              return "Left";

            default:
              return "";
          }
        },
        visibilityIsManaged: function () {
          return u.a.isManaged(this.visibility);
        },
        visible: function () {
          return this.visibility === u.a.HOVER ? this.hoverVisible : this.visibility === u.a.FOCUS ? this.focusVisible : this.visibility === u.a.VISIBLE;
        }
      },
      watch: {
        forceHidden: function () {
          this.hoverVisible || this.focusVisible ? (this.hoverVisible = !1, this.focusVisible = !1) : (this.$emit("update:forcehidden", !1), this.$emit("update:forceHidden", !1));
        }
      },
      created: function () {
        this.windowTapClickRegistration = Object(o.a)(window, this.windowTapOrClick);
      },
      mounted: function () {
        this.refreshClearMargin();
      },
      beforeDestroy: function () {
        this.windowTapClickRegistration.cleanup();
      },
      methods: {
        focusin: function (t) {
          this.contentTransitioning || (this.focusVisible || this.$emit("got-focus", t), this.focusVisible = !0, this.disableNextClick = !0);
        },
        focusout: function (t) {
          Object(s.b)(t.relatedTarget, this.$refs.popover) || (this.$emit("lost-focus", t), this.focusVisible = !1);
        },
        click: function (t) {
          !this.toggleVisibleOnClick || this.contentTransitioning || !Object(s.b)(t.target, this.$refs.popover) || Object(s.b)(t.target, this.$refs.popoverOrigin) || this.disableNextClick || (this.focusVisible = !this.focusVisible), this.disableNextClick = !1;
        },
        mousemove: function () {
          this.forceHidden || this.contentTransitioning || (this.hoverVisible = !0);
        },
        mouseleave: function (t) {
          this.forceHidden || Object(s.b)(t.relatedTarget, this.$refs.popover) || (this.hoverVisible = !1);
        },
        windowTapOrClick: function (t) {
          Object(s.b)(t.target, this.$refs.popover) || (this.hoverVisible = !1, this.focusVisible = !1);
        },
        refreshClearMargin: function () {
          if (this.showClearMargin && this.visible && this.$refs.popoverContent) {
            var t = this.$refs.popoverContent.getBoundingClientRect(),
                e = t.width,
                n = t.height,
                r = ("left" === this.direction || "right" === this.direction) && e || n;
            this.clearMargin = r + this.contentOffset;
          } else this.clearMargin = 0;
        },
        beforeContentEnter: function () {
          this.contentTransitioning = !0, this.$emit("will-appear");
        },
        contentEnter: function () {
          this.refreshClearMargin();
        },
        afterContentEnter: function () {
          this.contentTransitioning = !1, this.$emit("did-appear");
        },
        contentLeave: function () {
          this.refreshClearMargin();
        },
        beforeContentLeave: function () {
          this.contentTransitioningCancelled = this.contentTransitioning, this.contentTransitioning = !0, this.$emit("will-disappear", this.contentTransitioningCancelled);
        },
        afterContentLeave: function () {
          this.contentTransitioning = !1, this.$emit("did-disappear", this.contentTransitioningCancelled), this.contentTransitioningCancelled = !1, this.forceHidden && (this.$emit("update:forcehidden", !1), this.$emit("update:forceHidden", !1));
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    n.d(e, "a", function () {
      return r;
    });
    var r = {
      HOVER: "hover",
      FOCUS: "focus",
      HIDDEN: "hidden",
      VISIBLE: "visible",
      isManual: function (t) {
        return "hidden" === t || "visible" === t;
      },
      isManaged: function (t) {
        return "hover" === t || "focus" === t;
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(104),
        i = n(2);
    e.a = {
      components: {
        CalendarDay: r.a
      },
      props: {
        monthComps: Object,
        prevMonthComps: Object,
        nextMonthComps: Object,
        trimMaxWeek: Boolean
      },
      computed: {
        weeks: function () {
          for (var t = [], e = this.monthComps, n = e.firstDayOfWeek, r = e.firstWeekday, a = r + (r < n ? 7 : 0) - n, o = !0, s = !1, u = !1, c = this.prevMonthComps.days - a + 1, l = this.prevMonthComps.days - c + 1, d = Math.floor((c - 1) / 7 + 1), f = 1, h = this.prevMonthComps.weeks, p = 1, v = this.prevMonthComps.month, y = this.prevMonthComps.year, m = 1; m <= 6 && (!u || !this.trimMaxWeek); m++) {
            for (var b = [], g = 1, D = n; g <= 7; g++, D += 7 === D ? -6 : 1) {
              o && D === r && (c = 1, l = this.monthComps.days, d = Math.floor((c - 1) / 7 + 1), f = Math.floor((this.monthComps.days - c) / 7 + 1), h = 1, p = this.monthComps.weeks, v = this.monthComps.month, y = this.monthComps.year, o = !1, s = !0);

              var w = new Date(y, v - 1, c),
                  _ = c === i.x.day && v === i.x.month && y === i.x.year,
                  O = s && 1 === c,
                  C = s && c === this.monthComps.days;

              b.push({
                id: v + "." + c,
                label: c.toString(),
                day: c,
                dayFromEnd: l,
                weekday: D,
                weekdayOrdinal: d,
                weekdayOrdinalFromEnd: f,
                week: h,
                weekFromEnd: p,
                month: v,
                year: y,
                date: w,
                dateTime: w.getTime(),
                isToday: _,
                isFirstDay: O,
                isLastDay: C,
                inMonth: s,
                inPrevMonth: o,
                inNextMonth: u
              }), s && C ? (s = !1, u = !0, c = 1, l = this.nextMonthComps.days, d = 1, f = Math.floor((this.nextMonthComps.days - c) / 7 + 1), h = 1, p = this.nextMonthComps.weeks, v = this.nextMonthComps.month, y = this.nextMonthComps.year) : (c++, l--, d = Math.floor((c - 1) / 7 + 1), f = Math.floor((this.monthComps.days - c) / 7 + 1));
            }

            t.push(b), h++, p--;
          }

          return t;
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(31),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(22),
        u = n(106),
        c = n(2),
        l = n(4),
        d = n(3);
    e.a = {
      components: {
        Popover: s.a,
        CalendarDayPopoverRow: u.a
      },
      props: {
        day: {
          type: Object,
          required: !0
        },
        attributes: Object,
        popoverContentOffset: {
          type: Number,
          default: 7
        },
        styles: Object,
        formats: Object
      },
      data: function () {
        return {
          isHovered: !1,
          isFocused: !1,
          glyphs: {}
        };
      },
      computed: {
        label: function () {
          return this.day.label;
        },
        dateTime: function () {
          return this.day.dateTime;
        },
        inMonth: function () {
          return this.day.inMonth;
        },
        dayCellStyle: function () {
          return o()({}, this.styles.dayCell, !this.inMonth && this.styles.dayCellNotInMonth);
        },
        attributesLength: function () {
          return this.attributes.length;
        },
        attributesList: function () {
          return this.attributes.find(this.day);
        },
        attributesMap: function () {
          return Object(c.s)(this.attributesList);
        },
        shouldCheckDirty: function () {
          return this.attributesLength && !!this.attributesList.find(function (t) {
            return Object(l.c)(t.highlight) || Object(l.c)(t.highlightCaps) || Object(l.c)(t.dot) || Object(l.c)(t.bar) || Object(l.c)(t.popover) || Object(l.c)(t.contentStyle);
          });
        },
        isHoveredDirty: function () {
          return this.shouldCheckDirty && this.isHovered;
        },
        isFocusedDirty: function () {
          return this.shouldCheckDirty && this.isFocused;
        },
        backgrounds: function () {
          return this.glyphs.backgrounds;
        },
        hasBackgrounds: function () {
          return !!Object(c.a)(this.backgrounds);
        },
        dots: function () {
          return this.glyphs.dots;
        },
        hasDots: function () {
          return !!Object(c.a)(this.dots);
        },
        dotsStyle: function () {
          return this.styles.dots;
        },
        bars: function () {
          return this.glyphs.bars;
        },
        hasBars: function () {
          return !!Object(c.a)(this.bars);
        },
        barsStyle: function () {
          return this.styles.bars;
        },
        popovers: function () {
          return this.glyphs.popovers;
        },
        hasPopovers: function () {
          return !!Object(c.a)(this.popovers);
        },
        popoverContentStyle: function () {
          return this.styles.dayPopoverContent;
        },
        popoverState: function () {
          var t = "",
              e = !1,
              n = void 0;
          return this.popovers.forEach(function (r) {
            !t && r.visibility && (t = r.visibility), e = e || r.isInteractive, n = n || r.label || r.component || r.slot;
          }), {
            visibility: t || n && "hover" || "hidden",
            isInteractive: e
          };
        },
        popoverVisibility: function () {
          return this.popoverState.visibility;
        },
        popoverIsInteractive: function () {
          return this.popoverState.isInteractive;
        },
        contentStyle: function () {
          var t = this.styles.dayContent,
              e = this.dayCellStyle && (0 === parseFloat(this.dayCellStyle.opacity) || "none" === this.dayCellStyle.pointerEvents);
          return o()({}, Object(l.c)(t) && t({
            day: this.day,
            isHovered: this.isHovered,
            isFocused: this.isFocused
          }) || t, this.glyphs.contentStyle, e && {
            pointerEvents: "none"
          });
        }
      },
      watch: {
        isHoveredDirty: function () {
          this.refreshGlyphs();
        },
        isFocusedDirty: function () {
          this.refreshGlyphs();
        },
        attributesList: function (t, e) {
          t.forEach(function (t) {
            t.isNew = !e.find(function (e) {
              return e.key === t.key;
            });
          }), this.refreshGlyphs();
        }
      },
      created: function () {
        this.refreshGlyphs();
      },
      methods: {
        getDayEvent: function (t) {
          return o()({}, this.day, {
            attributes: this.attributesList,
            attributesMap: this.attributesMap,
            event: t
          });
        },
        click: function (t) {
          this.$emit("dayclick", this.getDayEvent(t));
        },
        mouseenter: function (t) {
          this.$emit("daymouseenter", this.getDayEvent(t));
        },
        mouseover: function (t) {
          this.isHovered = !0, this.$emit("daymouseover", this.getDayEvent(t));
        },
        mouseleave: function (t) {
          this.isHovered = !1, this.$emit("daymouseleave", this.getDayEvent(t));
        },
        refreshGlyphs: function () {
          var t = this;
          this.glyphs = (this.attributesList || []).map(function (e) {
            return t.evalAttribute(e, t.isHoveredDirty, t.isFocusedDirty);
          }).reduce(function (e, n) {
            var r = n.highlight,
                a = n.highlightCaps,
                o = n.onStart,
                s = n.onEnd,
                u = n.dot,
                c = n.bar,
                l = n.popover,
                d = e.backgrounds,
                f = e.dots,
                h = e.bars,
                p = e.popovers,
                v = e.contentStyle;
            return !r || o && s && a || d.push(t.getBackground(n)), a && (o || s) && d.push(t.getBackgroundCap(n)), u && f.push(t.getDot(n)), c && h.push(t.getBar(n)), l && p.unshift(t.getPopover(n)), i()(v, n.contentStyle), e;
          }, {
            backgrounds: [],
            dots: [],
            bars: [],
            popovers: [],
            contentStyle: {}
          });
        },
        evalAttribute: function (t, e, n) {
          var r = this,
              i = t.targetDate,
              a = i.startTime === this.dateTime,
              s = i.endTime === this.dateTime,
              u = !a && !s,
              f = function (t) {
            return Object(l.c)(t) && t({
              day: r.day,
              targetDate: i,
              onStart: a,
              onEnd: s,
              inBetween: u,
              isHovered: e,
              isFocused: n
            }) || Object(l.e)(t) && t;
          };

          return Object(c.r)(t, o()({}, t, {
            onStart: a,
            onEnd: s,
            inBetween: u
          }), [{
            name: "highlight",
            mixin: d.a.highlight,
            validate: f
          }, {
            name: "highlightCaps",
            mixin: d.a.highlightCaps,
            validate: f
          }, {
            name: "dot",
            mixin: d.a.dot,
            validate: f
          }, {
            name: "bar",
            mixin: d.a.bar,
            validate: f
          }, {
            name: "contentStyle",
            validate: f
          }, {
            name: "popover",
            validate: f
          }, {
            name: "customData"
          }]).target;
        },
        getBackground: function (t) {
          var e = t.key,
              n = t.highlight,
              r = t.highlightCaps,
              i = t.targetDate,
              a = n.animated,
              o = n.width,
              s = n.height,
              u = n.backgroundColor,
              c = n.borderColor,
              l = n.borderWidth,
              d = n.borderStyle,
              f = n.opacity,
              h = n.borderRadius || (i.isDate || i.isComplex ? "50%" : "290486px"),
              p = {
            key: e,
            style: {
              width: o || s,
              height: s,
              backgroundColor: u,
              borderColor: c,
              borderWidth: l,
              borderStyle: d,
              borderRadius: h,
              opacity: f
            }
          };
          if (i.isDate || i.isComplex) p.wrapperClass = "c-day-layer c-day-box-center-center " + (a ? "c-day-scale-enter c-day-scale-leave" : "");else {
            var v = i.startTime === this.dateTime,
                y = i.endTime === this.dateTime;

            if (v && y) {
              var m = a ? "c-day-scale-enter c-day-scale-leave" : "";
              p.wrapperClass = "c-day-layer c-day-box-center-center " + m, p.style.width = "95%", p.style.borderWidth = l, p.style.borderRadius = h + " " + h + " " + h + " " + h;
            } else if (v) {
              var b = a && !r ? "c-day-slide-left-scale-enter" : "";
              p.wrapperClass = "c-day-layer c-day-box-right-center shift-right " + b, r ? (p.style.width = "50%", p.style.borderWidth = l + " 0 " + l + " 0", p.style.borderRadius = 0) : (p.style.width = "95%", p.style.borderWidth = l + " 0 " + l + " " + l, p.style.borderRadius = h + " 0 0 " + h);
            } else if (y) {
              var g = a && !r ? "c-day-slide-right-scale-enter" : "";
              p.wrapperClass = "c-day-layer c-day-box-left-center shift-left " + g, r ? (p.style.width = "50%", p.style.borderWidth = l + " 0 " + l + " 0", p.style.borderRadius = 0) : (p.style.width = "95%", p.style.borderWidth = l + " " + l + " " + l + " 0", p.style.borderRadius = "0 " + h + " " + h + " 0");
            } else p.wrapperClass = "c-day-layer c-day-box-center-center shift-left-right", p.style.width = "100%", p.style.borderWidth = l + " 0", p.style.borderRadius = "0";
          }
          return p;
        },
        getBackgroundCap: function (t) {
          var e = t.key,
              n = t.highlightCaps,
              r = t.targetDate,
              i = t.isNew,
              a = r.startTime,
              o = r.endTime,
              s = n.animated,
              u = n.width,
              c = n.height,
              l = n.backgroundColor,
              d = n.borderColor,
              f = n.borderWidth,
              h = n.borderStyle,
              p = n.opacity,
              v = n.borderRadius || "50%",
              y = "";
          return s && (a === o ? y = "c-day-scale-enter c-day-scale-leave" : a === this.dateTime ? y = i ? "c-day-slide-left-translate-enter" : "c-day-slide-right-translate-enter" : o === this.dateTime && (y = i ? "c-day-slide-right-translate-enter" : "c-day-slide-left-translate-enter")), {
            key: e + "-cap",
            wrapperClass: "c-day-layer c-day-box-center-center " + (s ? y : ""),
            style: {
              width: u || c,
              height: c,
              backgroundColor: l,
              borderColor: d,
              borderWidth: f,
              borderStyle: h,
              borderRadius: v,
              opacity: p
            }
          };
        },
        getDot: function (t) {
          var e = t.key,
              n = t.dot;
          return {
            key: e,
            style: {
              width: n.diameter,
              height: n.diameter,
              backgroundColor: n.backgroundColor,
              borderColor: n.borderColor,
              borderWidth: n.borderWidth,
              borderStyle: n.borderStyle,
              borderRadius: n.borderRadius,
              opacity: n.opacity
            }
          };
        },
        getBar: function (t) {
          var e = t.key,
              n = t.bar;
          return {
            key: e,
            style: {
              height: n.height,
              backgroundColor: n.backgroundColor,
              borderColor: n.borderColor,
              borderWidth: n.borderWidth,
              borderStyle: n.borderStyle,
              opacity: n.opacity
            }
          };
        },
        getPopover: function (t) {
          var e = t.popover,
              n = e.label,
              r = e.labelStyle,
              i = e.component,
              a = e.slot,
              o = e.hideIndicator,
              s = e.visibility,
              u = e.isInteractive;
          return {
            key: t.key,
            customData: t.customData,
            attribute: t,
            label: Object(l.c)(n) ? n(t, this.day) : n,
            labelStyle: Object(l.c)(r) ? r(t, this.day) : r,
            component: i,
            slot: a,
            hideIndicator: o,
            visibility: s,
            isInteractive: void 0 !== u ? u : !!a
          };
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    e.a = {
      props: {
        attribute: Object,
        hideIndicator: Boolean
      },
      computed: {
        isSelectable: function () {
          return this.$listeners.select;
        },
        indicatorStyle: function () {
          var t = this.attribute;
          return t.highlight ? {
            backgroundColor: t.highlight.backgroundColor,
            width: "10px",
            height: "5px",
            borderRadius: "3px",
            opacity: t.highlight.opacity
          } : t.dot ? {
            backgroundColor: t.dot.backgroundColor,
            width: "5px",
            height: "5px",
            borderRadius: "50%",
            opacity: t.dot.opacity
          } : t.bar ? {
            backgroundColor: t.bar.backgroundColor,
            width: "10px",
            height: "3px",
            opacity: t.bar.opacity
          } : t.contentStyle ? {
            backgroundColor: t.contentStyle.color,
            width: "5px",
            height: "5px"
          } : null;
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(0),
        i = n.n(r),
        a = n(14),
        o = n.n(a),
        s = n(113),
        u = n.n(s),
        c = n(33),
        l = n(23),
        d = n(8),
        f = n(2);
    e.a = {
      components: {
        SvgIcon: c.a
      },
      props: {
        mode: {
          type: String,
          default: "month"
        },
        value: {
          type: Object,
          default: function () {
            return {
              month: 0,
              year: 0
            };
          }
        },
        validator: {
          type: Function,
          default: function () {
            return function () {
              return !0;
            };
          }
        },
        formats: Object,
        attributes: Array,
        styles: Object
      },
      data: function () {
        return {
          mode_: "",
          yearIndex: 0,
          yearGroupIndex: 0,
          attributesMap: {}
        };
      },
      computed: {
        month: function () {
          return this.value ? this.value.month || 0 : 0;
        },
        year: function () {
          return this.value ? this.value.year || 0 : 0;
        },
        headerStyle: function () {
          return this.styles.navHeader;
        },
        headerTitleStyle: function () {
          return this.styles.navHeaderTitle;
        },
        headerArrowsStyle: function () {
          return this.styles.navHeaderArrows;
        },
        monthItems: function () {
          var t = this;
          return Object(f.j)().map(function (e) {
            return Object(d.a)(e, t.formats.navMonths);
          }).map(function (e, n) {
            var r = n + 1;
            return {
              month: r,
              label: e,
              attributes: t.getMonthAttributes(r),
              isActive: r === t.month && t.yearIndex === t.year,
              isDisabled: !t.validator({
                month: r,
                year: t.yearIndex
              })
            };
          });
        },
        yearItems: function () {
          for (var t = 12 * this.yearGroupIndex, e = t + 12, n = [], r = t; r < e; r += 1) n.push({
            month: 0,
            year: r,
            isActive: r === this.year,
            isDisabled: !this.validator({
              month: this.month,
              year: r
            })
          });

          return n;
        },
        monthRows: function () {
          return this.createRows(this.monthItems, 3);
        },
        yearRows: function () {
          return this.createRows(this.yearItems, 3);
        },
        firstYear: function () {
          return Object(f.e)(this.yearItems.map(function (t) {
            return t.year;
          }), 0);
        },
        lastYear: function () {
          return Object(f.g)(this.yearItems.map(function (t) {
            return t.year;
          }), 0);
        }
      },
      watch: {
        mode: function (t) {
          this.mode_ = t;
        },
        year: function () {
          this.yearIndex = this.year;
        },
        yearIndex: function (t) {
          this.yearGroupIndex = this.getYearGroupIndex(t);
        },
        attributes: function () {
          this.mapAttributes(!0);
        },
        yearGroupIndex: function () {
          this.mapAttributes();
        }
      },
      created: function () {
        this.mode_ = this.mode, this.yearIndex = this.year;
      },
      methods: {
        getMonthCellStyle: function (t) {
          return Object(f.c)(this.styles.navMonthCell, t);
        },
        getYearCellStyle: function (t) {
          return Object(f.c)(this.styles.navYearCell, t);
        },
        getMonthAttributes: function (t) {
          if (this.attributesMap[this.yearIndex] && this.attributesMap[this.yearIndex][t]) return u()(this.attributesMap[this.yearIndex][t]);
        },
        mapAttributes: function (t) {
          var e = this;

          if (this.attributes && this.attributes.length) {
            for (var n = t ? {} : this.attributesMap, r = this.firstYear; r <= this.lastYear; r++) if (!n[r]) {
              for (var a = {}, s = function (t) {
                var n = {},
                    i = Object(f.i)(t, r),
                    s = new l.b({
                  start: new Date(i.year, i.month - 1, 1),
                  end: new Date(i.year, i.month - 1, i.days)
                });
                e.attributes.forEach(function (t) {
                  t.dates.find(function (t) {
                    return t.intersects(s);
                  }) && (n[t.key] = e.getAttributeInfo(t));
                }), o()(n).length && (a[t] = n);
              }, u = 1; u <= 12; u++) s(u);

              o()(a).length && (n[r] = a);
            }

            this.attributesMap = i()({}, n);
          } else this.attributesMap = {};
        },
        getAttributeInfo: function (t) {
          var e = void 0;
          return t.highlight ? e = t.highlight.backgroundColor : t.dot ? e = t.dot.backgroundColor : t.bar ? e = t.bar.backgroundColor : t.contentStyle && (e = t.contentStyle.backgroundColor || t.contentStyle.color), {
            key: t.key,
            style: {
              backgroundColor: e
            }
          };
        },
        getYearGroupIndex: function (t) {
          return Math.floor(t / 12);
        },
        monthClick: function (t) {
          this.$emit("input", {
            month: t,
            year: this.yearIndex
          });
        },
        yearClick: function (t) {
          this.yearIndex = t, this.selectMode("month");
        },
        selectMode: function (t) {
          this.mode_ = t, this.$emit("update:mode", t);
        },
        movePrevYear: function () {
          this.yearIndex--;
        },
        moveNextYear: function () {
          this.yearIndex++;
        },
        movePrevYearGroup: function () {
          this.yearGroupIndex--;
        },
        moveNextYearGroup: function () {
          this.yearGroupIndex++;
        },
        createRows: function (t, e) {
          var n = [],
              r = [];
          return t.forEach(function (t) {
            r.push(t), r.length >= e && (n.push(r), r = []);
          }), n;
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = {
      leftArrow: {
        viewBox: "3 2 12 32",
        path: "M11.196 10c0 0.143-0.071 0.304-0.179 0.411l-7.018 7.018 7.018 7.018c0.107 0.107 0.179 0.268 0.179 0.411s-0.071 0.304-0.179 0.411l-0.893 0.893c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-8.321-8.321c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l8.321-8.321c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l0.893 0.893c0.107 0.107 0.179 0.25 0.179 0.411z"
      },
      rightArrow: {
        viewBox: "-2 1 11 32",
        path: "M10.625 17.429c0 0.143-0.071 0.304-0.179 0.411l-8.321 8.321c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-0.893-0.893c-0.107-0.107-0.179-0.25-0.179-0.411 0-0.143 0.071-0.304 0.179-0.411l7.018-7.018-7.018-7.018c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l0.893-0.893c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l8.321 8.321c0.107 0.107 0.179 0.268 0.179 0.411z"
      },
      moon: {
        viewBox: "0 0 26 32",
        path: "M22.536 23.554c-0.643 0.107-1.304 0.161-1.964 0.161-6.625 0-12-5.375-12-12 0-2.268 0.661-4.482 1.857-6.375-4.75 1.411-8.143 5.768-8.143 10.946 0 6.304 5.125 11.429 11.429 11.429 3.446 0 6.679-1.571 8.821-4.161zM26.161 22.036c-2.232 4.839-7.125 7.964-12.446 7.964-7.554 0-13.714-6.161-13.714-13.714 0-7.411 5.804-13.429 13.196-13.696 0.5-0.018 0.911 0.268 1.089 0.696 0.196 0.446 0.071 0.964-0.268 1.286-2.036 1.857-3.161 4.393-3.161 7.143 0 5.357 4.357 9.714 9.714 9.714 1.411 0 2.768-0.304 4.071-0.911 0.446-0.196 0.946-0.107 1.286 0.232s0.429 0.857 0.232 1.286z"
      },
      sun: {
        viewBox: "0 0 32 32",
        path: "M26.286 16.286c0-5.679-4.607-10.286-10.286-10.286s-10.286 4.607-10.286 10.286 4.607 10.286 10.286 10.286 10.286-4.607 10.286-10.286zM31.214 21.232c-0.054 0.179-0.196 0.304-0.357 0.357l-5.214 1.714v5.464c0 0.179-0.089 0.357-0.232 0.464-0.161 0.107-0.339 0.143-0.518 0.071l-5.214-1.679-3.214 4.429c-0.107 0.143-0.286 0.232-0.464 0.232s-0.357-0.089-0.464-0.232l-3.214-4.429-5.214 1.679c-0.179 0.071-0.357 0.036-0.518-0.071-0.143-0.107-0.232-0.286-0.232-0.464v-5.464l-5.214-1.714c-0.161-0.054-0.304-0.179-0.357-0.357s-0.036-0.375 0.071-0.518l3.214-4.429-3.214-4.429c-0.107-0.161-0.125-0.339-0.071-0.518s0.196-0.304 0.357-0.357l5.214-1.714v-5.464c0-0.179 0.089-0.357 0.232-0.464 0.161-0.107 0.339-0.143 0.518-0.071l5.214 1.679 3.214-4.429c0.214-0.286 0.714-0.286 0.929 0l3.214 4.429 5.214-1.679c0.179-0.071 0.357-0.036 0.518 0.071 0.143 0.107 0.232 0.286 0.232 0.464v5.464l5.214 1.714c0.161 0.054 0.304 0.179 0.357 0.357s0.036 0.357-0.071 0.518l-3.214 4.429 3.214 4.429c0.107 0.143 0.125 0.339 0.071 0.518z"
      }
    };
    e.a = {
      props: ["name"],
      data: function () {
        return {
          width: "26px",
          height: "26px",
          viewBox: "0 0 32 32",
          path: "",
          isBaseline: !1
        };
      },
      mounted: function () {
        this.updateIcon();
      },
      watch: {
        name: function () {
          this.updateIcon();
        }
      },
      methods: {
        updateIcon: function () {
          var t = r[this.name];
          t && (this.width = t.width || "26px", this.height = t.height || "26px", this.viewBox = t.viewBox || "0 0 32 32", this.path = t.path);
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(0),
        i = n.n(r),
        a = n(23),
        o = n(2),
        s = n(4);

    e.a = function (t) {
      if (!t) return null;
      if (t.isAttribute) return t;
      t.dates && !Object(s.a)(t.dates) && (t.dates = [t.dates]), t.excludeDates && !Object(s.a)(t.excludeDates) && (t.excludeDates = [t.excludeDates]);
      var e = Object(o.a)(t.dates),
          n = Object(o.a)(t.excludeDates),
          r = t.excludeMode || "intersects",
          u = (e && t.dates || n && [{}] || []).map(function (e) {
        return e && (e.isDateInfo ? e : Object(a.b)(e, t.order));
      }).filter(function (t) {
        return t;
      }),
          c = (n && t.excludeDates || []).map(function (e) {
        return e && (e.isDateInfo ? e : Object(a.b)(e, t.order));
      }).filter(function (t) {
        return t;
      }),
          l = u.some(function (t) {
        return t.isComplex;
      }),
          d = i()({}, t, {
        isAttribute: !0,
        key: t.key || "guid",
        order: t.order || 0,
        dates: u,
        excludeDates: c,
        isComplex: l,
        intersectsDate: function (t) {
          return !d.excludesDate(t) && (u.find(function (e) {
            return e.intersectsDate(t);
          }) || !1);
        },
        includesDate: function (t) {
          return !d.excludesDate(t) && (u.find(function (e) {
            return e.includesDate(t);
          }) || !1);
        },
        excludesDate: function (t) {
          return n && c.find(function (e) {
            return "intersects" === r && e.intersectsDate(t) || "includes" === r && e.includesDate(t);
          });
        },
        includesDay: function (t) {
          return !d.excludesDay(t) && (u.find(function (e) {
            return e.includesDay(t);
          }) || !1);
        },
        excludesDay: function (t) {
          return n && c.find(function (e) {
            return e.includesDay(t);
          });
        }
      });
      return d;
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(12),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(22),
        u = n(123),
        c = n(124),
        l = n(125),
        d = n(126),
        f = n(24),
        h = n(53),
        p = n(3),
        v = n(23),
        y = n(2),
        m = n(4),
        b = n(8),
        g = n(13);
    e.a = {
      mixins: [g.a],
      render: function (t) {
        var e = this,
            n = function (n) {
          return t(e.componentName, o()({
            attrs: o()({}, e.$attrs, {
              value: e.value,
              isRequired: e.isRequired,
              formats: e.formats_,
              selectAttribute: e.selectAttribute_,
              dragAttribute: e.dragAttribute_,
              disabledAttribute: e.disabledAttribute_,
              minDate: e.minDate,
              maxDate: e.maxDate,
              fromPage: e.fromPage_,
              toPage: e.toPage_,
              themeStyles: e.themeStyles_
            }),
            on: e.mergeListeners({
              "update:fromPage": function (t) {
                return e.fromPage_ = t;
              },
              "update:toPage": function (t) {
                return e.toPage_ = t;
              },
              drag: function (t) {
                return e.dragValue = t;
              }
            }, e.filteredListeners()),
            slots: e.$slots,
            scopedSlots: e.$scopedSlots
          }, n && {
            slot: n
          }));
        };

        return this.isInline ? n() : t("popover", {
          attrs: {
            isExpanded: this.popoverExpanded,
            direction: this.popoverDirection,
            align: this.popoverAlign,
            visibility: this.popoverVisibility,
            contentStyle: this.popoverContentStyle,
            contentOffset: this.popoverContentOffset,
            forceHidden: this.popoverForceHidden,
            showClearMargin: this.popoverShowClearMargin,
            isInteractive: !0
          },
          on: {
            "will-appear": function (t) {
              return e.$emit("popover-will-appear", t);
            },
            "did-appear": function (t) {
              return e.$emit("popover-did-appear", t);
            },
            "will-disappear": function (t) {
              return e.$emit("popover-will-disappear", t);
            },
            "did-disappear": function (t) {
              return e.$emit("popover-did-disappear", t);
            },
            "update:forceHidden": function (t) {
              return e.popoverForceHidden = t;
            }
          }
        }, [Object(m.c)(this.$scopedSlots.default) && this.$scopedSlots.default({
          inputValue: this.inputValue,
          updateValue: this.updateValue
        }) || [t("input", {
          class: this.inputProps_.class,
          style: this.inputProps_.style,
          domProps: {
            value: this.inputValue
          },
          attrs: o()({
            type: "text"
          }, this.inputAttrs),
          on: {
            input: this.inputInput,
            change: this.inputChange,
            keyup: this.inputKeyup
          }
        })], n("popover-content")]);
      },
      components: {
        Popover: s.a,
        SingleDatePicker: u.a,
        MultipleDatePicker: c.a,
        DateRangePicker: l.a
      },
      props: {
        mode: {
          type: String,
          default: "single"
        },
        value: {
          type: null,
          required: !0
        },
        isRequired: Boolean,
        isInline: Boolean,
        minDate: Date,
        maxDate: Date,
        disabledDates: null,
        availableDates: null,
        formats: Object,
        inputProps: {
          type: Object,
          default: function () {
            return {};
          }
        },
        updateOnInput: {
          type: Boolean,
          default: function () {
            return p.a.datePickerUpdateOnInput;
          }
        },
        tintColor: {
          type: String,
          default: function () {
            return p.a.datePickerTintColor;
          }
        },
        dragAttribute: Object,
        selectAttribute: Object,
        disabledAttribute: Object,
        showCaps: {
          type: Boolean,
          default: function () {
            return p.a.datePickerShowCaps;
          }
        },
        showDayPopover: {
          type: Boolean,
          default: function () {
            return p.a.datePickerShowDayPopover;
          }
        },
        popoverExpanded: {
          type: Boolean,
          default: function () {
            return p.a.popoverExpanded;
          }
        },
        popoverDirection: {
          type: String,
          default: function () {
            return p.a.popoverDirection;
          }
        },
        popoverAlign: {
          type: String,
          default: function () {
            return p.a.popoverAlign;
          }
        },
        popoverVisibility: {
          type: String,
          default: function () {
            return p.a.popoverVisibility;
          }
        },
        popoverContentOffset: {
          type: Number,
          default: function () {
            return p.a.popoverContentOffset;
          }
        },
        popoverShowClearMargin: Boolean,
        popoverKeepVisibleOnInput: {
          type: Boolean,
          default: function () {
            return p.a.popoverKeepVisibleOnInput;
          }
        },
        fromPage: Object,
        toPage: Object,
        themeStyles: {
          type: Object,
          default: function () {
            return {};
          }
        }
      },
      data: function () {
        return {
          fromPage_: null,
          toPage_: null,
          dragValue: null,
          inputValue: "",
          popoverForceHidden: !1,
          disableFormatInput: !1,
          disablePopoverForceHidden: !1
        };
      },
      computed: {
        formats_: function () {
          return o()({}, p.a.formats, this.formats);
        },
        inputFormats: function () {
          var t = this.formats_.input;
          return Object(m.a)(t) && t || [t];
        },
        profile: function () {
          var t = this;
          return Object(f.a)(this.mode, function (e) {
            return Object(b.a)(e, t.inputFormats[0]);
          }, function (e) {
            return Object(b.b)(e, t.inputFormats);
          });
        },
        componentName: function () {
          return this.profile.componentName;
        },
        selectAttribute_: function () {
          return this.buildSelectDragAttribute(this.selectAttribute);
        },
        dragAttribute_: function () {
          return this.buildSelectDragAttribute(this.dragAttribute, !0);
        },
        disabledDates_: function () {
          var t = [];
          return this.disabledDates && (Object(m.a)(this.disabledDates) ? t.push.apply(t, i()(this.disabledDates)) : t.push(this.disabledDates)), this.minDate && t.push({
            start: null,
            end: Object(v.a)(this.minDate, -1)
          }), this.maxDate && t.push({
            start: Object(v.a)(this.maxDate, 1),
            end: null
          }), t;
        },
        disabledAttribute_: function () {
          return this.disabledDates_ || this.availableDates ? Object(h.a)(o()({
            key: "disabled",
            order: 100
          }, this.disabledAttribute || Object(p.c)(p.a.datePickerDisabledAttribute, {
            mode: this.mode,
            color: this.tintColor,
            showDayPopover: this.showDayPopover
          }), {
            dates: this.disabledDates_,
            excludeDates: this.availableDates,
            excludeMode: "includes"
          })) : null;
        },
        inputProps_: function () {
          var t = p.a.datePickerInputProps;
          return Object(m.c)(t) ? o()({}, t({
            mode: this.mode,
            value: this.value,
            dragValue: this.dragValue,
            format: p.a.masks[this.inputFormats[0]] || this.inputFormats[0]
          }), this.inputProps) : Object(m.e)(t) ? o()({}, t, this.inputProps) : this.inputProps;
        },
        inputAttrs: function () {
          var t = o()({}, this.inputProps_);
          return t && (delete t.style, delete t.class), t;
        },
        themeStyles_: function () {
          var t = this.themeStyles.dayContent || p.a.themeStyles.dayContent;
          return o()({}, this.themeStyles, {
            dayContent: function (e) {
              return o()({}, e.isHovered && {
                backgroundColor: "#dadada",
                border: "0",
                cursor: "pointer"
              }, Object(m.c)(t) && t(e) || t);
            }
          }, !this.isInline && {
            wrapper: null
          });
        },
        popoverContentStyle: function () {
          return o()({}, this.themeStyles.wrapper, {
            padding: "0",
            margin: "0"
          });
        }
      },
      watch: {
        fromPage: function (t) {
          this.fromPage_ = t;
        },
        toPage: function (t) {
          this.toPage_ = t;
        },
        fromPage_: function (t) {
          this.$emit("update:frompage", t), this.$emit("update:fromPage", t);
        },
        toPage_: function (t) {
          this.$emit("update:topage", t), this.$emit("update:toPage", t);
        },
        mode: function () {
          this.$emit("input", null);
        },
        value: function () {
          this.assignPageRange(), this.disableFormatInput || this.formatInput(), "multiple" === this.mode || this.disablePopoverForceHidden || this.hidePopover(), this.disableFormatInput = !1, this.disablePopoverForceHidden = !1;
        },
        dragValue: function () {
          this.formatInput();
        },
        disabledAttribute_: function () {
          this.dragValue || this.updateValue(this.value);
        }
      },
      created: function () {
        this.fromPage_ = this.fromPage, this.toPage_ = this.toPage, this.assignPageRange(), this.formatInput();
      },
      methods: {
        buildSelectDragAttribute: function (t, e) {
          var n = this,
              r = o()({
            key: "drag-select"
          }, t),
              i = r,
              a = i.highlight,
              s = i.highlightCaps,
              u = i.contentStyle,
              c = i.dot,
              l = i.bar;
          return c || l || (r = o()({}, r, {
            highlight: function (t) {
              return o()({
                backgroundColor: n.tintColor
              }, e && {
                height: "1.64rem",
                opacity: .5
              }, Object(m.c)(a) && a(t) || a);
            },
            highlightCaps: s || this.showCaps && function (t) {
              return !t.inBetween && {
                backgroundColor: "#fafafa",
                borderColor: n.tintColor,
                borderWidth: "2px"
              };
            },
            contentStyle: function (t) {
              return o()({}, !e && {
                color: "#fafafa"
              }, t.isHovered && {
                backgroundColor: "transparent",
                border: "0"
              }, n.showCaps && !t.inBetween && {
                color: "#333333"
              }, Object(m.c)(u) && u(t) || u);
            }
          })), (r.popover || this.showDayPopover) && (r.popover = o()({
            component: d.a,
            hideIndicator: !0
          }, r.popover)), r;
        },
        filteredListeners: function () {
          var t = o()({}, this.$listeners);
          return delete t["update:frompage"], delete t["update:fromPage"], delete t["update:topage"], delete t["update:toPage"], t;
        },
        assignPageRange: function () {
          var t = this.profile.getPageRange(this.value);

          if (t) {
            var e = Object(y.v)(this.fromPage_, t.from, t.to),
                n = Object(y.v)(this.toPage_, t.from, t.to);
            "single" === this.mode ? e || Object.prototype.hasOwnProperty.call(this.$attrs, "is-double-paned") ? n || (this.fromPage_ = t.to) : this.fromPage_ = t.from : (e || (this.fromPage_ = t.from), n || (this.toPage_ = t.to));
          }
        },
        inputInput: function (t) {
          this.inputValue = t.target.value, this.updateOnInput && this.updateValue(this.inputValue, {
            formatInput: !1,
            hidePopover: !1
          });
        },
        inputChange: function () {
          this.updateValue(this.inputValue, {
            formatInput: !0,
            hidePopover: !1
          });
        },
        inputKeyup: function (t) {
          27 === t.keyCode && this.updateValue(this.value, {
            formatInput: !0,
            hidePopover: !0
          });
        },
        updateValue: function () {
          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.inputValue,
              e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
              n = e.formatInput,
              r = void 0 !== n && n,
              i = e.hidePopover,
              a = void 0 === i ? !this.popoverKeepVisibleOnInput : i;
          this.inputValue = Object(m.f)(t) ? t : this.inputValue;
          var o = Object(m.f)(t) ? this.profile.parseValue(t) : t,
              s = this.profile.filterDisabled({
            value: this.profile.normalizeValue(o),
            isRequired: this.isRequired,
            disabled: this.disabledAttribute_,
            fallbackValue: this.value
          });

          if (this.profile.valuesAreEqual(o, s)) {
            !this.profile.valuesAreEqual(this.value, s) ? (this.disableFormatInput = !r, this.disablePopoverForceHidden = !a, this.$emit("input", s)) : (r && this.formatInput(), a && this.hidePopover());
          }
        },
        formatInput: function () {
          var t = this;
          this.$nextTick(function () {
            t.inputValue = t.profile.formatValue(t.value, t.dragValue);
          });
        },
        hidePopover: function () {
          var t = this;
          setTimeout(function () {
            t.popoverForceHidden = !0;
          }, 200);
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(12),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(21),
        u = n(24),
        c = n(13);
    e.a = {
      mixins: [c.a],
      render: function (t) {
        return t(s.a, {
          attrs: o()({}, this.$attrs, {
            attributes: this.attributes_
          }),
          on: this.mergeListeners({
            dayclick: this.clickDay
          }),
          slots: this.$slots,
          scopedSlots: this.$scopedSlots
        });
      },
      components: {
        Calendar: s.a
      },
      props: {
        value: {
          type: Date,
          default: null
        },
        isRequired: Boolean,
        selectAttribute: Object,
        disabledAttribute: Object,
        attributes: Array
      },
      computed: {
        selectAttribute_: function () {
          return Object(u.e)(this.value) ? o()({}, this.selectAttribute, {
            dates: [this.value]
          }) : null;
        },
        attributes_: function () {
          var t = [].concat(i()(this.attributes || []));
          return this.selectAttribute_ && t.push(this.selectAttribute_), this.disabledAttribute && t.push(this.disabledAttribute), t;
        }
      },
      methods: {
        clickDay: function (t) {
          this.disabledAttribute && this.disabledAttribute.includesDay(t) ? this.$emit("invalid-input", {
            reason: "disabled",
            value: t.date
          }) : Object(u.f)(t.date, this.value) ? this.isRequired || this.$emit("input", null) : this.$emit("input", t.date);
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(12),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(21),
        u = n(24),
        c = n(13);
    e.a = {
      mixins: [c.a],
      render: function (t) {
        return t(s.a, {
          attrs: o()({}, this.$attrs, {
            attributes: this.attributes_
          }),
          on: this.mergeListeners({
            dayclick: this.clickDay
          }),
          slots: this.$slots,
          scopedSlots: this.$scopedSlots
        });
      },
      components: {
        Calendar: s.a
      },
      props: {
        value: {
          type: Array,
          default: function () {
            return [];
          }
        },
        isRequired: Boolean,
        selectAttribute: Object,
        disabledAttribute: Object,
        attributes: Array
      },
      computed: {
        selectAttribute_: function () {
          return Object(u.b)(this.value) ? o()({}, this.selectAttribute, {
            dates: this.value
          }) : null;
        },
        attributes_: function () {
          var t = [].concat(i()(this.attributes || []));
          return this.selectAttribute_ && t.push(this.selectAttribute_), this.disabledAttribute && t.push(this.disabledAttribute), t;
        }
      },
      methods: {
        clickDay: function (t) {
          if (!this.disabledAttribute || !this.disabledAttribute.includesDay(t)) if (Object(u.b)(this.value)) {
            if (this.value.find(function (e) {
              return e.getTime() === t.dateTime;
            })) {
              var e = this.value.filter(function (e) {
                return !Object(u.f)(e, t.date);
              });
              e.length ? this.$emit("input", e) : this.isRequired || this.$emit("input", null);
            } else this.$emit("input", Object(u.c)([].concat(i()(this.value), [t.date])));
          } else this.$emit("input", [t.date]);
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(12),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(21),
        u = n(13),
        c = n(24);
    e.a = {
      mixins: [u.a],
      render: function (t) {
        return t(s.a, {
          attrs: o()({}, this.$attrs, {
            attributes: this.attributes_,
            themeStyles: this.themeStyles_
          }),
          on: this.mergeListeners({
            dayclick: this.clickDay,
            daymouseenter: this.enterDay
          }),
          slots: this.$slots,
          scopedSlots: this.$scopedSlots
        });
      },
      components: {
        Calendar: s.a
      },
      props: {
        value: {
          type: Object,
          default: function () {}
        },
        isRequired: Boolean,
        dragAttribute: Object,
        selectAttribute: Object,
        disabledAttribute: Object,
        themeStyles: Object,
        attributes: Array
      },
      data: function () {
        return {
          dragValue: null,
          showDisabledContent: !1
        };
      },
      computed: {
        dragAttribute_: function () {
          return this.dragValue && o()({}, this.dragAttribute, {
            dates: [this.dragValue]
          });
        },
        selectAttribute_: function () {
          return this.value && o()({}, this.selectAttribute, {
            dates: [this.value]
          });
        },
        attributes_: function () {
          var t = [].concat(i()(this.attributes || []));
          return this.dragAttribute_ ? t.push(this.dragAttribute_) : this.selectAttribute_ && t.push(this.selectAttribute_), this.disabledAttribute && t.push(this.disabledAttribute), t;
        },
        themeStyles_: function () {
          return o()({}, this.themeStyles, this.showDisabledContent && this.disabledAttribute && {
            dayContentHover: this.disabledAttribute.contentHoverStyle
          });
        }
      },
      watch: {
        dragValue: function (t) {
          this.$emit("drag", Object(c.d)(t));
        }
      },
      created: function () {
        var t = this;
        document.addEventListener("keydown", function (e) {
          t.dragValue && 27 === e.keyCode && (t.dragValue = null);
        });
      },
      methods: {
        clickDay: function (t) {
          var e = t.dateTime;

          if (this.dragValue) {
            var n = Object(c.d)({
              start: new Date(this.dragValue.start.getTime()),
              end: new Date(e)
            });
            this.dateIsValid(n) && (this.dragValue = null, this.$emit("input", n));
          } else {
            var r = {
              start: new Date(e),
              end: new Date(e)
            };
            this.dateIsValid(r) && (this.dragValue = r);
          }
        },
        enterDay: function (t) {
          var e = t.dateTime;

          if (this.dragValue) {
            var n = {
              start: new Date(this.dragValue.start.getTime()),
              end: new Date(e)
            };
            this.dateIsValid(n) ? (this.dragValue = n, this.showDisabledContent = !1) : this.showDisabledContent = !0;
          }
        },
        dateIsValid: function (t) {
          return !this.disabledAttribute || !this.disabledAttribute.intersectsDate(t);
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(33),
        i = n(8);
    e.a = {
      components: {
        SvgIcon: r.a
      },
      props: {
        attribute: Object,
        format: String
      },
      computed: {
        date: function () {
          return this.attribute.targetDate;
        },
        isDate: function () {
          return this.date.isDate;
        },
        isRange: function () {
          return this.date.isRange;
        },
        days: function () {
          return this.date.daySpan + 1;
        },
        nights: function () {
          return this.date.daySpan;
        },
        dateLabel: function () {
          return this.date && this.date.date ? this.getDateString(this.date.date) : "";
        },
        startDateLabel: function () {
          return this.date && this.date.start ? this.getDateString(this.date.start) : "";
        },
        endDateLabel: function () {
          return this.date && this.date.end ? this.getDateString(this.date.end) : "";
        }
      },
      methods: {
        getDateString: function (t) {
          return Object(i.a)(t, this.format);
        }
      }
    };
  }, function (t, e, n) {
    "use strict";

    Object.defineProperty(e, "__esModule", {
      value: !0
    }), n.d(e, "setupCalendar", function () {
      return h;
    });
    var r = n(14),
        i = n.n(r),
        a = n(0),
        o = n.n(a),
        s = n(21),
        u = n(122),
        c = n(22),
        l = n(129),
        d = n(3);
    n.d(e, "Calendar", function () {
      return s.a;
    }), n.d(e, "DatePicker", function () {
      return u.a;
    }), n.d(e, "Popover", function () {
      return c.a;
    });

    var f = {
      Calendar: s.a,
      DatePicker: u.a,
      Popover: c.a
    },
        h = function (t) {
      var e = t ? t.locale : new Intl.DateTimeFormat().resolvedOptions().locale;
      return Object(d.b)(d.a, Object(l.a)(e), t);
    },
        p = o()({}, f, {
      install: function (t, e) {
        var n = h(e);
        i()(f).forEach(function (e) {
          return t.component("" + n.componentPrefix + e, f[e]);
        });
      }
    });

    e.default = p, "undefined" != typeof window && window.Vue && window.Vue.use(p);
  }, function (t, e, n) {
    n(61), t.exports = n(5).Object.keys;
  }, function (t, e, n) {
    var r = n(15),
        i = n(16);
    n(65)("keys", function () {
      return function (t) {
        return i(r(t));
      };
    });
  }, function (t, e, n) {
    var r = n(17),
        i = n(26),
        a = n(63)(!1),
        o = n(28)("IE_PROTO");

    t.exports = function (t, e) {
      var n,
          s = i(t),
          u = 0,
          c = [];

      for (n in s) n != o && r(s, n) && c.push(n);

      for (; e.length > u;) r(s, n = e[u++]) && (~a(c, n) || c.push(n));

      return c;
    };
  }, function (t, e, n) {
    var r = n(26),
        i = n(36),
        a = n(64);

    t.exports = function (t) {
      return function (e, n, o) {
        var s,
            u = r(e),
            c = i(u.length),
            l = a(o, c);

        if (t && n != n) {
          for (; c > l;) if ((s = u[l++]) != s) return !0;
        } else for (; c > l; l++) if ((t || l in u) && u[l] === n) return t || l || 0;

        return !t && -1;
      };
    };
  }, function (t, e, n) {
    var r = n(27),
        i = Math.max,
        a = Math.min;

    t.exports = function (t, e) {
      return (t = r(t)) < 0 ? i(t + e, 0) : a(t, e);
    };
  }, function (t, e, n) {
    var r = n(7),
        i = n(5),
        a = n(20);

    t.exports = function (t, e) {
      var n = (i.Object || {})[t] || Object[t],
          o = {};
      o[t] = e(n), r(r.S + r.F * a(function () {
        n(1);
      }), "Object", o);
    };
  }, function (t, e) {
    t.exports = function (t) {
      if ("function" != typeof t) throw TypeError(t + " is not a function!");
      return t;
    };
  }, function (t, e, n) {
    t.exports = !n(11) && !n(20)(function () {
      return 7 != Object.defineProperty(n(41)("div"), "a", {
        get: function () {
          return 7;
        }
      }).a;
    });
  }, function (t, e, n) {
    var r = n(29);

    t.exports = function (t, e) {
      if (!r(t)) return t;
      var n, i;
      if (e && "function" == typeof (n = t.toString) && !r(i = n.call(t))) return i;
      if ("function" == typeof (n = t.valueOf) && !r(i = n.call(t))) return i;
      if (!e && "function" == typeof (n = t.toString) && !r(i = n.call(t))) return i;
      throw TypeError("Can't convert object to primitive value");
    };
  }, function (t, e, n) {
    n(70), t.exports = n(5).Object.assign;
  }, function (t, e, n) {
    var r = n(7);
    r(r.S + r.F, "Object", {
      assign: n(71)
    });
  }, function (t, e, n) {
    "use strict";

    var r = n(16),
        i = n(72),
        a = n(42),
        o = n(15),
        s = n(34),
        u = Object.assign;
    t.exports = !u || n(20)(function () {
      var t = {},
          e = {},
          n = Symbol(),
          r = "abcdefghijklmnopqrst";
      return t[n] = 7, r.split("").forEach(function (t) {
        e[t] = t;
      }), 7 != u({}, t)[n] || Object.keys(u({}, e)).join("") != r;
    }) ? function (t, e) {
      for (var n = o(t), u = arguments.length, c = 1, l = i.f, d = a.f; u > c;) for (var f, h = s(arguments[c++]), p = l ? r(h).concat(l(h)) : r(h), v = p.length, y = 0; v > y;) d.call(h, f = p[y++]) && (n[f] = h[f]);

      return n;
    } : u;
  }, function (t, e) {
    e.f = Object.getOwnPropertySymbols;
  }, function (t, e) {}, function (t, e, n) {
    t.exports = {
      default: n(75),
      __esModule: !0
    };
  }, function (t, e, n) {
    n(76), n(86), t.exports = n(5).Array.from;
  }, function (t, e, n) {
    "use strict";

    var r = n(77)(!0);
    n(78)(String, "String", function (t) {
      this._t = String(t), this._i = 0;
    }, function () {
      var t,
          e = this._t,
          n = this._i;
      return n >= e.length ? {
        value: void 0,
        done: !0
      } : (t = r(e, n), this._i += t.length, {
        value: t,
        done: !1
      });
    });
  }, function (t, e, n) {
    var r = n(27),
        i = n(25);

    t.exports = function (t) {
      return function (e, n) {
        var a,
            o,
            s = String(i(e)),
            u = r(n),
            c = s.length;
        return u < 0 || u >= c ? t ? "" : void 0 : (a = s.charCodeAt(u)) < 55296 || a > 56319 || u + 1 === c || (o = s.charCodeAt(u + 1)) < 56320 || o > 57343 ? t ? s.charAt(u) : a : t ? s.slice(u, u + 2) : o - 56320 + (a - 55296 << 10) + 65536;
      };
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(79),
        i = n(7),
        a = n(80),
        o = n(18),
        s = n(17),
        u = n(32),
        c = n(81),
        l = n(44),
        d = n(85),
        f = n(6)("iterator"),
        h = !([].keys && "next" in [].keys()),
        p = function () {
      return this;
    };

    t.exports = function (t, e, n, v, y, m, b) {
      c(n, e, v);

      var g,
          D,
          w,
          _ = function (t) {
        if (!h && t in x) return x[t];

        switch (t) {
          case "keys":
          case "values":
            return function () {
              return new n(this, t);
            };
        }

        return function () {
          return new n(this, t);
        };
      },
          O = e + " Iterator",
          C = "values" == y,
          M = !1,
          x = t.prototype,
          k = x[f] || x["@@iterator"] || y && x[y],
          S = !h && k || _(y),
          Y = y ? C ? _("entries") : S : void 0,
          j = "Array" == e ? x.entries || k : k;

      if (j && (w = d(j.call(new t()))) !== Object.prototype && w.next && (l(w, O, !0), r || s(w, f) || o(w, f, p)), C && k && "values" !== k.name && (M = !0, S = function () {
        return k.call(this);
      }), r && !b || !h && !M && x[f] || o(x, f, S), u[e] = S, u[O] = p, y) if (g = {
        values: C ? S : _("values"),
        keys: m ? S : _("keys"),
        entries: Y
      }, b) for (D in g) D in x || a(x, D, g[D]);else i(i.P + i.F * (h || M), e, g);
      return g;
    };
  }, function (t, e) {
    t.exports = !0;
  }, function (t, e, n) {
    t.exports = n(18);
  }, function (t, e, n) {
    "use strict";

    var r = n(82),
        i = n(30),
        a = n(44),
        o = {};
    n(18)(o, n(6)("iterator"), function () {
      return this;
    }), t.exports = function (t, e, n) {
      t.prototype = r(o, {
        next: i(1, n)
      }), a(t, e + " Iterator");
    };
  }, function (t, e, n) {
    var r = n(19),
        i = n(83),
        a = n(39),
        o = n(28)("IE_PROTO"),
        s = function () {},
        u = function () {
      var t,
          e = n(41)("iframe"),
          r = a.length;

      for (e.style.display = "none", n(84).appendChild(e), e.src = "javascript:", (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), u = t.F; r--;) delete u.prototype[a[r]];

      return u();
    };

    t.exports = Object.create || function (t, e) {
      var n;
      return null !== t ? (s.prototype = r(t), n = new s(), s.prototype = null, n[o] = t) : n = u(), void 0 === e ? n : i(n, e);
    };
  }, function (t, e, n) {
    var r = n(10),
        i = n(19),
        a = n(16);
    t.exports = n(11) ? Object.defineProperties : function (t, e) {
      i(t);

      for (var n, o = a(e), s = o.length, u = 0; s > u;) r.f(t, n = o[u++], e[n]);

      return t;
    };
  }, function (t, e, n) {
    var r = n(9).document;
    t.exports = r && r.documentElement;
  }, function (t, e, n) {
    var r = n(17),
        i = n(15),
        a = n(28)("IE_PROTO"),
        o = Object.prototype;

    t.exports = Object.getPrototypeOf || function (t) {
      return t = i(t), r(t, a) ? t[a] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? o : null;
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(40),
        i = n(7),
        a = n(15),
        o = n(87),
        s = n(88),
        u = n(36),
        c = n(89),
        l = n(90);
    i(i.S + i.F * !n(92)(function (t) {
      Array.from(t);
    }), "Array", {
      from: function (t) {
        var e,
            n,
            i,
            d,
            f = a(t),
            h = "function" == typeof this ? this : Array,
            p = arguments.length,
            v = p > 1 ? arguments[1] : void 0,
            y = void 0 !== v,
            m = 0,
            b = l(f);
        if (y && (v = r(v, p > 2 ? arguments[2] : void 0, 2)), void 0 == b || h == Array && s(b)) for (n = new h(e = u(f.length)); e > m; m++) c(n, m, y ? v(f[m], m) : f[m]);else for (d = b.call(f), n = new h(); !(i = d.next()).done; m++) c(n, m, y ? o(d, v, [i.value, m], !0) : i.value);
        return n.length = m, n;
      }
    });
  }, function (t, e, n) {
    var r = n(19);

    t.exports = function (t, e, n, i) {
      try {
        return i ? e(r(n)[0], n[1]) : e(n);
      } catch (e) {
        var a = t.return;
        throw void 0 !== a && r(a.call(t)), e;
      }
    };
  }, function (t, e, n) {
    var r = n(32),
        i = n(6)("iterator"),
        a = Array.prototype;

    t.exports = function (t) {
      return void 0 !== t && (r.Array === t || a[i] === t);
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(10),
        i = n(30);

    t.exports = function (t, e, n) {
      e in t ? r.f(t, e, i(0, n)) : t[e] = n;
    };
  }, function (t, e, n) {
    var r = n(91),
        i = n(6)("iterator"),
        a = n(32);

    t.exports = n(5).getIteratorMethod = function (t) {
      if (void 0 != t) return t[i] || t["@@iterator"] || a[r(t)];
    };
  }, function (t, e, n) {
    var r = n(35),
        i = n(6)("toStringTag"),
        a = "Arguments" == r(function () {
      return arguments;
    }());

    t.exports = function (t) {
      var e, n, o;
      return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) {
        try {
          return t[e];
        } catch (t) {}
      }(e = Object(t), i)) ? n : a ? r(e) : "Object" == (o = r(e)) && "function" == typeof e.callee ? "Arguments" : o;
    };
  }, function (t, e, n) {
    var r = n(6)("iterator"),
        i = !1;

    try {
      var a = [7][r]();
      a.return = function () {
        i = !0;
      }, Array.from(a, function () {
        throw 2;
      });
    } catch (t) {}

    t.exports = function (t, e) {
      if (!e && !i) return !1;
      var n = !1;

      try {
        var a = [7],
            o = a[r]();
        o.next = function () {
          return {
            done: n = !0
          };
        }, a[r] = function () {
          return o;
        }, t(a);
      } catch (t) {}

      return n;
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(45),
        i = n(120);

    var a = function (t) {
      n(94);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-2083cb72", null);

    e.a = o.exports;
  }, function (t, e) {}, function (t, e) {}, function (t, e, n) {
    "use strict";

    e.__esModule = !0;
    var r,
        i = n(97),
        a = (r = i, r && r.__esModule ? r : {
      default: r
    });

    e.default = function (t, e, n) {
      return e in t ? (0, a.default)(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t;
    };
  }, function (t, e, n) {
    t.exports = {
      default: n(98),
      __esModule: !0
    };
  }, function (t, e, n) {
    n(99);
    var r = n(5).Object;

    t.exports = function (t, e, n) {
      return r.defineProperty(t, e, n);
    };
  }, function (t, e, n) {
    var r = n(7);
    r(r.S + r.F * !n(11), "Object", {
      defineProperty: n(10).f
    });
  }, function (t, e, n) {
    "use strict";

    n.d(e, "a", function () {
      return a;
    });

    var r = n(3),
        i = n(4),
        a = function (t, e) {
      if (!t || !t.addEventListener || !Object(i.c)(e)) return null;

      var n = {
        touchState: null
      },
          a = function (t) {
        var e = t.targetTouches[0];
        n.touchState = {
          started: !0,
          startedOn: new Date(),
          startX: e.screenX,
          startY: e.screenY,
          x: e.screenX,
          y: e.screenY
        };
      },
          o = function (t) {
        var i = n.touchState;

        if (i && i.started) {
          var a = t.changedTouches[0];
          i.x = a.screenX, i.y = a.screenY, i.tapDetected = new Date() - i.startedOn <= r.a.maxTapDuration && Math.abs(i.x - i.startX) <= r.a.maxTapTolerance && Math.abs(i.y - i.startY) <= r.a.maxTapTolerance, i.tapDetected && e(t), i.started = !1;
        }
      },
          s = function (t) {
        var r = n.touchState;
        r && r.tapDetected || e(t);
      };

      return t.addEventListener("touchstart", a), t.addEventListener("touchend", o), t.addEventListener("click", s), n.cleanup = function () {
        t.removeEventListener("touchstart", a), t.removeEventListener("touchend", o), t.removeEventListener("click", s);
      }, n;
    };
  }, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("div", {
          ref: "popover",
          class: ["popover-container", {
            expanded: t.isExpanded
          }],
          style: t.containerStyle,
          attrs: {
            tabindex: "focus" === t.visibility ? -1 : void 0
          },
          on: {
            focusin: t.focusin,
            focusout: t.focusout,
            mouseleave: t.mouseleave,
            mousemove: t.mousemove,
            click: function (e) {
              e.stopPropagation(), t.click(e);
            }
          }
        }, [n("transition", {
          attrs: {
            tag: "div",
            name: t.transition
          },
          on: {
            enter: t.contentEnter,
            "before-enter": t.beforeContentEnter,
            "after-enter": t.afterContentEnter,
            leave: t.contentLeave,
            "before-leave": t.beforeContentLeave,
            "after-leave": t.afterContentLeave
          }
        }, [t.visible ? n("div", {
          ref: "popoverOrigin",
          class: ["popover-origin", "direction-" + t.direction, "align-" + t.align]
        }, [n("div", {
          ref: "popoverContentWrapper",
          class: ["popover-content-wrapper", "direction-" + t.direction, "align-" + t.align, {
            interactive: t.isInteractive
          }],
          style: t.contentWrapperStyle
        }, [n("div", {
          ref: "popoverContent",
          class: ["popover-content", "direction-" + t.direction, "align-" + t.align],
          style: t.contentStyle
        }, [t._t("popover-content", [n("div", [t._v("Popover content goes here")])])], 2)])]) : t._e()]), t._v(" "), t._t("default", [n("span", [t._v("Popover trigger goes here")])])], 2);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = n(48),
        i = n(110);

    var a = function (t) {
      n(103);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-28896542", null);

    e.a = o.exports;
  }, function (t, e) {}, function (t, e, n) {
    "use strict";

    var r = n(49),
        i = n(109);

    var a = function (t) {
      n(105);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-3db80f80", null);

    e.a = o.exports;
  }, function (t, e) {}, function (t, e, n) {
    "use strict";

    var r = n(50),
        i = n(108);

    var a = function (t) {
      n(107);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-54b1f93b", null);

    e.a = o.exports;
  }, function (t, e) {}, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("div", {
          class: ["c-day-popover-row", {
            selectable: t.isSelectable
          }],
          on: {
            click: function (e) {
              t.$emit("select");
            }
          }
        }, [!t.hideIndicator && t.indicatorStyle ? n("div", {
          staticClass: "c-day-popover-indicator"
        }, [n("span", {
          style: t.indicatorStyle
        })]) : t._e(), t._v(" "), n("div", {
          staticClass: "c-day-popover-content"
        }, [t._t("default", [t._v("\n      This is the default content slot.\n    ")])], 2)]);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("popover", {
          staticClass: "c-day-popover",
          attrs: {
            align: "center",
            transition: "fade",
            "content-offset": t.popoverContentOffset,
            visibility: t.popoverVisibility,
            "content-style": t.popoverContentStyle,
            "is-interactive": t.popoverIsInteractive,
            "toggle-visible-on-click": ""
          },
          on: {
            "got-focus": function (e) {
              t.isFocused = !0;
            },
            "lost-focus": function (e) {
              t.isFocused = !1;
            }
          }
        }, [n("div", {
          staticClass: "c-day",
          style: t.dayCellStyle
        }, [n("transition-group", {
          staticClass: "c-day-backgrounds c-day-layer",
          attrs: {
            name: "background",
            tag: "div"
          }
        }, t._l(t.backgrounds, function (t) {
          return n("div", {
            key: t.key,
            class: t.wrapperClass
          }, [n("div", {
            staticClass: "c-day-background",
            style: t.style
          })]);
        })), t._v(" "), n("div", {
          staticClass: "c-day-content-wrapper",
          on: {
            click: t.click,
            mouseenter: t.mouseenter,
            mouseover: t.mouseover,
            mouseleave: t.mouseleave
          }
        }, [t._t("day-content", [n("div", {
          staticClass: "c-day-content",
          style: t.contentStyle
        }, [n("div", [t._v("\n            " + t._s(t.day.label) + "\n          ")])])], {
          day: t.day,
          contentStyle: t.contentStyle,
          attributes: t.attributesList
        })], 2), t._v(" "), t.hasDots ? n("div", {
          staticClass: "c-day-layer c-day-box-center-bottom"
        }, [n("div", {
          staticClass: "c-day-dots",
          style: t.dotsStyle
        }, t._l(t.dots, function (t) {
          return n("span", {
            key: t.key,
            staticClass: "c-day-dot",
            style: t.style
          });
        }))]) : t._e(), t._v(" "), t.hasBars ? n("div", {
          staticClass: "c-day-layer c-day-box-center-bottom"
        }, [n("div", {
          staticClass: "c-day-bars",
          style: t.barsStyle
        }, t._l(t.bars, function (t) {
          return n("span", {
            key: t.key,
            staticClass: "c-day-bar",
            style: t.style
          });
        }))]) : t._e()], 1), t._v(" "), n("div", {
          staticClass: "c-day-popover-content",
          attrs: {
            slot: "popover-content"
          },
          slot: "popover-content"
        }, [t._t("day-popover-header", null, {
          day: t.day,
          attributes: t.attributesList
        }), t._v(" "), t._l(t.popovers, function (e) {
          return n("calendar-day-popover-row", {
            key: e.key,
            attrs: {
              attribute: e.attribute,
              "hide-indicator": e.hideIndicator
            }
          }, [t._t(e.slot, [e.label ? n("span", {
            key: e.key,
            staticClass: "popover-label",
            style: e.labelStyle
          }, [t._v("\n          " + t._s(e.label) + "\n        ")]) : t._e(), t._v(" "), e.component ? n(e.component, {
            tag: "component",
            attrs: {
              attribute: e.attribute,
              format: t.formats.dayPopover,
              day: t.day
            }
          }) : t._e()], {
            attribute: e.attribute,
            customData: e.attribute.customData,
            day: t.day
          })], 2);
        }), t._v(" "), t._t("day-popover-footer", null, {
          day: t.day,
          attributes: t.attributesList
        })], 2)]);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("div", t._l(t.weeks, function (e, r) {
          return n("div", {
            key: r + 1,
            staticClass: "c-week",
            on: {
              "&touchstart": function (e) {
                t.$emit("touchstart", e);
              },
              "&touchmove": function (e) {
                t.$emit("touchmove", e);
              },
              "&touchend": function (e) {
                t.$emit("touchend", e);
              }
            }
          }, t._l(e, function (e) {
            return n("calendar-day", t._g(t._b({
              key: e.id,
              attrs: {
                day: e
              },
              scopedSlots: t._u([t._l(Object.keys(t.$scopedSlots), function (e) {
                return {
                  key: e,
                  fn: function (n) {
                    return [t._t(e, null, null, n)];
                  }
                };
              })])
            }, "calendar-day", t.$attrs, !1), t.$listeners));
          }));
        }));
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = n(51),
        i = n(119);

    var a = function (t) {
      n(112);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-81948efe", null);

    e.a = o.exports;
  }, function (t, e) {}, function (t, e, n) {
    t.exports = {
      default: n(114),
      __esModule: !0
    };
  }, function (t, e, n) {
    n(115), t.exports = n(5).Object.values;
  }, function (t, e, n) {
    var r = n(7),
        i = n(116)(!1);
    r(r.S, "Object", {
      values: function (t) {
        return i(t);
      }
    });
  }, function (t, e, n) {
    var r = n(16),
        i = n(26),
        a = n(42).f;

    t.exports = function (t) {
      return function (e) {
        for (var n, o = i(e), s = r(o), u = s.length, c = 0, l = []; u > c;) a.call(o, n = s[c++]) && l.push(t ? [n, o[n]] : o[n]);

        return l;
      };
    };
  }, function (t, e) {}, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("svg", {
          staticClass: "svg-icon",
          attrs: {
            width: t.width,
            height: t.height,
            viewBox: t.viewBox
          },
          on: {
            click: function (e) {
              t.$emit("click", e);
            }
          }
        }, [n("path", {
          attrs: {
            d: t.path
          }
        })]);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("div", {
          staticClass: "c-nav"
        }, ["month" === t.mode_ ? n("div", [n("div", {
          staticClass: "c-header",
          style: t.headerStyle
        }, [n("div", {
          staticClass: "c-arrow-layout"
        }, [t._t("nav-left-button", [n("svg-icon", {
          staticClass: "c-arrow",
          style: t.headerArrowsStyle,
          attrs: {
            name: "leftArrow"
          },
          on: {
            click: t.movePrevYear
          }
        })], {
          monthItems: [].concat(t.monthItems),
          move: t.movePrevYear
        })], 2), t._v(" "), n("span", {
          staticClass: "c-title",
          style: t.headerTitleStyle,
          on: {
            click: function (e) {
              t.selectMode("year");
            }
          }
        }, [t._v("\n        " + t._s(t.yearIndex) + "\n      ")]), t._v(" "), n("div", {
          staticClass: "c-arrow-layout"
        }, [t._t("nav-right-button", [n("svg-icon", {
          staticClass: "c-arrow",
          style: t.headerArrowsStyle,
          attrs: {
            name: "rightArrow"
          },
          on: {
            click: t.moveNextYear
          }
        })], {
          monthItems: [].concat(t.monthItems),
          move: t.moveNextYear
        })], 2)]), t._v(" "), n("table", {
          staticClass: "c-table"
        }, t._l(t.monthRows, function (e, r) {
          return n("tr", {
            key: r
          }, t._l(e, function (e) {
            return n("td", {
              key: e.month
            }, [n("div", {
              staticClass: "c-table-cell",
              class: {
                "c-active": e.isActive,
                "c-disabled": e.isDisabled
              },
              style: t.getMonthCellStyle(e),
              on: {
                click: function (n) {
                  t.monthClick(e.month);
                }
              }
            }, [t._v("\n            " + t._s(e.label) + "\n            "), t._v(" "), n("transition", {
              attrs: {
                name: "indicators"
              }
            }, [e.attributes ? n("div", {
              staticClass: "c-indicators"
            }, t._l(e.attributes, function (t) {
              return n("span", {
                key: t.key,
                staticClass: "c-indicator",
                style: t.style
              });
            })) : t._e()])], 1)]);
          }));
        }))]) : t._e(), t._v(" "), "year" === t.mode_ ? n("div", [n("div", {
          staticClass: "c-header",
          style: t.headerStyle
        }, [n("div", {
          staticClass: "c-arrow-layout"
        }, [t._t("nav-left-button", [n("svg-icon", {
          staticClass: "c-arrow",
          style: t.headerArrowsStyle,
          attrs: {
            name: "leftArrow"
          },
          on: {
            click: t.movePrevYearGroup
          }
        })], {
          firstYear: t.firstYear,
          lastYear: t.lastYear,
          yearItems: [].concat(t.yearItems),
          move: t.movePrevYearGroup
        })], 2), t._v(" "), n("span", {
          staticClass: "c-title",
          style: t.headerTitleStyle,
          on: {
            click: function (e) {
              t.selectMode("month");
            }
          }
        }, [t._v("\n        " + t._s(t.firstYear) + " - " + t._s(t.lastYear) + "\n      ")]), t._v(" "), n("div", {
          staticClass: "c-arrow-layout"
        }, [t._t("nav-right-button", [n("svg-icon", {
          staticClass: "c-arrow",
          style: t.headerArrowsStyle,
          attrs: {
            name: "rightArrow"
          },
          on: {
            click: t.moveNextYearGroup
          }
        })], {
          firstYear: t.firstYear,
          lastYear: t.lastYear,
          yearItems: [].concat(t.yearItems),
          move: t.moveNextYearGroup
        })], 2)]), t._v(" "), n("table", {
          staticClass: "c-table"
        }, t._l(t.yearRows, function (e, r) {
          return n("tr", {
            key: r
          }, t._l(e, function (e) {
            return n("td", {
              key: e.year
            }, [n("div", {
              staticClass: "c-table-cell",
              class: {
                "c-active": e.isActive,
                "c-disabled": e.isDisabled
              },
              style: t.getYearCellStyle(e),
              on: {
                click: function (n) {
                  t.yearClick(e.year);
                }
              }
            }, [t._v("\n            " + t._s(e.year) + "\n          ")])]);
          }));
        }))]) : t._e()]);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this,
            e = t.$createElement,
            n = t._self._c || e;
        return n("div", {
          ref: "pane",
          staticClass: "c-pane",
          style: t.paneStyle
        }, [t._t("header", [n("div", {
          staticClass: "c-header",
          style: t.headerStyle
        }, [n("div", {
          staticClass: "c-arrow-layout"
        }, [t.hideLeftButton ? t._e() : t._t("header-left-button", [n("svg-icon", {
          class: ["c-arrow", {
            "c-disabled": !t.canMovePrevMonth
          }],
          style: t.arrowStyle,
          attrs: {
            name: "leftArrow"
          },
          on: {
            click: t.movePrevMonth
          }
        })], null, t.page_)], 2), t._v(" "), n("div", {
          class: ["c-title-layout", t.titleClass]
        }, [n("popover", {
          staticClass: "c-title-popover",
          attrs: {
            direction: "bottom",
            align: t.titlePosition,
            visibility: t.navVisibility,
            "content-style": t.navWrapperStyle,
            "force-hidden": t.navForceHidden,
            "toggle-visible-on-click": "",
            "is-interactive": ""
          },
          on: {
            "update:forceHidden": function (e) {
              t.navForceHidden = e;
            }
          }
        }, [n("transition-group", {
          staticClass: "c-title-anchor",
          attrs: {
            tag: "div",
            name: t.titleTransition_
          }
        }, t._l(t.pages, function (e) {
          return e === t.page_ ? n("div", {
            key: e.key,
            staticClass: "c-title",
            style: t.titleStyle
          }, [t._t("header-title", [t._v("\n                " + t._s(e.title) + "\n              ")], null, e)], 2) : t._e();
        })), t._v(" "), n("calendar-nav", {
          attrs: {
            slot: "popover-content",
            value: t.page_,
            validator: t.canMove,
            styles: t.styles,
            formats: t.formats
          },
          on: {
            input: function (e) {
              t.navPageSelected(e);
            }
          },
          slot: "popover-content",
          scopedSlots: t._u([t._l(t.navSlots, function (e) {
            return {
              key: e,
              fn: function (n) {
                return [t._t(e, null, null, n)];
              }
            };
          })])
        })], 1)], 1), t._v(" "), n("div", {
          staticClass: "c-arrow-layout"
        }, [t.hideRightButton ? t._e() : t._t("header-right-button", [n("svg-icon", {
          class: ["c-arrow", {
            "c-disabled": !t.canMoveNextMonth
          }],
          style: t.arrowStyle,
          attrs: {
            name: "rightArrow"
          },
          on: {
            click: t.moveNextMonth
          }
        })], null, t.page_)], 2)])], null, t.page_), t._v(" "), t.headerHorizontalDividerStyle_ ? n("div", {
          staticClass: "c-horizontal-divider",
          style: t.headerHorizontalDividerStyle_
        }) : t._e(), t._v(" "), n("div", {
          staticClass: "c-weekdays",
          style: t.weekdaysStyle_
        }, t._l(t.weekdayLabels, function (e, r) {
          return n("div", {
            key: r + 1,
            staticClass: "c-weekday"
          }, [t._v("\n      " + t._s(e) + "\n    ")]);
        })), t._v(" "), t.weekdaysHorizontalDividerStyle_ ? n("div", {
          staticClass: "c-horizontal-divider",
          style: t.weekdaysHorizontalDividerStyle_
        }) : t._e(), t._v(" "), n("div", {
          staticClass: "c-weeks",
          style: t.weeksStyle_
        }, [n("transition-group", {
          staticClass: "c-weeks-rows-wrapper",
          attrs: {
            tag: "div",
            name: t.weeksTransition_
          },
          on: {
            "before-enter": function (e) {
              t.weeksTransitioning = !0;
            },
            "after-enter": function (e) {
              t.weeksTransitioning = !1;
            }
          }
        }, t._l(t.pages, function (e) {
          return e === t.page_ ? n("calendar-weeks", t._g(t._b({
            key: e.key,
            staticClass: "c-weeks-rows",
            attrs: {
              "month-comps": e.monthComps,
              "prev-month-comps": e.prevMonthComps,
              "next-month-comps": e.nextMonthComps,
              styles: t.styles,
              formats: t.formats
            },
            on: {
              "&touchstart": function (e) {
                t.touchStart(e);
              },
              "&touchmove": function (e) {
                t.touchMove(e);
              },
              "&touchend": function (e) {
                t.touchEnd(e);
              }
            },
            scopedSlots: t._u([t._l(Object.keys(t.$scopedSlots), function (e) {
              return {
                key: e,
                fn: function (n) {
                  return [t._t(e, null, null, n)];
                }
              };
            })])
          }, "calendar-weeks", t.$attrs, !1), t.$listeners)) : t._e();
        }))], 1)], 2);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = n(0),
        i = n.n(r),
        a = n(53),
        o = n(2);

    e.a = function (t) {
      var e = Object(o.a)(t) && t.filter(function (t) {
        return t && t.dates;
      }).map(function (t, e) {
        return Object(a.a)(i()({
          key: t.key || e.toString(),
          order: t.order || 0
        }, t));
      }) || [];
      return {
        length: e.length,
        find: function (t) {
          return e.map(function (e) {
            return i()({}, e, {
              targetDate: e.includesDay(t)
            });
          }).filter(function (t) {
            return t.targetDate;
          }).sort(function (t, e) {
            return t.targetDate.compare(e.targetDate);
          });
        }
      };
    };
  }, function (t, e, n) {
    "use strict";

    var r = n(54),
        i = n(1)(r.a, null, !1, null, null, null);
    e.a = i.exports;
  }, function (t, e, n) {
    "use strict";

    var r = n(55),
        i = n(1)(r.a, null, !1, null, null, null);
    e.a = i.exports;
  }, function (t, e, n) {
    "use strict";

    var r = n(56),
        i = n(1)(r.a, null, !1, null, null, null);
    e.a = i.exports;
  }, function (t, e, n) {
    "use strict";

    var r = n(57),
        i = n(1)(r.a, null, !1, null, null, null);
    e.a = i.exports;
  }, function (t, e, n) {
    "use strict";

    var r = n(58),
        i = n(128);

    var a = function (t) {
      n(127);
    },
        o = n(1)(r.a, i.a, !1, a, "data-v-6c331e62", null);

    e.a = o.exports;
  }, function (t, e) {}, function (t, e, n) {
    "use strict";

    var r = {
      render: function () {
        var t = this.$createElement,
            e = this._self._c || t;
        return e("div", [e("div", {
          staticClass: "date-label"
        }, [this.dateLabel ? e("div", [this._v("\n      " + this._s(this.dateLabel) + "\n    ")]) : this._e(), this._v(" "), this.startDateLabel ? e("div", [this._v("\n      " + this._s(this.startDateLabel) + "\n    ")]) : this._e(), this._v(" "), this.endDateLabel ? e("div", [this._v("\n      " + this._s(this.endDateLabel) + "\n    ")]) : this._e()]), this._v(" "), this.isRange ? e("div", {
          staticClass: "days-nights"
        }, [e("span", {
          staticClass: "days"
        }, [e("svg-icon", {
          staticClass: "vc-sun-o",
          attrs: {
            name: "sun"
          }
        }), this._v("\n      " + this._s(this.days) + "\n    ")], 1), this._v(" "), e("span", {
          staticClass: "nights"
        }, [e("svg-icon", {
          staticClass: "vc-moon-o",
          attrs: {
            name: "moon"
          }
        }), this._v("\n      " + this._s(this.nights) + "\n    ")], 1)]) : this._e()]);
      },
      staticRenderFns: []
    };
    e.a = r;
  }, function (t, e, n) {
    "use strict";

    var r = n(0),
        i = n.n(r),
        a = n(2),
        o = {
      ar: {
        dow: 7,
        L: "D/M/YYYY"
      },
      bg: {
        dow: 2,
        L: "D.MM.YYYY"
      },
      ca: {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      "zh-CN": {
        dow: 2,
        L: "YYYY/MM/DD"
      },
      "zh-TW": {
        L: "YYYY/MM/DD"
      },
      hr: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      cs: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      da: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      nl: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      "en-US": {
        L: "MM/DD/YYYY"
      },
      "en-AU": {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      "en-CA": {
        L: "YYYY-MM-DD"
      },
      "en-GB": {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      "en-IE": {
        dow: 2,
        L: "DD-MM-YYYY"
      },
      "en-NZ": {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      eo: {
        dow: 2,
        L: "YYYY-MM-DD"
      },
      fi: {
        dow: 2,
        L: "Do MMMM[ta] YYYY"
      },
      fr: {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      "fr-CA": {
        L: "YYYY-MM-DD"
      },
      "fr-CH": {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      de: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      id: {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      it: {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      ja: {
        L: "YYYYMD"
      },
      ko: {
        L: "YYYY.MM.DD"
      },
      mk: {
        dow: 2,
        L: "D.MM.YYYY"
      },
      pl: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      pt: {
        dow: 2,
        L: "DD/MM/YYYY"
      },
      ro: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      ru: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      sk: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      es: {
        dow: 1,
        L: "DD/MM/YYYY"
      },
      sv: {
        dow: 2,
        L: "YYYY-MM-DD"
      },
      th: {
        L: "DD/MM/YYYY"
      },
      tr: {
        dow: 2,
        L: "DD.MM.YYYY"
      },
      uk: {
        dow: 2,
        L: "DD.MM.YYYY"
      }
    };
    o.en = o["en-US"], o.zh = o["zh-CN"];

    var s = function (t, e) {
      var n = new Intl.DateTimeFormat(t, {
        month: e,
        timezome: "UTC"
      });
      return Object(a.j)().map(function (t) {
        return n.format(t);
      });
    },
        u = function (t, e) {
      var n = new Intl.DateTimeFormat(t, {
        weekday: e,
        timeZone: "UTC"
      });
      return Object(a.q)({
        utc: !0
      }).map(function (t) {
        return n.format(t);
      });
    },
        c = function (t) {
      return "" + t + ([null, "st", "nd", "rd"][t % 100 >> 3 ^ 1 && t % 10] || "th");
    };

    e.a = function (t) {
      var e = new Intl.DateTimeFormat().resolvedOptions().locale,
          n = [t, t && t.substring(0, 2), e].find(function (t) {
        return o[t];
      }) || t || e,
          r = i()({
        dow: 1,
        L: "DD/MM/YYYY"
      }, o[n]),
          a = u(n, "long"),
          l = u(n, "short"),
          d = l.map(function (t) {
        return t.substring(0, 2);
      }),
          f = u(n, "narrow"),
          h = s(n, "long"),
          p = s(n, "short");
      return {
        locale: n,
        firstDayOfWeek: r.dow,
        masks: {
          L: r.L
        },
        dayNames: a,
        dayNamesShort: l,
        dayNamesShorter: d,
        dayNamesNarrow: f,
        monthNames: h,
        monthNamesShort: p,
        DoFn: c
      };
    };
  }]);
});
},{}],"+tzq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.Rules = exports.ErrorBag = exports.Validator = exports.mapFields = exports.mixin = exports.directive = exports.install = exports.default = void 0;

/**
  * vee-validate v2.1.0-beta.11
  * (c) 2018 Abdelrahman Awad
  * @license MIT
  */
// 
var supportsPassive = true;

var detectPassiveSupport = function () {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (e) {
    supportsPassive = false;
  }

  return supportsPassive;
};

var addEventListener = function (el, eventName, cb) {
  el.addEventListener(eventName, cb, supportsPassive ? {
    passive: true
  } : false);
};

var isTextInput = function (el) {
  return includes(['text', 'password', 'search', 'email', 'tel', 'url', 'textarea', 'number'], el.type);
};

var isCheckboxOrRadioInput = function (el) {
  return includes(['radio', 'checkbox'], el.type);
};

var isDateInput = function (el) {
  return includes(['date', 'week', 'month', 'datetime-local', 'time'], el.type);
};
/**
 * Gets the data attribute. the name must be kebab-case.
 */


var getDataAttribute = function (el, name) {
  return el.getAttribute("data-vv-" + name);
};
/**
 * Checks if the values are either null or undefined.
 */


var isNullOrUndefined = function () {
  var values = [],
      len = arguments.length;

  while (len--) values[len] = arguments[len];

  return values.every(function (value) {
    return value === null || value === undefined;
  });
};
/**
 * Creates the default flags object.
 */


var createFlags = function () {
  return {
    untouched: true,
    touched: false,
    dirty: false,
    pristine: true,
    valid: null,
    invalid: null,
    validated: false,
    pending: false,
    required: false,
    changed: false
  };
};
/**
 * Shallow object comparison.
 */


var isEqual = function (lhs, rhs) {
  if (lhs instanceof RegExp && rhs instanceof RegExp) {
    return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);
  }

  if (Array.isArray(lhs) && Array.isArray(rhs)) {
    if (lhs.length !== rhs.length) {
      return false;
    }

    for (var i = 0; i < lhs.length; i++) {
      if (!isEqual(lhs[i], rhs[i])) {
        return false;
      }
    }

    return true;
  } // if both are objects, compare each key recursively.


  if (isObject(lhs) && isObject(rhs)) {
    return Object.keys(lhs).every(function (key) {
      return isEqual(lhs[key], rhs[key]);
    }) && Object.keys(rhs).every(function (key) {
      return isEqual(lhs[key], rhs[key]);
    });
  }

  return lhs === rhs;
};
/**
 * Determines the input field scope.
 */


var getScope = function (el) {
  var scope = getDataAttribute(el, 'scope');

  if (isNullOrUndefined(scope)) {
    var form = getForm(el);

    if (form) {
      scope = getDataAttribute(form, 'scope');
    }
  }

  return !isNullOrUndefined(scope) ? scope : null;
};
/**
 * Get the closest form element.
 */


var getForm = function (el) {
  if (isNullOrUndefined(el)) {
    return null;
  }

  if (el.tagName === 'FORM') {
    return el;
  }

  if (!isNullOrUndefined(el.form)) {
    return el.form;
  }

  return !isNullOrUndefined(el.parentNode) ? getForm(el.parentNode) : null;
};
/**
 * Gets the value in an object safely.
 */


var getPath = function (path, target, def) {
  if (def === void 0) def = undefined;

  if (!path || !target) {
    return def;
  }

  var value = target;
  path.split('.').every(function (prop) {
    if (prop in value) {
      value = value[prop];
      return true;
    }

    value = def;
    return false;
  });
  return value;
};
/**
 * Checks if path exists within an object.
 */


var hasPath = function (path, target) {
  var obj = target;
  return path.split('.').every(function (prop) {
    if (prop in obj) {
      obj = obj[prop];
      return true;
    }

    return false;
  });
};
/**
 * Parses a rule string expression.
 */


var parseRule = function (rule) {
  var params = [];
  var name = rule.split(':')[0];

  if (includes(rule, ':')) {
    params = rule.split(':').slice(1).join(':').split(',');
  }

  return {
    name: name,
    params: params
  };
};
/**
 * Debounces a function.
 */


var debounce = function (fn, wait, immediate, token) {
  if (wait === void 0) wait = 0;
  if (immediate === void 0) immediate = false;
  if (token === void 0) token = {
    cancelled: false
  };

  if (wait === 0) {
    return fn;
  }

  var timeout;
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var later = function () {
      timeout = null;

      if (!immediate && !token.cancelled) {
        fn.apply(void 0, args);
      }
    };
    /* istanbul ignore next */


    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    /* istanbul ignore next */

    if (callNow) {
      fn.apply(void 0, args);
    }
  };
};
/**
 * Appends a rule definition to a list of rules.
 */


var appendRule = function (rule, rules) {
  if (!rules) {
    return normalizeRules(rule);
  }

  if (!rule) {
    return normalizeRules(rules);
  }

  if (typeof rules === 'string') {
    rules = normalizeRules(rules);
  }

  return assign({}, rules, normalizeRules(rule));
};
/**
 * Normalizes the given rules expression.
 */


var normalizeRules = function (rules) {
  // if falsy value return an empty object.
  if (!rules) {
    return {};
  }

  if (isObject(rules)) {
    // $FlowFixMe
    return Object.keys(rules).reduce(function (prev, curr) {
      var params = []; // $FlowFixMe

      if (rules[curr] === true) {
        params = [];
      } else if (Array.isArray(rules[curr])) {
        params = rules[curr];
      } else if (isObject(rules[curr])) {
        params = rules[curr];
      } else {
        params = [rules[curr]];
      } // $FlowFixMe


      if (rules[curr] !== false) {
        prev[curr] = params;
      }

      return prev;
    }, {});
  }

  if (typeof rules !== 'string') {
    warn('rules must be either a string or an object.');
    return {};
  }

  return rules.split('|').reduce(function (prev, rule) {
    var parsedRule = parseRule(rule);

    if (!parsedRule.name) {
      return prev;
    }

    prev[parsedRule.name] = parsedRule.params;
    return prev;
  }, {});
};
/**
 * Emits a warning to the console.
 */


var warn = function (message) {
  console.warn("[vee-validate] " + message); // eslint-disable-line
};
/**
 * Creates a branded error object.
 */


var createError = function (message) {
  return new Error("[vee-validate] " + message);
};
/**
 * Checks if the value is an object.
 */


var isObject = function (obj) {
  return obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);
};
/**
 * Checks if a function is callable.
 */


var isCallable = function (func) {
  return typeof func === 'function';
};
/**
 * Check if element has the css class on it.
 */


var hasClass = function (el, className) {
  if (el.classList) {
    return el.classList.contains(className);
  }

  return !!el.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
};
/**
 * Adds the provided css className to the element.
 */


var addClass = function (el, className) {
  if (el.classList) {
    el.classList.add(className);
    return;
  }

  if (!hasClass(el, className)) {
    el.className += " " + className;
  }
};
/**
 * Remove the provided css className from the element.
 */


var removeClass = function (el, className) {
  if (el.classList) {
    el.classList.remove(className);
    return;
  }

  if (hasClass(el, className)) {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    el.className = el.className.replace(reg, ' ');
  }
};
/**
 * Adds or removes a class name on the input depending on the status flag.
 */


var toggleClass = function (el, className, status) {
  if (!el || !className) {
    return;
  }

  if (Array.isArray(className)) {
    className.forEach(function (item) {
      return toggleClass(el, item, status);
    });
    return;
  }

  if (status) {
    return addClass(el, className);
  }

  removeClass(el, className);
};
/**
 * Converts an array-like object to array, provides a simple polyfill for Array.from
 */


var toArray = function (arrayLike) {
  if (isCallable(Array.from)) {
    return Array.from(arrayLike);
  }

  var array = [];
  var length = arrayLike.length;
  /* istanbul ignore next */

  for (var i = 0; i < length; i++) {
    array.push(arrayLike[i]);
  }
  /* istanbul ignore next */


  return array;
};
/**
 * Assign polyfill from the mdn.
 */


var assign = function (target) {
  var others = [],
      len = arguments.length - 1;

  while (len-- > 0) others[len] = arguments[len + 1];
  /* istanbul ignore else */


  if (isCallable(Object.assign)) {
    return Object.assign.apply(Object, [target].concat(others));
  }
  /* istanbul ignore next */


  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  /* istanbul ignore next */


  var to = Object(target);
  /* istanbul ignore next */

  others.forEach(function (arg) {
    // Skip over if undefined or null
    if (arg != null) {
      Object.keys(arg).forEach(function (key) {
        to[key] = arg[key];
      });
    }
  });
  /* istanbul ignore next */

  return to;
};

var id = 0;
var idTemplate = '{id}';
/**
 * Generates a unique id.
 */

var uniqId = function () {
  // handle too many uses of uniqId, although unlikely.
  if (id >= 9999) {
    id = 0; // shift the template.

    idTemplate = idTemplate.replace('{id}', '_{id}');
  }

  id++;
  var newId = idTemplate.replace('{id}', String(id));
  return newId;
};
/**
 * finds the first element that satisfies the predicate callback, polyfills array.find
 */


var find = function (arrayLike, predicate) {
  var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);

  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return array[i];
    }
  }

  return undefined;
};

var isBuiltInComponent = function (vnode) {
  if (!vnode) {
    return false;
  }

  var tag = vnode.componentOptions.tag;
  return /^(keep-alive|transition|transition-group)$/.test(tag);
};

var makeEventsArray = function (events) {
  return typeof events === 'string' && events.length ? events.split('|') : [];
};

var makeDelayObject = function (events, delay, delayConfig) {
  if (typeof delay === 'number') {
    return events.reduce(function (prev, e) {
      prev[e] = delay;
      return prev;
    }, {});
  }

  return events.reduce(function (prev, e) {
    if (typeof delay === 'object' && e in delay) {
      prev[e] = delay[e];
      return prev;
    }

    if (typeof delayConfig === 'number') {
      prev[e] = delayConfig;
      return prev;
    }

    prev[e] = delayConfig && delayConfig[e] || 0;
    return prev;
  }, {});
};

var deepParseInt = function (input) {
  if (typeof input === 'number') {
    return input;
  }

  if (typeof input === 'string') {
    return parseInt(input);
  }

  var map = {};

  for (var element in input) {
    map[element] = parseInt(input[element]);
  }

  return map;
};

var merge = function (target, source) {
  if (!(isObject(target) && isObject(source))) {
    return target;
  }

  Object.keys(source).forEach(function (key) {
    var obj, obj$1;

    if (isObject(source[key])) {
      if (!target[key]) {
        assign(target, (obj = {}, obj[key] = {}, obj));
      }

      merge(target[key], source[key]);
      return;
    }

    assign(target, (obj$1 = {}, obj$1[key] = source[key], obj$1));
  });
  return target;
};

var fillRulesFromElement = function (el, rules) {
  if (el.required) {
    rules = appendRule('required', rules);
  }

  if (isTextInput(el)) {
    if (el.type === 'email') {
      rules = appendRule("email" + (el.multiple ? ':multiple' : ''), rules);
    }

    if (el.pattern) {
      rules = appendRule({
        regex: el.pattern
      }, rules);
    } // 524288 is the max on some browsers and test environments.


    if (el.maxLength >= 0 && el.maxLength < 524288) {
      rules = appendRule("max:" + el.maxLength, rules);
    }

    if (el.minLength > 0) {
      rules = appendRule("min:" + el.minLength, rules);
    }

    if (el.type === 'number') {
      rules = appendRule('decimal', rules);

      if (el.min !== '') {
        rules = appendRule("min_value:" + el.min, rules);
      }

      if (el.max !== '') {
        rules = appendRule("max_value:" + el.max, rules);
      }
    }

    return rules;
  }

  if (isDateInput(el)) {
    var timeFormat = el.step && Number(el.step) < 60 ? 'HH:mm:ss' : 'HH:mm';

    if (el.type === 'date') {
      return appendRule('date_format:YYYY-MM-DD', rules);
    }

    if (el.type === 'datetime-local') {
      return appendRule("date_format:YYYY-MM-DDT" + timeFormat, rules);
    }

    if (el.type === 'month') {
      return appendRule('date_format:YYYY-MM', rules);
    }

    if (el.type === 'week') {
      return appendRule('date_format:YYYY-[W]WW', rules);
    }

    if (el.type === 'time') {
      return appendRule("date_format:" + timeFormat, rules);
    }
  }

  return rules;
};

var values = function (obj) {
  if (isCallable(Object.values)) {
    return Object.values(obj);
  } // fallback to keys()

  /* istanbul ignore next */


  return obj[Object.keys(obj)[0]];
};

var parseSelector = function (selector) {
  var rule = null;

  if (includes(selector, ':')) {
    rule = selector.split(':').pop();
    selector = selector.replace(":" + rule, '');
  }

  if (selector[0] === '#') {
    return {
      id: selector.slice(1),
      rule: rule,
      name: null,
      scope: null
    };
  }

  var scope = null;
  var name = selector;

  if (includes(selector, '.')) {
    var parts = selector.split('.');
    scope = parts[0];
    name = parts.slice(1).join('.');
  }

  return {
    id: null,
    scope: scope,
    name: name,
    rule: rule
  };
};

var includes = function (collection, item) {
  return collection.indexOf(item) !== -1;
};

var isEmptyArray = function (arr) {
  return Array.isArray(arr) && arr.length === 0;
}; // 


var LOCALE = 'en';

var Dictionary = function Dictionary(dictionary) {
  if (dictionary === void 0) dictionary = {};
  this.container = {};
  this.merge(dictionary);
};

var prototypeAccessors = {
  locale: {
    configurable: true
  }
};

prototypeAccessors.locale.get = function () {
  return LOCALE;
};

prototypeAccessors.locale.set = function (value) {
  LOCALE = value || 'en';
};

Dictionary.prototype.hasLocale = function hasLocale(locale) {
  return !!this.container[locale];
};

Dictionary.prototype.setDateFormat = function setDateFormat(locale, format) {
  if (!this.container[locale]) {
    this.container[locale] = {};
  }

  this.container[locale].dateFormat = format;
};

Dictionary.prototype.getDateFormat = function getDateFormat(locale) {
  if (!this.container[locale] || !this.container[locale].dateFormat) {
    return null;
  }

  return this.container[locale].dateFormat;
};

Dictionary.prototype.getMessage = function getMessage(locale, key, data) {
  var message = null;

  if (!this.hasMessage(locale, key)) {
    message = this._getDefaultMessage(locale);
  } else {
    message = this.container[locale].messages[key];
  }

  return isCallable(message) ? message.apply(void 0, data) : message;
};
/**
 * Gets a specific message for field. falls back to the rule message.
 */


Dictionary.prototype.getFieldMessage = function getFieldMessage(locale, field, key, data) {
  if (!this.hasLocale(locale)) {
    return this.getMessage(locale, key, data);
  }

  var dict = this.container[locale].custom && this.container[locale].custom[field];

  if (!dict || !dict[key]) {
    return this.getMessage(locale, key, data);
  }

  var message = dict[key];
  return isCallable(message) ? message.apply(void 0, data) : message;
};

Dictionary.prototype._getDefaultMessage = function _getDefaultMessage(locale) {
  if (this.hasMessage(locale, '_default')) {
    return this.container[locale].messages._default;
  }

  return this.container.en.messages._default;
};

Dictionary.prototype.getAttribute = function getAttribute(locale, key, fallback) {
  if (fallback === void 0) fallback = '';

  if (!this.hasAttribute(locale, key)) {
    return fallback;
  }

  return this.container[locale].attributes[key];
};

Dictionary.prototype.hasMessage = function hasMessage(locale, key) {
  return !!(this.hasLocale(locale) && this.container[locale].messages && this.container[locale].messages[key]);
};

Dictionary.prototype.hasAttribute = function hasAttribute(locale, key) {
  return !!(this.hasLocale(locale) && this.container[locale].attributes && this.container[locale].attributes[key]);
};

Dictionary.prototype.merge = function merge$1(dictionary) {
  merge(this.container, dictionary);
};

Dictionary.prototype.setMessage = function setMessage(locale, key, message) {
  if (!this.hasLocale(locale)) {
    this.container[locale] = {
      messages: {},
      attributes: {}
    };
  }

  this.container[locale].messages[key] = message;
};

Dictionary.prototype.setAttribute = function setAttribute(locale, key, attribute) {
  if (!this.hasLocale(locale)) {
    this.container[locale] = {
      messages: {},
      attributes: {}
    };
  }

  this.container[locale].attributes[key] = attribute;
};

Object.defineProperties(Dictionary.prototype, prototypeAccessors);
var drivers = {
  default: new Dictionary({
    en: {
      messages: {},
      attributes: {},
      custom: {}
    }
  })
};
var currentDriver = 'default';

var DictionaryResolver = function DictionaryResolver() {};

DictionaryResolver._checkDriverName = function _checkDriverName(driver) {
  if (!driver) {
    throw createError('you must provide a name to the dictionary drive');
  }
};

DictionaryResolver.setDriver = function setDriver(driver, implementation) {
  if (implementation === void 0) implementation = null;

  this._checkDriverName(driver);

  if (implementation) {
    drivers[driver] = implementation;
  }

  currentDriver = driver || 'default';
};

DictionaryResolver.getDriver = function getDriver() {
  return drivers[currentDriver];
}; // 


var ErrorBag = function ErrorBag(errorBag, id) {
  if (errorBag === void 0) errorBag = null;
  if (id === void 0) id = null;
  this.vmId = id || null; // make this bag a mirror of the provided one, sharing the same items reference.

  if (errorBag && errorBag instanceof ErrorBag) {
    this.items = errorBag.items;
  } else {
    this.items = [];
  }
};

exports.ErrorBag = ErrorBag;

ErrorBag.prototype[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'] = function () {
  var this$1 = this;
  var index = 0;
  return {
    next: function () {
      return {
        value: this$1.items[index++],
        done: index > this$1.items.length
      };
    }
  };
};
/**
 * Adds an error to the internal array.
 */


ErrorBag.prototype.add = function add(error) {
  var ref;
  (ref = this.items).push.apply(ref, this._normalizeError(error));
};
/**
 * Normalizes passed errors to an error array.
 */


ErrorBag.prototype._normalizeError = function _normalizeError(error) {
  var this$1 = this;

  if (Array.isArray(error)) {
    return error.map(function (e) {
      e.scope = !isNullOrUndefined(e.scope) ? e.scope : null;
      e.vmId = !isNullOrUndefined(e.vmId) ? e.vmId : this$1.vmId || null;
      return e;
    });
  }

  error.scope = !isNullOrUndefined(error.scope) ? error.scope : null;
  error.vmId = !isNullOrUndefined(error.vmId) ? error.vmId : this.vmId || null;
  return [error];
};
/**
 * Regenrates error messages if they have a generator function.
 */


ErrorBag.prototype.regenerate = function regenerate() {
  this.items.forEach(function (i) {
    i.msg = isCallable(i.regenerate) ? i.regenerate() : i.msg;
  });
};
/**
 * Updates a field error with the new field scope.
 */


ErrorBag.prototype.update = function update(id, error) {
  var item = find(this.items, function (i) {
    return i.id === id;
  });

  if (!item) {
    return;
  }

  var idx = this.items.indexOf(item);
  this.items.splice(idx, 1);
  item.scope = error.scope;
  this.items.push(item);
};
/**
 * Gets all error messages from the internal array.
 */


ErrorBag.prototype.all = function all(scope) {
  var this$1 = this;

  var filterFn = function (item) {
    var matchesScope = true;
    var matchesVM = true;

    if (!isNullOrUndefined(scope)) {
      matchesScope = item.scope === scope;
    }

    if (!isNullOrUndefined(this$1.vmId)) {
      matchesVM = item.vmId === this$1.vmId;
    }

    return matchesVM && matchesScope;
  };

  return this.items.filter(filterFn).map(function (e) {
    return e.msg;
  });
};
/**
 * Checks if there are any errors in the internal array.
 */


ErrorBag.prototype.any = function any(scope) {
  var this$1 = this;

  var filterFn = function (item) {
    var matchesScope = true;
    var matchesVM = true;

    if (!isNullOrUndefined(scope)) {
      matchesScope = item.scope === scope;
    }

    if (!isNullOrUndefined(this$1.vmId)) {
      matchesVM = item.vmId === this$1.vmId;
    }

    return matchesVM && matchesScope;
  };

  return !!this.items.filter(filterFn).length;
};
/**
 * Removes all items from the internal array.
 */


ErrorBag.prototype.clear = function clear(scope) {
  var this$1 = this;
  var matchesVM = isNullOrUndefined(this.vmId) ? function () {
    return true;
  } : function (i) {
    return i.vmId === this$1.vmId;
  };

  if (isNullOrUndefined(scope)) {
    scope = null;
  }

  for (var i = 0; i < this.items.length; ++i) {
    if (matchesVM(this$1.items[i]) && this$1.items[i].scope === scope) {
      this$1.items.splice(i, 1);
      --i;
    }
  }
};
/**
 * Collects errors into groups or for a specific field.
 */


ErrorBag.prototype.collect = function collect(field, scope, map) {
  var this$1 = this;
  if (map === void 0) map = true;
  var isSingleField = !isNullOrUndefined(field) && !field.includes('*');

  var groupErrors = function (items) {
    var errors = items.reduce(function (collection, error) {
      if (!isNullOrUndefined(this$1.vmId) && error.vmId !== this$1.vmId) {
        return collection;
      }

      if (!collection[error.field]) {
        collection[error.field] = [];
      }

      collection[error.field].push(map ? error.msg : error);
      return collection;
    }, {}); // reduce the collection to be a single array.

    if (isSingleField) {
      return values(errors)[0] || [];
    }

    return errors;
  };

  if (isNullOrUndefined(field)) {
    return groupErrors(this.items);
  }

  var selector = isNullOrUndefined(scope) ? String(field) : scope + "." + field;

  var ref = this._makeCandidateFilters(selector);

  var isPrimary = ref.isPrimary;
  var isAlt = ref.isAlt;
  var collected = this.items.reduce(function (prev, curr) {
    if (isPrimary(curr)) {
      prev.primary.push(curr);
    }

    if (isAlt(curr)) {
      prev.alt.push(curr);
    }

    return prev;
  }, {
    primary: [],
    alt: []
  });
  collected = collected.primary.length ? collected.primary : collected.alt;
  return groupErrors(collected);
};
/**
 * Gets the internal array length.
 */


ErrorBag.prototype.count = function count() {
  var this$1 = this;

  if (this.vmId) {
    return this.items.filter(function (e) {
      return e.vmId === this$1.vmId;
    }).length;
  }

  return this.items.length;
};
/**
 * Finds and fetches the first error message for the specified field id.
 */


ErrorBag.prototype.firstById = function firstById(id) {
  var error = find(this.items, function (i) {
    return i.id === id;
  });
  return error ? error.msg : undefined;
};
/**
 * Gets the first error message for a specific field.
 */


ErrorBag.prototype.first = function first(field, scope) {
  if (scope === void 0) scope = null;
  var selector = isNullOrUndefined(scope) ? field : scope + "." + field;

  var match = this._match(selector);

  return match && match.msg;
};
/**
 * Returns the first error rule for the specified field
 */


ErrorBag.prototype.firstRule = function firstRule(field, scope) {
  var errors = this.collect(field, scope, false);
  return errors.length && errors[0].rule || undefined;
};
/**
 * Checks if the internal array has at least one error for the specified field.
 */


ErrorBag.prototype.has = function has(field, scope) {
  if (scope === void 0) scope = null;
  return !!this.first(field, scope);
};
/**
 * Gets the first error message for a specific field and a rule.
 */


ErrorBag.prototype.firstByRule = function firstByRule(name, rule, scope) {
  if (scope === void 0) scope = null;
  var error = this.collect(name, scope, false).filter(function (e) {
    return e.rule === rule;
  })[0];
  return error && error.msg || undefined;
};
/**
 * Gets the first error message for a specific field that not match the rule.
 */


ErrorBag.prototype.firstNot = function firstNot(name, rule, scope) {
  if (rule === void 0) rule = 'required';
  if (scope === void 0) scope = null;
  var error = this.collect(name, scope, false).filter(function (e) {
    return e.rule !== rule;
  })[0];
  return error && error.msg || undefined;
};
/**
 * Removes errors by matching against the id or ids.
 */


ErrorBag.prototype.removeById = function removeById(id) {
  var this$1 = this;

  var condition = function (item) {
    return item.id === id;
  };

  if (Array.isArray(id)) {
    condition = function (item) {
      return id.indexOf(item.id) !== -1;
    };
  }

  for (var i = 0; i < this.items.length; ++i) {
    if (condition(this$1.items[i])) {
      this$1.items.splice(i, 1);
      --i;
    }
  }
};
/**
 * Removes all error messages associated with a specific field.
 */


ErrorBag.prototype.remove = function remove(field, scope, vmId) {
  var this$1 = this;

  if (isNullOrUndefined(field)) {
    return;
  }

  var selector = isNullOrUndefined(scope) ? String(field) : scope + "." + field;

  var ref = this._makeCandidateFilters(selector);

  var isPrimary = ref.isPrimary;

  var shouldRemove = function (item) {
    if (isNullOrUndefined(vmId)) {
      return isPrimary(item);
    }

    return isPrimary(item) && item.vmId === vmId;
  };

  for (var i = 0; i < this.items.length; ++i) {
    if (shouldRemove(this$1.items[i])) {
      this$1.items.splice(i, 1);
      --i;
    }
  }
};

ErrorBag.prototype._makeCandidateFilters = function _makeCandidateFilters(selector) {
  var this$1 = this;

  var matchesRule = function () {
    return true;
  };

  var matchesScope = function () {
    return true;
  };

  var matchesName = function () {
    return true;
  };

  var matchesVM = function () {
    return true;
  };

  var ref = parseSelector(selector);
  var id = ref.id;
  var rule = ref.rule;
  var scope = ref.scope;
  var name = ref.name;

  if (rule) {
    matchesRule = function (item) {
      return item.rule === rule;
    };
  } // match by id, can be combined with rule selection.


  if (id) {
    return {
      isPrimary: function (item) {
        return matchesRule(item) && function (item) {
          return id === item.id;
        };
      },
      isAlt: function () {
        return false;
      }
    };
  }

  if (isNullOrUndefined(scope)) {
    // if no scope specified, make sure the found error has no scope.
    matchesScope = function (item) {
      return isNullOrUndefined(item.scope);
    };
  } else {
    matchesScope = function (item) {
      return item.scope === scope;
    };
  }

  if (!isNullOrUndefined(name) && name !== '*') {
    matchesName = function (item) {
      return item.field === name;
    };
  }

  if (!isNullOrUndefined(this.vmId)) {
    matchesVM = function (item) {
      return item.vmId === this$1.vmId;
    };
  } // matches the first candidate.


  var isPrimary = function (item) {
    return matchesVM(item) && matchesName(item) && matchesRule(item) && matchesScope(item);
  }; // matches a second candidate, which is a field with a name containing the '.' character.


  var isAlt = function (item) {
    return matchesVM(item) && matchesRule(item) && item.field === scope + "." + name;
  };

  return {
    isPrimary: isPrimary,
    isAlt: isAlt
  };
};

ErrorBag.prototype._match = function _match(selector) {
  if (isNullOrUndefined(selector)) {
    return undefined;
  }

  var ref = this._makeCandidateFilters(selector);

  var isPrimary = ref.isPrimary;
  var isAlt = ref.isAlt;
  return this.items.reduce(function (prev, item, idx, arr) {
    var isLast = idx === arr.length - 1;

    if (prev.primary) {
      return isLast ? prev.primary : prev;
    }

    if (isPrimary(item)) {
      prev.primary = item;
    }

    if (isAlt(item)) {
      prev.alt = item;
    } // keep going.


    if (!isLast) {
      return prev;
    }

    return prev.primary || prev.alt;
  }, {});
};
/**
 * Generates the options required to construct a field.
 */


var Resolver = function Resolver() {};

Resolver.generate = function generate(el, binding, vnode) {
  var model = Resolver.resolveModel(binding, vnode);
  var options = pluginInstance.resolveConfig(vnode.context);
  return {
    name: Resolver.resolveName(el, vnode),
    el: el,
    listen: !binding.modifiers.disable,
    bails: binding.modifiers.bails ? true : binding.modifiers.continues === true ? false : undefined,
    scope: Resolver.resolveScope(el, binding, vnode),
    vm: Resolver.makeVM(vnode.context),
    expression: binding.value,
    component: vnode.componentInstance,
    classes: options.classes,
    classNames: options.classNames,
    getter: Resolver.resolveGetter(el, vnode, model),
    events: Resolver.resolveEvents(el, vnode) || options.events,
    model: model,
    delay: Resolver.resolveDelay(el, vnode, options),
    rules: Resolver.resolveRules(el, binding, vnode),
    immediate: !!binding.modifiers.initial || !!binding.modifiers.immediate,
    validity: options.validity,
    aria: options.aria,
    initialValue: Resolver.resolveInitialValue(vnode)
  };
};

Resolver.getCtorConfig = function getCtorConfig(vnode) {
  if (!vnode.componentInstance) {
    return null;
  }

  var config = getPath('componentInstance.$options.$_veeValidate', vnode);
  return config;
};
/**
 * Resolves the rules defined on an element.
 */


Resolver.resolveRules = function resolveRules(el, binding, vnode) {
  var rules = '';

  if (!binding.value && (!binding || !binding.expression)) {
    rules = getDataAttribute(el, 'rules');
  }

  if (binding.value && includes(['string', 'object'], typeof binding.value.rules)) {
    rules = binding.value.rules;
  } else if (binding.value) {
    rules = binding.value;
  }

  if (vnode.componentInstance) {
    return rules;
  }

  return fillRulesFromElement(el, rules);
};
/**
 * @param {*} vnode
 */


Resolver.resolveInitialValue = function resolveInitialValue(vnode) {
  var model = vnode.data.model || find(vnode.data.directives, function (d) {
    return d.name === 'model';
  });
  return model && model.value;
};
/**
 * Creates a non-circular partial VM instance from a Vue instance.
 * @param {*} vm
 */


Resolver.makeVM = function makeVM(vm) {
  return {
    get $el() {
      return vm.$el;
    },

    get $refs() {
      return vm.$refs;
    },

    $watch: vm.$watch ? vm.$watch.bind(vm) : function () {},
    $validator: vm.$validator ? {
      errors: vm.$validator.errors,
      validate: vm.$validator.validate.bind(vm.$validator),
      update: vm.$validator.update.bind(vm.$validator)
    } : null
  };
};
/**
 * Resolves the delay value.
 * @param {*} el
 * @param {*} vnode
 * @param {Object} options
 */


Resolver.resolveDelay = function resolveDelay(el, vnode, options) {
  var delay = getDataAttribute(el, 'delay');
  var globalDelay = options && 'delay' in options ? options.delay : 0;

  if (!delay && vnode.componentInstance && vnode.componentInstance.$attrs) {
    delay = vnode.componentInstance.$attrs['data-vv-delay'];
  }

  if (!isObject(globalDelay)) {
    return deepParseInt(delay || globalDelay);
  }

  if (!isNullOrUndefined(delay)) {
    globalDelay.input = delay;
  }

  return deepParseInt(globalDelay);
};
/**
 * Resolves the events to validate in response to.
 * @param {*} el
 * @param {*} vnode
 */


Resolver.resolveEvents = function resolveEvents(el, vnode) {
  // resolve it from the root element.
  var events = getDataAttribute(el, 'validate-on'); // resolve from data-vv-validate-on if its a vue component.

  if (!events && vnode.componentInstance && vnode.componentInstance.$attrs) {
    events = vnode.componentInstance.$attrs['data-vv-validate-on'];
  } // resolve it from $_veeValidate options.


  if (!events && vnode.componentInstance) {
    var config = Resolver.getCtorConfig(vnode);
    events = config && config.events;
  }

  if (!events && pluginInstance.config.events) {
    events = pluginInstance.config.events;
  } // resolve the model event if its configured for custom components.


  if (events && vnode.componentInstance && includes(events, 'input')) {
    var ref = vnode.componentInstance.$options.model || {
      event: 'input'
    };
    var event = ref.event; // if the prop was configured but not the model.

    if (!event) {
      return events;
    }

    events = events.replace('input', event);
  }

  return events;
};
/**
 * Resolves the scope for the field.
 * @param {*} el
 * @param {*} binding
 */


Resolver.resolveScope = function resolveScope(el, binding, vnode) {
  if (vnode === void 0) vnode = {};
  var scope = null;

  if (vnode.componentInstance && isNullOrUndefined(scope)) {
    scope = vnode.componentInstance.$attrs && vnode.componentInstance.$attrs['data-vv-scope'];
  }

  return !isNullOrUndefined(scope) ? scope : getScope(el);
};
/**
 * Checks if the node directives contains a v-model or a specified arg.
 * Args take priority over models.
 *
 * @return {Object}
 */


Resolver.resolveModel = function resolveModel(binding, vnode) {
  if (binding.arg) {
    return {
      expression: binding.arg
    };
  }

  var model = vnode.data.model || find(vnode.data.directives, function (d) {
    return d.name === 'model';
  });

  if (!model) {
    return null;
  } // https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L26


  var watchable = !/[^\w.$]/.test(model.expression) && hasPath(model.expression, vnode.context);
  var lazy = !!(model.modifiers && model.modifiers.lazy);

  if (!watchable) {
    return {
      expression: null,
      lazy: lazy
    };
  }

  return {
    expression: model.expression,
    lazy: lazy
  };
};
/**
 * Resolves the field name to trigger validations.
 * @return {String} The field name.
 */


Resolver.resolveName = function resolveName(el, vnode) {
  var name = getDataAttribute(el, 'name');

  if (!name && !vnode.componentInstance) {
    return el.name;
  }

  if (!name && vnode.componentInstance && vnode.componentInstance.$attrs) {
    name = vnode.componentInstance.$attrs['data-vv-name'] || vnode.componentInstance.$attrs['name'];
  }

  if (!name && vnode.componentInstance) {
    var config = Resolver.getCtorConfig(vnode);

    if (config && isCallable(config.name)) {
      var boundGetter = config.name.bind(vnode.componentInstance);
      return boundGetter();
    }

    return vnode.componentInstance.name;
  }

  return name;
};
/**
 * Returns a value getter input type.
 */


Resolver.resolveGetter = function resolveGetter(el, vnode, model) {
  if (model && model.expression) {
    return function () {
      return getPath(model.expression, vnode.context);
    };
  }

  if (vnode.componentInstance) {
    var path = getDataAttribute(el, 'value-path') || vnode.componentInstance.$attrs && vnode.componentInstance.$attrs['data-vv-value-path'];

    if (path) {
      return function () {
        return getPath(path, vnode.componentInstance);
      };
    }

    var config = Resolver.getCtorConfig(vnode);

    if (config && isCallable(config.value)) {
      var boundGetter = config.value.bind(vnode.componentInstance);
      return function () {
        return boundGetter();
      };
    }

    var ref = vnode.componentInstance.$options.model || {
      prop: 'value'
    };
    var prop = ref.prop;
    return function () {
      return vnode.componentInstance[prop];
    };
  }

  switch (el.type) {
    case 'checkbox':
      return function () {
        var els = document.querySelectorAll("input[name=\"" + el.name + "\"]");
        els = toArray(els).filter(function (el) {
          return el.checked;
        });

        if (!els.length) {
          return undefined;
        }

        return els.map(function (checkbox) {
          return checkbox.value;
        });
      };

    case 'radio':
      return function () {
        var els = document.querySelectorAll("input[name=\"" + el.name + "\"]");
        var elm = find(els, function (el) {
          return el.checked;
        });
        return elm && elm.value;
      };

    case 'file':
      return function (context) {
        return toArray(el.files);
      };

    case 'select-multiple':
      return function () {
        return toArray(el.options).filter(function (opt) {
          return opt.selected;
        }).map(function (opt) {
          return opt.value;
        });
      };

    default:
      return function () {
        return el && el.value;
      };
  }
};

var RULES = {};

var RuleContainer = function RuleContainer() {};

var staticAccessors = {
  rules: {
    configurable: true
  }
};

RuleContainer.add = function add(name, ref) {
  var validate = ref.validate;
  var options = ref.options;
  var paramNames = ref.paramNames;
  RULES[name] = {
    validate: validate,
    options: options,
    paramNames: paramNames
  };
};

staticAccessors.rules.get = function () {
  return RULES;
};

RuleContainer.has = function has(name) {
  return !!RULES[name];
};

RuleContainer.isImmediate = function isImmediate(name) {
  return !!(RULES[name] && RULES[name].options.immediate);
};

RuleContainer.isTargetRule = function isTargetRule(name) {
  return !!(RULES[name] && RULES[name].options.hasTarget);
};

RuleContainer.remove = function remove(ruleName) {
  delete RULES[ruleName];
};

RuleContainer.getParamNames = function getParamNames(ruleName) {
  return RULES[ruleName] && RULES[ruleName].paramNames;
};

RuleContainer.getOptions = function getOptions(ruleName) {
  return RULES[ruleName] && RULES[ruleName].options;
};

RuleContainer.getValidatorMethod = function getValidatorMethod(ruleName) {
  return RULES[ruleName] ? RULES[ruleName].validate : null;
};

Object.defineProperties(RuleContainer, staticAccessors); // 

var DEFAULT_OPTIONS = {
  targetOf: null,
  immediate: false,
  scope: null,
  listen: true,
  name: null,
  rules: {},
  vm: null,
  classes: false,
  validity: true,
  aria: true,
  events: 'input|blur',
  delay: 0,
  classNames: {
    touched: 'touched',
    // the control has been blurred
    untouched: 'untouched',
    // the control hasn't been blurred
    valid: 'valid',
    // model is valid
    invalid: 'invalid',
    // model is invalid
    pristine: 'pristine',
    // control has not been interacted with
    dirty: 'dirty' // control has been interacted with

  }
};

var Field = function Field(options) {
  if (options === void 0) options = {};
  this.id = uniqId();
  this.el = options.el;
  this.updated = false;
  this.dependencies = [];
  this.vmId = options.vmId;
  this.watchers = [];
  this.events = [];
  this.delay = 0;
  this.rules = {};

  this._cacheId(options);

  this.classNames = assign({}, DEFAULT_OPTIONS.classNames);
  options = assign({}, DEFAULT_OPTIONS, options);
  this._delay = !isNullOrUndefined(options.delay) ? options.delay : 0; // cache initial delay

  this.validity = options.validity;
  this.aria = options.aria;
  this.flags = createFlags();
  this.vm = options.vm;
  this.componentInstance = options.component;
  this.ctorConfig = this.componentInstance ? getPath('$options.$_veeValidate', this.componentInstance) : undefined;
  this.update(options); // set initial value.

  this.initialValue = this.value;
  this.updated = false;
};

var prototypeAccessors$1 = {
  validator: {
    configurable: true
  },
  isRequired: {
    configurable: true
  },
  isDisabled: {
    configurable: true
  },
  alias: {
    configurable: true
  },
  value: {
    configurable: true
  },
  bails: {
    configurable: true
  },
  rejectsFalse: {
    configurable: true
  }
};

prototypeAccessors$1.validator.get = function () {
  if (!this.vm || !this.vm.$validator) {
    return {
      validate: function () {}
    };
  }

  return this.vm.$validator;
};

prototypeAccessors$1.isRequired.get = function () {
  return !!this.rules.required;
};

prototypeAccessors$1.isDisabled.get = function () {
  return !!(this.componentInstance && this.componentInstance.disabled) || !!(this.el && this.el.disabled);
};
/**
 * Gets the display name (user-friendly name).
 */


prototypeAccessors$1.alias.get = function () {
  if (this._alias) {
    return this._alias;
  }

  var alias = null;

  if (this.el) {
    alias = getDataAttribute(this.el, 'as');
  }

  if (!alias && this.componentInstance) {
    return this.componentInstance.$attrs && this.componentInstance.$attrs['data-vv-as'];
  }

  return alias;
};
/**
 * Gets the input value.
 */


prototypeAccessors$1.value.get = function () {
  if (!isCallable(this.getter)) {
    return undefined;
  }

  return this.getter();
};

prototypeAccessors$1.bails.get = function () {
  return this._bails;
};
/**
 * If the field rejects false as a valid value for the required rule.
 */


prototypeAccessors$1.rejectsFalse.get = function () {
  if (this.componentInstance && this.ctorConfig) {
    return !!this.ctorConfig.rejectsFalse;
  }

  if (!this.el) {
    return false;
  }

  return this.el.type === 'checkbox';
};
/**
 * Determines if the instance matches the options provided.
 */


Field.prototype.matches = function matches(options) {
  var this$1 = this;

  if (!options) {
    return true;
  }

  if (options.id) {
    return this.id === options.id;
  }

  var matchesComponentId = isNullOrUndefined(options.vmId) ? function () {
    return true;
  } : function (id) {
    return id === this$1.vmId;
  };

  if (!matchesComponentId(options.vmId)) {
    return false;
  }

  if (options.name === undefined && options.scope === undefined) {
    return true;
  }

  if (options.scope === undefined) {
    return this.name === options.name;
  }

  if (options.name === undefined) {
    return this.scope === options.scope;
  }

  return options.name === this.name && options.scope === this.scope;
};
/**
 * Caches the field id.
 */


Field.prototype._cacheId = function _cacheId(options) {
  if (this.el && !options.targetOf) {
    this.el._veeValidateId = this.id;
  }
};
/**
 * Keeps a reference of the most current validation run.
 */


Field.prototype.waitFor = function waitFor(pendingPromise) {
  this._waitingFor = pendingPromise;
};

Field.prototype.isWaitingFor = function isWaitingFor(promise) {
  return this._waitingFor === promise;
};
/**
 * Updates the field with changed data.
 */


Field.prototype.update = function update(options) {
  this.targetOf = options.targetOf || null;
  this.immediate = options.immediate || this.immediate || false; // update errors scope if the field scope was changed.

  if (!isNullOrUndefined(options.scope) && options.scope !== this.scope && isCallable(this.validator.update)) {
    this.validator.update(this.id, {
      scope: options.scope
    });
  }

  this.scope = !isNullOrUndefined(options.scope) ? options.scope : !isNullOrUndefined(this.scope) ? this.scope : null;
  this.name = (!isNullOrUndefined(options.name) ? String(options.name) : options.name) || this.name || null;
  this.rules = options.rules !== undefined ? normalizeRules(options.rules) : this.rules;
  this._bails = options.bails !== undefined ? options.bails : this._bails;
  this.model = options.model || this.model;
  this.listen = options.listen !== undefined ? options.listen : this.listen;
  this.classes = (options.classes || this.classes || false) && !this.componentInstance;
  this.classNames = isObject(options.classNames) ? merge(this.classNames, options.classNames) : this.classNames;
  this.getter = isCallable(options.getter) ? options.getter : this.getter;
  this._alias = options.alias || this._alias;
  this.events = options.events ? makeEventsArray(options.events) : this.events;
  this.delay = makeDelayObject(this.events, options.delay || this.delay, this._delay);
  this.updateDependencies();
  this.addActionListeners();

  if ("production" !== 'production' && !this.name && !this.targetOf) {
    warn('A field is missing a "name" or "data-vv-name" attribute');
  } // update required flag flags


  if (options.rules !== undefined) {
    this.flags.required = this.isRequired;
  } // validate if it was validated before and field was updated and there was a rules mutation.


  if (this.flags.validated && options.rules !== undefined && this.updated) {
    this.validator.validate("#" + this.id);
  }

  this.updated = true;
  this.addValueListeners(); // no need to continue.

  if (!this.el) {
    return;
  }

  this.updateClasses();
  this.updateAriaAttrs();
};
/**
 * Resets field flags and errors.
 */


Field.prototype.reset = function reset() {
  var this$1 = this;

  if (this._cancellationToken) {
    this._cancellationToken.cancelled = true;
    delete this._cancellationToken;
  }

  var defaults = createFlags();
  Object.keys(this.flags).filter(function (flag) {
    return flag !== 'required';
  }).forEach(function (flag) {
    this$1.flags[flag] = defaults[flag];
  });
  this.addActionListeners();
  this.updateClasses();
  this.updateAriaAttrs();
  this.updateCustomValidity();
};
/**
 * Sets the flags and their negated counterparts, and updates the classes and re-adds action listeners.
 */


Field.prototype.setFlags = function setFlags(flags) {
  var this$1 = this;
  var negated = {
    pristine: 'dirty',
    dirty: 'pristine',
    valid: 'invalid',
    invalid: 'valid',
    touched: 'untouched',
    untouched: 'touched'
  };
  Object.keys(flags).forEach(function (flag) {
    this$1.flags[flag] = flags[flag]; // if it has a negation and was not specified, set it as well.

    if (negated[flag] && flags[negated[flag]] === undefined) {
      this$1.flags[negated[flag]] = !flags[flag];
    }
  });

  if (flags.untouched !== undefined || flags.touched !== undefined || flags.dirty !== undefined || flags.pristine !== undefined) {
    this.addActionListeners();
  }

  this.updateClasses();
  this.updateAriaAttrs();
  this.updateCustomValidity();
};
/**
 * Determines if the field requires references to target fields.
*/


Field.prototype.updateDependencies = function updateDependencies() {
  var this$1 = this; // reset dependencies.

  this.dependencies.forEach(function (d) {
    return d.field.destroy();
  });
  this.dependencies = []; // we get the selectors for each field.

  var fields = Object.keys(this.rules).reduce(function (prev, r) {
    if (RuleContainer.isTargetRule(r)) {
      prev.push({
        selector: this$1.rules[r][0],
        name: r
      });
    }

    return prev;
  }, []);

  if (!fields.length || !this.vm || !this.vm.$el) {
    return;
  } // must be contained within the same component, so we use the vm root element constrain our dom search.


  fields.forEach(function (ref$1) {
    var selector = ref$1.selector;
    var name = ref$1.name;
    var ref = this$1.vm.$refs[selector];
    var el = Array.isArray(ref) ? ref[0] : ref;

    if (!el) {
      return;
    }

    var options = {
      vm: this$1.vm,
      classes: this$1.classes,
      classNames: this$1.classNames,
      delay: this$1.delay,
      scope: this$1.scope,
      events: this$1.events.join('|'),
      immediate: this$1.immediate,
      targetOf: this$1.id
    }; // probably a component.

    if (isCallable(el.$watch)) {
      options.component = el;
      options.el = el.$el;
      options.getter = Resolver.resolveGetter(el.$el, el.$vnode);
    } else {
      options.el = el;
      options.getter = Resolver.resolveGetter(el, {});
    }

    this$1.dependencies.push({
      name: name,
      field: new Field(options)
    });
  });
};
/**
 * Removes listeners.
 */


Field.prototype.unwatch = function unwatch(tag) {
  if (tag === void 0) tag = null;

  if (!tag) {
    this.watchers.forEach(function (w) {
      return w.unwatch();
    });
    this.watchers = [];
    return;
  }

  this.watchers.filter(function (w) {
    return tag.test(w.tag);
  }).forEach(function (w) {
    return w.unwatch();
  });
  this.watchers = this.watchers.filter(function (w) {
    return !tag.test(w.tag);
  });
};
/**
 * Updates the element classes depending on each field flag status.
 */


Field.prototype.updateClasses = function updateClasses() {
  var this$1 = this;

  if (!this.classes || this.isDisabled) {
    return;
  }

  var applyClasses = function (el) {
    toggleClass(el, this$1.classNames.dirty, this$1.flags.dirty);
    toggleClass(el, this$1.classNames.pristine, this$1.flags.pristine);
    toggleClass(el, this$1.classNames.touched, this$1.flags.touched);
    toggleClass(el, this$1.classNames.untouched, this$1.flags.untouched); // make sure we don't set any classes if the state is undetermined.

    if (!isNullOrUndefined(this$1.flags.valid) && this$1.flags.validated) {
      toggleClass(el, this$1.classNames.valid, this$1.flags.valid);
    }

    if (!isNullOrUndefined(this$1.flags.invalid) && this$1.flags.validated) {
      toggleClass(el, this$1.classNames.invalid, this$1.flags.invalid);
    }
  };

  if (!isCheckboxOrRadioInput(this.el)) {
    applyClasses(this.el);
    return;
  }

  var els = document.querySelectorAll("input[name=\"" + this.el.name + "\"]");
  toArray(els).forEach(applyClasses);
};
/**
 * Adds the listeners required for automatic classes and some flags.
 */


Field.prototype.addActionListeners = function addActionListeners() {
  var this$1 = this; // remove previous listeners.

  this.unwatch(/class/);

  if (!this.el) {
    return;
  }

  var onBlur = function () {
    this$1.flags.touched = true;
    this$1.flags.untouched = false;

    if (this$1.classes) {
      toggleClass(this$1.el, this$1.classNames.touched, true);
      toggleClass(this$1.el, this$1.classNames.untouched, false);
    } // only needed once.


    this$1.unwatch(/^class_blur$/);
  };

  var inputEvent = isTextInput(this.el) ? 'input' : 'change';

  var onInput = function () {
    this$1.flags.dirty = true;
    this$1.flags.pristine = false;

    if (this$1.classes) {
      toggleClass(this$1.el, this$1.classNames.pristine, false);
      toggleClass(this$1.el, this$1.classNames.dirty, true);
    } // only needed once.


    this$1.unwatch(/^class_input$/);
  };

  if (this.componentInstance && isCallable(this.componentInstance.$once)) {
    this.componentInstance.$once('input', onInput);
    this.componentInstance.$once('blur', onBlur);
    this.watchers.push({
      tag: 'class_input',
      unwatch: function () {
        this$1.componentInstance.$off('input', onInput);
      }
    });
    this.watchers.push({
      tag: 'class_blur',
      unwatch: function () {
        this$1.componentInstance.$off('blur', onBlur);
      }
    });
    return;
  }

  if (!this.el) {
    return;
  }

  addEventListener(this.el, inputEvent, onInput); // Checkboxes and radio buttons on Mac don't emit blur naturally, so we listen on click instead.

  var blurEvent = isCheckboxOrRadioInput(this.el) ? 'change' : 'blur';
  addEventListener(this.el, blurEvent, onBlur);
  this.watchers.push({
    tag: 'class_input',
    unwatch: function () {
      this$1.el.removeEventListener(inputEvent, onInput);
    }
  });
  this.watchers.push({
    tag: 'class_blur',
    unwatch: function () {
      this$1.el.removeEventListener(blurEvent, onBlur);
    }
  });
};

Field.prototype.checkValueChanged = function checkValueChanged() {
  // handle some people initialize the value to null, since text inputs have empty string value.
  if (this.initialValue === null && this.value === '' && isTextInput(this.el)) {
    return false;
  }

  return this.value !== this.initialValue;
};
/**
 * Determines the suitable primary event to listen for.
 */


Field.prototype._determineInputEvent = function _determineInputEvent() {
  // if its a custom component, use the customized model event or the input event.
  if (this.componentInstance) {
    return this.componentInstance.$options.model && this.componentInstance.$options.model.event || 'input';
  }

  if (this.model && this.model.lazy) {
    return 'change';
  }

  if (isTextInput(this.el)) {
    return 'input';
  }

  return 'change';
};
/**
 * Determines the list of events to listen to.
 */


Field.prototype._determineEventList = function _determineEventList(defaultInputEvent) {
  var this$1 = this; // if no event is configured, or it is a component or a text input then respect the user choice.

  if (!this.events.length || this.componentInstance || isTextInput(this.el)) {
    return [].concat(this.events).map(function (evt) {
      if (evt === 'input' && this$1.model && this$1.model.lazy) {
        return 'change';
      }

      return evt;
    });
  } // force suitable event for non-text type fields.


  return this.events.map(function (e) {
    if (e === 'input') {
      return defaultInputEvent;
    }

    return e;
  });
};
/**
 * Adds the listeners required for validation.
 */


Field.prototype.addValueListeners = function addValueListeners() {
  var this$1 = this;
  this.unwatch(/^input_.+/);

  if (!this.listen || !this.el) {
    return;
  }

  var token = {
    cancelled: false
  };
  var fn = this.targetOf ? function () {
    this$1.flags.changed = this$1.checkValueChanged();
    this$1.validator.validate("#" + this$1.targetOf);
  } : function () {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len]; // if its a DOM event, resolve the value, otherwise use the first parameter as the value.


    if (args.length === 0 || isCallable(Event) && args[0] instanceof Event || args[0] && args[0].srcElement) {
      args[0] = this$1.value;
    }

    this$1.flags.changed = this$1.checkValueChanged();
    this$1.validator.validate("#" + this$1.id, args[0]);
  };

  var inputEvent = this._determineInputEvent();

  var events = this._determineEventList(inputEvent); // if there is a model and an on input validation is requested.


  if (this.model && includes(events, inputEvent)) {
    var ctx = null;
    var expression = this.model.expression; // if its watchable from the context vm.

    if (this.model.expression) {
      ctx = this.vm;
      expression = this.model.expression;
    } // watch it from the custom component vm instead.


    if (!expression && this.componentInstance && this.componentInstance.$options.model) {
      ctx = this.componentInstance;
      expression = this.componentInstance.$options.model.prop || 'value';
    }

    if (ctx && expression) {
      var debouncedFn = debounce(fn, this.delay[inputEvent], false, token);
      var unwatch = ctx.$watch(expression, function () {
        var args = [],
            len = arguments.length;

        while (len--) args[len] = arguments[len];

        this$1.flags.pending = true;
        this$1._cancellationToken = token;
        debouncedFn.apply(void 0, args);
      });
      this.watchers.push({
        tag: 'input_model',
        unwatch: unwatch
      }); // filter out input event as it is already handled by the watcher API.

      events = events.filter(function (e) {
        return e !== inputEvent;
      });
    }
  } // Add events.


  events.forEach(function (e) {
    var debouncedFn = debounce(fn, this$1.delay[e], false, token);

    var validate = function () {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      this$1.flags.pending = true;
      this$1._cancellationToken = token;
      debouncedFn.apply(void 0, args);
    };

    this$1._addComponentEventListener(e, validate);

    this$1._addHTMLEventListener(e, validate);
  });
};

Field.prototype._addComponentEventListener = function _addComponentEventListener(evt, validate) {
  var this$1 = this;

  if (!this.componentInstance) {
    return;
  }

  this.componentInstance.$on(evt, validate);
  this.watchers.push({
    tag: 'input_vue',
    unwatch: function () {
      this$1.componentInstance.$off(evt, validate);
    }
  });
};

Field.prototype._addHTMLEventListener = function _addHTMLEventListener(evt, validate) {
  var this$1 = this;

  if (!this.el || this.componentInstance) {
    return;
  } // listen for the current element.


  var addListener = function (el) {
    addEventListener(el, evt, validate);
    this$1.watchers.push({
      tag: 'input_native',
      unwatch: function () {
        el.removeEventListener(evt, validate);
      }
    });
  };

  addListener(this.el);

  if (!isCheckboxOrRadioInput(this.el)) {
    return;
  }

  var els = document.querySelectorAll("input[name=\"" + this.el.name + "\"]");
  toArray(els).forEach(function (el) {
    // skip if it is added by v-validate and is not the current element.
    if (el._veeValidateId && el !== this$1.el) {
      return;
    }

    addListener(el);
  });
};
/**
 * Updates aria attributes on the element.
 */


Field.prototype.updateAriaAttrs = function updateAriaAttrs() {
  var this$1 = this;

  if (!this.aria || !this.el || !isCallable(this.el.setAttribute)) {
    return;
  }

  var applyAriaAttrs = function (el) {
    el.setAttribute('aria-required', this$1.isRequired ? 'true' : 'false');
    el.setAttribute('aria-invalid', this$1.flags.invalid ? 'true' : 'false');
  };

  if (!isCheckboxOrRadioInput(this.el)) {
    applyAriaAttrs(this.el);
    return;
  }

  var els = document.querySelectorAll("input[name=\"" + this.el.name + "\"]");
  toArray(els).forEach(applyAriaAttrs);
};
/**
 * Updates the custom validity for the field.
 */


Field.prototype.updateCustomValidity = function updateCustomValidity() {
  if (!this.validity || !this.el || !isCallable(this.el.setCustomValidity) || !this.validator.errors) {
    return;
  }

  this.el.setCustomValidity(this.flags.valid ? '' : this.validator.errors.firstById(this.id) || '');
};
/**
 * Removes all listeners.
 */


Field.prototype.destroy = function destroy() {
  // ignore the result of any ongoing validation.
  if (this._cancellationToken) {
    this._cancellationToken.cancelled = true;
  }

  this.unwatch();
  this.dependencies.forEach(function (d) {
    return d.field.destroy();
  });
  this.dependencies = [];
};

Object.defineProperties(Field.prototype, prototypeAccessors$1); // 

var FieldBag = function FieldBag(items) {
  if (items === void 0) items = [];
  this.items = items || [];
};

var prototypeAccessors$2 = {
  length: {
    configurable: true
  }
};

FieldBag.prototype[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator'] = function () {
  var this$1 = this;
  var index = 0;
  return {
    next: function () {
      return {
        value: this$1.items[index++],
        done: index > this$1.items.length
      };
    }
  };
};
/**
 * Gets the current items length.
 */


prototypeAccessors$2.length.get = function () {
  return this.items.length;
};
/**
 * Finds the first field that matches the provided matcher object.
 */


FieldBag.prototype.find = function find$1(matcher) {
  return find(this.items, function (item) {
    return item.matches(matcher);
  });
};
/**
 * Filters the items down to the matched fields.
 */


FieldBag.prototype.filter = function filter(matcher) {
  // multiple matchers to be tried.
  if (Array.isArray(matcher)) {
    return this.items.filter(function (item) {
      return matcher.some(function (m) {
        return item.matches(m);
      });
    });
  }

  return this.items.filter(function (item) {
    return item.matches(matcher);
  });
};
/**
 * Maps the field items using the mapping function.
 */


FieldBag.prototype.map = function map(mapper) {
  return this.items.map(mapper);
};
/**
 * Finds and removes the first field that matches the provided matcher object, returns the removed item.
 */


FieldBag.prototype.remove = function remove(matcher) {
  var item = null;

  if (matcher instanceof Field) {
    item = matcher;
  } else {
    item = this.find(matcher);
  }

  if (!item) {
    return null;
  }

  var index = this.items.indexOf(item);
  this.items.splice(index, 1);
  return item;
};
/**
 * Adds a field item to the list.
 */


FieldBag.prototype.push = function push(item) {
  if (!(item instanceof Field)) {
    throw createError('FieldBag only accepts instances of Field that has an id defined.');
  }

  if (!item.id) {
    throw createError('Field id must be defined.');
  }

  if (this.find({
    id: item.id
  })) {
    throw createError("Field with id " + item.id + " is already added.");
  }

  this.items.push(item);
};

Object.defineProperties(FieldBag.prototype, prototypeAccessors$2);

var ScopedValidator = function ScopedValidator(base, vm) {
  this.id = vm._uid;
  this._base = base;
  this._paused = false; // create a mirror bag with limited component scope.

  this.errors = new ErrorBag(base.errors, this.id);
};

var prototypeAccessors$3 = {
  flags: {
    configurable: true
  },
  rules: {
    configurable: true
  },
  fields: {
    configurable: true
  },
  dictionary: {
    configurable: true
  },
  locale: {
    configurable: true
  }
};

prototypeAccessors$3.flags.get = function () {
  var this$1 = this;
  return this._base.fields.items.filter(function (f) {
    return f.vmId === this$1.id;
  }).reduce(function (acc, field) {
    if (field.scope) {
      if (!acc["$" + field.scope]) {
        acc["$" + field.scope] = {};
      }

      acc["$" + field.scope][field.name] = field.flags;
    }

    acc[field.name] = field.flags;
    return acc;
  }, {});
};

prototypeAccessors$3.rules.get = function () {
  return this._base.rules;
};

prototypeAccessors$3.fields.get = function () {
  return new FieldBag(this._base.fields.filter({
    vmId: this.id
  }));
};

prototypeAccessors$3.dictionary.get = function () {
  return this._base.dictionary;
};

prototypeAccessors$3.locale.get = function () {
  return this._base.locale;
};

prototypeAccessors$3.locale.set = function (val) {
  this._base.locale = val;
};

ScopedValidator.prototype.localize = function localize() {
  var ref;
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return (ref = this._base).localize.apply(ref, args);
};

ScopedValidator.prototype.update = function update() {
  var ref;
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return (ref = this._base).update.apply(ref, args);
};

ScopedValidator.prototype.attach = function attach(opts) {
  var attachOpts = assign({}, opts, {
    vmId: this.id
  });
  return this._base.attach(attachOpts);
};

ScopedValidator.prototype.pause = function pause() {
  this._paused = true;
};

ScopedValidator.prototype.resume = function resume() {
  this._paused = false;
};

ScopedValidator.prototype.remove = function remove(ruleName) {
  return this._base.remove(ruleName);
};

ScopedValidator.prototype.detach = function detach() {
  var ref;
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return (ref = this._base).detach.apply(ref, args.concat([this.id]));
};

ScopedValidator.prototype.extend = function extend() {
  var ref;
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return (ref = this._base).extend.apply(ref, args);
};

ScopedValidator.prototype.validate = function validate(descriptor, value, opts) {
  if (opts === void 0) opts = {};

  if (this._paused) {
    return Promise.resolve(true);
  }

  return this._base.validate(descriptor, value, assign({}, {
    vmId: this.id
  }, opts || {}));
};

ScopedValidator.prototype.validateAll = function validateAll(values$$1, opts) {
  if (opts === void 0) opts = {};

  if (this._paused) {
    return Promise.resolve(true);
  }

  return this._base.validateAll(values$$1, assign({}, {
    vmId: this.id
  }, opts || {}));
};

ScopedValidator.prototype.validateScopes = function validateScopes(opts) {
  if (opts === void 0) opts = {};

  if (this._paused) {
    return Promise.resolve(true);
  }

  return this._base.validateScopes(assign({}, {
    vmId: this.id
  }, opts || {}));
};

ScopedValidator.prototype.destroy = function destroy() {
  delete this.id;
  delete this._base;
};

ScopedValidator.prototype.reset = function reset(matcher) {
  return this._base.reset(Object.assign({}, matcher || {}, {
    vmId: this.id
  }));
};

ScopedValidator.prototype.flag = function flag() {
  var ref;
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return (ref = this._base).flag.apply(ref, args.concat([this.id]));
};

Object.defineProperties(ScopedValidator.prototype, prototypeAccessors$3); // 

/**
 * Checks if a parent validator instance was requested.
 */

var requestsValidator = function (injections) {
  if (isObject(injections) && injections.$validator) {
    return true;
  }

  return false;
};

var mixin = {
  provide: function provide() {
    if (this.$validator && !isBuiltInComponent(this.$vnode)) {
      return {
        $validator: this.$validator
      };
    }

    return {};
  },
  beforeCreate: function beforeCreate() {
    // if built in do nothing.
    if (isBuiltInComponent(this.$vnode)) {
      return;
    } // if its a root instance set the config if it exists.


    if (!this.$parent) {
      pluginInstance.configure(this.$options.$_veeValidate || {});
    }

    var options = pluginInstance.resolveConfig(this); // if its a root instance, inject anyways, or if it requested a new instance.

    if (!this.$parent || this.$options.$_veeValidate && /new/.test(this.$options.$_veeValidate.validator)) {
      this.$validator = new ScopedValidator(pluginInstance._validator, this);
    }

    var requested = requestsValidator(this.$options.inject); // if automatic injection is enabled and no instance was requested.

    if (!this.$validator && options.inject && !requested) {
      this.$validator = new ScopedValidator(pluginInstance._validator, this);
    } // don't inject errors or fieldBag as no validator was resolved.


    if (!requested && !this.$validator) {
      return;
    } // There is a validator but it isn't injected, mark as reactive.


    if (!requested && this.$validator) {
      var Vue = this.$options._base; // the vue constructor.

      Vue.util.defineReactive(this.$validator, 'errors', this.$validator.errors);
    }

    if (!this.$options.computed) {
      this.$options.computed = {};
    }

    this.$options.computed[options.errorBagName || 'errors'] = function errorBagGetter() {
      return this.$validator.errors;
    };

    this.$options.computed[options.fieldsBagName || 'fields'] = function fieldBagGetter() {
      return this.$validator.fields.items.reduce(function (acc, field) {
        if (field.scope) {
          if (!acc["$" + field.scope]) {
            acc["$" + field.scope] = {};
          }

          acc["$" + field.scope][field.name] = field.flags;
          return acc;
        }

        acc[field.name] = field.flags;
        return acc;
      }, {});
    };
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$validator && this._uid === this.$validator.id) {
      this.$validator.errors.clear(); // remove errors generated by this component.
    }
  }
}; // 

/**
 * Finds the requested field by id from the context object.
 */

exports.mixin = mixin;

function findField(el, context) {
  if (!context || !context.$validator) {
    return null;
  }

  return context.$validator.fields.find({
    id: el._veeValidateId
  });
}

var directive = {
  bind: function bind(el, binding, vnode) {
    var validator = vnode.context.$validator;

    if (!validator) {
      if ("production" !== 'production') {
        warn("No validator instance is present on vm, did you forget to inject '$validator'?");
      }

      return;
    }

    var fieldOptions = Resolver.generate(el, binding, vnode);
    validator.attach(fieldOptions);
  },
  inserted: function inserted(el, binding, vnode) {
    var field = findField(el, vnode.context);
    var scope = Resolver.resolveScope(el, binding, vnode); // skip if scope hasn't changed.

    if (!field || scope === field.scope) {
      return;
    } // only update scope.


    field.update({
      scope: scope
    }); // allows the field to re-evaluated once more in the update hook.

    field.updated = false;
  },
  update: function update(el, binding, vnode) {
    var field = findField(el, vnode.context); // make sure we don't do unneccasary work if no important change was done.

    if (!field || field.updated && isEqual(binding.value, binding.oldValue)) {
      return;
    }

    var scope = Resolver.resolveScope(el, binding, vnode);
    var rules = Resolver.resolveRules(el, binding, vnode);
    field.update({
      scope: scope,
      rules: rules
    });
  },
  unbind: function unbind(el, binding, ref) {
    var context = ref.context;
    var field = findField(el, context);

    if (!field) {
      return;
    }

    context.$validator.detach(field);
  }
}; // 

exports.directive = directive;

var Validator = function Validator(validations, options) {
  if (options === void 0) options = {
    fastExit: true
  };
  this.errors = new ErrorBag();
  this.fields = new FieldBag();

  this._createFields(validations);

  this.paused = false;
  this.fastExit = !isNullOrUndefined(options && options.fastExit) ? options.fastExit : true;
};

exports.Validator = Validator;
var prototypeAccessors$4 = {
  rules: {
    configurable: true
  },
  flags: {
    configurable: true
  },
  dictionary: {
    configurable: true
  },
  locale: {
    configurable: true
  }
};
var staticAccessors$1 = {
  rules: {
    configurable: true
  },
  dictionary: {
    configurable: true
  },
  locale: {
    configurable: true
  }
};

staticAccessors$1.rules.get = function () {
  return RuleContainer.rules;
};

prototypeAccessors$4.rules.get = function () {
  return RuleContainer.rules;
};

prototypeAccessors$4.flags.get = function () {
  return this.fields.items.reduce(function (acc, field) {
    var obj;

    if (field.scope) {
      acc["$" + field.scope] = (obj = {}, obj[field.name] = field.flags, obj);
      return acc;
    }

    acc[field.name] = field.flags;
    return acc;
  }, {});
};
/**
 * Getter for the dictionary.
 */


prototypeAccessors$4.dictionary.get = function () {
  return pluginInstance.i18nDriver;
};

staticAccessors$1.dictionary.get = function () {
  return pluginInstance.i18nDriver;
};
/**
 * Getter for the current locale.
 */


prototypeAccessors$4.locale.get = function () {
  return Validator.locale;
};
/**
 * Setter for the validator locale.
 */


prototypeAccessors$4.locale.set = function (value) {
  Validator.locale = value;
};

staticAccessors$1.locale.get = function () {
  return this.dictionary.locale;
};
/**
 * Setter for the validator locale.
 */


staticAccessors$1.locale.set = function (value) {
  var hasChanged = value !== Validator.dictionary.locale;
  Validator.dictionary.locale = value;

  if (hasChanged && pluginInstance._vm) {
    pluginInstance._vm.$emit('localeChanged');
  }
};
/**
 * Static constructor.
 */


Validator.create = function create(validations, options) {
  return new Validator(validations, options);
};
/**
 * Adds a custom validator to the list of validation rules.
 */


Validator.extend = function extend(name, validator, options) {
  if (options === void 0) options = {};

  Validator._guardExtend(name, validator);

  Validator._merge(name, {
    validator: validator,
    paramNames: options && options.paramNames,
    options: assign({}, {
      hasTarget: false,
      immediate: true
    }, options || {})
  });
};
/**
 * Removes a rule from the list of validators.
 */


Validator.remove = function remove(name) {
  RuleContainer.remove(name);
};
/**
 * Checks if the given rule name is a rule that targets other fields.
 */


Validator.isTargetRule = function isTargetRule(name) {
  return RuleContainer.isTargetRule(name);
};
/**
 * Adds and sets the current locale for the validator.
 */


Validator.prototype.localize = function localize(lang, dictionary) {
  Validator.localize(lang, dictionary);
};
/**
 * Adds and sets the current locale for the validator.
 */


Validator.localize = function localize(lang, dictionary) {
  var obj;

  if (isObject(lang)) {
    Validator.dictionary.merge(lang);
    return;
  } // merge the dictionary.


  if (dictionary) {
    var locale = lang || dictionary.name;
    dictionary = assign({}, dictionary);
    Validator.dictionary.merge((obj = {}, obj[locale] = dictionary, obj));
  }

  if (lang) {
    // set the locale.
    Validator.locale = lang;
  }
};
/**
 * Registers a field to be validated.
 */


Validator.prototype.attach = function attach(fieldOpts) {
  // fixes initial value detection with v-model and select elements.
  var value = fieldOpts.initialValue;
  var field = new Field(fieldOpts);
  this.fields.push(field); // validate the field initially

  if (field.immediate) {
    this.validate("#" + field.id, value || field.value, {
      vmId: fieldOpts.vmId
    });
  } else {
    this._validate(field, value || field.value, {
      initial: true
    }).then(function (result) {
      field.flags.valid = result.valid;
      field.flags.invalid = !result.valid;
    });
  }

  return field;
};
/**
 * Sets the flags on a field.
 */


Validator.prototype.flag = function flag(name, flags, uid) {
  if (uid === void 0) uid = null;

  var field = this._resolveField(name, undefined, uid);

  if (!field || !flags) {
    return;
  }

  field.setFlags(flags);
};
/**
 * Removes a field from the validator.
 */


Validator.prototype.detach = function detach(name, scope, uid) {
  var field = isCallable(name.destroy) ? name : this._resolveField(name, scope, uid);

  if (!field) {
    return;
  }

  field.destroy();
  this.errors.remove(field.name, field.scope, field.vmId);
  this.fields.remove(field);
};
/**
 * Adds a custom validator to the list of validation rules.
 */


Validator.prototype.extend = function extend(name, validator, options) {
  if (options === void 0) options = {};
  Validator.extend(name, validator, options);
};

Validator.prototype.reset = function reset(matcher) {
  var this$1 = this; // two ticks

  return pluginInstance._vm.$nextTick().then(function () {
    return pluginInstance._vm.$nextTick();
  }).then(function () {
    this$1.fields.filter(matcher).forEach(function (field) {
      field.reset(); // reset field flags.

      this$1.errors.remove(field.name, field.scope);
    });
  });
};
/**
 * Updates a field, updating both errors and flags.
 */


Validator.prototype.update = function update(id, ref) {
  var scope = ref.scope;

  var field = this._resolveField("#" + id);

  if (!field) {
    return;
  } // remove old scope.


  this.errors.update(id, {
    scope: scope
  });
};
/**
 * Removes a rule from the list of validators.
 */


Validator.prototype.remove = function remove(name) {
  Validator.remove(name);
};
/**
 * Validates a value against a registered field validations.
 */


Validator.prototype.validate = function validate(fieldDescriptor, value, ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var silent = ref.silent;
  var vmId = ref.vmId;

  if (this.paused) {
    return Promise.resolve(true);
  } // overload to validate all.


  if (isNullOrUndefined(fieldDescriptor)) {
    return this.validateScopes({
      silent: silent,
      vmId: vmId
    });
  } // overload to validate scope-less fields.


  if (fieldDescriptor === '*') {
    return this.validateAll(undefined, {
      silent: silent,
      vmId: vmId
    });
  } // if scope validation was requested.


  if (/^(.+)\.\*$/.test(fieldDescriptor)) {
    var matched = fieldDescriptor.match(/^(.+)\.\*$/)[1];
    return this.validateAll(matched);
  }

  var field = this._resolveField(fieldDescriptor);

  if (!field) {
    return this._handleFieldNotFound(name);
  }

  if (!silent) {
    field.flags.pending = true;
  }

  if (value === undefined) {
    value = field.value;
  }

  var validationPromise = this._validate(field, value);

  field.waitFor(validationPromise);
  return validationPromise.then(function (result) {
    if (!silent && field.isWaitingFor(validationPromise)) {
      // allow next validation to mutate the state.
      field.waitFor(null);

      this$1._handleValidationResults([result], vmId);
    }

    return result.valid;
  });
};
/**
 * Pauses the validator.
 */


Validator.prototype.pause = function pause() {
  this.paused = true;
  return this;
};
/**
 * Resumes the validator.
 */


Validator.prototype.resume = function resume() {
  this.paused = false;
  return this;
};
/**
 * Validates each value against the corresponding field validations.
 */


Validator.prototype.validateAll = function validateAll(values$$1, ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var silent = ref.silent;
  var vmId = ref.vmId;

  if (this.paused) {
    return Promise.resolve(true);
  }

  var matcher = null;
  var providedValues = false;

  if (typeof values$$1 === 'string') {
    matcher = {
      scope: values$$1,
      vmId: vmId
    };
  } else if (isObject(values$$1)) {
    matcher = Object.keys(values$$1).map(function (key) {
      return {
        name: key,
        vmId: vmId,
        scope: null
      };
    });
    providedValues = true;
  } else if (Array.isArray(values$$1)) {
    matcher = values$$1.map(function (key) {
      return {
        name: key,
        vmId: vmId
      };
    });
  } else {
    matcher = {
      scope: null,
      vmId: vmId
    };
  }

  return Promise.all(this.fields.filter(matcher).map(function (field) {
    return this$1._validate(field, providedValues ? values$$1[field.name] : field.value);
  })).then(function (results) {
    if (!silent) {
      this$1._handleValidationResults(results, vmId);
    }

    return results.every(function (t) {
      return t.valid;
    });
  });
};
/**
 * Validates all scopes.
 */


Validator.prototype.validateScopes = function validateScopes(ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var silent = ref.silent;
  var vmId = ref.vmId;

  if (this.paused) {
    return Promise.resolve(true);
  }

  return Promise.all(this.fields.filter({
    vmId: vmId
  }).map(function (field) {
    return this$1._validate(field, field.value);
  })).then(function (results) {
    if (!silent) {
      this$1._handleValidationResults(results, vmId);
    }

    return results.every(function (t) {
      return t.valid;
    });
  });
};
/**
 * Validates a value against the rules.
 */


Validator.prototype.verify = function verify(value, rules, options) {
  if (options === void 0) options = {};
  var field = {
    name: options && options.name || '{field}',
    rules: normalizeRules(rules),
    bails: getPath('bails', options, true)
  };
  field.isRequired = field.rules.required;
  var targetRules = Object.keys(field.rules).filter(Validator.isTargetRule);

  if (targetRules.length && options && isObject(options.values)) {
    // patch the field params with the targets' values.
    targetRules.forEach(function (rule) {
      var ref = field.rules[rule];
      var first = ref[0];
      var rest = ref.slice(1);
      field.rules[rule] = [options.values[first]].concat(rest);
    });
  }

  return this._validate(field, value).then(function (result) {
    return {
      valid: result.valid,
      errors: result.errors.map(function (e) {
        return e.msg;
      })
    };
  });
};
/**
 * Perform cleanup.
 */


Validator.prototype.destroy = function destroy() {
  pluginInstance._vm.$off('localeChanged');
};
/**
 * Creates the fields to be validated.
 */


Validator.prototype._createFields = function _createFields(validations) {
  var this$1 = this;

  if (!validations) {
    return;
  }

  Object.keys(validations).forEach(function (field) {
    var options = assign({}, {
      name: field,
      rules: validations[field]
    });
    this$1.attach(options);
  });
};
/**
 * Date rules need the existence of a format, so date_format must be supplied.
 */


Validator.prototype._getDateFormat = function _getDateFormat(validations) {
  var format = null;

  if (validations.date_format && Array.isArray(validations.date_format)) {
    format = validations.date_format[0];
  }

  return format || this.dictionary.getDateFormat(this.locale);
};
/**
 * Formats an error message for field and a rule.
 */


Validator.prototype._formatErrorMessage = function _formatErrorMessage(field, rule, data, targetName) {
  if (data === void 0) data = {};
  if (targetName === void 0) targetName = null;

  var name = this._getFieldDisplayName(field);

  var params = this._getLocalizedParams(rule, targetName);

  return this.dictionary.getFieldMessage(this.locale, field.name, rule.name, [name, params, data]);
};
/**
 * We need to convert any object param to an array format since the locales do not handle params as objects yet.
 */


Validator.prototype._convertParamObjectToArray = function _convertParamObjectToArray(obj, ruleName) {
  if (Array.isArray(obj)) {
    return obj;
  }

  var paramNames = RuleContainer.getParamNames(ruleName);

  if (!paramNames || !isObject(obj)) {
    return obj;
  }

  return paramNames.reduce(function (prev, paramName) {
    if (paramName in obj) {
      prev.push(obj[paramName]);
    }

    return prev;
  }, []);
};
/**
 * Translates the parameters passed to the rule (mainly for target fields).
 */


Validator.prototype._getLocalizedParams = function _getLocalizedParams(rule, targetName) {
  if (targetName === void 0) targetName = null;

  var params = this._convertParamObjectToArray(rule.params, rule.name);

  if (rule.options.hasTarget && params && params[0]) {
    var localizedName = targetName || this.dictionary.getAttribute(this.locale, params[0], params[0]);
    return [localizedName].concat(params.slice(1));
  }

  return params;
};
/**
 * Resolves an appropriate display name, first checking 'data-as' or the registered 'prettyName'
 */


Validator.prototype._getFieldDisplayName = function _getFieldDisplayName(field) {
  return field.alias || this.dictionary.getAttribute(this.locale, field.name, field.name);
};
/**
 * Converts an array of params to an object with named properties.
 * Only works if the rule is configured with a paramNames array.
 * Returns the same params if it cannot convert it.
 */


Validator.prototype._convertParamArrayToObj = function _convertParamArrayToObj(params, ruleName) {
  var paramNames = RuleContainer.getParamNames(ruleName);

  if (!paramNames) {
    return params;
  }

  if (isObject(params)) {
    // check if the object is either a config object or a single parameter that is an object.
    var hasKeys = paramNames.some(function (name) {
      return Object.keys(params).indexOf(name) !== -1;
    }); // if it has some of the keys, return it as is.

    if (hasKeys) {
      return params;
    } // otherwise wrap the object in an array.


    params = [params];
  } // Reduce the paramsNames to a param object.


  return params.reduce(function (prev, value, idx) {
    prev[paramNames[idx]] = value;
    return prev;
  }, {});
};
/**
 * Tests a single input value against a rule.
 */


Validator.prototype._test = function _test(field, value, rule) {
  var this$1 = this;
  var validator = RuleContainer.getValidatorMethod(rule.name);
  var params = Array.isArray(rule.params) ? toArray(rule.params) : rule.params;

  if (!params) {
    params = [];
  }

  var targetName = null;

  if (!validator || typeof validator !== 'function') {
    return Promise.reject(createError("No such validator '" + rule.name + "' exists."));
  } // has field dependencies.


  if (rule.options.hasTarget && field.dependencies) {
    var target = find(field.dependencies, function (d) {
      return d.name === rule.name;
    });

    if (target) {
      targetName = target.field.alias;
      params = [target.field.value].concat(params.slice(1));
    }
  } else if (rule.name === 'required' && field.rejectsFalse) {
    // invalidate false if no args were specified and the field rejects false by default.
    params = params.length ? params : [true];
  }

  if (rule.options.isDate) {
    var dateFormat = this._getDateFormat(field.rules);

    if (rule.name !== 'date_format') {
      params.push(dateFormat);
    }
  }

  var result = validator(value, this._convertParamArrayToObj(params, rule.name)); // If it is a promise.

  if (isCallable(result.then)) {
    return result.then(function (values$$1) {
      var allValid = true;
      var data = {};

      if (Array.isArray(values$$1)) {
        allValid = values$$1.every(function (t) {
          return isObject(t) ? t.valid : t;
        });
      } else {
        // Is a single object/boolean.
        allValid = isObject(values$$1) ? values$$1.valid : values$$1;
        data = values$$1.data;
      }

      return {
        valid: allValid,
        errors: allValid ? [] : [this$1._createFieldError(field, rule, data, targetName)]
      };
    });
  }

  if (!isObject(result)) {
    result = {
      valid: result,
      data: {}
    };
  }

  return {
    valid: result.valid,
    errors: result.valid ? [] : [this._createFieldError(field, rule, result.data, targetName)]
  };
};
/**
 * Merges a validator object into the RULES and Messages.
 */


Validator._merge = function _merge(name, ref) {
  var validator = ref.validator;
  var options = ref.options;
  var paramNames = ref.paramNames;
  var validate = isCallable(validator) ? validator : validator.validate;

  if (validator.getMessage) {
    Validator.dictionary.setMessage(Validator.locale, name, validator.getMessage);
  }

  RuleContainer.add(name, {
    validate: validate,
    options: options,
    paramNames: paramNames
  });
};
/**
 * Guards from extension violations.
 */


Validator._guardExtend = function _guardExtend(name, validator) {
  if (isCallable(validator)) {
    return;
  }

  if (!isCallable(validator.validate)) {
    throw createError("Extension Error: The validator '" + name + "' must be a function or have a 'validate' method.");
  }
};
/**
 * Creates a Field Error Object.
 */


Validator.prototype._createFieldError = function _createFieldError(field, rule, data, targetName) {
  var this$1 = this;
  return {
    id: field.id,
    vmId: field.vmId,
    field: field.name,
    msg: this._formatErrorMessage(field, rule, data, targetName),
    rule: rule.name,
    scope: field.scope,
    regenerate: function () {
      return this$1._formatErrorMessage(field, rule, data, targetName);
    }
  };
};
/**
 * Tries different strategies to find a field.
 */


Validator.prototype._resolveField = function _resolveField(name, scope, uid) {
  if (name[0] === '#') {
    return this.fields.find({
      id: name.slice(1)
    });
  }

  if (!isNullOrUndefined(scope)) {
    return this.fields.find({
      name: name,
      scope: scope,
      vmId: uid
    });
  }

  if (includes(name, '.')) {
    var ref = name.split('.');
    var fieldScope = ref[0];
    var fieldName = ref.slice(1);
    var field = this.fields.find({
      name: fieldName.join('.'),
      scope: fieldScope,
      vmId: uid
    });

    if (field) {
      return field;
    }
  }

  return this.fields.find({
    name: name,
    scope: null,
    vmId: uid
  });
};
/**
 * Handles when a field is not found.
 */


Validator.prototype._handleFieldNotFound = function _handleFieldNotFound(name, scope) {
  var fullName = isNullOrUndefined(scope) ? name : "" + (!isNullOrUndefined(scope) ? scope + '.' : '') + name;
  return Promise.reject(createError("Validating a non-existent field: \"" + fullName + "\". Use \"attach()\" first."));
};
/**
 * Handles validation results.
 */


Validator.prototype._handleValidationResults = function _handleValidationResults(results, vmId) {
  var this$1 = this;
  var matchers = results.map(function (result) {
    return {
      id: result.id
    };
  });
  this.errors.removeById(matchers.map(function (m) {
    return m.id;
  })); // remove by name and scope to remove any custom errors added.

  results.forEach(function (result) {
    this$1.errors.remove(result.field, result.scope, vmId);
  });
  var allErrors = results.reduce(function (prev, curr) {
    prev.push.apply(prev, curr.errors);
    return prev;
  }, []);
  this.errors.add(allErrors); // handle flags.

  this.fields.filter(matchers).forEach(function (field) {
    var result = find(results, function (r) {
      return r.id === field.id;
    });
    field.setFlags({
      pending: false,
      valid: result.valid,
      validated: true
    });
  });
};

Validator.prototype._shouldSkip = function _shouldSkip(field, value) {
  // field is configured to run through the pipeline regardless
  if (field.bails === false) {
    return false;
  } // disabled fields are skipped


  if (field.isDisabled) {
    return true;
  } // skip if the field is not required and has an empty value.


  return !field.isRequired && (isNullOrUndefined(value) || value === '' || isEmptyArray(value));
};

Validator.prototype._shouldBail = function _shouldBail(field) {
  // if the field was configured explicitly.
  if (field.bails !== undefined) {
    return field.bails;
  }

  return this.fastExit;
};
/**
 * Starts the validation process.
 */


Validator.prototype._validate = function _validate(field, value, ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var initial = ref.initial;

  if (this._shouldSkip(field, value)) {
    return Promise.resolve({
      valid: true,
      id: field.id,
      field: field.name,
      scope: field.scope,
      errors: []
    });
  }

  var promises = [];
  var errors = [];
  var isExitEarly = false; // use of '.some()' is to break iteration in middle by returning true

  Object.keys(field.rules).filter(function (rule) {
    if (!initial || !RuleContainer.has(rule)) {
      return true;
    }

    return RuleContainer.isImmediate(rule);
  }).some(function (rule) {
    var ruleOptions = RuleContainer.getOptions(rule);

    var result = this$1._test(field, value, {
      name: rule,
      params: field.rules[rule],
      options: ruleOptions
    });

    if (isCallable(result.then)) {
      promises.push(result);
    } else if (!result.valid && this$1._shouldBail(field)) {
      errors.push.apply(errors, result.errors);
      isExitEarly = true;
    } else {
      // promisify the result.
      promises.push(new Promise(function (resolve) {
        return resolve(result);
      }));
    }

    return isExitEarly;
  });

  if (isExitEarly) {
    return Promise.resolve({
      valid: false,
      errors: errors,
      id: field.id,
      field: field.name,
      scope: field.scope
    });
  }

  return Promise.all(promises).then(function (results) {
    return results.reduce(function (prev, v) {
      var ref;

      if (!v.valid) {
        (ref = prev.errors).push.apply(ref, v.errors);
      }

      prev.valid = prev.valid && v.valid;
      return prev;
    }, {
      valid: true,
      errors: errors,
      id: field.id,
      field: field.name,
      scope: field.scope
    });
  });
};

Object.defineProperties(Validator.prototype, prototypeAccessors$4);
Object.defineProperties(Validator, staticAccessors$1); // 

var normalize = function (fields) {
  if (Array.isArray(fields)) {
    return fields.reduce(function (prev, curr) {
      if (includes(curr, '.')) {
        prev[curr.split('.')[1]] = curr;
      } else {
        prev[curr] = curr;
      }

      return prev;
    }, {});
  }

  return fields;
}; // Combines two flags using either AND or OR depending on the flag type.


var combine = function (lhs, rhs) {
  var mapper = {
    pristine: function (lhs, rhs) {
      return lhs && rhs;
    },
    dirty: function (lhs, rhs) {
      return lhs || rhs;
    },
    touched: function (lhs, rhs) {
      return lhs || rhs;
    },
    untouched: function (lhs, rhs) {
      return lhs && rhs;
    },
    valid: function (lhs, rhs) {
      return lhs && rhs;
    },
    invalid: function (lhs, rhs) {
      return lhs || rhs;
    },
    pending: function (lhs, rhs) {
      return lhs || rhs;
    },
    required: function (lhs, rhs) {
      return lhs || rhs;
    },
    validated: function (lhs, rhs) {
      return lhs && rhs;
    }
  };
  return Object.keys(mapper).reduce(function (flags, flag) {
    flags[flag] = mapper[flag](lhs[flag], rhs[flag]);
    return flags;
  }, {});
};

var mapScope = function (scope, deep) {
  if (deep === void 0) deep = true;
  return Object.keys(scope).reduce(function (flags, field) {
    if (!flags) {
      flags = assign({}, scope[field]);
      return flags;
    } // scope.


    var isScope = field.indexOf('$') === 0;

    if (deep && isScope) {
      return combine(mapScope(scope[field]), flags);
    } else if (!deep && isScope) {
      return flags;
    }

    flags = combine(flags, scope[field]);
    return flags;
  }, null);
};
/**
 * Maps fields to computed functions.
 */


var mapFields = function (fields) {
  if (!fields) {
    return function () {
      return mapScope(this.$validator.flags);
    };
  }

  var normalized = normalize(fields);
  return Object.keys(normalized).reduce(function (prev, curr) {
    var field = normalized[curr];

    prev[curr] = function mappedField() {
      // if field exists
      if (this.$validator.flags[field]) {
        return this.$validator.flags[field];
      } // scopeless fields were selected.


      if (normalized[curr] === '*') {
        return mapScope(this.$validator.flags, false);
      } // if it has a scope defined


      var index = field.indexOf('.');

      if (index <= 0) {
        return {};
      }

      var ref = field.split('.');
      var scope = ref[0];
      var name = ref.slice(1);
      scope = this.$validator.flags["$" + scope];
      name = name.join('.'); // an entire scope was selected: scope.*

      if (name === '*' && scope) {
        return mapScope(scope);
      }

      if (scope && scope[name]) {
        return scope[name];
      }

      return {};
    };

    return prev;
  }, {});
}; // 


exports.mapFields = mapFields;

var normalizeValue = function (value) {
  if (isObject(value)) {
    return Object.keys(value).reduce(function (prev, key) {
      prev[key] = normalizeValue(value[key]);
      return prev;
    }, {});
  }

  if (isCallable(value)) {
    return value('{0}', ['{1}', '{2}', '{3}']);
  }

  return value;
};

var normalizeFormat = function (locale) {
  // normalize messages
  var dictionary = {};

  if (locale.messages) {
    dictionary.messages = normalizeValue(locale.messages);
  }

  if (locale.custom) {
    dictionary.custom = normalizeValue(locale.custom);
  }

  if (locale.attributes) {
    dictionary.attributes = locale.attributes;
  }

  if (!isNullOrUndefined(locale.dateFormat)) {
    dictionary.dateFormat = locale.dateFormat;
  }

  return dictionary;
};

var I18nDictionary = function I18nDictionary(i18n, rootKey) {
  this.i18n = i18n;
  this.rootKey = rootKey;
};

var prototypeAccessors$5 = {
  locale: {
    configurable: true
  }
};

prototypeAccessors$5.locale.get = function () {
  return this.i18n.locale;
};

prototypeAccessors$5.locale.set = function (value) {
  warn('Cannot set locale from the validator when using vue-i18n, use i18n.locale setter instead');
};

I18nDictionary.prototype.getDateFormat = function getDateFormat(locale) {
  return this.i18n.getDateTimeFormat(locale || this.locale);
};

I18nDictionary.prototype.setDateFormat = function setDateFormat(locale, value) {
  this.i18n.setDateTimeFormat(locale || this.locale, value);
};

I18nDictionary.prototype.getMessage = function getMessage(_, key, data) {
  var path = this.rootKey + ".messages." + key;
  var result = this.i18n.t(path, data);

  if (result !== path) {
    return result;
  }

  return this.i18n.t(this.rootKey + ".messages._default", data);
};

I18nDictionary.prototype.getAttribute = function getAttribute(_, key, fallback) {
  if (fallback === void 0) fallback = '';
  var path = this.rootKey + ".attributes." + key;
  var result = this.i18n.t(path);

  if (result !== path) {
    return result;
  }

  return fallback;
};

I18nDictionary.prototype.getFieldMessage = function getFieldMessage(_, field, key, data) {
  var path = this.rootKey + ".custom." + field + "." + key;
  var result = this.i18n.t(path, data);

  if (result !== path) {
    return result;
  }

  return this.getMessage(_, key, data);
};

I18nDictionary.prototype.merge = function merge$1(dictionary) {
  var this$1 = this;
  Object.keys(dictionary).forEach(function (localeKey) {
    var obj; // i18n doesn't deep merge
    // first clone the existing locale (avoid mutations to locale)

    var clone = merge({}, getPath(localeKey + "." + this$1.rootKey, this$1.i18n.messages, {})); // Merge cloned locale with new one

    var locale = merge(clone, normalizeFormat(dictionary[localeKey]));
    this$1.i18n.mergeLocaleMessage(localeKey, (obj = {}, obj[this$1.rootKey] = locale, obj));

    if (locale.dateFormat) {
      this$1.i18n.setDateTimeFormat(localeKey, locale.dateFormat);
    }
  });
};

I18nDictionary.prototype.setMessage = function setMessage(locale, key, value) {
  var obj, obj$1;
  this.merge((obj$1 = {}, obj$1[locale] = {
    messages: (obj = {}, obj[key] = value, obj)
  }, obj$1));
};

I18nDictionary.prototype.setAttribute = function setAttribute(locale, key, value) {
  var obj, obj$1;
  this.merge((obj$1 = {}, obj$1[locale] = {
    attributes: (obj = {}, obj[key] = value, obj)
  }, obj$1));
};

Object.defineProperties(I18nDictionary.prototype, prototypeAccessors$5); // 

var defaultConfig = {
  locale: 'en',
  delay: 0,
  errorBagName: 'errors',
  dictionary: null,
  fieldsBagName: 'fields',
  classes: false,
  classNames: null,
  events: 'input',
  inject: true,
  fastExit: true,
  aria: true,
  validity: false,
  i18n: null,
  i18nRootKey: 'validation'
};
var Vue;
var pendingPlugins;
var currentConfig = assign({}, defaultConfig);
var pluginInstance;

var VeeValidate$1 = function VeeValidate(config, _Vue) {
  this.configure(config);
  pluginInstance = this;

  if (_Vue) {
    Vue = _Vue;
  }

  this._validator = new Validator(null, {
    fastExit: config && config.fastExit
  });

  this._initVM(this.config);

  this._initI18n(this.config);
};

var prototypeAccessors$6 = {
  i18nDriver: {
    configurable: true
  },
  config: {
    configurable: true
  }
};
var staticAccessors$2 = {
  i18nDriver: {
    configurable: true
  }
};

VeeValidate$1.setI18nDriver = function setI18nDriver(driver, instance) {
  DictionaryResolver.setDriver(driver, instance);
};

VeeValidate$1.configure = function configure(cfg) {
  currentConfig = assign({}, currentConfig, cfg);
};

VeeValidate$1.use = function use(plugin, options) {
  if (options === void 0) options = {};

  if (!isCallable(plugin)) {
    return warn('The plugin must be a callable function');
  } // Don't install plugins until vee-validate is installed.


  if (!pluginInstance) {
    if (!pendingPlugins) {
      pendingPlugins = [];
    }

    pendingPlugins.push({
      plugin: plugin,
      options: options
    });
    return;
  }

  plugin({
    Validator: Validator,
    ErrorBag: ErrorBag,
    Rules: Validator.rules
  }, options);
};

VeeValidate$1.install = function install(_Vue, opts) {
  if (Vue && _Vue === Vue) {
    if ("production" !== 'production') {
      warn('already installed, Vue.use(VeeValidate) should only be called once.');
    }

    return;
  }

  Vue = _Vue;
  pluginInstance = new VeeValidate$1(opts);
  detectPassiveSupport();
  Vue.mixin(mixin);
  Vue.directive('validate', directive);

  if (pendingPlugins) {
    pendingPlugins.forEach(function (ref) {
      var plugin = ref.plugin;
      var options = ref.options;
      VeeValidate$1.use(plugin, options);
    });
    pendingPlugins = null;
  }
};

prototypeAccessors$6.i18nDriver.get = function () {
  return DictionaryResolver.getDriver();
};

staticAccessors$2.i18nDriver.get = function () {
  return DictionaryResolver.getDriver();
};

prototypeAccessors$6.config.get = function () {
  return currentConfig;
};

VeeValidate$1.prototype._initVM = function _initVM(config) {
  var this$1 = this;
  this._vm = new Vue({
    data: function () {
      return {
        errors: this$1._validator.errors,
        fields: this$1._validator.fields
      };
    }
  });
};

VeeValidate$1.prototype._initI18n = function _initI18n(config) {
  var this$1 = this;
  var dictionary = config.dictionary;
  var i18n = config.i18n;
  var i18nRootKey = config.i18nRootKey;
  var locale = config.locale;

  var onLocaleChanged = function () {
    this$1._validator.errors.regenerate();
  }; // i18 is being used for localization.


  if (i18n) {
    VeeValidate$1.setI18nDriver('i18n', new I18nDictionary(i18n, i18nRootKey));

    i18n._vm.$watch('locale', onLocaleChanged);
  } else if (typeof window !== 'undefined') {
    this._vm.$on('localeChanged', onLocaleChanged);
  }

  if (dictionary) {
    this.i18nDriver.merge(dictionary);
  }

  if (locale && !i18n) {
    this._validator.localize(locale);
  }
};

VeeValidate$1.prototype.configure = function configure(cfg) {
  VeeValidate$1.configure(cfg);
};

VeeValidate$1.prototype.resolveConfig = function resolveConfig(ctx) {
  var selfConfig = getPath('$options.$_veeValidate', ctx, {});
  return assign({}, this.config, selfConfig);
};

Object.defineProperties(VeeValidate$1.prototype, prototypeAccessors$6);
Object.defineProperties(VeeValidate$1, staticAccessors$2);
VeeValidate$1.version = '2.1.0-beta.11';
VeeValidate$1.mixin = mixin;
VeeValidate$1.directive = directive;
VeeValidate$1.Validator = Validator;
VeeValidate$1.ErrorBag = ErrorBag;
VeeValidate$1.mapFields = mapFields;
/**
 * Formates file size.
 *
 * @param {Number|String} size
 */

var formatFileSize = function (size) {
  var units = ['Byte', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
  var threshold = 1024;
  size = Number(size) * threshold;
  var i = size === 0 ? 0 : Math.floor(Math.log(size) / Math.log(threshold));
  return (size / Math.pow(threshold, i)).toFixed(2) * 1 + " " + units[i];
};
/**
 * Checks if vee-validate is defined globally.
 */


var isDefinedGlobally = function () {
  return typeof VeeValidate !== 'undefined';
};

var obj;
var messages = {
  _default: function (field) {
    return "The " + field + " value is not valid.";
  },
  after: function (field, ref) {
    var target = ref[0];
    var inclusion = ref[1];
    return "The " + field + " must be after " + (inclusion ? 'or equal to ' : '') + target + ".";
  },
  alpha_dash: function (field) {
    return "The " + field + " field may contain alpha-numeric characters as well as dashes and underscores.";
  },
  alpha_num: function (field) {
    return "The " + field + " field may only contain alpha-numeric characters.";
  },
  alpha_spaces: function (field) {
    return "The " + field + " field may only contain alphabetic characters as well as spaces.";
  },
  alpha: function (field) {
    return "The " + field + " field may only contain alphabetic characters.";
  },
  before: function (field, ref) {
    var target = ref[0];
    var inclusion = ref[1];
    return "The " + field + " must be before " + (inclusion ? 'or equal to ' : '') + target + ".";
  },
  between: function (field, ref) {
    var min = ref[0];
    var max = ref[1];
    return "The " + field + " field must be between " + min + " and " + max + ".";
  },
  confirmed: function (field) {
    return "The " + field + " confirmation does not match.";
  },
  credit_card: function (field) {
    return "The " + field + " field is invalid.";
  },
  date_between: function (field, ref) {
    var min = ref[0];
    var max = ref[1];
    return "The " + field + " must be between " + min + " and " + max + ".";
  },
  date_format: function (field, ref) {
    var format = ref[0];
    return "The " + field + " must be in the format " + format + ".";
  },
  decimal: function (field, ref) {
    if (ref === void 0) ref = [];
    var decimals = ref[0];
    if (decimals === void 0) decimals = '*';
    return "The " + field + " field must be numeric and may contain " + (!decimals || decimals === '*' ? '' : decimals) + " decimal points.";
  },
  digits: function (field, ref) {
    var length = ref[0];
    return "The " + field + " field must be numeric and exactly contain " + length + " digits.";
  },
  dimensions: function (field, ref) {
    var width = ref[0];
    var height = ref[1];
    return "The " + field + " field must be " + width + " pixels by " + height + " pixels.";
  },
  email: function (field) {
    return "The " + field + " field must be a valid email.";
  },
  ext: function (field) {
    return "The " + field + " field must be a valid file.";
  },
  image: function (field) {
    return "The " + field + " field must be an image.";
  },
  included: function (field) {
    return "The " + field + " field must be a valid value.";
  },
  integer: function (field) {
    return "The " + field + " field must be an integer.";
  },
  ip: function (field) {
    return "The " + field + " field must be a valid ip address.";
  },
  length: function (field, ref) {
    var length = ref[0];
    var max = ref[1];

    if (max) {
      return "The " + field + " length must be between " + length + " and " + max + ".";
    }

    return "The " + field + " length must be " + length + ".";
  },
  max: function (field, ref) {
    var length = ref[0];
    return "The " + field + " field may not be greater than " + length + " characters.";
  },
  max_value: function (field, ref) {
    var max = ref[0];
    return "The " + field + " field must be " + max + " or less.";
  },
  mimes: function (field) {
    return "The " + field + " field must have a valid file type.";
  },
  min: function (field, ref) {
    var length = ref[0];
    return "The " + field + " field must be at least " + length + " characters.";
  },
  min_value: function (field, ref) {
    var min = ref[0];
    return "The " + field + " field must be " + min + " or more.";
  },
  excluded: function (field) {
    return "The " + field + " field must be a valid value.";
  },
  numeric: function (field) {
    return "The " + field + " field may only contain numeric characters.";
  },
  regex: function (field) {
    return "The " + field + " field format is invalid.";
  },
  required: function (field) {
    return "The " + field + " field is required.";
  },
  size: function (field, ref) {
    var size = ref[0];
    return "The " + field + " size must be less than " + formatFileSize(size) + ".";
  },
  url: function (field) {
    return "The " + field + " field is not a valid URL.";
  }
};
var locale = {
  name: 'en',
  messages: messages,
  attributes: {}
};

if (isDefinedGlobally()) {
  // eslint-disable-next-line
  VeeValidate.Validator.localize((obj = {}, obj[locale.name] = locale, obj));
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns = {
  dateTimeDelimeter: /[T ]/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [/^([+-]\d{2})$/, // 0 additional digits
  /^([+-]\d{3})$/, // 1 additional digit
  /^([+-]\d{4})$/ // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [/^([+-]\d{4})/, // 0 additional digits
  /^([+-]\d{5})/, // 1 additional digit
  /^([+-]\d{6})/ // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // timezone tokens
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-])(\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If an argument is a string, the function tries to parse it.
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument is null, it is treated as an invalid date.
 *
 * If all above fails, the function passes the given argument to Date constructor.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
 *
 * @param {*} argument - the value to convert
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = toDate('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * var result = toDate('+02014101', {additionalDigits: 1})
 * //=> Fri Apr 11 2014 00:00:00
 */

function toDate(argument, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
  }

  if (argument === null) {
    return new Date(NaN);
  }

  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits === undefined ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  } // Clone the date


  if (argument instanceof Date) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument !== 'string') {
    return new Date(argument);
  }

  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date = parseDate(restDateString, year);

  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
    } else {
      // get offset accurate to hour in timezones that change offset
      offset = new Date(timestamp + time).getTimezoneOffset();
      offset = new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE).getTimezoneOffset();
    }

    return new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE);
  } else {
    return new Date(argument);
  }
}

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimeter);
  var timeString;

  if (patterns.plainTime.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var patternYYY = patterns.YYY[additionalDigits];
  var patternYYYYY = patterns.YYYYY[additionalDigits];
  var token; // YYYY or YYYYY

  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);

  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  } // YY or YYY


  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);

  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  } // Invalid ISO-formatted year


  return {
    year: null
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) {
    return null;
  }

  var token;
  var date;
  var month;
  var week; // YYYY

  if (dateString.length === 0) {
    date = new Date(0);
    date.setUTCFullYear(year);
    return date;
  } // YYYY-MM


  token = patterns.MM.exec(dateString);

  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    date.setUTCFullYear(year, month);
    return date;
  } // YYYY-DDD or YYYYDDD


  token = patterns.DDD.exec(dateString);

  if (token) {
    date = new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  } // YYYY-MM-DD or YYYYMMDD


  token = patterns.MMDD.exec(dateString);

  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    date.setUTCFullYear(year, month, day);
    return date;
  } // YYYY-Www or YYYYWww


  token = patterns.Www.exec(dateString);

  if (token) {
    week = parseInt(token[1], 10) - 1;
    return dayOfISOYear(year, week);
  } // YYYY-Www-D or YYYYWwwD


  token = patterns.WwwD.exec(dateString);

  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    return dayOfISOYear(year, week, dayOfWeek);
  } // Invalid ISO-formatted date


  return null;
}

function parseTime(timeString) {
  var token;
  var hours;
  var minutes; // hh

  token = patterns.HH.exec(timeString);

  if (token) {
    hours = parseFloat(token[1].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR;
  } // hh:mm or hhmm


  token = patterns.HHMM.exec(timeString);

  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
  } // hh:mm:ss or hhmmss


  token = patterns.HHMMSS.exec(timeString);

  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
  } // Invalid ISO-formatted time


  return null;
}

function parseTimezone(timezoneString) {
  var token;
  var absoluteOffset; // Z

  token = patterns.timezoneZ.exec(timezoneString);

  if (token) {
    return 0;
  } // hh


  token = patterns.timezoneHH.exec(timezoneString);

  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60;
    return token[1] === '+' ? -absoluteOffset : absoluteOffset;
  } // hh:mm or hhmm


  token = patterns.timezoneHHMM.exec(timezoneString);

  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
    return token[1] === '+' ? -absoluteOffset : absoluteOffset;
  }

  return 0;
}

function dayOfISOYear(isoYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = new Date(0);
  date.setUTCFullYear(isoYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */


function addMilliseconds(dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var timestamp = toDate(dirtyDate, dirtyOptions).getTime();
  var amount = Number(dirtyAmount);
  return new Date(timestamp + amount);
}

function cloneObject(dirtyObject) {
  dirtyObject = dirtyObject || {};
  var object = {};

  for (var property in dirtyObject) {
    if (dirtyObject.hasOwnProperty(property)) {
      object[property] = dirtyObject[property];
    }
  }

  return object;
}

var MILLISECONDS_IN_MINUTE$2 = 60000;
/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the new date with the minutes added
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */

function addMinutes(dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$2, dirtyOptions);
}
/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // For the valid date:
 * var result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * var result = isValid('2014-02-31')
 * //=> true
 *
 * @example
 * // For the invalid date:
 * var result = isValid(new Date(''))
 * //=> false
 */


function isValid(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
  }

  var date = toDate(dirtyDate, dirtyOptions);
  return !isNaN(date);
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

function formatDistance(token, count, options) {
  options = options || {};
  var result;

  if (typeof formatDistanceLocale[token] === 'string') {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace('{{count}}', count);
  }

  if (options.addSuffix) {
    if (options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
}

var tokensToBeShortedPattern = /MMMM|MM|DD|dddd/g;

function buildShortLongFormat(format) {
  return format.replace(tokensToBeShortedPattern, function (token) {
    return token.slice(1);
  });
}
/**
 * @name buildFormatLongFn
 * @category Locale Helpers
 * @summary Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
 *
 * @description
 * Build `formatLong` property for locale used by `format`, `formatRelative` and `parse` functions.
 * Returns a function which takes one of the following tokens as the argument:
 * `'LTS'`, `'LT'`, `'L'`, `'LL'`, `'LLL'`, `'l'`, `'ll'`, `'lll'`, `'llll'`
 * and returns a long format string written as `format` token strings.
 * See [format]{@link https://date-fns.org/docs/format}
 *
 * `'l'`, `'ll'`, `'lll'` and `'llll'` formats are built automatically
 * by shortening some of the tokens from corresponding unshortened formats
 * (e.g., if `LL` is `'MMMM DD YYYY'` then `ll` will be `MMM D YYYY`)
 *
 * @param {Object} obj - the object with long formats written as `format` token strings
 * @param {String} obj.LT - time format: hours and minutes
 * @param {String} obj.LTS - time format: hours, minutes and seconds
 * @param {String} obj.L - short date format: numeric day, month and year
 * @param {String} [obj.l] - short date format: numeric day, month and year (shortened)
 * @param {String} obj.LL - long date format: day, month in words, and year
 * @param {String} [obj.ll] - long date format: day, month in words, and year (shortened)
 * @param {String} obj.LLL - long date and time format
 * @param {String} [obj.lll] - long date and time format (shortened)
 * @param {String} obj.LLLL - long date, time and weekday format
 * @param {String} [obj.llll] - long date, time and weekday format (shortened)
 * @returns {Function} `formatLong` property of the locale
 *
 * @example
 * // For `en-US` locale:
 * locale.formatLong = buildFormatLongFn({
 *   LT: 'h:mm aa',
 *   LTS: 'h:mm:ss aa',
 *   L: 'MM/DD/YYYY',
 *   LL: 'MMMM D YYYY',
 *   LLL: 'MMMM D YYYY h:mm aa',
 *   LLLL: 'dddd, MMMM D YYYY h:mm aa'
 * })
 */


function buildFormatLongFn(obj) {
  var formatLongLocale = {
    LTS: obj.LTS,
    LT: obj.LT,
    L: obj.L,
    LL: obj.LL,
    LLL: obj.LLL,
    LLLL: obj.LLLL,
    l: obj.l || buildShortLongFormat(obj.L),
    ll: obj.ll || buildShortLongFormat(obj.LL),
    lll: obj.lll || buildShortLongFormat(obj.LLL),
    llll: obj.llll || buildShortLongFormat(obj.LLLL)
  };
  return function (token) {
    return formatLongLocale[token];
  };
}

var formatLong = buildFormatLongFn({
  LT: 'h:mm aa',
  LTS: 'h:mm:ss aa',
  L: 'MM/DD/YYYY',
  LL: 'MMMM D YYYY',
  LLL: 'MMMM D YYYY h:mm aa',
  LLLL: 'dddd, MMMM D YYYY h:mm aa'
});
var formatRelativeLocale = {
  lastWeek: '[last] dddd [at] LT',
  yesterday: '[yesterday at] LT',
  today: '[today at] LT',
  tomorrow: '[tomorrow at] LT',
  nextWeek: 'dddd [at] LT',
  other: 'L'
};

function formatRelative(token, date, baseDate, options) {
  return formatRelativeLocale[token];
}
/**
 * @name buildLocalizeFn
 * @category Locale Helpers
 * @summary Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale.
 *
 * @description
 * Build `localize.weekday`, `localize.month` and `localize.timeOfDay` properties for the locale
 * used by `format` function.
 * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
 *
 * `localize.weekday` function takes the weekday index as argument (0 - Sunday).
 * `localize.month` takes the month index (0 - January).
 * `localize.timeOfDay` takes the hours. Use `indexCallback` to convert them to an array index (see example).
 *
 * @param {Object} values - the object with arrays of values
 * @param {String} defaultType - the default type for the localize function
 * @param {Function} [indexCallback] - the callback which takes the resulting function argument
 *   and converts it into value array index
 * @returns {Function} the resulting function
 *
 * @example
 * var timeOfDayValues = {
 *   uppercase: ['AM', 'PM'],
 *   lowercase: ['am', 'pm'],
 *   long: ['a.m.', 'p.m.']
 * }
 * locale.localize.timeOfDay = buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
 *   // 0 is a.m. array index, 1 is p.m. array index
 *   return (hours / 12) >= 1 ? 1 : 0
 * })
 * locale.localize.timeOfDay(16, {type: 'uppercase'}) //=> 'PM'
 * locale.localize.timeOfDay(5) //=> 'a.m.'
 */


function buildLocalizeFn(values, defaultType, indexCallback) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    var valuesArray = values[type] || values[defaultType];
    var index = indexCallback ? indexCallback(Number(dirtyIndex)) : Number(dirtyIndex);
    return valuesArray[index];
  };
}
/**
 * @name buildLocalizeArrayFn
 * @category Locale Helpers
 * @summary Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
 *
 * @description
 * Build `localize.weekdays`, `localize.months` and `localize.timesOfDay` properties for the locale.
 * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
 *
 * @param {Object} values - the object with arrays of values
 * @param {String} defaultType - the default type for the localize function
 * @returns {Function} the resulting function
 *
 * @example
 * var weekdayValues = {
 *   narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
 *   short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
 *   long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
 * }
 * locale.localize.weekdays = buildLocalizeArrayFn(weekdayValues, 'long')
 * locale.localize.weekdays({type: 'narrow'}) //=> ['Su', 'Mo', ...]
 * locale.localize.weekdays() //=> ['Sunday', 'Monday', ...]
 */


function buildLocalizeArrayFn(values, defaultType) {
  return function (dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    return values[type] || values[defaultType];
  };
} // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.


var weekdayValues = {
  narrow: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  short: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  long: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var monthValues = {
  short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  long: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
}; // `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
// Use the system which is used the most commonly in the locale.
// For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
//
//   var timeOfDayValues = {
//     any: ['in the night', 'in the morning', 'in the afternoon', 'in the evening']
//   }
//
// And later:
//
//   var localize = {
//     // The callback takes the hours as the argument and returns the array index
//     timeOfDay: buildLocalizeFn(timeOfDayValues, 'any', function (hours) {
//       if (hours >= 17) {
//         return 3
//       } else if (hours >= 12) {
//         return 2
//       } else if (hours >= 4) {
//         return 1
//       } else {
//         return 0
//       }
//     }),
//     timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'any')
//   }

var timeOfDayValues = {
  uppercase: ['AM', 'PM'],
  lowercase: ['am', 'pm'],
  long: ['a.m.', 'p.m.']
};

function ordinalNumber(dirtyNumber, dirtyOptions) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`:
  //
  //   var options = dirtyOptions || {}
  //   var unit = String(options.unit)
  //
  // where `unit` can be 'month', 'quarter', 'week', 'isoWeek', 'dayOfYear',
  // 'dayOfMonth' or 'dayOfWeek'

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
}

var localize = {
  ordinalNumber: ordinalNumber,
  weekday: buildLocalizeFn(weekdayValues, 'long'),
  weekdays: buildLocalizeArrayFn(weekdayValues, 'long'),
  month: buildLocalizeFn(monthValues, 'long'),
  months: buildLocalizeArrayFn(monthValues, 'long'),
  timeOfDay: buildLocalizeFn(timeOfDayValues, 'long', function (hours) {
    return hours / 12 >= 1 ? 1 : 0;
  }),
  timesOfDay: buildLocalizeArrayFn(timeOfDayValues, 'long')
};
/**
 * @name buildMatchFn
 * @category Locale Helpers
 * @summary Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale.
 *
 * @description
 * Build `match.weekdays`, `match.months` and `match.timesOfDay` properties for the locale used by `parse` function.
 * If no `type` is supplied to the options of the resulting function, `defaultType` will be used (see example).
 * The result of the match function will be passed into corresponding parser function
 * (`match.weekday`, `match.month` or `match.timeOfDay` respectively. See `buildParseFn`).
 *
 * @param {Object} values - the object with RegExps
 * @param {String} defaultType - the default type for the match function
 * @returns {Function} the resulting function
 *
 * @example
 * var matchWeekdaysPatterns = {
 *   narrow: /^(su|mo|tu|we|th|fr|sa)/i,
 *   short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
 *   long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
 * }
 * locale.match.weekdays = buildMatchFn(matchWeekdaysPatterns, 'long')
 * locale.match.weekdays('Sunday', {type: 'narrow'}) //=> ['Su', 'Su', ...]
 * locale.match.weekdays('Sunday') //=> ['Sunday', 'Sunday', ...]
 */

function buildMatchFn(patterns, defaultType) {
  return function (dirtyString, dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    var pattern = patterns[type] || patterns[defaultType];
    var string = String(dirtyString);
    return string.match(pattern);
  };
}
/**
 * @name buildParseFn
 * @category Locale Helpers
 * @summary Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale.
 *
 * @description
 * Build `match.weekday`, `match.month` and `match.timeOfDay` properties for the locale used by `parse` function.
 * The argument of the resulting function is the result of the corresponding match function
 * (`match.weekdays`, `match.months` or `match.timesOfDay` respectively. See `buildMatchFn`).
 *
 * @param {Object} values - the object with arrays of RegExps
 * @param {String} defaultType - the default type for the parser function
 * @returns {Function} the resulting function
 *
 * @example
 * var parseWeekdayPatterns = {
 *   any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
 * }
 * locale.match.weekday = buildParseFn(matchWeekdaysPatterns, 'long')
 * var matchResult = locale.match.weekdays('Friday')
 * locale.match.weekday(matchResult) //=> 5
 */


function buildParseFn(patterns, defaultType) {
  return function (matchResult, dirtyOptions) {
    var options = dirtyOptions || {};
    var type = options.type ? String(options.type) : defaultType;
    var patternsArray = patterns[type] || patterns[defaultType];
    var string = matchResult[1];
    return patternsArray.findIndex(function (pattern) {
      return pattern.test(string);
    });
  };
}
/**
 * @name buildMatchPatternFn
 * @category Locale Helpers
 * @summary Build match function from a single RegExp.
 *
 * @description
 * Build match function from a single RegExp.
 * Usually used for building `match.ordinalNumbers` property of the locale.
 *
 * @param {Object} pattern - the RegExp
 * @returns {Function} the resulting function
 *
 * @example
 * locale.match.ordinalNumbers = buildMatchPatternFn(/^(\d+)(th|st|nd|rd)?/i)
 * locale.match.ordinalNumbers('3rd') //=> ['3rd', '3', 'rd', ...]
 */


function buildMatchPatternFn(pattern) {
  return function (dirtyString) {
    var string = String(dirtyString);
    return string.match(pattern);
  };
}
/**
 * @name parseDecimal
 * @category Locale Helpers
 * @summary Parses the match result into decimal number.
 *
 * @description
 * Parses the match result into decimal number.
 * Uses the string matched with the first set of parentheses of match RegExp.
 *
 * @param {Array} matchResult - the object returned by matching function
 * @returns {Number} the parsed value
 *
 * @example
 * locale.match = {
 *   ordinalNumbers: (dirtyString) {
 *     return String(dirtyString).match(/^(\d+)(th|st|nd|rd)?/i)
 *   },
 *   ordinalNumber: parseDecimal
 * }
 */


function parseDecimal(matchResult) {
  return parseInt(matchResult[1], 10);
}

var matchOrdinalNumbersPattern = /^(\d+)(th|st|nd|rd)?/i;
var matchWeekdaysPatterns = {
  narrow: /^(su|mo|tu|we|th|fr|sa)/i,
  short: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  long: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseWeekdayPatterns = {
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchMonthsPatterns = {
  short: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  long: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}; // `timeOfDay` is used to designate which part of the day it is, when used with 12-hour clock.
// Use the system which is used the most commonly in the locale.
// For example, if the country doesn't use a.m./p.m., you can use `night`/`morning`/`afternoon`/`evening`:
//
//   var matchTimesOfDayPatterns = {
//     long: /^((in the)? (night|morning|afternoon|evening?))/i
//   }
//
//   var parseTimeOfDayPatterns = {
//     any: [/(night|morning)/i, /(afternoon|evening)/i]
//   }

var matchTimesOfDayPatterns = {
  short: /^(am|pm)/i,
  long: /^([ap]\.?\s?m\.?)/i
};
var parseTimeOfDayPatterns = {
  any: [/^a/i, /^p/i]
};
var match = {
  ordinalNumbers: buildMatchPatternFn(matchOrdinalNumbersPattern),
  ordinalNumber: parseDecimal,
  weekdays: buildMatchFn(matchWeekdaysPatterns, 'long'),
  weekday: buildParseFn(parseWeekdayPatterns, 'any'),
  months: buildMatchFn(matchMonthsPatterns, 'long'),
  month: buildParseFn(parseMonthPatterns, 'any'),
  timesOfDay: buildMatchFn(matchTimesOfDayPatterns, 'long'),
  timeOfDay: buildParseFn(parseTimeOfDayPatterns, 'any')
};
/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 */

var locale$1 = {
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var MILLISECONDS_IN_DAY$1 = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1;
} // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376


function startOfUTCISOWeek(dirtyDate, dirtyOptions) {
  var weekStartsOn = 1;
  var date = toDate(dirtyDate, dirtyOptions);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
} // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376


function getUTCISOWeekYear(dirtyDate, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear, dirtyOptions);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
} // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376


function startOfUTCISOWeekYear(dirtyDate, dirtyOptions) {
  var year = getUTCISOWeekYear(dirtyDate, dirtyOptions);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK$2 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var diff = startOfUTCISOWeek(date, dirtyOptions).getTime() - startOfUTCISOWeekYear(date, dirtyOptions).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
}

var formatters = {
  // Month: 1, 2, ..., 12
  'M': function (date) {
    return date.getUTCMonth() + 1;
  },
  // Month: 1st, 2nd, ..., 12th
  'Mo': function (date, options) {
    var month = date.getUTCMonth() + 1;
    return options.locale.localize.ordinalNumber(month, {
      unit: 'month'
    });
  },
  // Month: 01, 02, ..., 12
  'MM': function (date) {
    return addLeadingZeros(date.getUTCMonth() + 1, 2);
  },
  // Month: Jan, Feb, ..., Dec
  'MMM': function (date, options) {
    return options.locale.localize.month(date.getUTCMonth(), {
      type: 'short'
    });
  },
  // Month: January, February, ..., December
  'MMMM': function (date, options) {
    return options.locale.localize.month(date.getUTCMonth(), {
      type: 'long'
    });
  },
  // Quarter: 1, 2, 3, 4
  'Q': function (date) {
    return Math.ceil((date.getUTCMonth() + 1) / 3);
  },
  // Quarter: 1st, 2nd, 3rd, 4th
  'Qo': function (date, options) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    return options.locale.localize.ordinalNumber(quarter, {
      unit: 'quarter'
    });
  },
  // Day of month: 1, 2, ..., 31
  'D': function (date) {
    return date.getUTCDate();
  },
  // Day of month: 1st, 2nd, ..., 31st
  'Do': function (date, options) {
    return options.locale.localize.ordinalNumber(date.getUTCDate(), {
      unit: 'dayOfMonth'
    });
  },
  // Day of month: 01, 02, ..., 31
  'DD': function (date) {
    return addLeadingZeros(date.getUTCDate(), 2);
  },
  // Day of year: 1, 2, ..., 366
  'DDD': function (date) {
    return getUTCDayOfYear(date);
  },
  // Day of year: 1st, 2nd, ..., 366th
  'DDDo': function (date, options) {
    return options.locale.localize.ordinalNumber(getUTCDayOfYear(date), {
      unit: 'dayOfYear'
    });
  },
  // Day of year: 001, 002, ..., 366
  'DDDD': function (date) {
    return addLeadingZeros(getUTCDayOfYear(date), 3);
  },
  // Day of week: Su, Mo, ..., Sa
  'dd': function (date, options) {
    return options.locale.localize.weekday(date.getUTCDay(), {
      type: 'narrow'
    });
  },
  // Day of week: Sun, Mon, ..., Sat
  'ddd': function (date, options) {
    return options.locale.localize.weekday(date.getUTCDay(), {
      type: 'short'
    });
  },
  // Day of week: Sunday, Monday, ..., Saturday
  'dddd': function (date, options) {
    return options.locale.localize.weekday(date.getUTCDay(), {
      type: 'long'
    });
  },
  // Day of week: 0, 1, ..., 6
  'd': function (date) {
    return date.getUTCDay();
  },
  // Day of week: 0th, 1st, 2nd, ..., 6th
  'do': function (date, options) {
    return options.locale.localize.ordinalNumber(date.getUTCDay(), {
      unit: 'dayOfWeek'
    });
  },
  // Day of ISO week: 1, 2, ..., 7
  'E': function (date) {
    return date.getUTCDay() || 7;
  },
  // ISO week: 1, 2, ..., 53
  'W': function (date) {
    return getUTCISOWeek(date);
  },
  // ISO week: 1st, 2nd, ..., 53th
  'Wo': function (date, options) {
    return options.locale.localize.ordinalNumber(getUTCISOWeek(date), {
      unit: 'isoWeek'
    });
  },
  // ISO week: 01, 02, ..., 53
  'WW': function (date) {
    return addLeadingZeros(getUTCISOWeek(date), 2);
  },
  // Year: 00, 01, ..., 99
  'YY': function (date) {
    return addLeadingZeros(date.getUTCFullYear(), 4).substr(2);
  },
  // Year: 1900, 1901, ..., 2099
  'YYYY': function (date) {
    return addLeadingZeros(date.getUTCFullYear(), 4);
  },
  // ISO week-numbering year: 00, 01, ..., 99
  'GG': function (date) {
    return String(getUTCISOWeekYear(date)).substr(2);
  },
  // ISO week-numbering year: 1900, 1901, ..., 2099
  'GGGG': function (date) {
    return getUTCISOWeekYear(date);
  },
  // Hour: 0, 1, ... 23
  'H': function (date) {
    return date.getUTCHours();
  },
  // Hour: 00, 01, ..., 23
  'HH': function (date) {
    return addLeadingZeros(date.getUTCHours(), 2);
  },
  // Hour: 1, 2, ..., 12
  'h': function (date) {
    var hours = date.getUTCHours();

    if (hours === 0) {
      return 12;
    } else if (hours > 12) {
      return hours % 12;
    } else {
      return hours;
    }
  },
  // Hour: 01, 02, ..., 12
  'hh': function (date) {
    return addLeadingZeros(formatters['h'](date), 2);
  },
  // Minute: 0, 1, ..., 59
  'm': function (date) {
    return date.getUTCMinutes();
  },
  // Minute: 00, 01, ..., 59
  'mm': function (date) {
    return addLeadingZeros(date.getUTCMinutes(), 2);
  },
  // Second: 0, 1, ..., 59
  's': function (date) {
    return date.getUTCSeconds();
  },
  // Second: 00, 01, ..., 59
  'ss': function (date) {
    return addLeadingZeros(date.getUTCSeconds(), 2);
  },
  // 1/10 of second: 0, 1, ..., 9
  'S': function (date) {
    return Math.floor(date.getUTCMilliseconds() / 100);
  },
  // 1/100 of second: 00, 01, ..., 99
  'SS': function (date) {
    return addLeadingZeros(Math.floor(date.getUTCMilliseconds() / 10), 2);
  },
  // Millisecond: 000, 001, ..., 999
  'SSS': function (date) {
    return addLeadingZeros(date.getUTCMilliseconds(), 3);
  },
  // Timezone: -01:00, +00:00, ... +12:00
  'Z': function (date, options) {
    var originalDate = options._originalDate || date;
    return formatTimezone(originalDate.getTimezoneOffset(), ':');
  },
  // Timezone: -0100, +0000, ... +1200
  'ZZ': function (date, options) {
    var originalDate = options._originalDate || date;
    return formatTimezone(originalDate.getTimezoneOffset());
  },
  // Seconds timestamp: 512969520
  'X': function (date, options) {
    var originalDate = options._originalDate || date;
    return Math.floor(originalDate.getTime() / 1000);
  },
  // Milliseconds timestamp: 512969520900
  'x': function (date, options) {
    var originalDate = options._originalDate || date;
    return originalDate.getTime();
  },
  // AM, PM
  'A': function (date, options) {
    return options.locale.localize.timeOfDay(date.getUTCHours(), {
      type: 'uppercase'
    });
  },
  // am, pm
  'a': function (date, options) {
    return options.locale.localize.timeOfDay(date.getUTCHours(), {
      type: 'lowercase'
    });
  },
  // a.m., p.m.
  'aa': function (date, options) {
    return options.locale.localize.timeOfDay(date.getUTCHours(), {
      type: 'long'
    });
  }
};

function formatTimezone(offset, delimeter) {
  delimeter = delimeter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2);
}

function addLeadingZeros(number, targetLength) {
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return output;
} // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376


function addUTCMinutes(dirtyDate, dirtyAmount, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var amount = Number(dirtyAmount);
  date.setUTCMinutes(date.getUTCMinutes() + amount);
  return date;
}

var longFormattingTokensRegExp = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
var defaultFormattingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format.
 *
 * Accepted tokens:
 * | Unit                    | Token | Result examples                  |
 * |-------------------------|-------|----------------------------------|
 * | Month                   | M     | 1, 2, ..., 12                    |
 * |                         | Mo    | 1st, 2nd, ..., 12th              |
 * |                         | MM    | 01, 02, ..., 12                  |
 * |                         | MMM   | Jan, Feb, ..., Dec               |
 * |                         | MMMM  | January, February, ..., December |
 * | Quarter                 | Q     | 1, 2, 3, 4                       |
 * |                         | Qo    | 1st, 2nd, 3rd, 4th               |
 * | Day of month            | D     | 1, 2, ..., 31                    |
 * |                         | Do    | 1st, 2nd, ..., 31st              |
 * |                         | DD    | 01, 02, ..., 31                  |
 * | Day of year             | DDD   | 1, 2, ..., 366                   |
 * |                         | DDDo  | 1st, 2nd, ..., 366th             |
 * |                         | DDDD  | 001, 002, ..., 366               |
 * | Day of week             | d     | 0, 1, ..., 6                     |
 * |                         | do    | 0th, 1st, ..., 6th               |
 * |                         | dd    | Su, Mo, ..., Sa                  |
 * |                         | ddd   | Sun, Mon, ..., Sat               |
 * |                         | dddd  | Sunday, Monday, ..., Saturday    |
 * | Day of ISO week         | E     | 1, 2, ..., 7                     |
 * | ISO week                | W     | 1, 2, ..., 53                    |
 * |                         | Wo    | 1st, 2nd, ..., 53rd              |
 * |                         | WW    | 01, 02, ..., 53                  |
 * | Year                    | YY    | 00, 01, ..., 99                  |
 * |                         | YYYY  | 1900, 1901, ..., 2099            |
 * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |
 * |                         | GGGG  | 1900, 1901, ..., 2099            |
 * | AM/PM                   | A     | AM, PM                           |
 * |                         | a     | am, pm                           |
 * |                         | aa    | a.m., p.m.                       |
 * | Hour                    | H     | 0, 1, ... 23                     |
 * |                         | HH    | 00, 01, ... 23                   |
 * |                         | h     | 1, 2, ..., 12                    |
 * |                         | hh    | 01, 02, ..., 12                  |
 * | Minute                  | m     | 0, 1, ..., 59                    |
 * |                         | mm    | 00, 01, ..., 59                  |
 * | Second                  | s     | 0, 1, ..., 59                    |
 * |                         | ss    | 00, 01, ..., 59                  |
 * | 1/10 of second          | S     | 0, 1, ..., 9                     |
 * | 1/100 of second         | SS    | 00, 01, ..., 99                  |
 * | Millisecond             | SSS   | 000, 001, ..., 999               |
 * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |
 * |                         | ZZ    | -0100, +0000, ..., +1200         |
 * | Seconds timestamp       | X     | 512969520                        |
 * | Milliseconds timestamp  | x     | 512969520900                     |
 * | Long format             | LT    | 05:30 a.m.                       |
 * |                         | LTS   | 05:30:15 a.m.                    |
 * |                         | L     | 07/02/1995                       |
 * |                         | l     | 7/2/1995                         |
 * |                         | LL    | July 2 1995                      |
 * |                         | ll    | Jul 2 1995                       |
 * |                         | LLL   | July 2 1995 05:30 a.m.           |
 * |                         | lll   | Jul 2 1995 05:30 a.m.            |
 * |                         | LLLL  | Sunday, July 2 1995 05:30 a.m.   |
 * |                         | llll  | Sun, Jul 2 1995 05:30 a.m.       |
 *
 * The characters wrapped in square brackets are escaped.
 *
 * The result may vary by locale.
 *
 * @param {Date|String|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(
 *   new Date(2014, 1, 11),
 *   'MM/DD/YYYY'
 * )
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(
 *   new Date(2014, 6, 2),
 *   'Do [de] MMMM YYYY',
 *   {locale: eoLocale}
 * )
 * //=> '2-a de julio 2014'
 */

function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || locale$1;

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var localeFormatters = locale.formatters || {};
  var formattingTokensRegExp = locale.formattingTokensRegExp || defaultFormattingTokensRegExp;
  var formatLong = locale.formatLong;
  var originalDate = toDate(dirtyDate, options);

  if (!isValid(originalDate, options)) {
    return 'Invalid Date';
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = originalDate.getTimezoneOffset();
  var utcDate = addUTCMinutes(originalDate, -timezoneOffset, options);
  var formatterOptions = cloneObject(options);
  formatterOptions.locale = locale;
  formatterOptions.formatters = formatters; // When UTC functions will be implemented, options._originalDate will likely be a part of public API.
  // Right now, please don't use it in locales. If you have to use an original date,
  // please restore it from `date`, adding a timezone offset to it.

  formatterOptions._originalDate = originalDate;
  var result = formatStr.replace(longFormattingTokensRegExp, function (substring) {
    if (substring[0] === '[') {
      return substring;
    }

    if (substring[0] === '\\') {
      return cleanEscapedString(substring);
    }

    return formatLong(substring);
  }).replace(formattingTokensRegExp, function (substring) {
    var formatter = localeFormatters[substring] || formatters[substring];

    if (formatter) {
      return formatter(utcDate, formatterOptions);
    } else {
      return cleanEscapedString(substring);
    }
  });
  return result;
}

function cleanEscapedString(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|]$/g, '');
  }

  return input.replace(/\\/g, '');
}
/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be subtracted
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Date} the new date with the mintues subtracted
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * var result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */


function subMinutes(dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var amount = Number(dirtyAmount);
  return addMinutes(dirtyDate, -amount, dirtyOptions);
}
/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @param {Date|String|Number} date - the date that should be after the other one to return true
 * @param {Date|String|Number} dateToCompare - the date to compare with
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the first date is after the second date
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * var result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */


function isAfter(dirtyDate, dirtyDateToCompare, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var date = toDate(dirtyDate, dirtyOptions);
  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
  return date.getTime() > dateToCompare.getTime();
}
/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @param {Date|String|Number} date - the date that should be before the other one to return true
 * @param {Date|String|Number} dateToCompare - the date to compare with
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the first date is before the second date
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * var result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */


function isBefore(dirtyDate, dirtyDateToCompare, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var date = toDate(dirtyDate, dirtyOptions);
  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
  return date.getTime() < dateToCompare.getTime();
}
/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @param {Date|String|Number} dateLeft - the first date to compare
 * @param {Date|String|Number} dateRight - the second date to compare
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @returns {Boolean} the dates are equal
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * var result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0)
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */


function isEqual$1(dirtyLeftDate, dirtyRightDate, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
  }

  var dateLeft = toDate(dirtyLeftDate, dirtyOptions);
  var dateRight = toDate(dirtyRightDate, dirtyOptions);
  return dateLeft.getTime() === dateRight.getTime();
}

var patterns$1 = {
  'M': /^(1[0-2]|0?\d)/,
  // 0 to 12
  'D': /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  'DDD': /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  'W': /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  'YYYY': /^(\d{1,4})/,
  // 0 to 9999
  'H': /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  'm': /^([0-5]?\d)/,
  // 0 to 59
  'Z': /^([+-])(\d{2}):(\d{2})/,
  'ZZ': /^([+-])(\d{2})(\d{2})/,
  singleDigit: /^(\d)/,
  twoDigits: /^(\d{2})/,
  threeDigits: /^(\d{3})/,
  fourDigits: /^(\d{4})/,
  anyDigits: /^(\d+)/
};

function parseDecimal$1(matchResult) {
  return parseInt(matchResult[1], 10);
}

var parsers = {
  // Year: 00, 01, ..., 99
  'YY': {
    unit: 'twoDigitYear',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult);
    }
  },
  // Year: 1900, 1901, ..., 2099
  'YYYY': {
    unit: 'year',
    match: patterns$1.YYYY,
    parse: parseDecimal$1
  },
  // ISO week-numbering year: 00, 01, ..., 99
  'GG': {
    unit: 'isoYear',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) + 1900;
    }
  },
  // ISO week-numbering year: 1900, 1901, ..., 2099
  'GGGG': {
    unit: 'isoYear',
    match: patterns$1.YYYY,
    parse: parseDecimal$1
  },
  // Quarter: 1, 2, 3, 4
  'Q': {
    unit: 'quarter',
    match: patterns$1.singleDigit,
    parse: parseDecimal$1
  },
  // Ordinal quarter
  'Qo': {
    unit: 'quarter',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {
        unit: 'quarter'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {
        unit: 'quarter'
      });
    }
  },
  // Month: 1, 2, ..., 12
  'M': {
    unit: 'month',
    match: patterns$1.M,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) - 1;
    }
  },
  // Ordinal month
  'Mo': {
    unit: 'month',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {
        unit: 'month'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {
        unit: 'month'
      }) - 1;
    }
  },
  // Month: 01, 02, ..., 12
  'MM': {
    unit: 'month',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) - 1;
    }
  },
  // Month: Jan, Feb, ..., Dec
  'MMM': {
    unit: 'month',
    match: function (string, options) {
      return options.locale.match.months(string, {
        type: 'short'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.month(matchResult, {
        type: 'short'
      });
    }
  },
  // Month: January, February, ..., December
  'MMMM': {
    unit: 'month',
    match: function (string, options) {
      return options.locale.match.months(string, {
        type: 'long'
      }) || options.locale.match.months(string, {
        type: 'short'
      });
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.month(matchResult, {
        type: 'long'
      });

      if (parseResult == null) {
        parseResult = options.locale.match.month(matchResult, {
          type: 'short'
        });
      }

      return parseResult;
    }
  },
  // ISO week: 1, 2, ..., 53
  'W': {
    unit: 'isoWeek',
    match: patterns$1.W,
    parse: parseDecimal$1
  },
  // Ordinal ISO week
  'Wo': {
    unit: 'isoWeek',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {
        unit: 'isoWeek'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {
        unit: 'isoWeek'
      });
    }
  },
  // ISO week: 01, 02, ..., 53
  'WW': {
    unit: 'isoWeek',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },
  // Day of week: 0, 1, ..., 6
  'd': {
    unit: 'dayOfWeek',
    match: patterns$1.singleDigit,
    parse: parseDecimal$1
  },
  // Ordinal day of week
  'do': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {
        unit: 'dayOfWeek'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {
        unit: 'dayOfWeek'
      });
    }
  },
  // Day of week: Su, Mo, ..., Sa
  'dd': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.weekdays(string, {
        type: 'narrow'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.weekday(matchResult, {
        type: 'narrow'
      });
    }
  },
  // Day of week: Sun, Mon, ..., Sat
  'ddd': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.weekdays(string, {
        type: 'short'
      }) || options.locale.match.weekdays(string, {
        type: 'narrow'
      });
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.weekday(matchResult, {
        type: 'short'
      });

      if (parseResult == null) {
        parseResult = options.locale.match.weekday(matchResult, {
          type: 'narrow'
        });
      }

      return parseResult;
    }
  },
  // Day of week: Sunday, Monday, ..., Saturday
  'dddd': {
    unit: 'dayOfWeek',
    match: function (string, options) {
      return options.locale.match.weekdays(string, {
        type: 'long'
      }) || options.locale.match.weekdays(string, {
        type: 'short'
      }) || options.locale.match.weekdays(string, {
        type: 'narrow'
      });
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.weekday(matchResult, {
        type: 'long'
      });

      if (parseResult == null) {
        parseResult = options.locale.match.weekday(matchResult, {
          type: 'short'
        });

        if (parseResult == null) {
          parseResult = options.locale.match.weekday(matchResult, {
            type: 'narrow'
          });
        }
      }

      return parseResult;
    }
  },
  // Day of ISO week: 1, 2, ..., 7
  'E': {
    unit: 'dayOfISOWeek',
    match: patterns$1.singleDigit,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult);
    }
  },
  // Day of month: 1, 2, ..., 31
  'D': {
    unit: 'dayOfMonth',
    match: patterns$1.D,
    parse: parseDecimal$1
  },
  // Ordinal day of month
  'Do': {
    unit: 'dayOfMonth',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {
        unit: 'dayOfMonth'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {
        unit: 'dayOfMonth'
      });
    }
  },
  // Day of month: 01, 02, ..., 31
  'DD': {
    unit: 'dayOfMonth',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },
  // Day of year: 1, 2, ..., 366
  'DDD': {
    unit: 'dayOfYear',
    match: patterns$1.DDD,
    parse: parseDecimal$1
  },
  // Ordinal day of year
  'DDDo': {
    unit: 'dayOfYear',
    match: function (string, options) {
      return options.locale.match.ordinalNumbers(string, {
        unit: 'dayOfYear'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.ordinalNumber(matchResult, {
        unit: 'dayOfYear'
      });
    }
  },
  // Day of year: 001, 002, ..., 366
  'DDDD': {
    unit: 'dayOfYear',
    match: patterns$1.threeDigits,
    parse: parseDecimal$1
  },
  // AM, PM
  'A': {
    unit: 'timeOfDay',
    match: function (string, options) {
      return options.locale.match.timesOfDay(string, {
        type: 'short'
      });
    },
    parse: function (matchResult, options) {
      return options.locale.match.timeOfDay(matchResult, {
        type: 'short'
      });
    }
  },
  // a.m., p.m.
  'aa': {
    unit: 'timeOfDay',
    match: function (string, options) {
      return options.locale.match.timesOfDay(string, {
        type: 'long'
      }) || options.locale.match.timesOfDay(string, {
        type: 'short'
      });
    },
    parse: function (matchResult, options) {
      var parseResult = options.locale.match.timeOfDay(matchResult, {
        type: 'long'
      });

      if (parseResult == null) {
        parseResult = options.locale.match.timeOfDay(matchResult, {
          type: 'short'
        });
      }

      return parseResult;
    }
  },
  // Hour: 0, 1, ... 23
  'H': {
    unit: 'hours',
    match: patterns$1.H,
    parse: parseDecimal$1
  },
  // Hour: 00, 01, ..., 23
  'HH': {
    unit: 'hours',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },
  // Hour: 1, 2, ..., 12
  'h': {
    unit: 'timeOfDayHours',
    match: patterns$1.M,
    parse: parseDecimal$1
  },
  // Hour: 01, 02, ..., 12
  'hh': {
    unit: 'timeOfDayHours',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },
  // Minute: 0, 1, ..., 59
  'm': {
    unit: 'minutes',
    match: patterns$1.m,
    parse: parseDecimal$1
  },
  // Minute: 00, 01, ..., 59
  'mm': {
    unit: 'minutes',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },
  // Second: 0, 1, ..., 59
  's': {
    unit: 'seconds',
    match: patterns$1.m,
    parse: parseDecimal$1
  },
  // Second: 00, 01, ..., 59
  'ss': {
    unit: 'seconds',
    match: patterns$1.twoDigits,
    parse: parseDecimal$1
  },
  // 1/10 of second: 0, 1, ..., 9
  'S': {
    unit: 'milliseconds',
    match: patterns$1.singleDigit,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) * 100;
    }
  },
  // 1/100 of second: 00, 01, ..., 99
  'SS': {
    unit: 'milliseconds',
    match: patterns$1.twoDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) * 10;
    }
  },
  // Millisecond: 000, 001, ..., 999
  'SSS': {
    unit: 'milliseconds',
    match: patterns$1.threeDigits,
    parse: parseDecimal$1
  },
  // Timezone: -01:00, +00:00, ... +12:00
  'Z': {
    unit: 'timezone',
    match: patterns$1.Z,
    parse: function (matchResult) {
      var sign = matchResult[1];
      var hours = parseInt(matchResult[2], 10);
      var minutes = parseInt(matchResult[3], 10);
      var absoluteOffset = hours * 60 + minutes;
      return sign === '+' ? absoluteOffset : -absoluteOffset;
    }
  },
  // Timezone: -0100, +0000, ... +1200
  'ZZ': {
    unit: 'timezone',
    match: patterns$1.ZZ,
    parse: function (matchResult) {
      var sign = matchResult[1];
      var hours = parseInt(matchResult[2], 10);
      var minutes = parseInt(matchResult[3], 10);
      var absoluteOffset = hours * 60 + minutes;
      return sign === '+' ? absoluteOffset : -absoluteOffset;
    }
  },
  // Seconds timestamp: 512969520
  'X': {
    unit: 'timestamp',
    match: patterns$1.anyDigits,
    parse: function (matchResult) {
      return parseDecimal$1(matchResult) * 1000;
    }
  },
  // Milliseconds timestamp: 512969520900
  'x': {
    unit: 'timestamp',
    match: patterns$1.anyDigits,
    parse: parseDecimal$1
  }
};
parsers['a'] = parsers['A']; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn === undefined ? 0 : Number(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn === undefined ? defaultWeekStartsOn : Number(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate, dirtyOptions);
  var day = Number(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376


function setUTCISODay(dirtyDate, dirtyDay, dirtyOptions) {
  var day = Number(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate, dirtyOptions);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376


function setUTCISOWeek(dirtyDate, dirtyISOWeek, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var isoWeek = Number(dirtyISOWeek);
  var diff = getUTCISOWeek(date, dirtyOptions) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var MILLISECONDS_IN_DAY$3 = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISOWeekYear(dirtyDate, dirtyISOYear, dirtyOptions) {
  var date = toDate(dirtyDate, dirtyOptions);
  var isoYear = Number(dirtyISOYear);
  var dateStartOfYear = startOfUTCISOWeekYear(date, dirtyOptions);
  var diff = Math.floor((date.getTime() - dateStartOfYear.getTime()) / MILLISECONDS_IN_DAY$3);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(isoYear, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  date = startOfUTCISOWeekYear(fourthOfJanuary, dirtyOptions);
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

var MILLISECONDS_IN_MINUTE$6 = 60000;

function setTimeOfDay(hours, timeOfDay) {
  var isAM = timeOfDay === 0;

  if (isAM) {
    if (hours === 12) {
      return 0;
    }
  } else {
    if (hours !== 12) {
      return 12 + hours;
    }
  }

  return hours;
}

var units = {
  twoDigitYear: {
    priority: 10,
    set: function (dateValues, value) {
      var century = Math.floor(dateValues.date.getUTCFullYear() / 100);
      var year = century * 100 + value;
      dateValues.date.setUTCFullYear(year, 0, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  year: {
    priority: 10,
    set: function (dateValues, value) {
      dateValues.date.setUTCFullYear(value, 0, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  isoYear: {
    priority: 10,
    set: function (dateValues, value, options) {
      dateValues.date = startOfUTCISOWeekYear(setUTCISOWeekYear(dateValues.date, value, options), options);
      return dateValues;
    }
  },
  quarter: {
    priority: 20,
    set: function (dateValues, value) {
      dateValues.date.setUTCMonth((value - 1) * 3, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  month: {
    priority: 30,
    set: function (dateValues, value) {
      dateValues.date.setUTCMonth(value, 1);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  isoWeek: {
    priority: 40,
    set: function (dateValues, value, options) {
      dateValues.date = startOfUTCISOWeek(setUTCISOWeek(dateValues.date, value, options), options);
      return dateValues;
    }
  },
  dayOfWeek: {
    priority: 50,
    set: function (dateValues, value, options) {
      dateValues.date = setUTCDay(dateValues.date, value, options);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  dayOfISOWeek: {
    priority: 50,
    set: function (dateValues, value, options) {
      dateValues.date = setUTCISODay(dateValues.date, value, options);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  dayOfMonth: {
    priority: 50,
    set: function (dateValues, value) {
      dateValues.date.setUTCDate(value);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  dayOfYear: {
    priority: 50,
    set: function (dateValues, value) {
      dateValues.date.setUTCMonth(0, value);
      dateValues.date.setUTCHours(0, 0, 0, 0);
      return dateValues;
    }
  },
  timeOfDay: {
    priority: 60,
    set: function (dateValues, value, options) {
      dateValues.timeOfDay = value;
      return dateValues;
    }
  },
  hours: {
    priority: 70,
    set: function (dateValues, value, options) {
      dateValues.date.setUTCHours(value, 0, 0, 0);
      return dateValues;
    }
  },
  timeOfDayHours: {
    priority: 70,
    set: function (dateValues, value, options) {
      var timeOfDay = dateValues.timeOfDay;

      if (timeOfDay != null) {
        value = setTimeOfDay(value, timeOfDay);
      }

      dateValues.date.setUTCHours(value, 0, 0, 0);
      return dateValues;
    }
  },
  minutes: {
    priority: 80,
    set: function (dateValues, value) {
      dateValues.date.setUTCMinutes(value, 0, 0);
      return dateValues;
    }
  },
  seconds: {
    priority: 90,
    set: function (dateValues, value) {
      dateValues.date.setUTCSeconds(value, 0);
      return dateValues;
    }
  },
  milliseconds: {
    priority: 100,
    set: function (dateValues, value) {
      dateValues.date.setUTCMilliseconds(value);
      return dateValues;
    }
  },
  timezone: {
    priority: 110,
    set: function (dateValues, value) {
      dateValues.date = new Date(dateValues.date.getTime() - value * MILLISECONDS_IN_MINUTE$6);
      return dateValues;
    }
  },
  timestamp: {
    priority: 120,
    set: function (dateValues, value) {
      dateValues.date = new Date(value);
      return dateValues;
    }
  }
};
var TIMEZONE_UNIT_PRIORITY = 110;
var MILLISECONDS_IN_MINUTE$7 = 60000;
var longFormattingTokensRegExp$1 = /(\[[^[]*])|(\\)?(LTS|LT|LLLL|LLL|LL|L|llll|lll|ll|l)/g;
var defaultParsingTokensRegExp = /(\[[^[]*])|(\\)?(x|ss|s|mm|m|hh|h|do|dddd|ddd|dd|d|aa|a|ZZ|Z|YYYY|YY|X|Wo|WW|W|SSS|SS|S|Qo|Q|Mo|MMMM|MMM|MM|M|HH|H|GGGG|GG|E|Do|DDDo|DDDD|DDD|DD|D|A|.)/g;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format.
 *
 * Accepted format tokens:
 * | Unit                    | Priority | Token | Input examples                   |
 * |-------------------------|----------|-------|----------------------------------|
 * | Year                    | 10       | YY    | 00, 01, ..., 99                  |
 * |                         |          | YYYY  | 1900, 1901, ..., 2099            |
 * | ISO week-numbering year | 10       | GG    | 00, 01, ..., 99                  |
 * |                         |          | GGGG  | 1900, 1901, ..., 2099            |
 * | Quarter                 | 20       | Q     | 1, 2, 3, 4                       |
 * |                         |          | Qo    | 1st, 2nd, 3rd, 4th               |
 * | Month                   | 30       | M     | 1, 2, ..., 12                    |
 * |                         |          | Mo    | 1st, 2nd, ..., 12th              |
 * |                         |          | MM    | 01, 02, ..., 12                  |
 * |                         |          | MMM   | Jan, Feb, ..., Dec               |
 * |                         |          | MMMM  | January, February, ..., December |
 * | ISO week                | 40       | W     | 1, 2, ..., 53                    |
 * |                         |          | Wo    | 1st, 2nd, ..., 53rd              |
 * |                         |          | WW    | 01, 02, ..., 53                  |
 * | Day of week             | 50       | d     | 0, 1, ..., 6                     |
 * |                         |          | do    | 0th, 1st, ..., 6th               |
 * |                         |          | dd    | Su, Mo, ..., Sa                  |
 * |                         |          | ddd   | Sun, Mon, ..., Sat               |
 * |                         |          | dddd  | Sunday, Monday, ..., Saturday    |
 * | Day of ISO week         | 50       | E     | 1, 2, ..., 7                     |
 * | Day of month            | 50       | D     | 1, 2, ..., 31                    |
 * |                         |          | Do    | 1st, 2nd, ..., 31st              |
 * |                         |          | DD    | 01, 02, ..., 31                  |
 * | Day of year             | 50       | DDD   | 1, 2, ..., 366                   |
 * |                         |          | DDDo  | 1st, 2nd, ..., 366th             |
 * |                         |          | DDDD  | 001, 002, ..., 366               |
 * | Time of day             | 60       | A     | AM, PM                           |
 * |                         |          | a     | am, pm                           |
 * |                         |          | aa    | a.m., p.m.                       |
 * | Hour                    | 70       | H     | 0, 1, ... 23                     |
 * |                         |          | HH    | 00, 01, ... 23                   |
 * | Time of day hour        | 70       | h     | 1, 2, ..., 12                    |
 * |                         |          | hh    | 01, 02, ..., 12                  |
 * | Minute                  | 80       | m     | 0, 1, ..., 59                    |
 * |                         |          | mm    | 00, 01, ..., 59                  |
 * | Second                  | 90       | s     | 0, 1, ..., 59                    |
 * |                         |          | ss    | 00, 01, ..., 59                  |
 * | 1/10 of second          | 100      | S     | 0, 1, ..., 9                     |
 * | 1/100 of second         | 100      | SS    | 00, 01, ..., 99                  |
 * | Millisecond             | 100      | SSS   | 000, 001, ..., 999               |
 * | Timezone                | 110      | Z     | -01:00, +00:00, ... +12:00       |
 * |                         |          | ZZ    | -0100, +0000, ..., +1200         |
 * | Seconds timestamp       | 120      | X     | 512969520                        |
 * | Milliseconds timestamp  | 120      | x     | 512969520900                     |
 *
 * Values will be assigned to the date in the ascending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `baseDate` which works as a context of parsing.
 *
 * `baseDate` must be passed for correct work of the function.
 * If you're not sure which `baseDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/DD/YYYY', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `baseDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * Also, `parse` unfolds long formats like those in [format]{@link https://date-fns.org/docs/format}:
 * | Token | Input examples                 |
 * |-------|--------------------------------|
 * | LT    | 05:30 a.m.                     |
 * | LTS   | 05:30:15 a.m.                  |
 * | L     | 07/02/1995                     |
 * | l     | 7/2/1995                       |
 * | LL    | July 2 1995                    |
 * | ll    | Jul 2 1995                     |
 * | LLL   | July 2 1995 05:30 a.m.         |
 * | lll   | Jul 2 1995 05:30 a.m.          |
 * | LLLL  | Sunday, July 2 1995 05:30 a.m. |
 * | llll  | Sun, Jul 2 1995 05:30 a.m.     |
 *
 * The characters wrapped in square brackets in the format string are escaped.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `baseDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|String|Number} baseDate - the date to took the missing higher priority values from
 * @param {Options} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
 * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse(
 *   '02/11/2014',
 *   'MM/DD/YYYY',
 *   new Date()
 * )
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in English locale in the context of 2010 year:
 * import eoLocale from 'date-fns/locale/eo'
 * var result = parse(
 *   '28-a de februaro',
 *   'Do [de] MMMM',
 *   new Date(2010, 0, 1)
 *   {locale: eoLocale}
 * )
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyBaseDate, dirtyOptions) {
  if (arguments.length < 3) {
    throw new TypeError('3 arguments required, but only ' + arguments.length + ' present');
  }

  var dateString = String(dirtyDateString);
  var options = dirtyOptions || {};
  var weekStartsOn = options.weekStartsOn === undefined ? 0 : Number(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var locale = options.locale || locale$1;
  var localeParsers = locale.parsers || {};
  var localeUnits = locale.units || {};

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var formatString = String(dirtyFormatString).replace(longFormattingTokensRegExp$1, function (substring) {
    if (substring[0] === '[') {
      return substring;
    }

    if (substring[0] === '\\') {
      return cleanEscapedString$1(substring);
    }

    return locale.formatLong(substring);
  });

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyBaseDate, options);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = cloneObject(options);
  subFnOptions.locale = locale;
  var tokens = formatString.match(locale.parsingTokensRegExp || defaultParsingTokensRegExp);
  var tokensLength = tokens.length; // If timezone isn't specified, it will be set to the system timezone

  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;

  for (i = 0; i < tokensLength; i++) {
    var token = tokens[i];
    var parser = localeParsers[token] || parsers[token];

    if (parser) {
      var matchResult;

      if (parser.match instanceof RegExp) {
        matchResult = parser.match.exec(dateString);
      } else {
        matchResult = parser.match(dateString, subFnOptions);
      }

      if (!matchResult) {
        return new Date(NaN);
      }

      var unitName = parser.unit;
      var unit = localeUnits[unitName] || units[unitName];
      setters.push({
        priority: unit.priority,
        set: unit.set,
        value: parser.parse(matchResult, subFnOptions),
        index: setters.length
      });
      var substring = matchResult[0];
      dateString = dateString.slice(substring.length);
    } else {
      var head = tokens[i].match(/^\[.*]$/) ? tokens[i].replace(/^\[|]$/g, '') : tokens[i];

      if (dateString.indexOf(head) === 0) {
        dateString = dateString.slice(head.length);
      } else {
        return new Date(NaN);
      }
    }
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return a - b;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).reverse();
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyBaseDate, options);

  if (isNaN(date)) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


  var utcDate = subMinutes(date, date.getTimezoneOffset());
  var dateValues = {
    date: utcDate
  };
  var settersLength = uniquePrioritySetters.length;

  for (i = 0; i < settersLength; i++) {
    var setter = uniquePrioritySetters[i];
    dateValues = setter.set(dateValues, setter.value, subFnOptions);
  }

  return dateValues.date;
}

function dateToSystemTimezone(dateValues) {
  var date = dateValues.date;
  var time = date.getTime(); // Get the system timezone offset at (moment of time - offset)

  var offset = date.getTimezoneOffset(); // Get the system timezone offset at the exact moment of time

  offset = new Date(time + offset * MILLISECONDS_IN_MINUTE$7).getTimezoneOffset(); // Convert date in timezone "UTC+00:00" to the system timezone

  dateValues.date = new Date(time + offset * MILLISECONDS_IN_MINUTE$7);
  return dateValues;
}

function cleanEscapedString$1(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|]$/g, '');
  }

  return input.replace(/\\/g, '');
} // This file is generated automatically by `scripts/build/indices.js`. Please, don't change it.
// 

/**
 * Custom parse behavior on top of date-fns parse function.
 */


function parseDate$1(date, format$$1) {
  if (typeof date !== 'string') {
    return isValid(date) ? date : null;
  }

  var parsed = parse(date, format$$1, new Date()); // if date is not valid or the formatted output after parsing does not match
  // the string value passed in (avoids overflows)

  if (!isValid(parsed) || format(parsed, format$$1) !== date) {
    return null;
  }

  return parsed;
}

var afterValidator = function (value, ref) {
  if (ref === void 0) ref = {};
  var targetValue = ref.targetValue;
  var inclusion = ref.inclusion;
  if (inclusion === void 0) inclusion = false;
  var format$$1 = ref.format;

  if (typeof format$$1 === 'undefined') {
    format$$1 = inclusion;
    inclusion = false;
  }

  value = parseDate$1(value, format$$1);
  targetValue = parseDate$1(targetValue, format$$1); // if either is not valid.

  if (!value || !targetValue) {
    return false;
  }

  return isAfter(value, targetValue) || inclusion && isEqual$1(value, targetValue);
};

var options = {
  hasTarget: true,
  isDate: true
}; // required to convert from a list of array values to an object.

var paramNames = ['targetValue', 'inclusion', 'format'];
var after = {
  validate: afterValidator,
  options: options,
  paramNames: paramNames
};
/**
 * Some Alpha Regex helpers.
 * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js
 */

var alpha = {
  en: /^[A-Z]*$/i,
  cs: /^[A-Z]*$/i,
  da: /^[A-Z]*$/i,
  de: /^[A-Z]*$/i,
  es: /^[A-Z]*$/i,
  fr: /^[A-Z]*$/i,
  lt: /^[A-Z]*$/i,
  nl: /^[A-Z]*$/i,
  hu: /^[A-Z]*$/i,
  pl: /^[A-Z]*$/i,
  pt: /^[A-Z]*$/i,
  ru: /^[-]*$/i,
  sk: /^[A-Z]*$/i,
  sr: /^[A-Z]*$/i,
  tr: /^[A-Z]*$/i,
  uk: /^[-]*$/i,
  ar: /^[]*$/
};
var alphaSpaces = {
  en: /^[A-Z\s]*$/i,
  cs: /^[A-Z\s]*$/i,
  da: /^[A-Z\s]*$/i,
  de: /^[A-Z\s]*$/i,
  es: /^[A-Z\s]*$/i,
  fr: /^[A-Z\s]*$/i,
  lt: /^[A-Z\s]*$/i,
  nl: /^[A-Z\s]*$/i,
  hu: /^[A-Z\s]*$/i,
  pl: /^[A-Z\s]*$/i,
  pt: /^[A-Z\s]*$/i,
  ru: /^[-\s]*$/i,
  sk: /^[A-Z\s]*$/i,
  sr: /^[A-Z\s]*$/i,
  tr: /^[A-Z\s]*$/i,
  uk: /^[-\s]*$/i,
  ar: /^[\s]*$/
};
var alphanumeric = {
  en: /^[0-9A-Z]*$/i,
  cs: /^[0-9A-Z]*$/i,
  da: /^[0-9A-Z]$/i,
  de: /^[0-9A-Z]*$/i,
  es: /^[0-9A-Z]*$/i,
  fr: /^[0-9A-Z]*$/i,
  lt: /^[0-9A-Z]*$/i,
  hu: /^[0-9A-Z]*$/i,
  nl: /^[0-9A-Z]*$/i,
  pl: /^[0-9A-Z]*$/i,
  pt: /^[0-9A-Z]*$/i,
  ru: /^[0-9-]*$/i,
  sk: /^[0-9A-Z]*$/i,
  sr: /^[0-9A-Z]*$/i,
  tr: /^[0-9A-Z]*$/i,
  uk: /^[0-9-]*$/i,
  ar: /^[0-9]*$/
};
var alphaDash = {
  en: /^[0-9A-Z_-]*$/i,
  cs: /^[0-9A-Z_-]*$/i,
  da: /^[0-9A-Z_-]*$/i,
  de: /^[0-9A-Z_-]*$/i,
  es: /^[0-9A-Z_-]*$/i,
  fr: /^[0-9A-Z_-]*$/i,
  lt: /^[0-9A-Z_-]*$/i,
  nl: /^[0-9A-Z_-]*$/i,
  hu: /^[0-9A-Z_-]*$/i,
  pl: /^[0-9A-Z_-]*$/i,
  pt: /^[0-9A-Z_-]*$/i,
  ru: /^[0-9-_-]*$/i,
  sk: /^[0-9A-Z_-]*$/i,
  sr: /^[0-9A-Z_-]*$/i,
  tr: /^[0-9A-Z_-]*$/i,
  uk: /^[0-9-_-]*$/i,
  ar: /^[0-9_-]*$/
};

var validate = function (value, ref) {
  if (ref === void 0) ref = {};
  var locale = ref.locale;

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate(val, [locale]);
    });
  } // Match at least one locale.


  if (!locale) {
    return Object.keys(alpha).some(function (loc) {
      return alpha[loc].test(value);
    });
  }

  return (alpha[locale] || alpha.en).test(value);
};

var paramNames$1 = ['locale'];
var alpha$1 = {
  validate: validate,
  paramNames: paramNames$1
};

var validate$1 = function (value, ref) {
  if (ref === void 0) ref = {};
  var locale = ref.locale;

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$1(val, [locale]);
    });
  } // Match at least one locale.


  if (!locale) {
    return Object.keys(alphaDash).some(function (loc) {
      return alphaDash[loc].test(value);
    });
  }

  return (alphaDash[locale] || alphaDash.en).test(value);
};

var paramNames$2 = ['locale'];
var alpha_dash = {
  validate: validate$1,
  paramNames: paramNames$2
};

var validate$2 = function (value, ref) {
  if (ref === void 0) ref = {};
  var locale = ref.locale;

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$2(val, [locale]);
    });
  } // Match at least one locale.


  if (!locale) {
    return Object.keys(alphanumeric).some(function (loc) {
      return alphanumeric[loc].test(value);
    });
  }

  return (alphanumeric[locale] || alphanumeric.en).test(value);
};

var paramNames$3 = ['locale'];
var alpha_num = {
  validate: validate$2,
  paramNames: paramNames$3
};

var validate$3 = function (value, ref) {
  if (ref === void 0) ref = {};
  var locale = ref.locale;

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$3(val, [locale]);
    });
  } // Match at least one locale.


  if (!locale) {
    return Object.keys(alphaSpaces).some(function (loc) {
      return alphaSpaces[loc].test(value);
    });
  }

  return (alphaSpaces[locale] || alphaSpaces.en).test(value);
};

var paramNames$4 = ['locale'];
var alpha_spaces = {
  validate: validate$3,
  paramNames: paramNames$4
};

var validate$4 = function (value, ref) {
  if (ref === void 0) ref = {};
  var targetValue = ref.targetValue;
  var inclusion = ref.inclusion;
  if (inclusion === void 0) inclusion = false;
  var format$$1 = ref.format;

  if (typeof format$$1 === 'undefined') {
    format$$1 = inclusion;
    inclusion = false;
  }

  value = parseDate$1(value, format$$1);
  targetValue = parseDate$1(targetValue, format$$1); // if either is not valid.

  if (!value || !targetValue) {
    return false;
  }

  return isBefore(value, targetValue) || inclusion && isEqual$1(value, targetValue);
};

var options$1 = {
  hasTarget: true,
  isDate: true
};
var paramNames$5 = ['targetValue', 'inclusion', 'format'];
var before = {
  validate: validate$4,
  options: options$1,
  paramNames: paramNames$5
};

var validate$5 = function (value, ref) {
  if (ref === void 0) ref = {};
  var min = ref.min;
  var max = ref.max;

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$5(val, {
        min: min,
        max: max
      });
    });
  }

  return Number(min) <= value && Number(max) >= value;
};

var paramNames$6 = ['min', 'max'];
var between = {
  validate: validate$5,
  paramNames: paramNames$6
};

var validate$6 = function (value, ref) {
  var targetValue = ref.targetValue;
  return String(value) === String(targetValue);
};

var options$2 = {
  hasTarget: true
};
var paramNames$7 = ['targetValue'];
var confirmed = {
  validate: validate$6,
  options: options$2,
  paramNames: paramNames$7
};

function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var assertString_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString;

  function assertString(input) {
    var isString = typeof input === 'string' || input instanceof String;

    if (!isString) {
      throw new TypeError('This library (validator.js) validates strings only');
    }
  }

  module.exports = exports['default'];
});
unwrapExports(assertString_1);
var isCreditCard_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard;

  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /* eslint-disable max-len */


  var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
  /* eslint-enable max-len */

  function isCreditCard(str) {
    (0, _assertString2.default)(str);
    var sanitized = str.replace(/[- ]+/g, '');

    if (!creditCard.test(sanitized)) {
      return false;
    }

    var sum = 0;
    var digit = void 0;
    var tmpNum = void 0;
    var shouldDouble = void 0;

    for (var i = sanitized.length - 1; i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);

      if (shouldDouble) {
        tmpNum *= 2;

        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }

      shouldDouble = !shouldDouble;
    }

    return !!(sum % 10 === 0 ? sanitized : false);
  }

  module.exports = exports['default'];
});
var isCreditCard = unwrapExports(isCreditCard_1);

var validate$7 = function (value) {
  return isCreditCard(String(value));
};

var credit_card = {
  validate: validate$7
};

var validate$8 = function (value, ref) {
  if (ref === void 0) ref = {};
  var min$$1 = ref.min;
  var max$$1 = ref.max;
  var inclusivity = ref.inclusivity;
  if (inclusivity === void 0) inclusivity = '()';
  var format$$1 = ref.format;

  if (typeof format$$1 === 'undefined') {
    format$$1 = inclusivity;
    inclusivity = '()';
  }

  var minDate = parseDate$1(String(min$$1), format$$1);
  var maxDate = parseDate$1(String(max$$1), format$$1);
  var dateVal = parseDate$1(String(value), format$$1);

  if (!minDate || !maxDate || !dateVal) {
    return false;
  }

  if (inclusivity === '()') {
    return isAfter(dateVal, minDate) && isBefore(dateVal, maxDate);
  }

  if (inclusivity === '(]') {
    return isAfter(dateVal, minDate) && (isEqual$1(dateVal, maxDate) || isBefore(dateVal, maxDate));
  }

  if (inclusivity === '[)') {
    return isBefore(dateVal, maxDate) && (isEqual$1(dateVal, minDate) || isAfter(dateVal, minDate));
  }

  return isEqual$1(dateVal, maxDate) || isEqual$1(dateVal, minDate) || isBefore(dateVal, maxDate) && isAfter(dateVal, minDate);
};

var options$3 = {
  isDate: true
};
var paramNames$8 = ['min', 'max', 'inclusivity', 'format'];
var date_between = {
  validate: validate$8,
  options: options$3,
  paramNames: paramNames$8
};

var validate$9 = function (value, ref) {
  var format = ref.format;
  return !!parseDate$1(value, format);
};

var options$4 = {
  isDate: true
};
var paramNames$9 = ['format'];
var date_format = {
  validate: validate$9,
  options: options$4,
  paramNames: paramNames$9
};

var validate$a = function (value, ref) {
  if (ref === void 0) ref = {};
  var decimals = ref.decimals;
  if (decimals === void 0) decimals = '*';
  var separator = ref.separator;
  if (separator === void 0) separator = '.';

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$a(val, {
        decimals: decimals,
        separator: separator
      });
    });
  }

  if (value === null || value === undefined || value === '') {
    return false;
  } // if is 0.


  if (Number(decimals) === 0) {
    return /^-?\d*$/.test(value);
  }

  var regexPart = decimals === '*' ? '+' : "{1," + decimals + "}";
  var regex = new RegExp("^[-+]?\\d*(\\" + separator + "\\d" + regexPart + ")?$");

  if (!regex.test(value)) {
    return false;
  }

  var parsedValue = parseFloat(value); // eslint-disable-next-line

  return parsedValue === parsedValue;
};

var paramNames$a = ['decimals', 'separator'];
var decimal = {
  validate: validate$a,
  paramNames: paramNames$a
};

var validate$b = function (value, ref) {
  var length = ref[0];

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$b(val, [length]);
    });
  }

  var strVal = String(value);
  return /^[0-9]*$/.test(strVal) && strVal.length === Number(length);
};

var digits = {
  validate: validate$b
};

var validateImage = function (file, width, height) {
  var URL = window.URL || window.webkitURL;
  return new Promise(function (resolve) {
    var image = new Image();

    image.onerror = function () {
      return resolve({
        valid: false
      });
    };

    image.onload = function () {
      return resolve({
        valid: image.width === Number(width) && image.height === Number(height)
      });
    };

    image.src = URL.createObjectURL(file);
  });
};

var validate$c = function (files, ref) {
  var width = ref[0];
  var height = ref[1];
  var list = [];

  for (var i = 0; i < files.length; i++) {
    // if file is not an image, reject.
    if (!/\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {
      return false;
    }

    list.push(files[i]);
  }

  return Promise.all(list.map(function (file) {
    return validateImage(file, width, height);
  }));
};

var dimensions = {
  validate: validate$c
};
var merge_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge;

  function merge() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments[1];

    for (var key in defaults) {
      if (typeof obj[key] === 'undefined') {
        obj[key] = defaults[key];
      }
    }

    return obj;
  }

  module.exports = exports['default'];
});
unwrapExports(merge_1);
var isByteLength_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  exports.default = isByteLength;

  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  /* eslint-disable prefer-rest-params */


  function isByteLength(str, options) {
    (0, _assertString2.default)(str);
    var min = void 0;
    var max = void 0;

    if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
      min = options.min || 0;
      max = options.max;
    } else {
      // backwards compatibility: isByteLength(str, min [, max])
      min = arguments[1];
      max = arguments[2];
    }

    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === 'undefined' || len <= max);
  }

  module.exports = exports['default'];
});
unwrapExports(isByteLength_1);
var isFQDN_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN;

  var _assertString2 = _interopRequireDefault(assertString_1);

  var _merge2 = _interopRequireDefault(merge_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false
  };

  function isFQDN(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge2.default)(options, default_fqdn_options);
    /* Remove the optional trailing dot before checking validity */

    if (options.allow_trailing_dot && str[str.length - 1] === '.') {
      str = str.substring(0, str.length - 1);
    }

    var parts = str.split('.');

    for (var i = 0; i < parts.length; i++) {
      if (parts[i].length > 63) {
        return false;
      }
    }

    if (options.require_tld) {
      var tld = parts.pop();

      if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      } // disallow spaces


      if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
        return false;
      }
    }

    for (var part, _i = 0; _i < parts.length; _i++) {
      part = parts[_i];

      if (options.allow_underscores) {
        part = part.replace(/_/g, '');
      }

      if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      } // disallow full-width chars


      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }

      if (part[0] === '-' || part[part.length - 1] === '-') {
        return false;
      }
    }

    return true;
  }

  module.exports = exports['default'];
});
unwrapExports(isFQDN_1);
var isIP_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP;

  var _assertString2 = _interopRequireDefault(assertString_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
  var ipv6Block = /^[0-9A-F]{1,4}$/i;

  function isIP(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    (0, _assertString2.default)(str);
    version = String(version);

    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    } else if (version === '4') {
      if (!ipv4Maybe.test(str)) {
        return false;
      }

      var parts = str.split('.').sort(function (a, b) {
        return a - b;
      });
      return parts[3] <= 255;
    } else if (version === '6') {
      var blocks = str.split(':');
      var foundOmissionBlock = false; // marker to indicate ::
      // At least some OS accept the last 32 bits of an IPv6 address
      // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
      // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
      // and '::a.b.c.d' is deprecated, but also valid.

      var foundIPv4TransitionBlock = isIP(blocks[blocks.length - 1], 4);
      var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

      if (blocks.length > expectedNumberOfBlocks) {
        return false;
      } // initial or final ::


      if (str === '::') {
        return true;
      } else if (str.substr(0, 2) === '::') {
        blocks.shift();
        blocks.shift();
        foundOmissionBlock = true;
      } else if (str.substr(str.length - 2) === '::') {
        blocks.pop();
        blocks.pop();
        foundOmissionBlock = true;
      }

      for (var i = 0; i < blocks.length; ++i) {
        // test for a :: which can not be at the string start/end
        // since those cases have been handled above
        if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {
          if (foundOmissionBlock) {
            return false; // multiple :: in address
          }

          foundOmissionBlock = true;
        } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ;else if (!ipv6Block.test(blocks[i])) {
          return false;
        }
      }

      if (foundOmissionBlock) {
        return blocks.length >= 1;
      }

      return blocks.length === expectedNumberOfBlocks;
    }

    return false;
  }

  module.exports = exports['default'];
});
var isIP = unwrapExports(isIP_1);
var isEmail_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail;

  var _assertString2 = _interopRequireDefault(assertString_1);

  var _merge2 = _interopRequireDefault(merge_1);

  var _isByteLength2 = _interopRequireDefault(isByteLength_1);

  var _isFQDN2 = _interopRequireDefault(isFQDN_1);

  var _isIP2 = _interopRequireDefault(isIP_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var default_email_options = {
    allow_display_name: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true
  };
  /* eslint-disable max-len */

  /* eslint-disable no-control-regex */

  var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  /* eslint-enable max-len */

  /* eslint-enable no-control-regex */

  function isEmail(str, options) {
    (0, _assertString2.default)(str);
    options = (0, _merge2.default)(options, default_email_options);

    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(displayName);

      if (display_email) {
        str = display_email[1];
      } else if (options.require_display_name) {
        return false;
      }
    }

    var parts = str.split('@');
    var domain = parts.pop();
    var user = parts.join('@');
    var lower_domain = domain.toLowerCase();

    if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
      /*
        Previously we removed dots for gmail addresses before validating.
        This was removed because it allows `multiple..dots@gmail.com`
        to be reported as valid, but it is not.
        Gmail only normalizes single dots, removing them from here is pointless,
        should be done in normalizeEmail
      */
      user = user.toLowerCase(); // Removing sub-address from username before gmail validation

      var username = user.split('+')[0]; // Dots are not included in gmail length restriction

      if (!(0, _isByteLength2.default)(username.replace('.', ''), {
        min: 6,
        max: 30
      })) {
        return false;
      }

      var _user_parts = username.split('.');

      for (var i = 0; i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }

    if (!(0, _isByteLength2.default)(user, {
      max: 64
    }) || !(0, _isByteLength2.default)(domain, {
      max: 254
    })) {
      return false;
    }

    if (!(0, _isFQDN2.default)(domain, {
      require_tld: options.require_tld
    })) {
      if (!options.allow_ip_domain) {
        return false;
      }

      if (!(0, _isIP2.default)(domain)) {
        if (!domain.startsWith('[') || !domain.endsWith(']')) {
          return false;
        }

        var noBracketdomain = domain.substr(1, domain.length - 2);

        if (noBracketdomain.length === 0 || !(0, _isIP2.default)(noBracketdomain)) {
          return false;
        }
      }
    }

    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }

    var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split('.');

    for (var _i = 0; _i < user_parts.length; _i++) {
      if (!pattern.test(user_parts[_i])) {
        return false;
      }
    }

    return true;
  }

  module.exports = exports['default'];
});
var isEmail = unwrapExports(isEmail_1);

var validate$d = function (value, options) {
  if (options === void 0) options = {};

  if (options.multiple) {
    value = value.split(',').map(function (emailStr) {
      return emailStr.trim();
    });
  }

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return isEmail(String(val), options);
    });
  }

  return isEmail(String(value), options);
};

var email = {
  validate: validate$d
};

var validate$e = function (value, options) {
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$e(val, options);
    });
  }

  return toArray(options).some(function (item) {
    // eslint-disable-next-line
    return item == value;
  });
};

var included = {
  validate: validate$e
};

var validate$f = function () {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return !validate$e.apply(void 0, args);
};

var excluded = {
  validate: validate$f
};

var validate$g = function (files, extensions) {
  var regex = new RegExp(".(" + extensions.join('|') + ")$", 'i');
  return files.every(function (file) {
    return regex.test(file.name);
  });
};

var ext = {
  validate: validate$g
};

var validate$h = function (files) {
  return files.every(function (file) {
    return /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name);
  });
};

var image = {
  validate: validate$h
};

var validate$i = function (value) {
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return /^-?[0-9]+$/.test(String(val));
    });
  }

  return /^-?[0-9]+$/.test(String(value));
};

var integer = {
  validate: validate$i
};

var validate$j = function (value, ref) {
  if (ref === void 0) ref = {};
  var version = ref.version;
  if (version === void 0) version = 4;

  if (isNullOrUndefined(value)) {
    value = '';
  }

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return isIP(val, version);
    });
  }

  return isIP(value, version);
};

var paramNames$b = ['version'];
var ip = {
  validate: validate$j,
  paramNames: paramNames$b
};

var validate$k = function (value, ref) {
  if (ref === void 0) ref = [];
  var other = ref[0];
  return value === other;
};

var is = {
  validate: validate$k
};

var validate$l = function (value, ref) {
  if (ref === void 0) ref = [];
  var other = ref[0];
  return value !== other;
};

var is_not = {
  validate: validate$l
};
/**
 * @param {Array|String} value
 * @param {Number} length
 * @param {Number} max
 */

var compare = function (value, length, max) {
  if (max === undefined) {
    return value.length === length;
  } // cast to number.


  max = Number(max);
  return value.length >= length && value.length <= max;
};

var validate$m = function (value, ref) {
  var length = ref[0];
  var max = ref[1];
  if (max === void 0) max = undefined;
  length = Number(length);

  if (value === undefined || value === null) {
    return false;
  }

  if (typeof value === 'number') {
    value = String(value);
  }

  if (!value.length) {
    value = toArray(value);
  }

  return compare(value, length, max);
};

var length = {
  validate: validate$m
};

var validate$n = function (value, ref) {
  var length = ref[0];

  if (value === undefined || value === null) {
    return length >= 0;
  }

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$n(val, [length]);
    });
  }

  return String(value).length <= length;
};

var max$1 = {
  validate: validate$n
};

var validate$o = function (value, ref) {
  var max = ref[0];

  if (value === null || value === undefined || value === '') {
    return false;
  }

  if (Array.isArray(value)) {
    return value.length > 0 && value.every(function (val) {
      return validate$o(val, [max]);
    });
  }

  return Number(value) <= max;
};

var max_value = {
  validate: validate$o
};

var validate$p = function (files, mimes) {
  var regex = new RegExp(mimes.join('|').replace('*', '.+') + "$", 'i');
  return files.every(function (file) {
    return regex.test(file.type);
  });
};

var mimes = {
  validate: validate$p
};

var validate$q = function (value, ref) {
  var length = ref[0];

  if (value === undefined || value === null) {
    return false;
  }

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$q(val, [length]);
    });
  }

  return String(value).length >= length;
};

var min$1 = {
  validate: validate$q
};

var validate$r = function (value, ref) {
  var min = ref[0];

  if (value === null || value === undefined || value === '') {
    return false;
  }

  if (Array.isArray(value)) {
    return value.length > 0 && value.every(function (val) {
      return validate$r(val, [min]);
    });
  }

  return Number(value) >= min;
};

var min_value = {
  validate: validate$r
};

var validate$s = function (value) {
  if (Array.isArray(value)) {
    return value.every(function (val) {
      return /^[0-9]+$/.test(String(val));
    });
  }

  return /^[0-9]+$/.test(String(value));
};

var numeric = {
  validate: validate$s
};

var validate$t = function (value, ref) {
  var expression = ref.expression;

  if (typeof expression === 'string') {
    expression = new RegExp(expression);
  }

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return validate$t(val, {
        expression: expression
      });
    });
  }

  return expression.test(String(value));
};

var paramNames$c = ['expression'];
var regex = {
  validate: validate$t,
  paramNames: paramNames$c
};

var validate$u = function (value, ref) {
  if (ref === void 0) ref = [];
  var invalidateFalse = ref[0];
  if (invalidateFalse === void 0) invalidateFalse = false;

  if (isEmptyArray(value)) {
    return false;
  } // incase a field considers `false` as an empty value like checkboxes.


  if (value === false && invalidateFalse) {
    return false;
  }

  if (value === undefined || value === null) {
    return false;
  }

  return !!String(value).trim().length;
};

var required = {
  validate: validate$u
};

var validate$v = function (files, ref) {
  var size = ref[0];

  if (isNaN(size)) {
    return false;
  }

  var nSize = Number(size) * 1024;

  for (var i = 0; i < files.length; i++) {
    if (files[i].size > nSize) {
      return false;
    }
  }

  return true;
};

var size = {
  validate: validate$v
};
var isURL_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL;

  var _assertString2 = _interopRequireDefault(assertString_1);

  var _isFQDN2 = _interopRequireDefault(isFQDN_1);

  var _isIP2 = _interopRequireDefault(isIP_1);

  var _merge2 = _interopRequireDefault(merge_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var default_url_options = {
    protocols: ['http', 'https', 'ftp'],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  }

  function checkHost(host, matches) {
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i];

      if (host === match || isRegExp(match) && match.test(host)) {
        return true;
      }
    }

    return false;
  }

  function isURL(url, options) {
    (0, _assertString2.default)(url);

    if (!url || url.length >= 2083 || /[\s<>]/.test(url)) {
      return false;
    }

    if (url.indexOf('mailto:') === 0) {
      return false;
    }

    options = (0, _merge2.default)(options, default_url_options);
    var protocol = void 0,
        auth = void 0,
        host = void 0,
        hostname = void 0,
        port = void 0,
        port_str = void 0,
        split = void 0,
        ipv6 = void 0;
    split = url.split('#');
    url = split.shift();
    split = url.split('?');
    url = split.shift();
    split = url.split('://');

    if (split.length > 1) {
      protocol = split.shift().toLowerCase();

      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.substr(0, 2) === '//') {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }

      split[0] = url.substr(2);
    }

    url = split.join('://');

    if (url === '') {
      return false;
    }

    split = url.split('/');
    url = split.shift();

    if (url === '' && !options.require_host) {
      return true;
    }

    split = url.split('@');

    if (split.length > 1) {
      auth = split.shift();

      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
        return false;
      }
    }

    hostname = split.join('@');
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);

    if (ipv6_match) {
      host = '';
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(':');
      host = split.shift();

      if (split.length) {
        port_str = split.join(':');
      }
    }

    if (port_str !== null) {
      port = parseInt(port_str, 10);

      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    }

    if (!(0, _isIP2.default)(host) && !(0, _isFQDN2.default)(host, options) && (!ipv6 || !(0, _isIP2.default)(ipv6, 6))) {
      return false;
    }

    host = host || ipv6;

    if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
      return false;
    }

    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }

    return true;
  }

  module.exports = exports['default'];
});
var isURL = unwrapExports(isURL_1);

var validate$w = function (value, options) {
  if (options === void 0) options = {};

  if (isNullOrUndefined(value)) {
    value = '';
  }

  if (Array.isArray(value)) {
    return value.every(function (val) {
      return isURL(val, options);
    });
  }

  return isURL(value, options);
};

var url = {
  validate: validate$w
};
/* eslint-disable camelcase */

var Rules =
/*#__PURE__*/
Object.freeze({
  after: after,
  alpha_dash: alpha_dash,
  alpha_num: alpha_num,
  alpha_spaces: alpha_spaces,
  alpha: alpha$1,
  before: before,
  between: between,
  confirmed: confirmed,
  credit_card: credit_card,
  date_between: date_between,
  date_format: date_format,
  decimal: decimal,
  digits: digits,
  dimensions: dimensions,
  email: email,
  ext: ext,
  image: image,
  included: included,
  integer: integer,
  length: length,
  ip: ip,
  is_not: is_not,
  is: is,
  max: max$1,
  max_value: max_value,
  mimes: mimes,
  min: min$1,
  min_value: min_value,
  excluded: excluded,
  numeric: numeric,
  regex: regex,
  required: required,
  size: size,
  url: url
});
exports.Rules = Rules;
var version = '2.1.0-beta.11';
exports.version = version;

var rulesPlugin = function (ref) {
  var Validator$$1 = ref.Validator;
  Object.keys(Rules).forEach(function (rule) {
    Validator$$1.extend(rule, Rules[rule].validate, assign({}, Rules[rule].options, {
      paramNames: Rules[rule].paramNames
    }));
  }); // Merge the english messages.

  Validator$$1.localize('en', locale);
};

var install = VeeValidate$1.install;
exports.install = install;
VeeValidate$1.use(rulesPlugin);
var _default = VeeValidate$1;
exports.default = _default;
},{}],"w0qg":[function(require,module,exports) {
var camel2hyphen = function (str) {
  return str
          .replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
          })
          .toLowerCase();
};

module.exports = camel2hyphen;
},{}],"28r3":[function(require,module,exports) {
var camel2hyphen = require('string-convert/camel2hyphen');

var isDimension = function (feature) {
  var re = /[height|width]$/;
  return re.test(feature);
};

var obj2mq = function (obj) {
  var mq = '';
  var features = Object.keys(obj);
  features.forEach(function (feature, index) {
    var value = obj[feature];
    feature = camel2hyphen(feature);
    // Add px to dimension features
    if (isDimension(feature) && typeof value === 'number') {
      value = value + 'px';
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += 'not ' + feature;
    } else {
      mq += '(' + feature + ': ' + value + ')';
    }
    if (index < features.length-1) {
      mq += ' and '
    }
  });
  return mq;
};

var json2mq = function (query) {
  var mq = '';
  if (typeof query === 'string') {
    return query;
  }
  // Handling array of media queries
  if (query instanceof Array) {
    query.forEach(function (q, index) {
      mq += obj2mq(q);
      if (index < query.length-1) {
        mq += ', '
      }
    });
    return mq;
  }
  // Handling single media query
  return obj2mq(query);
};

module.exports = json2mq;
},{"string-convert/camel2hyphen":"w0qg"}],"duKR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _json2mq = _interopRequireDefault(require("json2mq"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function convertBreakpointsToMediaQueries(breakpoints) {
  var keys = Object.keys(breakpoints);
  var values = keys.map(function (key) {
    return breakpoints[key];
  });
  var breakpointValues = [0].concat(_toConsumableArray(values.slice(0, -1)));
  var mediaQueries = breakpointValues.reduce(function (sum, value, index) {
    var options = Object.assign({
      minWidth: value
    }, index < keys.length - 1 ? {
      maxWidth: breakpointValues[index + 1] - 1
    } : {});
    var mediaQuery = (0, _json2mq.default)(options);
    return Object.assign(sum, _defineProperty({}, keys[index], mediaQuery));
  }, {});
  return mediaQueries;
}

function transformValuesFromBreakpoints(breakpoints, values, currentBreakpoint) {
  var findClosestValue = function findClosestValue(currentBreakpoint) {
    if (values[currentBreakpoint] !== undefined) return values[currentBreakpoint];
    var index = breakpoints.findIndex(function (b) {
      return b === currentBreakpoint;
    });
    var newBreakpoint = index !== -1 || index !== 0 ? breakpoints[index - 1] : null;
    if (!newBreakpoint) return values[index];
    return values[newBreakpoint] !== undefined ? values[newBreakpoint] : findClosestValue(newBreakpoint);
  };

  return findClosestValue(currentBreakpoint);
}

function selectBreakpoints(breakpoints, currentBreakpoint) {
  var index = breakpoints.findIndex(function (b) {
    return b === currentBreakpoint;
  });
  return breakpoints.slice(index);
}

function isArray(arg) {
  return Object.prototype.toString.call(arg) === '[object Array]';
} // USAGE
// mq-layout(mq="lg")
//   p Im lg


var component = {
  props: {
    mq: {
      required: true,
      type: [String, Array]
    }
  },
  computed: {
    plusModifier: function plusModifier() {
      return !isArray(this.mq) && this.mq.slice(-1) === '+';
    },
    activeBreakpoints: function activeBreakpoints() {
      var breakpoints = Object.keys(this.$mqAvailableBreakpoints);
      var mq = this.plusModifier ? this.mq.slice(0, -1) : isArray(this.mq) ? this.mq : [this.mq];
      return this.plusModifier ? selectBreakpoints(breakpoints, mq) : mq;
    }
  },
  render: function render(h, props) {
    var shouldRenderChildren = this.activeBreakpoints.includes(this.$mq);
    return shouldRenderChildren ? h('div', this.$slots.default) : h();
  }
};
var DEFAULT_BREAKPOINT = {
  sm: 450,
  md: 1250,
  lg: Infinity
};

var install = function install(Vue) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$breakpoints = _ref.breakpoints,
      breakpoints = _ref$breakpoints === void 0 ? DEFAULT_BREAKPOINT : _ref$breakpoints; // Init reactive component


  var reactorComponent = new Vue({
    data: function data() {
      return {
        currentBreakpoint: null
      };
    }
  });
  var mediaQueries = convertBreakpointsToMediaQueries(breakpoints);
  Object.keys(mediaQueries).map(function (key) {
    var mediaQuery = mediaQueries[key];

    var enter = function enter() {
      reactorComponent.currentBreakpoint = key;
    };

    _subscribeToMediaQuery(mediaQuery, enter);
  });

  function _subscribeToMediaQuery(mediaQuery, enter) {
    var mql = window.matchMedia(mediaQuery);

    var cb = function cb(_ref2) {
      var matches = _ref2.matches;
      if (matches) enter();
    };

    mql.addListener(cb); //subscribing

    cb(mql); //initial trigger
  }

  Vue.filter('mq', function (currentBreakpoint, values) {
    return transformValuesFromBreakpoints(Object.keys(breakpoints), values, currentBreakpoint);
  });
  Vue.mixin({
    computed: {
      $mq: function $mq() {
        return reactorComponent.currentBreakpoint;
      }
    }
  });
  Vue.prototype.$mqAvailableBreakpoints = breakpoints;
  Vue.component('MqLayout', component);
};

var index = {
  install: install
};
var _default = index;
exports.default = _default;
},{"json2mq":"28r3"}],"Hi/0":[function(require,module,exports) {
var define;
var global = arguments[3];
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.infiniteScroll = factory());
}(this, function () { 'use strict';

  var ctx = '@@InfiniteScroll';

  var throttle = function throttle(fn, delay) {
    var now, lastExec, timer, context, args; //eslint-disable-line

    var execute = function execute() {
      fn.apply(context, args);
      lastExec = now;
    };

    return function () {
      context = this;
      args = arguments;

      now = Date.now();

      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      if (lastExec) {
        var diff = delay - (now - lastExec);
        if (diff < 0) {
          execute();
        } else {
          timer = setTimeout(function () {
            execute();
          }, diff);
        }
      } else {
        execute();
      }
    };
  };

  var getScrollTop = function getScrollTop(element) {
    if (element === window) {
      return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);
    }

    return element.scrollTop;
  };

  var getComputedStyle = document.defaultView.getComputedStyle;

  var getScrollEventTarget = function getScrollEventTarget(element) {
    var currentNode = element;
    // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome
    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {
      var overflowY = getComputedStyle(currentNode).overflowY;
      if (overflowY === 'scroll' || overflowY === 'auto') {
        return currentNode;
      }
      currentNode = currentNode.parentNode;
    }
    return window;
  };

  var getVisibleHeight = function getVisibleHeight(element) {
    if (element === window) {
      return document.documentElement.clientHeight;
    }

    return element.clientHeight;
  };

  var getElementTop = function getElementTop(element) {
    if (element === window) {
      return getScrollTop(window);
    }
    return element.getBoundingClientRect().top + getScrollTop(window);
  };

  var isAttached = function isAttached(element) {
    var currentNode = element.parentNode;
    while (currentNode) {
      if (currentNode.tagName === 'HTML') {
        return true;
      }
      if (currentNode.nodeType === 11) {
        return false;
      }
      currentNode = currentNode.parentNode;
    }
    return false;
  };

  var doBind = function doBind() {
    if (this.binded) return; // eslint-disable-line
    this.binded = true;

    var directive = this;
    var element = directive.el;

    var throttleDelayExpr = element.getAttribute('infinite-scroll-throttle-delay');
    var throttleDelay = 200;
    if (throttleDelayExpr) {
      throttleDelay = Number(directive.vm[throttleDelayExpr] || throttleDelayExpr);
      if (isNaN(throttleDelay) || throttleDelay < 0) {
        throttleDelay = 200;
      }
    }
    directive.throttleDelay = throttleDelay;

    directive.scrollEventTarget = getScrollEventTarget(element);
    directive.scrollListener = throttle(doCheck.bind(directive), directive.throttleDelay);
    directive.scrollEventTarget.addEventListener('scroll', directive.scrollListener);

    this.vm.$on('hook:beforeDestroy', function () {
      directive.scrollEventTarget.removeEventListener('scroll', directive.scrollListener);
    });

    var disabledExpr = element.getAttribute('infinite-scroll-disabled');
    var disabled = false;

    if (disabledExpr) {
      this.vm.$watch(disabledExpr, function (value) {
        directive.disabled = value;
        if (!value && directive.immediateCheck) {
          doCheck.call(directive);
        }
      });
      disabled = Boolean(directive.vm[disabledExpr]);
    }
    directive.disabled = disabled;

    var distanceExpr = element.getAttribute('infinite-scroll-distance');
    var distance = 0;
    if (distanceExpr) {
      distance = Number(directive.vm[distanceExpr] || distanceExpr);
      if (isNaN(distance)) {
        distance = 0;
      }
    }
    directive.distance = distance;

    var immediateCheckExpr = element.getAttribute('infinite-scroll-immediate-check');
    var immediateCheck = true;
    if (immediateCheckExpr) {
      immediateCheck = Boolean(directive.vm[immediateCheckExpr]);
    }
    directive.immediateCheck = immediateCheck;

    if (immediateCheck) {
      doCheck.call(directive);
    }

    var eventName = element.getAttribute('infinite-scroll-listen-for-event');
    if (eventName) {
      directive.vm.$on(eventName, function () {
        doCheck.call(directive);
      });
    }
  };

  var doCheck = function doCheck(force) {
    var scrollEventTarget = this.scrollEventTarget;
    var element = this.el;
    var distance = this.distance;

    if (force !== true && this.disabled) return; //eslint-disable-line
    var viewportScrollTop = getScrollTop(scrollEventTarget);
    var viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);

    var shouldTrigger = false;

    if (scrollEventTarget === element) {
      shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;
    } else {
      var elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;

      shouldTrigger = viewportBottom + distance >= elementBottom;
    }

    if (shouldTrigger && this.expression) {
      this.expression();
    }
  };

  var InfiniteScroll = {
    bind: function bind(el, binding, vnode) {
      el[ctx] = {
        el: el,
        vm: vnode.context,
        expression: binding.value
      };
      var args = arguments;
      el[ctx].vm.$on('hook:mounted', function () {
        el[ctx].vm.$nextTick(function () {
          if (isAttached(el)) {
            doBind.call(el[ctx], args);
          }

          el[ctx].bindTryCount = 0;

          var tryBind = function tryBind() {
            if (el[ctx].bindTryCount > 10) return; //eslint-disable-line
            el[ctx].bindTryCount++;
            if (isAttached(el)) {
              doBind.call(el[ctx], args);
            } else {
              setTimeout(tryBind, 50);
            }
          };

          tryBind();
        });
      });
    },
    unbind: function unbind(el) {
      if (el && el[ctx] && el[ctx].scrollEventTarget) el[ctx].scrollEventTarget.removeEventListener('scroll', el[ctx].scrollListener);
    }
  };

  var install = function install(Vue) {
    Vue.directive('InfiniteScroll', InfiniteScroll);
  };

  if (window.Vue) {
    window.infiniteScroll = InfiniteScroll;
    Vue.use(install); // eslint-disable-line
  }

  InfiniteScroll.install = install;

  return InfiniteScroll;

}));
},{}],"Z9Sy":[function(require,module,exports) {
var define;
(function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.VMoney=t():e.VMoney=t()})(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=".",t(t.s=9)}([function(e,t,n){"use strict";t.a={prefix:"",suffix:"",thousands:",",decimal:".",precision:2}},function(e,t,n){"use strict";var r=n(2),i=n(5),u=n(0);t.a=function(e,t){if(t.value){var o=n.i(i.a)(u.a,t.value);if("INPUT"!==e.tagName.toLocaleUpperCase()){var a=e.getElementsByTagName("input");1!==a.length||(e=a[0])}e.oninput=function(){var t=e.value.length-e.selectionEnd;e.value=n.i(r.a)(e.value,o),t=Math.max(t,o.suffix.length),t=e.value.length-t,t=Math.max(t,o.prefix.length+1),n.i(r.b)(e,t),e.dispatchEvent(n.i(r.c)("change"))},e.onfocus=function(){n.i(r.b)(e,e.value.length-o.suffix.length)},e.oninput(),e.dispatchEvent(n.i(r.c)("input"))}}},function(e,t,n){"use strict";function r(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.a;"number"==typeof e&&(e=e.toFixed(o(t.precision)));var n=e.indexOf("-")>=0?"-":"",r=u(e),i=c(r,t.precision),a=d(i).split("."),p=a[0],l=a[1];return p=f(p,t.thousands),t.prefix+n+s(p,l,t.decimal)+t.suffix}function i(e,t){var n=e.indexOf("-")>=0?-1:1,r=u(e),i=c(r,t);return parseFloat(i)*n}function u(e){return d(e).replace(/\D+/g,"")||"0"}function o(e){return a(0,e,20)}function a(e,t,n){return Math.max(e,Math.min(t,n))}function c(e,t){var n=Math.pow(10,t);return(parseFloat(e)/n).toFixed(o(t))}function f(e,t){return e.replace(/(\d)(?=(?:\d{3})+\b)/gm,"$1"+t)}function s(e,t,n){return t?e+n+t:e}function d(e){return e?e.toString():""}function p(e,t){var n=function(){e.setSelectionRange(t,t)};e===document.activeElement&&(n(),setTimeout(n,1))}function l(e){var t=document.createEvent("Event");return t.initEvent(e,!0,!0),t}var m=n(0);n.d(t,"a",function(){return r}),n.d(t,"d",function(){return i}),n.d(t,"b",function(){return p}),n.d(t,"c",function(){return l})},function(e,t,n){"use strict";function r(e,t){t&&Object.keys(t).map(function(e){a.a[e]=t[e]}),e.directive("money",o.a),e.component("money",u.a)}Object.defineProperty(t,"__esModule",{value:!0});var i=n(6),u=n.n(i),o=n(1),a=n(0);n.d(t,"Money",function(){return u.a}),n.d(t,"VMoney",function(){return o.a}),n.d(t,"options",function(){return a.a}),n.d(t,"VERSION",function(){return c});var c="0.8.1";t.default=r,"undefined"!=typeof window&&window.Vue&&window.Vue.use(r)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(1),i=n(0),u=n(2);t.default={name:"Money",props:{value:{required:!0,type:[Number,String],default:0},masked:{type:Boolean,default:!1},precision:{type:Number,default:function(){return i.a.precision}},decimal:{type:String,default:function(){return i.a.decimal}},thousands:{type:String,default:function(){return i.a.thousands}},prefix:{type:String,default:function(){return i.a.prefix}},suffix:{type:String,default:function(){return i.a.suffix}}},directives:{money:r.a},data:function(){return{formattedValue:""}},watch:{value:{immediate:!0,handler:function(e,t){var r=n.i(u.a)(e,this.$props);r!==this.formattedValue&&(this.formattedValue=r)}}},methods:{change:function(e){this.$emit("input",this.masked?e.target.value:n.i(u.d)(e.target.value,this.precision))}}}},function(e,t,n){"use strict";t.a=function(e,t){return e=e||{},t=t||{},Object.keys(e).concat(Object.keys(t)).reduce(function(n,r){return n[r]=void 0===t[r]?e[r]:t[r],n},{})}},function(e,t,n){var r=n(7)(n(4),n(8),null,null);e.exports=r.exports},function(e,t){e.exports=function(e,t,n,r){var i,u=e=e||{},o=typeof e.default;"object"!==o&&"function"!==o||(i=e,u=e.default);var a="function"==typeof u?u.options:u;if(t&&(a.render=t.render,a.staticRenderFns=t.staticRenderFns),n&&(a._scopeId=n),r){var c=a.computed||(a.computed={});Object.keys(r).forEach(function(e){var t=r[e];c[e]=function(){return t}})}return{esModule:i,exports:u,options:a}}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement;return(e._self._c||t)("input",{directives:[{name:"money",rawName:"v-money",value:{precision:e.precision,decimal:e.decimal,thousands:e.thousands,prefix:e.prefix,suffix:e.suffix},expression:"{precision, decimal, thousands, prefix, suffix}"}],staticClass:"v-money",attrs:{type:"tel"},domProps:{value:e.formattedValue},on:{change:e.change}})},staticRenderFns:[]}},function(e,t,n){e.exports=n(3)}])});
},{}],"HJD/":[function(require,module,exports) {
"use strict";

require("../node_modules/v-calendar/lib/v-calendar.min.css");

var _vue = _interopRequireDefault(require("vue"));

var _vueApollo = _interopRequireDefault(require("vue-apollo"));

var _vueLazyload = _interopRequireDefault(require("vue-lazyload"));

var _App = _interopRequireDefault(require("./App"));

var _router = _interopRequireDefault(require("./router"));

var _store = _interopRequireDefault(require("./store"));

var _fastclick = _interopRequireDefault(require("fastclick"));

var _vueDrawerLayout = _interopRequireDefault(require("vue-drawer-layout"));

var _apolloClient = require("apollo-client");

var _apolloLinkHttp = require("apollo-link-http");

var _apolloLinkContext = require("apollo-link-context");

var _apolloCacheInmemory = require("apollo-cache-inmemory");

var _apolloLinkError = require("apollo-link-error");

var _apiStatusCodes = _interopRequireDefault(require("./utils/api-status-codes"));

var _vCalendar = _interopRequireDefault(require("v-calendar"));

var _veeValidate = _interopRequireWildcard(require("vee-validate"));

var _vueMq = _interopRequireDefault(require("vue-mq"));

var _vueSvgicon = _interopRequireDefault(require("vue-svgicon"));

var _sweetalert = _interopRequireDefault(require("sweetalert2"));

var _vueInfiniteScroll = _interopRequireDefault(require("vue-infinite-scroll"));

var _vMoney = _interopRequireDefault(require("v-money"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-new */
var fragmentMatcher = new _apolloCacheInmemory.IntrospectionFragmentMatcher({
  introspectionQueryResultData: {
    '__schema': {
      'types': [{
        'kind': 'UNION',
        'name': 'ToolOwner',
        'possibleTypes': [{
          'name': 'Location'
        }, {
          'name': 'User'
        }]
      }]
    }
  }
});
var cache = new _apolloCacheInmemory.InMemoryCache({
  fragmentMatcher: fragmentMatcher,
  dataIdFromObject: function dataIdFromObject(object) {
    // fixing issue on history page where objects were getting scrambled with each other (same ids but different data at different snapshots in time).
    // using a combination of fields to create a unique identifier for the entries
    if (object.__typename === 'PreviousToolSnapshotDiff') {
      return "".concat(object.id).concat(object.__typename).concat(object.owner ? object.owner.id || object.owner.id : '').concat(object.status);
    }

    if (object.__typename === 'ToolSnapshotMetadata') {
      return "".concat(object.timestamp).concat(object.__typename);
    }

    if (_router.default.currentRoute.path.includes('history') && (object.__typename === 'Tool' || object.__typename === 'ConfigurableItem' || object.__typename === 'User')) {
      return "".concat(JSON.stringify(object));
    }

    return "".concat(object.id).concat(object.__typename);
  }
});
var httpLink = new _apolloLinkHttp.HttpLink({
  uri: "prod" === 'prod' ? 'https://retina-api.renascentinc.com/graphql' : 'http://retina-api-develop.us-east-2.elasticbeanstalk.com/graphql'
});
var authLink = (0, _apolloLinkContext.setContext)(function (_ref, _ref2) {
  var operationName = _ref.operationName;
  var _ref2$headers = _ref2.headers,
      headers = _ref2$headers === void 0 ? {} : _ref2$headers;
  var token = localStorage.getItem('token');

  if (token && operationName !== 'attemptUserLogin' && operationName !== 'attemptPasswordReset') {
    headers.authorization = "Bearer ".concat(token);
  }

  return {
    headers: headers
  };
});
var errorLink = (0, _apolloLinkError.onError)(function (_ref3) {
  var _ref3$graphQLErrors = _ref3.graphQLErrors,
      graphQLErrors = _ref3$graphQLErrors === void 0 ? [] : _ref3$graphQLErrors;
  graphQLErrors.map(function (_ref4) {
    var code = _ref4.extensions.code;

    if (code === _apiStatusCodes.default.UNAUTHENTICATED && _router.default.currentRoute.path !== '/login' && _router.default.currentRoute.path !== '/password-reset') {
      window.localStorage.removeItem('token');
      (0, _sweetalert.default)({
        type: 'error',
        title: 'SESSION EXPIRED',
        text: 'Your Session Has Expired. Please Log In Again',
        timer: 2000,
        showConfirmButton: false
      });

      _router.default.push({
        path: '/login'
      });
    }
  });
});
var defaultClient = new _apolloClient.ApolloClient({
  link: authLink.concat(errorLink).concat(httpLink),
  connectToDevTools: false,
  shouldBatch: true,
  cache: cache
});
var apolloProvider = new _vueApollo.default({
  defaultClient: defaultClient
});
_vue.default.config.productionTip = false;

_vue.default.use(_vueInfiniteScroll.default);

_vue.default.use(_vueDrawerLayout.default);

_vue.default.use(_vueApollo.default);

_vue.default.use(_vCalendar.default);

_vue.default.use(_veeValidate.default);

_vue.default.use(_vueSvgicon.default);

_vue.default.use(_vueLazyload.default);

_vue.default.use(_vMoney.default, {
  precision: 2
});

_vue.default.use(_vueMq.default, {
  breakpoints: {
    mobile: 500,
    desktop: Infinity
  }
});

(0, _fastclick.default)(document.body, {
  tapDelay: 50
});
new _vue.default({
  router: _router.default,
  store: _store.default,
  el: '#app',
  apolloProvider: apolloProvider,
  render: function render(h) {
    return h(_App.default);
  }
});
var dictionary = {
  en: {
    attributes: {
      brand: 'brand',
      type: 'type',
      owner: 'owner',
      modelNumber: 'model number',
      serialNumber: 'serial number',
      modelYear: 'model year',
      purchasedFrom: 'purchased from',
      price: 'price',
      passwordResetEmail: 'email'
    }
  }
};

_veeValidate.Validator.localize(dictionary);
},{"../node_modules/v-calendar/lib/v-calendar.min.css":"T1lj","vue":"4673","vue-apollo":"SvHR","vue-lazyload":"gQ3o","./App":"6plK","./router":"Fe6F","./store":"O/Nc","fastclick":"c2Ns","vue-drawer-layout":"m2w4","apollo-client":"pd9I","apollo-link-http":"YLHZ","apollo-link-context":"QduR","apollo-cache-inmemory":"XyQB","apollo-link-error":"n+qt","./utils/api-status-codes":"8A9v","v-calendar":"iHcO","vee-validate":"+tzq","vue-mq":"duKR","vue-svgicon":"rKNI","sweetalert2":"Y8u2","vue-infinite-scroll":"Hi/0","v-money":"Z9Sy"}]},{},["HJD/"], null)
//# sourceMappingURL=main.960b330e.map